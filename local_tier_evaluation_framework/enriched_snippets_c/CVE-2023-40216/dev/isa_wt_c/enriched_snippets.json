[
  {
    "function_name": "wtstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "1048-1080",
    "snippet": "int\nwtstatus(sc)\n\tstruct wt_softc *sc;\n{\n\tchar *p;\n\tint s;\n\n\ts = splbio();\n\twtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\toutb(sc->CMDPORT, QIC_RDSTAT);\t/* send `read status' command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->ONLINE);\t\t\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\n\tp = (char *)&sc->error;\n\twhile (p < (char *)&sc->error + 6) {\n\t\tu_char x = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP);\n\t\tif ((x & sc->NOEXCEP) == 0) {\t/* error */\n\t\t\tsplx(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*p++ = inb(sc->DATAPORT);\t/* read status byte */\n\n\t\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE); /* set request */\n\t\twtpoll(sc, sc->BUSY, 0);\t/* wait for not ready */\n\t\toutb(sc->CTLPORT, sc->ONLINE);\t/* unset request */\n\t}\n\tsplx(s);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtstatus",
      "u_char wtpoll"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->CTLPORT",
            "sc->ONLINE"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtpoll",
          "args": [
            "sc",
            "sc->BUSY",
            "0"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "wtpoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "794-821",
          "snippet": "u_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nu_char wtpoll;\n\nu_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->DATAPORT"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtstatus;\nu_char wtpoll;\n\nint\nwtstatus(sc)\n\tstruct wt_softc *sc;\n{\n\tchar *p;\n\tint s;\n\n\ts = splbio();\n\twtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\toutb(sc->CMDPORT, QIC_RDSTAT);\t/* send `read status' command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->ONLINE);\t\t\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\n\tp = (char *)&sc->error;\n\twhile (p < (char *)&sc->error + 6) {\n\t\tu_char x = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP);\n\t\tif ((x & sc->NOEXCEP) == 0) {\t/* error */\n\t\t\tsplx(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*p++ = inb(sc->DATAPORT);\t/* read status byte */\n\n\t\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE); /* set request */\n\t\twtpoll(sc, sc->BUSY, 0);\t/* wait for not ready */\n\t\toutb(sc->CTLPORT, sc->ONLINE);\t/* unset request */\n\t}\n\tsplx(s);\n\treturn 1;\n}"
  },
  {
    "function_name": "wtsense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "996-1043",
    "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtsense",
      "int wtstatus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "sc->sc_dev.dv_xname",
            "msg"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtstatus",
          "args": [
            "sc"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "wtstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "1048-1080",
          "snippet": "int\nwtstatus(sc)\n\tstruct wt_softc *sc;\n{\n\tchar *p;\n\tint s;\n\n\ts = splbio();\n\twtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\toutb(sc->CMDPORT, QIC_RDSTAT);\t/* send `read status' command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->ONLINE);\t\t\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\n\tp = (char *)&sc->error;\n\twhile (p < (char *)&sc->error + 6) {\n\t\tu_char x = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP);\n\t\tif ((x & sc->NOEXCEP) == 0) {\t/* error */\n\t\t\tsplx(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*p++ = inb(sc->DATAPORT);\t/* read status byte */\n\n\t\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE); /* set request */\n\t\twtpoll(sc, sc->BUSY, 0);\t/* wait for not ready */\n\t\toutb(sc->CTLPORT, sc->ONLINE);\t/* unset request */\n\t}\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtstatus",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtstatus;\nu_char wtpoll;\n\nint\nwtstatus(sc)\n\tstruct wt_softc *sc;\n{\n\tchar *p;\n\tint s;\n\n\ts = splbio();\n\twtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\toutb(sc->CMDPORT, QIC_RDSTAT);\t/* send `read status' command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->ONLINE);\t\t\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\n\tp = (char *)&sc->error;\n\twhile (p < (char *)&sc->error + 6) {\n\t\tu_char x = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP);\n\t\tif ((x & sc->NOEXCEP) == 0) {\t/* error */\n\t\t\tsplx(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*p++ = inb(sc->DATAPORT);\t/* read status byte */\n\n\t\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE); /* set request */\n\t\twtpoll(sc, sc->BUSY, 0);\t/* wait for not ready */\n\t\toutb(sc->CTLPORT, sc->ONLINE);\t/* unset request */\n\t}\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wtsense() ignore=0x%x\\n\", ignore)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "wtreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "965-990",
    "snippet": "int\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtreset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->STATPORT"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->CTLPORT",
            "sc->ONLINE"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtreset;\n\nint\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}"
  },
  {
    "function_name": "wttimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "938-960",
    "snippet": "void\nwttimer(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = (struct wt_softc *)arg;\n\tint s;\n\n\tsc->flags &= ~TPTIMER;\n\tif ((sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK)) == 0)\n\t\treturn;\n\n\t/* If i/o going, simulate interrupt. */\n\ts = splbio();\n\tif ((inb(sc->STATPORT) & (sc->BUSY | sc->NOEXCEP)) != (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"wttimer() -- \"));\n\t\twtintr(sc);\n\t}\n\tsplx(s);\n\n\t/* Restart timer if i/o pending. */\n\tif (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\twtclock(sc);\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wttimer",
      "void wtclock",
      "int wtintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtintr",
          "args": [
            "sc"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "wtintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "640-729",
          "snippet": "int\nwtintr(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = arg;\n\tu_char x;\n\n\tx = inb(sc->STATPORT);\t\t\t/* get status */\n\tWTDBPRINT((\"wtintr() status=0x%x -- \", x));\n\tif ((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"busy\\n\"));\n\t\treturn 0;\t\t\t/* device is busy */\n\t}\n\n\t/*\n\t * Check if rewind finished.\n\t */\n\tif (sc->flags & TPREW) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"rewind busy?\\n\" : \"rewind finished\\n\"));\n\t\tsc->flags &= ~TPREW;\t\t/* rewind finished */\n\t\twtsense(sc, 1, TP_WRP);\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check if writing/reading of file mark finished.\n\t */\n\tif (sc->flags & (TPRMARK | TPWMARK)) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"marker r/w busy?\\n\" : \"marker r/w finished\\n\"));\n\t\tif ((x & sc->NOEXCEP) == 0)\t/* operation failed */\n\t\t\twtsense(sc, 1, (sc->flags & TPRMARK) ? TP_WRP : 0);\n\t\tsc->flags &= ~(TPRMARK | TPWMARK); /* operation finished */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Do we started any i/o?  If no, just return.\n\t */\n\tif ((sc->flags & TPACTIVE) == 0) {\n\t\tWTDBPRINT((\"unexpected interrupt\\n\"));\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPACTIVE;\n\tsc->dmacount += sc->bsize;\t\t/* increment counter */\n\n\t/*\n\t * Clean up dma.\n\t */\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* If reading short block, copy the internal buffer\n\t\t * to the user memory. */\n\t\tisadma_done(sc->chan);\n\t\tbcopy(sc->buf, sc->dmavaddr, sc->dmatotal - sc->dmacount);\n\t} else\n\t\tisadma_done(sc->chan);\n\n\t/*\n\t * On exception, check for end of file and end of volume.\n\t */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tWTDBPRINT((\"i/o exception\\n\"));\n\t\twtsense(sc, 1, (sc->dmaflags & DMAMODE_READ) ? TP_WRP : 0);\n\t\tif (sc->error & (TP_EOM | TP_FIL))\n\t\t\tsc->flags |= TPVOL;\t/* end of file */\n\t\telse\n\t\t\tsc->flags |= TPEXCEP;\t/* i/o error */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\tif (sc->dmacount < sc->dmatotal) {\n\t\t/* Continue I/O. */\n\t\tsc->dmavaddr += sc->bsize;\n\t\twtdma(sc);\n\t\tWTDBPRINT((\"continue i/o, %d\\n\", sc->dmacount));\n\t\treturn 1;\n\t}\n\tif (sc->dmacount > sc->dmatotal)\t/* short last block */\n\t\tsc->dmacount = sc->dmatotal;\n\t/* Wake up user level. */\n\tuntimeout(wttimer, sc);\n\twakeup((caddr_t)sc);\n\tWTDBPRINT((\"i/o finished, %d\\n\", sc->dmacount));\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wtdma",
            "void wttimer",
            "int wtsense",
            "int wtintr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtdma;\nvoid wttimer;\nint wtsense;\nint wtintr;\n\nint\nwtintr(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = arg;\n\tu_char x;\n\n\tx = inb(sc->STATPORT);\t\t\t/* get status */\n\tWTDBPRINT((\"wtintr() status=0x%x -- \", x));\n\tif ((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"busy\\n\"));\n\t\treturn 0;\t\t\t/* device is busy */\n\t}\n\n\t/*\n\t * Check if rewind finished.\n\t */\n\tif (sc->flags & TPREW) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"rewind busy?\\n\" : \"rewind finished\\n\"));\n\t\tsc->flags &= ~TPREW;\t\t/* rewind finished */\n\t\twtsense(sc, 1, TP_WRP);\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check if writing/reading of file mark finished.\n\t */\n\tif (sc->flags & (TPRMARK | TPWMARK)) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"marker r/w busy?\\n\" : \"marker r/w finished\\n\"));\n\t\tif ((x & sc->NOEXCEP) == 0)\t/* operation failed */\n\t\t\twtsense(sc, 1, (sc->flags & TPRMARK) ? TP_WRP : 0);\n\t\tsc->flags &= ~(TPRMARK | TPWMARK); /* operation finished */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Do we started any i/o?  If no, just return.\n\t */\n\tif ((sc->flags & TPACTIVE) == 0) {\n\t\tWTDBPRINT((\"unexpected interrupt\\n\"));\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPACTIVE;\n\tsc->dmacount += sc->bsize;\t\t/* increment counter */\n\n\t/*\n\t * Clean up dma.\n\t */\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* If reading short block, copy the internal buffer\n\t\t * to the user memory. */\n\t\tisadma_done(sc->chan);\n\t\tbcopy(sc->buf, sc->dmavaddr, sc->dmatotal - sc->dmacount);\n\t} else\n\t\tisadma_done(sc->chan);\n\n\t/*\n\t * On exception, check for end of file and end of volume.\n\t */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tWTDBPRINT((\"i/o exception\\n\"));\n\t\twtsense(sc, 1, (sc->dmaflags & DMAMODE_READ) ? TP_WRP : 0);\n\t\tif (sc->error & (TP_EOM | TP_FIL))\n\t\t\tsc->flags |= TPVOL;\t/* end of file */\n\t\telse\n\t\t\tsc->flags |= TPEXCEP;\t/* i/o error */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\tif (sc->dmacount < sc->dmatotal) {\n\t\t/* Continue I/O. */\n\t\tsc->dmavaddr += sc->bsize;\n\t\twtdma(sc);\n\t\tWTDBPRINT((\"continue i/o, %d\\n\", sc->dmacount));\n\t\treturn 1;\n\t}\n\tif (sc->dmacount > sc->dmatotal)\t/* short last block */\n\t\tsc->dmacount = sc->dmatotal;\n\t/* Wake up user level. */\n\tuntimeout(wttimer, sc);\n\twakeup((caddr_t)sc);\n\tWTDBPRINT((\"i/o finished, %d\\n\", sc->dmacount));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wttimer() -- \")"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->STATPORT"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\nint wtintr;\n\nvoid\nwttimer(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = (struct wt_softc *)arg;\n\tint s;\n\n\tsc->flags &= ~TPTIMER;\n\tif ((sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK)) == 0)\n\t\treturn;\n\n\t/* If i/o going, simulate interrupt. */\n\ts = splbio();\n\tif ((inb(sc->STATPORT) & (sc->BUSY | sc->NOEXCEP)) != (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"wttimer() -- \"));\n\t\twtintr(sc);\n\t}\n\tsplx(s);\n\n\t/* Restart timer if i/o pending. */\n\tif (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\twtclock(sc);\n}"
  },
  {
    "function_name": "wtclock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "918-931",
    "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wttimer",
      "void wtclock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wttimer",
            "sc",
            "(sc->flags & TPACTIVE) ? 1 : hz"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
  },
  {
    "function_name": "wtstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "891-913",
    "snippet": "int\nwtstart(sc, flag, vaddr, len)\n\tstruct wt_softc *sc;\n\tint flag;\n\tvoid *vaddr;\n\tsize_t len;\n{\n\tu_char x;\n\n\tWTDBPRINT((\"wtstart()\\n\"));\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tsc->flags |= TPEXCEP;\t/* error */\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPEXCEP;\t\t/* clear exception flag */\n\tsc->dmavaddr = vaddr;\n\tsc->dmatotal = len;\n\tsc->dmacount = 0;\n\tsc->dmaflags = flag & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\twtdma(sc);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtstart",
      "void wtdma",
      "u_char wtpoll"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtdma",
          "args": [
            "sc"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "wtdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "869-888",
          "snippet": "void\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wtdma",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtdma;\nvoid wtclock;\n\nvoid\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtpoll",
          "args": [
            "sc",
            "sc->BUSY | sc->NOEXCEP",
            "sc->BUSY | sc->NOEXCEP"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "wtpoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "794-821",
          "snippet": "u_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nu_char wtpoll;\n\nu_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wtstart()\\n\")"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtstart;\nvoid wtdma;\nu_char wtpoll;\n\nint\nwtstart(sc, flag, vaddr, len)\n\tstruct wt_softc *sc;\n\tint flag;\n\tvoid *vaddr;\n\tsize_t len;\n{\n\tu_char x;\n\n\tWTDBPRINT((\"wtstart()\\n\"));\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tsc->flags |= TPEXCEP;\t/* error */\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPEXCEP;\t\t/* clear exception flag */\n\tsc->dmavaddr = vaddr;\n\tsc->dmatotal = len;\n\tsc->dmacount = 0;\n\tsc->dmaflags = flag & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\twtdma(sc);\n\treturn 1;\n}"
  },
  {
    "function_name": "wtdma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "869-888",
    "snippet": "void\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wtdma",
      "void wtclock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isadma_start",
          "args": [
            "sc->dmavaddr",
            "sc->bsize",
            "sc->chan",
            "sc->dmaflags"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_start",
          "args": [
            "sc->buf",
            "sc->bsize",
            "sc->chan",
            "sc->dmaflags"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->SDMAPORT",
            "0"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtdma;\nvoid wtclock;\n\nvoid\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}"
  },
  {
    "function_name": "wtwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "853-866",
    "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
    ],
    "globals_used": [
      "int wtwait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "WTPRI | catch",
            "msg",
            "0"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wtwait() `%s'\\n\", msg)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
  },
  {
    "function_name": "wtcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "826-850",
    "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtcmd",
      "u_char wtpoll"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtpoll",
          "args": [
            "sc",
            "sc->BUSY",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "wtpoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "794-821",
          "snippet": "u_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nu_char wtpoll;\n\nu_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->CTLPORT",
            "sc->IEN | sc->ONLINE"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wtcmd() cmd=0x%x\\n\", cmd)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
  },
  {
    "function_name": "wtpoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "794-821",
    "snippet": "u_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
    ],
    "globals_used": [
      "u_char wtpoll"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)wtpoll",
            "WTPRI",
            "\"wtpoll\"",
            "1"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->STATPORT"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nu_char wtpoll;\n\nu_char\nwtpoll(sc, mask, bits)\n\tstruct wt_softc *sc;\n\tint mask, bits;\n{\n\tu_char x;\n\tint i;\n\n\t/* Poll status port, waiting for specified bits. */\n\tfor (i = 0; i < 1000; ++i) {\t/* up to 1 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(1);\n\t}\n\tfor (i = 0; i < 100; ++i) {\t/* up to 10 msec */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\tdelay(100);\n\t}\n\tfor (;;) {\t\t\t/* forever */\n\t\tx = inb(sc->STATPORT);\n\t\tif ((x & mask) != bits)\n\t\t\treturn x;\n\t\ttsleep((caddr_t)wtpoll, WTPRI, \"wtpoll\", 1);\n\t}\n}"
  },
  {
    "function_name": "wtwritefm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "775-789",
    "snippet": "int\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
    ],
    "globals_used": [
      "int wtwait",
      "int wtcmd",
      "void wtclock",
      "int wtsense",
      "int wtwritefm"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtwait",
          "args": [
            "sc",
            "0",
            "\"wtwfm\""
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "wtwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "853-866",
          "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtsense",
          "args": [
            "sc",
            "1",
            "0"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "wtsense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "996-1043",
          "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtsense",
            "int wtstatus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "QIC_WRITEFM"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)wtwritefm",
            "WTPRI",
            "\"wtwfm\"",
            "hz"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtwritefm;\n\nint\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}"
  },
  {
    "function_name": "wtreadfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "756-770",
    "snippet": "int\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtcmd",
      "void wtclock",
      "int wtsense",
      "int wtreadfm"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtsense",
          "args": [
            "sc",
            "1",
            "TP_WRP"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "wtsense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "996-1043",
          "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtsense",
            "int wtstatus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "QIC_READFM"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtreadfm;\n\nint\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}"
  },
  {
    "function_name": "wtrewind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "732-751",
    "snippet": "void\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtcmd",
      "void wtclock",
      "void wtrewind"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "QIC_REWIND"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->CTLPORT",
            "0"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nvoid wtrewind;\n\nvoid\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}"
  },
  {
    "function_name": "wtintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "640-729",
    "snippet": "int\nwtintr(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = arg;\n\tu_char x;\n\n\tx = inb(sc->STATPORT);\t\t\t/* get status */\n\tWTDBPRINT((\"wtintr() status=0x%x -- \", x));\n\tif ((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"busy\\n\"));\n\t\treturn 0;\t\t\t/* device is busy */\n\t}\n\n\t/*\n\t * Check if rewind finished.\n\t */\n\tif (sc->flags & TPREW) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"rewind busy?\\n\" : \"rewind finished\\n\"));\n\t\tsc->flags &= ~TPREW;\t\t/* rewind finished */\n\t\twtsense(sc, 1, TP_WRP);\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check if writing/reading of file mark finished.\n\t */\n\tif (sc->flags & (TPRMARK | TPWMARK)) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"marker r/w busy?\\n\" : \"marker r/w finished\\n\"));\n\t\tif ((x & sc->NOEXCEP) == 0)\t/* operation failed */\n\t\t\twtsense(sc, 1, (sc->flags & TPRMARK) ? TP_WRP : 0);\n\t\tsc->flags &= ~(TPRMARK | TPWMARK); /* operation finished */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Do we started any i/o?  If no, just return.\n\t */\n\tif ((sc->flags & TPACTIVE) == 0) {\n\t\tWTDBPRINT((\"unexpected interrupt\\n\"));\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPACTIVE;\n\tsc->dmacount += sc->bsize;\t\t/* increment counter */\n\n\t/*\n\t * Clean up dma.\n\t */\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* If reading short block, copy the internal buffer\n\t\t * to the user memory. */\n\t\tisadma_done(sc->chan);\n\t\tbcopy(sc->buf, sc->dmavaddr, sc->dmatotal - sc->dmacount);\n\t} else\n\t\tisadma_done(sc->chan);\n\n\t/*\n\t * On exception, check for end of file and end of volume.\n\t */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tWTDBPRINT((\"i/o exception\\n\"));\n\t\twtsense(sc, 1, (sc->dmaflags & DMAMODE_READ) ? TP_WRP : 0);\n\t\tif (sc->error & (TP_EOM | TP_FIL))\n\t\t\tsc->flags |= TPVOL;\t/* end of file */\n\t\telse\n\t\t\tsc->flags |= TPEXCEP;\t/* i/o error */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\tif (sc->dmacount < sc->dmatotal) {\n\t\t/* Continue I/O. */\n\t\tsc->dmavaddr += sc->bsize;\n\t\twtdma(sc);\n\t\tWTDBPRINT((\"continue i/o, %d\\n\", sc->dmacount));\n\t\treturn 1;\n\t}\n\tif (sc->dmacount > sc->dmatotal)\t/* short last block */\n\t\tsc->dmacount = sc->dmatotal;\n\t/* Wake up user level. */\n\tuntimeout(wttimer, sc);\n\twakeup((caddr_t)sc);\n\tWTDBPRINT((\"i/o finished, %d\\n\", sc->dmacount));\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wtdma",
      "void wttimer",
      "int wtsense",
      "int wtintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"i/o finished, %d\\n\", sc->dmacount)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)sc"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wttimer",
            "sc"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"continue i/o, %d\\n\", sc->dmacount)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtdma",
          "args": [
            "sc"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "wtdma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "869-888",
          "snippet": "void\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wtdma",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtdma;\nvoid wtclock;\n\nvoid\nwtdma(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags |= TPACTIVE;\n\twtclock(sc);\n\n\tif (sc->type == ARCHIVE) {\n\t\t/* Set DMA. */\n\t\toutb(sc->SDMAPORT, 0);\n\t}\n\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* Reading short block; do it through the internal buffer. */\n\t\tisadma_start(sc->buf, sc->bsize, sc->chan, sc->dmaflags);\n\t} else\n\t\tisadma_start(sc->dmavaddr, sc->bsize, sc->chan, sc->dmaflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtsense",
          "args": [
            "sc",
            "1",
            "(sc->dmaflags & DMAMODE_READ) ? TP_WRP : 0"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "wtsense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "996-1043",
          "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtsense",
            "int wtstatus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"i/o exception\\n\")"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_done",
          "args": [
            "sc->chan"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->buf",
            "sc->dmavaddr",
            "sc->dmatotal - sc->dmacount"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_done",
          "args": [
            "sc->chan"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"unexpected interrupt\\n\")"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"marker r/w busy?\\n\" : \"marker r/w finished\\n\")"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"rewind busy?\\n\" : \"rewind finished\\n\")"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"busy\\n\")"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTDBPRINT",
          "args": [
            "(\"wtintr() status=0x%x -- \", x)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->STATPORT"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtdma;\nvoid wttimer;\nint wtsense;\nint wtintr;\n\nint\nwtintr(arg)\n\tvoid *arg;\n{\n\tstruct wt_softc *sc = arg;\n\tu_char x;\n\n\tx = inb(sc->STATPORT);\t\t\t/* get status */\n\tWTDBPRINT((\"wtintr() status=0x%x -- \", x));\n\tif ((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP)) {\n\t\tWTDBPRINT((\"busy\\n\"));\n\t\treturn 0;\t\t\t/* device is busy */\n\t}\n\n\t/*\n\t * Check if rewind finished.\n\t */\n\tif (sc->flags & TPREW) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"rewind busy?\\n\" : \"rewind finished\\n\"));\n\t\tsc->flags &= ~TPREW;\t\t/* rewind finished */\n\t\twtsense(sc, 1, TP_WRP);\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check if writing/reading of file mark finished.\n\t */\n\tif (sc->flags & (TPRMARK | TPWMARK)) {\n\t\tWTDBPRINT(((x & (sc->BUSY | sc->NOEXCEP)) == (sc->BUSY | sc->NOEXCEP) ?\n\t\t    \"marker r/w busy?\\n\" : \"marker r/w finished\\n\"));\n\t\tif ((x & sc->NOEXCEP) == 0)\t/* operation failed */\n\t\t\twtsense(sc, 1, (sc->flags & TPRMARK) ? TP_WRP : 0);\n\t\tsc->flags &= ~(TPRMARK | TPWMARK); /* operation finished */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Do we started any i/o?  If no, just return.\n\t */\n\tif ((sc->flags & TPACTIVE) == 0) {\n\t\tWTDBPRINT((\"unexpected interrupt\\n\"));\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPACTIVE;\n\tsc->dmacount += sc->bsize;\t\t/* increment counter */\n\n\t/*\n\t * Clean up dma.\n\t */\n\tif ((sc->dmaflags & DMAMODE_READ) &&\n\t    (sc->dmatotal - sc->dmacount) < sc->bsize) {\n\t\t/* If reading short block, copy the internal buffer\n\t\t * to the user memory. */\n\t\tisadma_done(sc->chan);\n\t\tbcopy(sc->buf, sc->dmavaddr, sc->dmatotal - sc->dmacount);\n\t} else\n\t\tisadma_done(sc->chan);\n\n\t/*\n\t * On exception, check for end of file and end of volume.\n\t */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tWTDBPRINT((\"i/o exception\\n\"));\n\t\twtsense(sc, 1, (sc->dmaflags & DMAMODE_READ) ? TP_WRP : 0);\n\t\tif (sc->error & (TP_EOM | TP_FIL))\n\t\t\tsc->flags |= TPVOL;\t/* end of file */\n\t\telse\n\t\t\tsc->flags |= TPEXCEP;\t/* i/o error */\n\t\twakeup((caddr_t)sc);\n\t\treturn 1;\n\t}\n\n\tif (sc->dmacount < sc->dmatotal) {\n\t\t/* Continue I/O. */\n\t\tsc->dmavaddr += sc->bsize;\n\t\twtdma(sc);\n\t\tWTDBPRINT((\"continue i/o, %d\\n\", sc->dmacount));\n\t\treturn 1;\n\t}\n\tif (sc->dmacount > sc->dmatotal)\t/* short last block */\n\t\tsc->dmacount = sc->dmatotal;\n\t/* Wake up user level. */\n\tuntimeout(wttimer, sc);\n\twakeup((caddr_t)sc);\n\tWTDBPRINT((\"i/o finished, %d\\n\", sc->dmacount));\n\treturn 1;\n}"
  },
  {
    "function_name": "wtwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "627-635",
    "snippet": "int\nwtwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(wtstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wtstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwtwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(wtstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "wtread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "617-625",
    "snippet": "int\nwtread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(wtstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wtstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwtread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(wtstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "wtstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "542-615",
    "snippet": "void\nwtstrategy(bp)\n\tstruct buf *bp;\n{\n\tint unit = minor(bp->b_dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\tint s;\n\n\tbp->b_resid = bp->b_bcount;\n\n\t/* at file marks and end of tape, we just return '0 bytes available' */\n\tif (sc->flags & TPVOL)\n\t\tgoto xit;\n\n\tif (bp->b_flags & B_READ) {\n\t\t/* Check read access and no previous write to this tape. */\n\t\tif ((sc->flags & TPREAD) == 0 || (sc->flags & TPWANY))\n\t\t\tgoto errxit;\n\n\t\t/* For now, we assume that all data will be copied out */\n\t\t/* If read command outstanding, just skip down */\n\t\tif ((sc->flags & TPRO) == 0) {\n\t\t\tif (!wtsense(sc, 1, TP_WRP)) {\n\t\t\t\t/* Clear status. */\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tif (!wtcmd(sc, QIC_RDDATA)) {\n\t\t\t\t/* Set read mode. */\n\t\t\t\twtsense(sc, 1, TP_WRP);\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tsc->flags |= TPRO | TPRANY;\n\t\t}\n\t} else {\n\t\t/* Check write access and write protection. */\n\t\t/* No previous read from this tape allowed. */\n\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & (TPWP | TPRANY)))\n\t\t\tgoto errxit;\n\n\t\t/* If write command outstanding, just skip down */\n\t\tif ((sc->flags & TPWO) == 0) {\n\t\t\tif (!wtsense(sc, 1, 0)) {\n\t\t\t\t/* Clear status. */\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tif (!wtcmd(sc, QIC_WRTDATA)) {\n\t\t\t\t/* Set write mode. */\n\t\t\t\twtsense(sc, 1, 0);\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tsc->flags |= TPWO | TPWANY;\n\t\t}\n\t}\n\n\tif (bp->b_bcount == 0)\n\t\tgoto xit;\n\n\tsc->flags &= ~TPEXCEP;\n\ts = splbio();\n\tif (wtstart(sc, bp->b_flags, bp->b_data, bp->b_bcount)) {\n\t\twtwait(sc, 0, (bp->b_flags & B_READ) ? \"wtread\" : \"wtwrite\");\n\t\tbp->b_resid -= sc->dmacount;\n\t}\n\tsplx(s);\n\n\tif (sc->flags & TPEXCEP) {\nerrxit:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t}\nxit:\n\tbiodone(bp);\n\treturn;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtwait",
      "int wtcmd",
      "int wtstart",
      "int wtsense",
      "struct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtwait",
          "args": [
            "sc",
            "0",
            "(bp->b_flags & B_READ) ? \"wtread\" : \"wtwrite\""
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "wtwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "853-866",
          "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtstart",
          "args": [
            "sc",
            "bp->b_flags",
            "bp->b_data",
            "bp->b_bcount"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "wtstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "891-913",
          "snippet": "int\nwtstart(sc, flag, vaddr, len)\n\tstruct wt_softc *sc;\n\tint flag;\n\tvoid *vaddr;\n\tsize_t len;\n{\n\tu_char x;\n\n\tWTDBPRINT((\"wtstart()\\n\"));\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tsc->flags |= TPEXCEP;\t/* error */\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPEXCEP;\t\t/* clear exception flag */\n\tsc->dmavaddr = vaddr;\n\tsc->dmatotal = len;\n\tsc->dmacount = 0;\n\tsc->dmaflags = flag & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\twtdma(sc);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtstart",
            "void wtdma",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtstart;\nvoid wtdma;\nu_char wtpoll;\n\nint\nwtstart(sc, flag, vaddr, len)\n\tstruct wt_softc *sc;\n\tint flag;\n\tvoid *vaddr;\n\tsize_t len;\n{\n\tu_char x;\n\n\tWTDBPRINT((\"wtstart()\\n\"));\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\n\t\tsc->flags |= TPEXCEP;\t/* error */\n\t\treturn 0;\n\t}\n\tsc->flags &= ~TPEXCEP;\t\t/* clear exception flag */\n\tsc->dmavaddr = vaddr;\n\tsc->dmatotal = len;\n\tsc->dmacount = 0;\n\tsc->dmaflags = flag & B_READ ? DMAMODE_READ : DMAMODE_WRITE;\n\twtdma(sc);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtsense",
          "args": [
            "sc",
            "1",
            "0"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "wtsense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "996-1043",
          "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtsense",
            "int wtstatus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "QIC_WRTDATA"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "bp->b_dev"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtwait;\nint wtcmd;\nint wtstart;\nint wtsense;\nstruct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};\n\nvoid\nwtstrategy(bp)\n\tstruct buf *bp;\n{\n\tint unit = minor(bp->b_dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\tint s;\n\n\tbp->b_resid = bp->b_bcount;\n\n\t/* at file marks and end of tape, we just return '0 bytes available' */\n\tif (sc->flags & TPVOL)\n\t\tgoto xit;\n\n\tif (bp->b_flags & B_READ) {\n\t\t/* Check read access and no previous write to this tape. */\n\t\tif ((sc->flags & TPREAD) == 0 || (sc->flags & TPWANY))\n\t\t\tgoto errxit;\n\n\t\t/* For now, we assume that all data will be copied out */\n\t\t/* If read command outstanding, just skip down */\n\t\tif ((sc->flags & TPRO) == 0) {\n\t\t\tif (!wtsense(sc, 1, TP_WRP)) {\n\t\t\t\t/* Clear status. */\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tif (!wtcmd(sc, QIC_RDDATA)) {\n\t\t\t\t/* Set read mode. */\n\t\t\t\twtsense(sc, 1, TP_WRP);\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tsc->flags |= TPRO | TPRANY;\n\t\t}\n\t} else {\n\t\t/* Check write access and write protection. */\n\t\t/* No previous read from this tape allowed. */\n\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & (TPWP | TPRANY)))\n\t\t\tgoto errxit;\n\n\t\t/* If write command outstanding, just skip down */\n\t\tif ((sc->flags & TPWO) == 0) {\n\t\t\tif (!wtsense(sc, 1, 0)) {\n\t\t\t\t/* Clear status. */\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tif (!wtcmd(sc, QIC_WRTDATA)) {\n\t\t\t\t/* Set write mode. */\n\t\t\t\twtsense(sc, 1, 0);\n\t\t\t\tgoto errxit;\n\t\t\t}\n\t\t\tsc->flags |= TPWO | TPWANY;\n\t\t}\n\t}\n\n\tif (bp->b_bcount == 0)\n\t\tgoto xit;\n\n\tsc->flags &= ~TPEXCEP;\n\ts = splbio();\n\tif (wtstart(sc, bp->b_flags, bp->b_data, bp->b_bcount)) {\n\t\twtwait(sc, 0, (bp->b_flags & B_READ) ? \"wtread\" : \"wtwrite\");\n\t\tbp->b_resid -= sc->dmacount;\n\t}\n\tsplx(s);\n\n\tif (sc->flags & TPEXCEP) {\nerrxit:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t}\nxit:\n\tbiodone(bp);\n\treturn;\n}"
  },
  {
    "function_name": "wtioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "437-537",
    "snippet": "int\nwtioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\tint error, count, op;\n\n\tswitch (cmd) {\n\tdefault:\n\t\treturn EINVAL;\n\tcase WTQICMD:\t/* direct QIC command */\n\t\top = *(int *)addr;\n\t\tswitch (op) {\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\tcase QIC_ERASE:\t\t/* erase the whole tape */\n\t\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & TPWP))\n\t\t\t\treturn EACCES;\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wterase\")) != 0)\n\t\t\t\treturn error;\n\t\t\tbreak;\n\t\tcase QIC_RETENS:\t/* retension the tape */\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wtretens\")) != 0)\n\t\t\t\treturn error;\n\t\t\tbreak;\n\t\t}\n\t\t/* Both ERASE and RETENS operations work like REWIND. */\n\t\t/* Simulate the rewind operation here. */\n\t\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t\tif (!wtcmd(sc, op))\n\t\t\treturn EIO;\n\t\tsc->flags |= TPSTART | TPREW;\n\t\tif (op == QIC_ERASE)\n\t\t\tsc->flags |= TPWANY;\n\t\twtclock(sc);\n\t\treturn 0;\n\tcase MTIOCIEOT:\t/* ignore EOT errors */\n\tcase MTIOCEEOT:\t/* enable EOT errors */\n\t\treturn 0;\n\tcase MTIOCGET:\n\t\t((struct mtget*)addr)->mt_type =\n\t\t\tsc->type == ARCHIVE ? MT_ISVIPER1 : 0x11;\n\t\t((struct mtget*)addr)->mt_dsreg = sc->flags;\t/* status */\n\t\t((struct mtget*)addr)->mt_erreg = sc->error;\t/* errors */\n\t\t((struct mtget*)addr)->mt_resid = 0;\n\t\t((struct mtget*)addr)->mt_fileno = 0;\t\t/* file */\n\t\t((struct mtget*)addr)->mt_blkno = 0;\t\t/* block */\n\t\t((struct mtget*)addr)->mt_density = sc->dens;\t/* density */\n\t\treturn 0;\n\tcase MTIOCTOP:\n\t\tbreak;\n\t}\n\n\tswitch ((short)((struct mtop*)addr)->mt_op) {\n\tdefault:\n#if 0\n\tcase MTFSR:\t/* forward space record */\n\tcase MTBSR:\t/* backward space record */\n\tcase MTBSF:\t/* backward space file */\n#endif\n\t\treturn EINVAL;\n\tcase MTNOP:\t/* no operation, sets status only */\n\tcase MTCACHE:\t/* enable controller cache */\n\tcase MTNOCACHE:\t/* disable controller cache */\n\t\treturn 0;\n\tcase MTREW:\t/* rewind */\n\tcase MTOFFL:\t/* rewind and put the drive offline */\n\t\tif (sc->flags & TPREW)   /* rewind is running */\n\t\t\treturn 0;\n\t\tif ((error = wtwait(sc, PCATCH, \"wtorew\")) != 0)\n\t\t\treturn error;\n\t\twtrewind(sc);\n\t\treturn 0;\n\tcase MTFSF:\t/* forward space file */\n\t\tfor (count = ((struct mtop*)addr)->mt_count; count > 0;\n\t\t    --count) {\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wtorfm\")) != 0)\n\t\t\t\treturn error;\n\t\t\tif ((error = wtreadfm(sc)) != 0)\n\t\t\t\treturn error;\n\t\t}\n\t\treturn 0;\n\tcase MTWEOF:\t/* write an end-of-file record */\n\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & TPWP))\n\t\t\treturn EACCES;\n\t\tif ((error = wtwait(sc, PCATCH, \"wtowfm\")) != 0)\n\t\t\treturn error;\n\t\tif ((error = wtwritefm(sc)) != 0)\n\t\t\treturn error;\n\t\treturn 0;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"wtioctl: impossible\");\n#endif\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtwait",
      "int wtcmd",
      "void wtclock",
      "void wtrewind",
      "int wtreadfm",
      "int wtwritefm",
      "struct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wtioctl: impossible\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtwritefm",
          "args": [
            "sc"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "wtwritefm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "775-789",
          "snippet": "int\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait",
            "int wtcmd",
            "void wtclock",
            "int wtsense",
            "int wtwritefm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtwritefm;\n\nint\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtwait",
          "args": [
            "sc",
            "PCATCH",
            "\"wtowfm\""
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "wtwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "853-866",
          "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtreadfm",
          "args": [
            "sc"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "wtreadfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "756-770",
          "snippet": "int\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "void wtclock",
            "int wtsense",
            "int wtreadfm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtreadfm;\n\nint\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtrewind",
          "args": [
            "sc"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "wtrewind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "732-751",
          "snippet": "void\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "void wtclock",
            "void wtrewind"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nvoid wtrewind;\n\nvoid\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtclock",
          "args": [
            "sc"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "wtclock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "918-931",
          "snippet": "void\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void wttimer",
            "void wtclock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wttimer;\nvoid wtclock;\n\nvoid\nwtclock(sc)\n\tstruct wt_softc *sc;\n{\n\n\tif (sc->flags & TPTIMER)\n\t\treturn;\n\tsc->flags |= TPTIMER;\n\t/*\n\t * Some controllers seem to lose dma interrupts too often.  To make the\n\t * tape stream we need 1 tick timeout.\n\t */\n\ttimeout(wttimer, sc, (sc->flags & TPACTIVE) ? 1 : hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "op"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtwait;\nint wtcmd;\nvoid wtclock;\nvoid wtrewind;\nint wtreadfm;\nint wtwritefm;\nstruct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};\n\nint\nwtioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\tint error, count, op;\n\n\tswitch (cmd) {\n\tdefault:\n\t\treturn EINVAL;\n\tcase WTQICMD:\t/* direct QIC command */\n\t\top = *(int *)addr;\n\t\tswitch (op) {\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t\tcase QIC_ERASE:\t\t/* erase the whole tape */\n\t\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & TPWP))\n\t\t\t\treturn EACCES;\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wterase\")) != 0)\n\t\t\t\treturn error;\n\t\t\tbreak;\n\t\tcase QIC_RETENS:\t/* retension the tape */\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wtretens\")) != 0)\n\t\t\t\treturn error;\n\t\t\tbreak;\n\t\t}\n\t\t/* Both ERASE and RETENS operations work like REWIND. */\n\t\t/* Simulate the rewind operation here. */\n\t\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t\tif (!wtcmd(sc, op))\n\t\t\treturn EIO;\n\t\tsc->flags |= TPSTART | TPREW;\n\t\tif (op == QIC_ERASE)\n\t\t\tsc->flags |= TPWANY;\n\t\twtclock(sc);\n\t\treturn 0;\n\tcase MTIOCIEOT:\t/* ignore EOT errors */\n\tcase MTIOCEEOT:\t/* enable EOT errors */\n\t\treturn 0;\n\tcase MTIOCGET:\n\t\t((struct mtget*)addr)->mt_type =\n\t\t\tsc->type == ARCHIVE ? MT_ISVIPER1 : 0x11;\n\t\t((struct mtget*)addr)->mt_dsreg = sc->flags;\t/* status */\n\t\t((struct mtget*)addr)->mt_erreg = sc->error;\t/* errors */\n\t\t((struct mtget*)addr)->mt_resid = 0;\n\t\t((struct mtget*)addr)->mt_fileno = 0;\t\t/* file */\n\t\t((struct mtget*)addr)->mt_blkno = 0;\t\t/* block */\n\t\t((struct mtget*)addr)->mt_density = sc->dens;\t/* density */\n\t\treturn 0;\n\tcase MTIOCTOP:\n\t\tbreak;\n\t}\n\n\tswitch ((short)((struct mtop*)addr)->mt_op) {\n\tdefault:\n#if 0\n\tcase MTFSR:\t/* forward space record */\n\tcase MTBSR:\t/* backward space record */\n\tcase MTBSF:\t/* backward space file */\n#endif\n\t\treturn EINVAL;\n\tcase MTNOP:\t/* no operation, sets status only */\n\tcase MTCACHE:\t/* enable controller cache */\n\tcase MTNOCACHE:\t/* disable controller cache */\n\t\treturn 0;\n\tcase MTREW:\t/* rewind */\n\tcase MTOFFL:\t/* rewind and put the drive offline */\n\t\tif (sc->flags & TPREW)   /* rewind is running */\n\t\t\treturn 0;\n\t\tif ((error = wtwait(sc, PCATCH, \"wtorew\")) != 0)\n\t\t\treturn error;\n\t\twtrewind(sc);\n\t\treturn 0;\n\tcase MTFSF:\t/* forward space file */\n\t\tfor (count = ((struct mtop*)addr)->mt_count; count > 0;\n\t\t    --count) {\n\t\t\tif ((error = wtwait(sc, PCATCH, \"wtorfm\")) != 0)\n\t\t\t\treturn error;\n\t\t\tif ((error = wtreadfm(sc)) != 0)\n\t\t\t\treturn error;\n\t\t}\n\t\treturn 0;\n\tcase MTWEOF:\t/* write an end-of-file record */\n\t\tif ((sc->flags & TPWRITE) == 0 || (sc->flags & TPWP))\n\t\t\treturn EACCES;\n\t\tif ((error = wtwait(sc, PCATCH, \"wtowfm\")) != 0)\n\t\t\treturn error;\n\t\tif ((error = wtwritefm(sc)) != 0)\n\t\t\treturn error;\n\t\treturn 0;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"wtioctl: impossible\");\n#endif\n}"
  },
  {
    "function_name": "wtclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "383-427",
    "snippet": "int\nwtclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\n\t/* If rewind is pending, do nothing */\n\tif (sc->flags & TPREW)\n\t\tgoto done;\n\n\t/* If seek forward is pending and no rewind on close, do nothing */\n\tif (sc->flags & TPRMARK) {\n\t\tif (minor(dev) & T_NOREWIND)\n\t\t\tgoto done;\n\n\t\t/* If read file mark is going on, wait */\n\t\twtwait(sc, 0, \"wtrfm\");\n\t}\n\n\tif (sc->flags & TPWANY) {\n\t\t/* Tape was written.  Write file mark. */\n\t\twtwritefm(sc);\n\t}\n\n\tif ((minor(dev) & T_NOREWIND) == 0) {\n\t\t/* Rewind to beginning of tape. */\n\t\t/* Don't wait until rewind, though. */\n\t\twtrewind(sc);\n\t\tgoto done;\n\t}\n\tif ((sc->flags & TPRANY) && (sc->flags & (TPVOL | TPWANY)) == 0) {\n\t\t/* Space forward to after next file mark if no writing done. */\n\t\t/* Don't wait for completion. */\n\t\twtreadfm(sc);\n\t}\n\ndone:\n\tsc->flags &= TPREW | TPRMARK | TPSTART | TPTIMER;\n\tfree(sc->buf, M_TEMP);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtwait",
      "void wtrewind",
      "int wtreadfm",
      "int wtwritefm",
      "struct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->buf",
            "M_TEMP"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "sb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "2202-2209",
          "snippet": "void\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtreadfm",
          "args": [
            "sc"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "wtreadfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "756-770",
          "snippet": "int\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "void wtclock",
            "int wtsense",
            "int wtreadfm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtreadfm;\n\nint\nwtreadfm(sc)\n\tstruct wt_softc *sc;\n{\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\tif (!wtcmd(sc, QIC_READFM)) {\n\t\twtsense(sc, 1, TP_WRP);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPRMARK | TPRANY;\n\twtclock(sc);\n\t/* Don't wait for completion here. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtrewind",
          "args": [
            "sc"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "wtrewind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "732-751",
          "snippet": "void\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "void wtclock",
            "void wtrewind"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nvoid wtclock;\nvoid wtrewind;\n\nvoid\nwtrewind(sc)\n\tstruct wt_softc *sc;\n{\n\tint rwmode = sc->flags & (TPRO | TPWO);\n\n\tsc->flags &= ~(TPRO | TPWO | TPVOL);\n\t/*\n\t * Wangtek strictly follows QIC-02 standard:\n\t * clearing ONLINE in read/write modes causes rewind.\n\t * REWIND command is not allowed in read/write mode\n\t * and gives `illegal command' error.\n\t */\n\tif (sc->type == WANGTEK && rwmode) {\n\t\toutb(sc->CTLPORT, 0);\n\t} else if (!wtcmd(sc, QIC_REWIND))\n\t\treturn;\n\tsc->flags |= TPSTART | TPREW;\n\twtclock(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtwritefm",
          "args": [
            "sc"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "wtwritefm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "775-789",
          "snippet": "int\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait",
            "int wtcmd",
            "void wtclock",
            "int wtsense",
            "int wtwritefm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\nint wtcmd;\nvoid wtclock;\nint wtsense;\nint wtwritefm;\n\nint\nwtwritefm(sc)\n\tstruct wt_softc *sc;\n{\n\n\ttsleep((caddr_t)wtwritefm, WTPRI, \"wtwfm\", hz);\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtcmd(sc, QIC_WRITEFM)) {\n\t\twtsense(sc, 1, 0);\n\t\treturn EIO;\n\t}\n\tsc->flags |= TPWMARK | TPWANY;\n\twtclock(sc);\n\treturn wtwait(sc, 0, \"wtwfm\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtwait",
          "args": [
            "sc",
            "0",
            "\"wtrfm\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "wtwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "853-866",
          "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtwait;\nvoid wtrewind;\nint wtreadfm;\nint wtwritefm;\nstruct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};\n\nint\nwtclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc = wt_cd.cd_devs[unit];\n\n\t/* If rewind is pending, do nothing */\n\tif (sc->flags & TPREW)\n\t\tgoto done;\n\n\t/* If seek forward is pending and no rewind on close, do nothing */\n\tif (sc->flags & TPRMARK) {\n\t\tif (minor(dev) & T_NOREWIND)\n\t\t\tgoto done;\n\n\t\t/* If read file mark is going on, wait */\n\t\twtwait(sc, 0, \"wtrfm\");\n\t}\n\n\tif (sc->flags & TPWANY) {\n\t\t/* Tape was written.  Write file mark. */\n\t\twtwritefm(sc);\n\t}\n\n\tif ((minor(dev) & T_NOREWIND) == 0) {\n\t\t/* Rewind to beginning of tape. */\n\t\t/* Don't wait until rewind, though. */\n\t\twtrewind(sc);\n\t\tgoto done;\n\t}\n\tif ((sc->flags & TPRANY) && (sc->flags & (TPVOL | TPWANY)) == 0) {\n\t\t/* Space forward to after next file mark if no writing done. */\n\t\t/* Don't wait for completion. */\n\t\twtreadfm(sc);\n\t}\n\ndone:\n\tsc->flags &= TPREW | TPRMARK | TPSTART | TPTIMER;\n\tfree(sc->buf, M_TEMP);\n\treturn 0;\n}"
  },
  {
    "function_name": "wtopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "292-378",
    "snippet": "int\nwtopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc;\n\tint error;\n\n\tif (unit >= wt_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = wt_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\t/* Check that device is not in use */\n\tif (sc->flags & TPINUSE)\n\t\treturn EBUSY;\n\n\t/* If the tape is in rewound state, check the status and set density. */\n\tif (sc->flags & TPSTART) {\n\t\t/* If rewind is going on, wait */\n\t\tif ((error = wtwait(sc, PCATCH, \"wtrew\")) != 0)\n\t\t\treturn error;\n\n\t\t/* Check the controller status */\n\t\tif (!wtsense(sc, 0, (flag & FWRITE) ? 0 : TP_WRP)) {\n\t\t\t/* Bad status, reset the controller. */\n\t\t\tif (!wtreset(sc))\n\t\t\t\treturn EIO;\n\t\t\tif (!wtsense(sc, 1, (flag & FWRITE) ? 0 : TP_WRP))\n\t\t\t\treturn EIO;\n\t\t}\n\n\t\t/* Set up tape density. */\n\t\tif (sc->dens != (minor(dev) & WT_DENSEL)) {\n\t\t\tint d = 0;\n\n\t\t\tswitch (minor(dev) & WT_DENSEL) {\n\t\t\tcase WT_DENSDFLT:\n\t\t\tdefault:\n\t\t\t\tbreak;\t\t\t/* default density */\n\t\t\tcase WT_QIC11:\n\t\t\t\td = QIC_FMT11;  break;\t/* minor 010 */\n\t\t\tcase WT_QIC24:\n\t\t\t\td = QIC_FMT24;  break;\t/* minor 020 */\n\t\t\tcase WT_QIC120:\n\t\t\t\td = QIC_FMT120; break;\t/* minor 030 */\n\t\t\tcase WT_QIC150:\n\t\t\t\td = QIC_FMT150; break;\t/* minor 040 */\n\t\t\tcase WT_QIC300:\n\t\t\t\td = QIC_FMT300; break;\t/* minor 050 */\n\t\t\tcase WT_QIC600:\n\t\t\t\td = QIC_FMT600; break;\t/* minor 060 */\n\t\t\t}\n\t\t\tif (d) {\n\t\t\t\t/* Change tape density. */\n\t\t\t\tif (!wtcmd(sc, d))\n\t\t\t\t\treturn EIO;\n\t\t\t\tif (!wtsense(sc, 1, TP_WRP | TP_ILL))\n\t\t\t\t\treturn EIO;\n\n\t\t\t\t/* Check the status of the controller. */\n\t\t\t\tif (sc->error & TP_ILL) {\n\t\t\t\t\tprintf(\"%s: invalid tape density\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\treturn ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc->dens = minor(dev) & WT_DENSEL;\n\t\t}\n\t\tsc->flags &= ~TPSTART;\n\t} else if (sc->dens != (minor(dev) & WT_DENSEL))\n\t\treturn ENXIO;\n\n\tsc->bsize = (minor(dev) & WT_BSIZE) ? 1024 : 512;\n\tsc->buf = malloc(sc->bsize, M_TEMP, M_WAITOK);\n\n\tsc->flags = TPINUSE;\n\tif (flag & FREAD)\n\t\tsc->flags |= TPREAD;\n\tif (flag & FWRITE)\n\t\tsc->flags |= TPWRITE;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int wtwait",
      "int wtcmd",
      "int wtreset",
      "int wtsense",
      "struct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sc->bsize",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid tape density\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtsense",
          "args": [
            "sc",
            "1",
            "TP_WRP | TP_ILL"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "wtsense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "996-1043",
          "snippet": "int\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtsense",
            "int wtstatus"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtsense;\nint wtstatus;\n\nint\nwtsense(sc, verbose, ignore)\n\tstruct wt_softc *sc;\n\tint verbose, ignore;\n{\n\tchar *msg = 0;\n\tint error;\n\n\tWTDBPRINT((\"wtsense() ignore=0x%x\\n\", ignore));\n\tsc->flags &= ~(TPRO | TPWO);\n\tif (!wtstatus(sc))\n\t\treturn 0;\n\tif ((sc->error & TP_ST0) == 0)\n\t\tsc->error &= ~TP_ST0MASK;\n\tif ((sc->error & TP_ST1) == 0)\n\t\tsc->error &= ~TP_ST1MASK;\n\tsc->error &= ~ignore;\t/* ignore certain errors */\n\terror = sc->error & (TP_FIL | TP_BNL | TP_UDA | TP_EOM | TP_WRP |\n\t    TP_USL | TP_CNI | TP_MBD | TP_NDT | TP_ILL);\n\tif (!error)\n\t\treturn 1;\n\tif (!verbose)\n\t\treturn 0;\n\n\t/* lifted from tdriver.c from Wangtek */\n\tif (error & TP_USL)\n\t\tmsg = \"Drive not online\";\n\telse if (error & TP_CNI)\n\t\tmsg = \"No cartridge\";\n\telse if ((error & TP_WRP) && (sc->flags & TPWP) == 0) {\n\t\tmsg = \"Tape is write protected\";\n\t\tsc->flags |= TPWP;\n\t} else if (error & TP_FIL)\n\t\tmsg = 0 /*\"Filemark detected\"*/;\n\telse if (error & TP_EOM)\n\t\tmsg = 0 /*\"End of tape\"*/;\n\telse if (error & TP_BNL)\n\t\tmsg = \"Block not located\";\n\telse if (error & TP_UDA)\n\t\tmsg = \"Unrecoverable data error\";\n\telse if (error & TP_NDT)\n\t\tmsg = \"No data detected\";\n\telse if (error & TP_ILL)\n\t\tmsg = \"Illegal command\";\n\tif (msg)\n\t\tprintf(\"%s: %s\\n\", sc->sc_dev.dv_xname, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtcmd",
          "args": [
            "sc",
            "d"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "wtcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "826-850",
          "snippet": "int\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtcmd",
            "u_char wtpoll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtcmd;\nu_char wtpoll;\n\nint\nwtcmd(sc, cmd)\n\tstruct wt_softc *sc;\n\tint cmd;\n{\n\tu_char x;\n\tint s;\n\n\tWTDBPRINT((\"wtcmd() cmd=0x%x\\n\", cmd));\n\ts = splbio();\n\tx = wtpoll(sc, sc->BUSY | sc->NOEXCEP, sc->BUSY | sc->NOEXCEP); /* ready? */\n\tif ((x & sc->NOEXCEP) == 0) {\t\t\t/* error */\n\t\tsplx(s);\n\t\treturn 0;\n\t}\n\t\n\toutb(sc->CMDPORT, cmd);\t\t\t\t/* output the command */\n\n\toutb(sc->CTLPORT, sc->REQUEST | sc->ONLINE);\t/* set request */\n\twtpoll(sc, sc->BUSY, sc->BUSY);\t\t\t/* wait for ready */\n\toutb(sc->CTLPORT, sc->IEN | sc->ONLINE);\t/* reset request */\n\twtpoll(sc, sc->BUSY, 0);\t\t\t/* wait for not ready */\n\tsplx(s);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtreset",
          "args": [
            "sc"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "wtreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "965-990",
          "snippet": "int\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtreset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtreset;\n\nint\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtwait",
          "args": [
            "sc",
            "PCATCH",
            "\"wtrew\""
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "wtwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "853-866",
          "snippet": "int\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */"
          ],
          "globals_used": [
            "int wtwait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WTPRI\t\t\t(PZERO+10)\t/* sleep priority */\n\nint wtwait;\n\nint\nwtwait(sc, catch, msg)\n\tstruct wt_softc *sc;\n\tint catch;\n\tchar *msg;\n{\n\tint error;\n\n\tWTDBPRINT((\"wtwait() `%s'\\n\", msg));\n\twhile (sc->flags & (TPACTIVE | TPREW | TPRMARK | TPWMARK))\n\t\tif ((error = tsleep((caddr_t)sc, WTPRI | catch, msg, 0)) != 0)\n\t\t\treturn error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtwait;\nint wtcmd;\nint wtreset;\nint wtsense;\nstruct cfdriver wt_cd = {\n\tNULL, \"wt\", DV_TAPE\n};\n\nint\nwtopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = minor(dev) & T_UNIT;\n\tstruct wt_softc *sc;\n\tint error;\n\n\tif (unit >= wt_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = wt_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\t/* Check that device is not in use */\n\tif (sc->flags & TPINUSE)\n\t\treturn EBUSY;\n\n\t/* If the tape is in rewound state, check the status and set density. */\n\tif (sc->flags & TPSTART) {\n\t\t/* If rewind is going on, wait */\n\t\tif ((error = wtwait(sc, PCATCH, \"wtrew\")) != 0)\n\t\t\treturn error;\n\n\t\t/* Check the controller status */\n\t\tif (!wtsense(sc, 0, (flag & FWRITE) ? 0 : TP_WRP)) {\n\t\t\t/* Bad status, reset the controller. */\n\t\t\tif (!wtreset(sc))\n\t\t\t\treturn EIO;\n\t\t\tif (!wtsense(sc, 1, (flag & FWRITE) ? 0 : TP_WRP))\n\t\t\t\treturn EIO;\n\t\t}\n\n\t\t/* Set up tape density. */\n\t\tif (sc->dens != (minor(dev) & WT_DENSEL)) {\n\t\t\tint d = 0;\n\n\t\t\tswitch (minor(dev) & WT_DENSEL) {\n\t\t\tcase WT_DENSDFLT:\n\t\t\tdefault:\n\t\t\t\tbreak;\t\t\t/* default density */\n\t\t\tcase WT_QIC11:\n\t\t\t\td = QIC_FMT11;  break;\t/* minor 010 */\n\t\t\tcase WT_QIC24:\n\t\t\t\td = QIC_FMT24;  break;\t/* minor 020 */\n\t\t\tcase WT_QIC120:\n\t\t\t\td = QIC_FMT120; break;\t/* minor 030 */\n\t\t\tcase WT_QIC150:\n\t\t\t\td = QIC_FMT150; break;\t/* minor 040 */\n\t\t\tcase WT_QIC300:\n\t\t\t\td = QIC_FMT300; break;\t/* minor 050 */\n\t\t\tcase WT_QIC600:\n\t\t\t\td = QIC_FMT600; break;\t/* minor 060 */\n\t\t\t}\n\t\t\tif (d) {\n\t\t\t\t/* Change tape density. */\n\t\t\t\tif (!wtcmd(sc, d))\n\t\t\t\t\treturn EIO;\n\t\t\t\tif (!wtsense(sc, 1, TP_WRP | TP_ILL))\n\t\t\t\t\treturn EIO;\n\n\t\t\t\t/* Check the status of the controller. */\n\t\t\t\tif (sc->error & TP_ILL) {\n\t\t\t\t\tprintf(\"%s: invalid tape density\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\treturn ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc->dens = minor(dev) & WT_DENSEL;\n\t\t}\n\t\tsc->flags &= ~TPSTART;\n\t} else if (sc->dens != (minor(dev) & WT_DENSEL))\n\t\treturn ENXIO;\n\n\tsc->bsize = (minor(dev) & WT_BSIZE) ? 1024 : 512;\n\tsc->buf = malloc(sc->bsize, M_TEMP, M_WAITOK);\n\n\tsc->flags = TPINUSE;\n\tif (flag & FREAD)\n\t\tsc->flags |= TPREAD;\n\tif (flag & FWRITE)\n\t\tsc->flags |= TPWRITE;\n\treturn 0;\n}"
  },
  {
    "function_name": "wtsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "280-287",
    "snippet": "int\nwtsize(dev)\n\tdev_t dev;\n{\n\n\t/* Not implemented. */\n\treturn -1;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwtsize(dev)\n\tdev_t dev;\n{\n\n\t/* Not implemented. */\n\treturn -1;\n}"
  },
  {
    "function_name": "wtdump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "268-278",
    "snippet": "int\nwtdump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwtdump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "wtattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "247-266",
    "snippet": "void\nwtattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wt_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\n\tif (sc->type == ARCHIVE) {\n\t\tprintf(\": type <Archive>\\n\");\n\t\t/* Reset DMA. */\n\t\toutb(sc->RDMAPORT, 0);\n\t} else\n\t\tprintf(\": type <Wangtek>\\n\");\n\tsc->flags = TPSTART;\t\t/* tape is rewound */\n\tsc->dens = -1;\t\t\t/* unknown density */\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, wtintr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wtattach",
      "int wtintr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_BIO",
            "wtintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": type <Wangtek>\\n\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->RDMAPORT",
            "0"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wtattach;\nint wtintr;\n\nvoid\nwtattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wt_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\n\tif (sc->type == ARCHIVE) {\n\t\tprintf(\": type <Archive>\\n\");\n\t\t/* Reset DMA. */\n\t\toutb(sc->RDMAPORT, 0);\n\t} else\n\t\tprintf(\": type <Wangtek>\\n\");\n\tsc->flags = TPSTART;\t\t/* tape is rewound */\n\tsc->dens = -1;\t\t\t/* unknown density */\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, wtintr, sc, sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "wtprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
    "lines": "189-242",
    "snippet": "int\nwtprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct wt_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint iobase;\n\n\tsc->chan = ia->ia_drq;\n\tsc->sc_iobase = iobase = ia->ia_iobase;\n\tif (sc->chan < 1 || sc->chan > 3) {\n\t\tprintf(\"%s: Bad drq=%d, should be 1..3\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->chan);\n\t\treturn 0;\n\t}\n\n\t/* Try Wangtek. */\n\tsc->type = WANGTEK;\n\tsc->CTLPORT = WT_CTLPORT(iobase);\n\tsc->STATPORT = WT_STATPORT(iobase);\n\tsc->CMDPORT = WT_CMDPORT(iobase);\n\tsc->DATAPORT = WT_DATAPORT(iobase);\n\tsc->SDMAPORT = sc->RDMAPORT = 0;\n\tsc->BUSY = WT_BUSY;\t\tsc->NOEXCEP = WT_NOEXCEP;\n\tsc->RESETMASK = WT_RESETMASK;\tsc->RESETVAL = WT_RESETVAL;\n\tsc->ONLINE = WT_ONLINE;\t\tsc->RESET = WT_RESET;\n\tsc->REQUEST = WT_REQUEST;\tsc->IEN = WT_IEN;\n\tif (wtreset(sc)) {\n\t\tia->ia_iosize = WT_NPORT;\n\t\treturn 1;\n\t}\n\n\t/* Try Archive. */\n\tsc->type = ARCHIVE;\n\tsc->CTLPORT = AV_CTLPORT(iobase);\n\tsc->STATPORT = AV_STATPORT(iobase);\n\tsc->CMDPORT = AV_CMDPORT(iobase);\n\tsc->DATAPORT = AV_DATAPORT(iobase);\n\tsc->SDMAPORT = AV_SDMAPORT(iobase);\n\tsc->RDMAPORT = AV_RDMAPORT(iobase);\n\tsc->BUSY = AV_BUSY;\t\tsc->NOEXCEP = AV_NOEXCEP;\n\tsc->RESETMASK = AV_RESETMASK;\tsc->RESETVAL = AV_RESETVAL;\n\tsc->ONLINE = 0;\t\t\tsc->RESET = AV_RESET;\n\tsc->REQUEST = AV_REQUEST;\tsc->IEN = AV_IEN;\n\tif (wtreset(sc)) {\n\t\tia->ia_iosize = AV_NPORT;\n\t\treturn 1;\n\t}\n\n\t/* Tape controller not found. */\n\tsc->type = UNKNOWN;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/wtreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm_param.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define AV_IEN\t\t\t0x20\t\t/* enable interrupts */",
      "#define AV_REQUEST\t\t0x40\t\t/* request command */",
      "#define AV_RESET\t\t0x80\t\t/* reset command */",
      "#define AV_RESETVAL\t\t0x50\t\t/* state after reset */",
      "#define AV_RESETMASK\t\t0xf8\t\t/* to check after reset */",
      "#define AV_NOEXCEP\t\t0x20\t\t/* no exception bit define */",
      "#define AV_BUSY\t\t\t0x40\t\t/* not ready bit define */",
      "#define AV_NPORT\t\t4\t\t/* 4 i/o ports */",
      "#define WT_IEN\t\t\t0x08\t\t/* enable dma */",
      "#define WT_REQUEST\t\t0x04\t\t/* request command */",
      "#define WT_RESET\t\t0x02\t\t/* reset command */",
      "#define WT_ONLINE\t\t0x01\t\t/* device selected */",
      "#define WT_RESETVAL\t\t0x05\t\t/* state after reset */",
      "#define WT_RESETMASK\t\t0x07\t\t/* to check after reset */",
      "#define WT_NOEXCEP\t\t0x02\t\t/* no exception bit define */",
      "#define WT_BUSY\t\t\t0x01\t\t/* not ready bit define */",
      "#define WT_NPORT\t\t2\t\t/* 2 i/o ports */"
    ],
    "globals_used": [
      "int wtreset",
      "int wtprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wtreset",
          "args": [
            "sc"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "wtreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wt.c",
          "lines": "965-990",
          "snippet": "int\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}",
          "includes": [
            "#include <dev/isa/wtreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm_param.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int wtreset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint wtreset;\n\nint\nwtreset(sc)\n\tstruct wt_softc *sc;\n{\n\tu_char x;\n\tint i;\n\n\toutb(sc->CTLPORT, sc->RESET | sc->ONLINE); /* send reset */\n\tdelay(30);\n\toutb(sc->CTLPORT, sc->ONLINE);\t/* turn off reset */\n\tdelay(30);\n\n\t/* Read the controller status. */\n\tx = inb(sc->STATPORT);\n\tif (x == 0xff)\t\t\t/* no port at this address? */\n\t\treturn 0;\n\n\t/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */\n\tfor (i = 0; i < 3000; ++i) {\n\t\tif ((x & sc->BUSY) == 0 || (x & sc->NOEXCEP) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t\tx = inb(sc->STATPORT);\n\t}\n\treturn (x & sc->RESETMASK) == sc->RESETVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AV_RDMAPORT",
          "args": [
            "iobase"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AV_SDMAPORT",
          "args": [
            "iobase"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AV_DATAPORT",
          "args": [
            "iobase"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AV_CMDPORT",
          "args": [
            "iobase"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AV_STATPORT",
          "args": [
            "iobase"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AV_CTLPORT",
          "args": [
            "iobase"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WT_DATAPORT",
          "args": [
            "iobase"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WT_CMDPORT",
          "args": [
            "iobase"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WT_STATPORT",
          "args": [
            "iobase"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WT_CTLPORT",
          "args": [
            "iobase"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Bad drq=%d, should be 1..3\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->chan"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/wtreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <vm/vm_param.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AV_IEN\t\t\t0x20\t\t/* enable interrupts */\n#define AV_REQUEST\t\t0x40\t\t/* request command */\n#define AV_RESET\t\t0x80\t\t/* reset command */\n#define AV_RESETVAL\t\t0x50\t\t/* state after reset */\n#define AV_RESETMASK\t\t0xf8\t\t/* to check after reset */\n#define AV_NOEXCEP\t\t0x20\t\t/* no exception bit define */\n#define AV_BUSY\t\t\t0x40\t\t/* not ready bit define */\n#define AV_NPORT\t\t4\t\t/* 4 i/o ports */\n#define WT_IEN\t\t\t0x08\t\t/* enable dma */\n#define WT_REQUEST\t\t0x04\t\t/* request command */\n#define WT_RESET\t\t0x02\t\t/* reset command */\n#define WT_ONLINE\t\t0x01\t\t/* device selected */\n#define WT_RESETVAL\t\t0x05\t\t/* state after reset */\n#define WT_RESETMASK\t\t0x07\t\t/* to check after reset */\n#define WT_NOEXCEP\t\t0x02\t\t/* no exception bit define */\n#define WT_BUSY\t\t\t0x01\t\t/* not ready bit define */\n#define WT_NPORT\t\t2\t\t/* 2 i/o ports */\n\nint wtreset;\nint wtprobe;\n\nint\nwtprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct wt_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint iobase;\n\n\tsc->chan = ia->ia_drq;\n\tsc->sc_iobase = iobase = ia->ia_iobase;\n\tif (sc->chan < 1 || sc->chan > 3) {\n\t\tprintf(\"%s: Bad drq=%d, should be 1..3\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->chan);\n\t\treturn 0;\n\t}\n\n\t/* Try Wangtek. */\n\tsc->type = WANGTEK;\n\tsc->CTLPORT = WT_CTLPORT(iobase);\n\tsc->STATPORT = WT_STATPORT(iobase);\n\tsc->CMDPORT = WT_CMDPORT(iobase);\n\tsc->DATAPORT = WT_DATAPORT(iobase);\n\tsc->SDMAPORT = sc->RDMAPORT = 0;\n\tsc->BUSY = WT_BUSY;\t\tsc->NOEXCEP = WT_NOEXCEP;\n\tsc->RESETMASK = WT_RESETMASK;\tsc->RESETVAL = WT_RESETVAL;\n\tsc->ONLINE = WT_ONLINE;\t\tsc->RESET = WT_RESET;\n\tsc->REQUEST = WT_REQUEST;\tsc->IEN = WT_IEN;\n\tif (wtreset(sc)) {\n\t\tia->ia_iosize = WT_NPORT;\n\t\treturn 1;\n\t}\n\n\t/* Try Archive. */\n\tsc->type = ARCHIVE;\n\tsc->CTLPORT = AV_CTLPORT(iobase);\n\tsc->STATPORT = AV_STATPORT(iobase);\n\tsc->CMDPORT = AV_CMDPORT(iobase);\n\tsc->DATAPORT = AV_DATAPORT(iobase);\n\tsc->SDMAPORT = AV_SDMAPORT(iobase);\n\tsc->RDMAPORT = AV_RDMAPORT(iobase);\n\tsc->BUSY = AV_BUSY;\t\tsc->NOEXCEP = AV_NOEXCEP;\n\tsc->RESETMASK = AV_RESETMASK;\tsc->RESETVAL = AV_RESETVAL;\n\tsc->ONLINE = 0;\t\t\tsc->RESET = AV_RESET;\n\tsc->REQUEST = AV_REQUEST;\tsc->IEN = AV_IEN;\n\tif (wtreset(sc)) {\n\t\tia->ia_iosize = AV_NPORT;\n\t\treturn 1;\n\t}\n\n\t/* Tape controller not found. */\n\tsc->type = UNKNOWN;\n\treturn 0;\n}"
  }
]