[
  {
    "function_name": "aic_dump_driver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2156-2173",
    "snippet": "void\naic_dump_driver(sc)\n\tstruct aic_softc *sc;\n{\n\tstruct aic_tinfo *ti;\n\tint i;\n\n\tprintf(\"nexus=%p prevphase=%x\\n\", sc->sc_nexus, sc->sc_prevphase);\n\tprintf(\"state=%x msgin=%x \", sc->sc_state, sc->sc_imess[0]);\n\tprintf(\"msgpriq=%x msgoutq=%x lastmsg=%x currmsg=%x\\n\", sc->sc_msgpriq,\n\t    sc->sc_msgoutq, sc->sc_lastmsg, sc->sc_currmsg);\n\tfor (i = 0; i < 7; i++) {\n\t\tti = &sc->sc_tinfo[i];\n\t\tprintf(\"tinfo%d: %d cmds %d disconnects %d timeouts\",\n\t\t    i, ti->cmds, ti->dconns, ti->touts);\n\t\tprintf(\" %d senses flags=%x\\n\", ti->senses, ti->flags);\n\t}\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d senses flags=%x\\n\"",
            "ti->senses",
            "ti->flags"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_dump_driver(sc)\n\tstruct aic_softc *sc;\n{\n\tstruct aic_tinfo *ti;\n\tint i;\n\n\tprintf(\"nexus=%p prevphase=%x\\n\", sc->sc_nexus, sc->sc_prevphase);\n\tprintf(\"state=%x msgin=%x \", sc->sc_state, sc->sc_imess[0]);\n\tprintf(\"msgpriq=%x msgoutq=%x lastmsg=%x currmsg=%x\\n\", sc->sc_msgpriq,\n\t    sc->sc_msgoutq, sc->sc_lastmsg, sc->sc_currmsg);\n\tfor (i = 0; i < 7; i++) {\n\t\tti = &sc->sc_tinfo[i];\n\t\tprintf(\"tinfo%d: %d cmds %d disconnects %d timeouts\",\n\t\t    i, ti->cmds, ti->dconns, ti->touts);\n\t\tprintf(\" %d senses flags=%x\\n\", ti->senses, ti->flags);\n\t}\n}"
  },
  {
    "function_name": "aic_dump6360",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2126-2154",
    "snippet": "void\naic_dump6360(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tprintf(\"aic6360: SCSISEQ=%x SXFRCTL0=%x SXFRCTL1=%x SCSISIG=%x\\n\",\n\t    bus_space_read_1(iot, ioh, SCSISEQ),\n\t    bus_space_read_1(iot, ioh, SXFRCTL0),\n\t    bus_space_read_1(iot, ioh, SXFRCTL1),\n\t    bus_space_read_1(iot, ioh, SCSISIG));\n\tprintf(\"         SSTAT0=%x SSTAT1=%x SSTAT2=%x SSTAT3=%x SSTAT4=%x\\n\",\n\t    bus_space_read_1(iot, ioh, SSTAT0),\n\t    bus_space_read_1(iot, ioh, SSTAT1),\n\t    bus_space_read_1(iot, ioh, SSTAT2),\n\t    bus_space_read_1(iot, ioh, SSTAT3),\n\t    bus_space_read_1(iot, ioh, SSTAT4));\n\tprintf(\"         SIMODE0=%x SIMODE1=%x \",\n\t    bus_space_read_1(iot, ioh, SIMODE0),\n\t    bus_space_read_1(iot, ioh, SIMODE1));\n\tprintf(\"DMACNTRL0=%x DMACNTRL1=%x DMASTAT=%x\\n\",\n\t    bus_space_read_1(iot, ioh, DMACNTRL0),\n\t    bus_space_read_1(iot, ioh, DMACNTRL1),\n\t    bus_space_read_1(iot, ioh, DMASTAT));\n\tprintf(\"         FIFOSTAT=%d SCSIBUS=0x%x\\n\",\n\t    bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SCSIBUS));\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"         FIFOSTAT=%d SCSIBUS=0x%x\\n\"",
            "bus_space_read_1(iot, ioh, FIFOSTAT)",
            "bus_space_read_1(iot, ioh, SCSIBUS)"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIBUS"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "FIFOSTAT"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL1"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE0"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT4"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT3"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT2"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT1"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT0"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_dump6360(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tprintf(\"aic6360: SCSISEQ=%x SXFRCTL0=%x SXFRCTL1=%x SCSISIG=%x\\n\",\n\t    bus_space_read_1(iot, ioh, SCSISEQ),\n\t    bus_space_read_1(iot, ioh, SXFRCTL0),\n\t    bus_space_read_1(iot, ioh, SXFRCTL1),\n\t    bus_space_read_1(iot, ioh, SCSISIG));\n\tprintf(\"         SSTAT0=%x SSTAT1=%x SSTAT2=%x SSTAT3=%x SSTAT4=%x\\n\",\n\t    bus_space_read_1(iot, ioh, SSTAT0),\n\t    bus_space_read_1(iot, ioh, SSTAT1),\n\t    bus_space_read_1(iot, ioh, SSTAT2),\n\t    bus_space_read_1(iot, ioh, SSTAT3),\n\t    bus_space_read_1(iot, ioh, SSTAT4));\n\tprintf(\"         SIMODE0=%x SIMODE1=%x \",\n\t    bus_space_read_1(iot, ioh, SIMODE0),\n\t    bus_space_read_1(iot, ioh, SIMODE1));\n\tprintf(\"DMACNTRL0=%x DMACNTRL1=%x DMASTAT=%x\\n\",\n\t    bus_space_read_1(iot, ioh, DMACNTRL0),\n\t    bus_space_read_1(iot, ioh, DMACNTRL1),\n\t    bus_space_read_1(iot, ioh, DMASTAT));\n\tprintf(\"         FIFOSTAT=%d SCSIBUS=0x%x\\n\",\n\t    bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SCSIBUS));\n}"
  },
  {
    "function_name": "aic_print_active_acb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2107-2124",
    "snippet": "void\naic_print_active_acb()\n{\n\tstruct aic_acb *acb;\n\tstruct aic_softc *sc = aic_cd.cd_devs[0];\n\n\tprintf(\"ready list:\\n\");\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next)\n\t\taic_print_acb(acb);\n\tprintf(\"nexus:\\n\");\n\tif (sc->sc_nexus != NULL)\n\t\taic_print_acb(sc->sc_nexus);\n\tprintf(\"nexus list:\\n\");\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next)\n\t\taic_print_acb(acb);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver aic_cd = {\n\tNULL, \"aic\", DV_DULL\n};",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_print_acb",
          "args": [
            "acb"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "aic_print_acb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "2096-2105",
          "snippet": "void\naic_print_acb(acb)\n\tstruct aic_acb *acb;\n{\n\n\tprintf(\"acb@%p xs=%p flags=%x\", acb, acb->xs, acb->flags);\n\tprintf(\" dp=%p dleft=%d target_stat=%x\\n\",\n\t       acb->data_addr, acb->data_length, acb->target_stat);\n\taic_show_scsi_cmd(acb);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint flags;\n\nvoid\naic_print_acb(acb)\n\tstruct aic_acb *acb;\n{\n\n\tprintf(\"acb@%p xs=%p flags=%x\", acb, acb->xs, acb->flags);\n\tprintf(\" dp=%p dleft=%d target_stat=%x\\n\",\n\t       acb->data_addr, acb->data_length, acb->target_stat);\n\taic_show_scsi_cmd(acb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"nexus list:\\n\""
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct cfdriver aic_cd = {\n\tNULL, \"aic\", DV_DULL\n};\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_print_active_acb()\n{\n\tstruct aic_acb *acb;\n\tstruct aic_softc *sc = aic_cd.cd_devs[0];\n\n\tprintf(\"ready list:\\n\");\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next)\n\t\taic_print_acb(acb);\n\tprintf(\"nexus:\\n\");\n\tif (sc->sc_nexus != NULL)\n\t\taic_print_acb(sc->sc_nexus);\n\tprintf(\"nexus list:\\n\");\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next)\n\t\taic_print_acb(acb);\n}"
  },
  {
    "function_name": "aic_print_acb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2096-2105",
    "snippet": "void\naic_print_acb(acb)\n\tstruct aic_acb *acb;\n{\n\n\tprintf(\"acb@%p xs=%p flags=%x\", acb, acb->xs, acb->flags);\n\tprintf(\" dp=%p dleft=%d target_stat=%x\\n\",\n\t       acb->data_addr, acb->data_length, acb->target_stat);\n\taic_show_scsi_cmd(acb);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_show_scsi_cmd",
          "args": [
            "acb"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "aic_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "2076-2094",
          "snippet": "void\naic_show_scsi_cmd(acb)\n\tstruct aic_acb *acb;\n{\n\tu_char  *b = (u_char *)&acb->scsi_cmd;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint i;\n\n\tsc_print_addr(sc_link);\n\tif ((acb->xs->flags & SCSI_RESET) == 0) {\n\t\tfor (i = 0; i < acb->scsi_cmd_length; i++) {\n\t\t\tif (i)\n\t\t\t\tprintf(\",\");\n\t\t\tprintf(\"%x\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"RESET\\n\");\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint flags;\n\nvoid\naic_show_scsi_cmd(acb)\n\tstruct aic_acb *acb;\n{\n\tu_char  *b = (u_char *)&acb->scsi_cmd;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint i;\n\n\tsc_print_addr(sc_link);\n\tif ((acb->xs->flags & SCSI_RESET) == 0) {\n\t\tfor (i = 0; i < acb->scsi_cmd_length; i++) {\n\t\t\tif (i)\n\t\t\t\tprintf(\",\");\n\t\t\tprintf(\"%x\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"RESET\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" dp=%p dleft=%d target_stat=%x\\n\"",
            "acb->data_addr",
            "acb->data_length",
            "acb->target_stat"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint flags;\n\nvoid\naic_print_acb(acb)\n\tstruct aic_acb *acb;\n{\n\n\tprintf(\"acb@%p xs=%p flags=%x\", acb, acb->xs, acb->flags);\n\tprintf(\" dp=%p dleft=%d target_stat=%x\\n\",\n\t       acb->data_addr, acb->data_length, acb->target_stat);\n\taic_show_scsi_cmd(acb);\n}"
  },
  {
    "function_name": "aic_show_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2076-2094",
    "snippet": "void\naic_show_scsi_cmd(acb)\n\tstruct aic_acb *acb;\n{\n\tu_char  *b = (u_char *)&acb->scsi_cmd;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint i;\n\n\tsc_print_addr(sc_link);\n\tif ((acb->xs->flags & SCSI_RESET) == 0) {\n\t\tfor (i = 0; i < acb->scsi_cmd_length; i++) {\n\t\t\tif (i)\n\t\t\t\tprintf(\",\");\n\t\t\tprintf(\"%x\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"RESET\\n\");\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RESET\\n\""
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint flags;\n\nvoid\naic_show_scsi_cmd(acb)\n\tstruct aic_acb *acb;\n{\n\tu_char  *b = (u_char *)&acb->scsi_cmd;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint i;\n\n\tsc_print_addr(sc_link);\n\tif ((acb->xs->flags & SCSI_RESET) == 0) {\n\t\tfor (i = 0; i < acb->scsi_cmd_length; i++) {\n\t\t\tif (i)\n\t\t\t\tprintf(\",\");\n\t\t\tprintf(\"%x\", b[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t} else\n\t\tprintf(\"RESET\\n\");\n}"
  },
  {
    "function_name": "aic_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2041-2068",
    "snippet": "void\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_timeout",
      "void\taic_abort",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_abort",
          "args": [
            "sc",
            "acb"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "aic_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "2016-2039",
          "snippet": "void\naic_abort(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\t/* 2 secs for the abort */\n\tacb->timeout = AIC_ABORT_TIMEOUT;\n\tacb->flags |= ACB_ABORT;\n\n\tif (acb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == AIC_CONNECTED)\n\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAIC_ABORT_TIMEOUT\t2000\t/* time to wait for abort */"
          ],
          "globals_used": [
            "void\taic_dequeue",
            "void\taic_sched",
            "void\taic_abort",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_ABORT_TIMEOUT\t2000\t/* time to wait for abort */\n\nvoid\taic_dequeue;\nvoid\taic_sched;\nvoid\taic_abort;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_abort(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\t/* 2 secs for the abort */\n\tacb->timeout = AIC_ABORT_TIMEOUT;\n\tacb->flags |= ACB_ABORT;\n\n\tif (acb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == AIC_CONNECTED)\n\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_timeout;\nvoid\taic_abort;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aic_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "2016-2039",
    "snippet": "void\naic_abort(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\t/* 2 secs for the abort */\n\tacb->timeout = AIC_ABORT_TIMEOUT;\n\tacb->flags |= ACB_ABORT;\n\n\tif (acb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == AIC_CONNECTED)\n\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAIC_ABORT_TIMEOUT\t2000\t/* time to wait for abort */"
    ],
    "globals_used": [
      "void\taic_dequeue",
      "void\taic_sched",
      "void\taic_abort",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_sched",
          "args": [
            "sc"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "740-776",
          "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_dequeue",
          "args": [
            "sc",
            "acb"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "aic_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "879-890",
          "snippet": "void\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_dequeue",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "598-609",
          "snippet": "integrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "integrate void",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\naic_sched_msgout __P((struct aic_softc *, u_char));\nintegrate void;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_ABORT_TIMEOUT\t2000\t/* time to wait for abort */\n\nvoid\taic_dequeue;\nvoid\taic_sched;\nvoid\taic_abort;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_abort(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\t/* 2 secs for the abort */\n\tacb->timeout = AIC_ABORT_TIMEOUT;\n\tacb->flags |= ACB_ABORT;\n\n\tif (acb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == AIC_CONNECTED)\n\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}"
  },
  {
    "function_name": "aicintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "1647-2014",
    "snippet": "int\naicintr(arg)\n\tvoid *arg;\n{\n\tregister struct aic_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat0, sstat1;\n\tregister struct aic_acb *acb;\n\tregister struct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\tint n;\n\n\t/*\n\t * Clear INTEN.  We enable it again before returning.  This makes the\n\t * interrupt esssentially level-triggered.\n\t */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\tAIC_TRACE((\"aicintr  \"));\n\nloop:\n\t/*\n\t * First check for abnormal conditions, such as reset.\n\t */\n\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\tAIC_MISC((\"sstat1:0x%02x \", sstat1));\n\n\tif ((sstat1 & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: SCSI bus reset\\n\", sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Check for less serious errors.\n\t */\n\tif ((sstat1 & SCSIPERR) != 0) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSCSIPERR);\n\t\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t} else\n\t\t\taic_sched_msgout(sc, SEND_INIT_DET_ERR);\n\t}\n\n\t/*\n\t * If we're not already busy doing something test for the following\n\t * conditions:\n\t * 1) We have been reselected by something\n\t * 2) We have selected something successfully\n\t * 3) Our selection process has timed out\n\t * 4) This is really a bus free interrupt just to get a new command\n\t *    going?\n\t * 5) Spurious interrupt?\n\t */\n\tswitch (sc->sc_state) {\n\tcase AIC_IDLE:\n\tcase AIC_SELECTING:\n\t\tsstat0 = bus_space_read_1(iot, ioh, SSTAT0);\n\t\tAIC_MISC((\"sstat0:0x%02x \", sstat0));\n\n\t\tif ((sstat0 & TARGET) != 0) {\n\t\t\t/*\n\t\t\t * We don't currently support target mode.\n\t\t\t */\n\t\t\tprintf(\"%s: target mode selected; going to BUS FREE\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, 0);\n\n\t\t\tgoto sched;\n\t\t} else if ((sstat0 & SELDI) != 0) {\n\t\t\tAIC_MISC((\"reselected  \"));\n\n\t\t\t/*\n\t\t\t * If we're trying to select a target ourselves,\n\t\t\t * push our command back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == AIC_SELECTING) {\n\t\t\t\tAIC_MISC((\"backoff selector  \"));\n\t\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\t\tacb = sc->sc_nexus;\n\t\t\t\tsc->sc_nexus = NULL;\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\t\t}\n\n\t\t\t/* Save reselection ID. */\n\t\t\tsc->sc_selid = bus_space_read_1(iot, ioh, SELID);\n\n\t\t\tsc->sc_state = AIC_RESELECTED;\n\t\t} else if ((sstat0 & SELDO) != 0) {\n\t\t\tAIC_MISC((\"selected  \"));\n\n\t\t\t/* We have selected a target. Things to do:\n\t\t\t * a) Determine what message(s) to send.\n\t\t\t * b) Verify that we're still selecting the target.\n\t\t\t * c) Mark device as busy.\n\t\t\t */\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection out while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tsc_link = acb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tsc->sc_msgpriq = SEND_IDENTIFY;\n\t\t\tif (acb->flags & ACB_RESET)\n\t\t\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\t\telse if (acb->flags & ACB_ABORT)\n\t\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t\telse {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tif ((ti->flags & DO_SYNC) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_SDTR;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tif ((ti->flags & DO_WIDE) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_WDTR;\n#endif\n\t\t\t}\n\n\t\t\tacb->flags |= ACB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\t\t\t/* On our first connection, schedule a timeout. */\n\t\t\tif ((acb->xs->flags & SCSI_POLL) == 0)\n\t\t\t\ttimeout(aic_timeout, acb,\n\t\t\t\t    (acb->timeout * hz) / 1000);\n\n\t\t\tsc->sc_state = AIC_CONNECTED;\n\t\t} else if ((sstat1 & SELTO) != 0) {\n\t\t\tAIC_MISC((\"selection timeout  \"));\n\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection timeout while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSELTIMO);\n\t\t\tdelay(250);\n\n\t\t\tacb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\t\t} else {\n\t\t\tif (sc->sc_state != AIC_IDLE) {\n\t\t\t\tprintf(\"%s: BUS FREE while not idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"state=%d\\n\", sc->sc_state);\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto sched;\n\t\t}\n\n\t\t/*\n\t\t * Turn off selection stuff, and prepare to catch bus free\n\t\t * interrupts, parity errors, and phase changes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRSTCNT | CLRCH);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENAUTOATNP);\n\t\tbus_space_write_1(iot, ioh, CLRSINT0, CLRSELDI | CLRSELDO);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\t\tbus_space_write_1(iot, ioh, SIMODE0, 0);\n\t\tbus_space_write_1(iot, ioh, SIMODE1,\n\t\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT |\n\t\t    ENPHASECHG);\n\n\t\tsc->sc_flags = 0;\n\t\tsc->sc_prevphase = PH_INVALID;\n\t\tgoto dophase;\n\t}\n\n\tif ((sstat1 & BUSFREE) != 0) {\n\t\t/* We've gone to BUS FREE phase. */\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase AIC_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase AIC_CONNECTED:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\t\t\t/*\n\t\t\t\t * If the target went to BUS FREE phase during\n\t\t\t\t * or immediately after sending a SDTR or WDTR\n\t\t\t\t * message, disable negotiation.\n\t\t\t\t */\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tcase SEND_SDTR:\n\t\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tcase SEND_WDTR:\n\t\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tif ((sc->sc_flags & AIC_ABORTING) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec suggests\n\t\t\t\t * issuing a REQUEST SENSE following an\n\t\t\t\t * unexpected disconnect.  Some devices go into\n\t\t\t\t * a contingent allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary to\n\t\t\t\t * clean up their state.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\taic_sense(sc, acb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tgoto finish;\n\n\t\tcase AIC_DISCONNECT:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n#if 1 /* XXXX */\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n#endif\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, acb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase AIC_CMDCOMPLETE:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh, CLRSINT1, CLRPHASECHG);\n\ndophase:\n\tif ((sstat1 & REQINIT) == 0) {\n\t\t/* Wait for REQINIT. */\n\t\tgoto out;\n\t}\n\n\tsc->sc_phase = bus_space_read_1(iot, ioh, SCSISIG) & PH_MASK;\n\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase);\n\n\tswitch (sc->sc_phase) {\n\tcase PH_MSGOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgout(sc);\n\t\tsc->sc_prevphase = PH_MSGOUT;\n\t\tgoto loop;\n\n\tcase PH_MSGIN:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgin(sc);\n\t\tsc->sc_prevphase = PH_MSGIN;\n\t\tgoto loop;\n\n\tcase PH_CMD:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n#if AIC_DEBUG\n\t\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tprintf(\"cmd=0x%02x+%d \",\n\t\t\t    acb->scsi_cmd.opcode, acb->scsi_cmd_length-1);\n\t\t}\n#endif\n\t\tn = aic_dataout_pio(sc, sc->sc_cp, sc->sc_cleft);\n\t\tsc->sc_cp += n;\n\t\tsc->sc_cleft -= n;\n\t\tsc->sc_prevphase = PH_CMD;\n\t\tgoto loop;\n\n\tcase PH_DATAOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"dataout dleft=%d \", sc->sc_dleft));\n\t\tn = aic_dataout_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAOUT;\n\t\tgoto loop;\n\n\tcase PH_DATAIN:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"datain %d \", sc->sc_dleft));\n\t\tn = aic_datain_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAIN;\n\t\tgoto loop;\n\n\tcase PH_STAT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\tacb->target_stat = bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\tAIC_MISC((\"target_stat=0x%02x \", acb->target_stat));\n\t\tsc->sc_prevphase = PH_STAT;\n\t\tgoto loop;\n\t}\n\n\tprintf(\"%s: unexpected bus phase; resetting\\n\", sc->sc_dev.dv_xname);\n\tAIC_BREAK();\nreset:\n\taic_init(sc);\n\treturn 1;\n\nfinish:\n\tuntimeout(aic_timeout, acb);\n\taic_done(sc, acb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = AIC_IDLE;\n\taic_sched(sc);\n\tgoto out;\n\nout:\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AIC_DEBUG\t\t1",
      "#define\tAIC_USE_WIDE\t\t0",
      "#define AIC_USE_SYNCHRONOUS\t0"
    ],
    "globals_used": [
      "void \taic_init",
      "void\taic_done",
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_timeout",
      "void\taic_sched",
      "void\taic_sense",
      "void\taic_msgin",
      "void\taic_msgout",
      "int\taic_dataout_pio",
      "int\taic_datain_pio",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "INTEN"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_sched",
          "args": [
            "sc"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "740-776",
          "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_done",
          "args": [
            "sc",
            "acb"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "aic_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "814-877",
          "snippet": "void\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\taic_done",
            "void\taic_dequeue",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_sched",
            "void\taic_free_acb",
            "void\taic_sense",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_DEBUG\t\t1\n\nvoid\taic_done;\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_sched;\nvoid\taic_free_acb;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "aic_timeout",
            "acb"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_init",
          "args": [
            "sc"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "aic_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "361-424",
          "snippet": "void\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAIC_MAX_WIDTH\t\t0",
            "#define\tAIC_USE_WIDE\t\t0",
            "#define AIC_SYNC_REQ_ACK_OFS \t8",
            "#define AIC_USE_SYNCHRONOUS\t0"
          ],
          "globals_used": [
            "void \taic_init",
            "void\taic_done",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_timeout",
            "void\taic_scsi_reset",
            "void\taic_reset",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_MAX_WIDTH\t\t0\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_SYNC_REQ_ACK_OFS \t8\n#define AIC_USE_SYNCHRONOUS\t0\n\nvoid \taic_init;\nvoid\taic_done;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_timeout;\nvoid\taic_scsi_reset;\nvoid\taic_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected bus phase; resetting\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"target_stat=0x%02x \", acb->target_stat)"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | SPIOEN"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_datain_pio",
          "args": [
            "sc",
            "sc->sc_dp",
            "sc->sc_dleft"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "aic_datain_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "1523-1640",
          "snippet": "int\naic_datain_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat;\n\tint in = 0;\n#define DINAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* We leave this loop if one or more of the following is true:\n\t * a) phase != PH_DATAIN && FIFOs are empty\n\t * b) SCSIRSTI is set (a reset has occurred) or busfree is detected.\n\t */\n\twhile (n > 0) {\n\t\t/* Wait for fifo half full or phase mismatch */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOFULL | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & DFIFOFULL) != 0) {\n\t\t\tn -= DINAMOUNT;\n\t\t\tin += DINAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DINAMOUNT >> 2);\n#else\n\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DINAMOUNT >> 1);\n#endif\n\n\t\t\tp += DINAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = min(bus_space_read_1(iot, ioh, FIFOSTAT), n);\n\t\t\tAIC_MISC((\">%d \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tin += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE);\n\t\t\t\tbus_space_read_multi_1(iot, ioh, DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO);\n\t\t\t}\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\t}\n\n\t/* Some SCSI-devices are rude enough to transfer more data than what\n\t * was requested, e.g. 2048 bytes from a CD-ROM instead of the\n\t * requested 512.  Test for progress, i.e. real transfers.  If no real\n\t * transfers have been performed (n is probably already zero) and the\n\t * FIFO is not empty, waste some bytes....\n\t */\n\tif (in == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t}\n\nphasechange:\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn in;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DINAMOUNT 128\t\t/* Full FIFO */",
            "#define AIC_USE_DWORDS\t\t0"
          ],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "int\taic_datain_pio",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DINAMOUNT 128\t\t/* Full FIFO */\n#define AIC_USE_DWORDS\t\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint\taic_datain_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nint\naic_datain_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat;\n\tint in = 0;\n#define DINAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* We leave this loop if one or more of the following is true:\n\t * a) phase != PH_DATAIN && FIFOs are empty\n\t * b) SCSIRSTI is set (a reset has occurred) or busfree is detected.\n\t */\n\twhile (n > 0) {\n\t\t/* Wait for fifo half full or phase mismatch */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOFULL | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & DFIFOFULL) != 0) {\n\t\t\tn -= DINAMOUNT;\n\t\t\tin += DINAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DINAMOUNT >> 2);\n#else\n\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DINAMOUNT >> 1);\n#endif\n\n\t\t\tp += DINAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = min(bus_space_read_1(iot, ioh, FIFOSTAT), n);\n\t\t\tAIC_MISC((\">%d \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tin += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE);\n\t\t\t\tbus_space_read_multi_1(iot, ioh, DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO);\n\t\t\t}\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\t}\n\n\t/* Some SCSI-devices are rude enough to transfer more data than what\n\t * was requested, e.g. 2048 bytes from a CD-ROM instead of the\n\t * requested 512.  Test for progress, i.e. real transfers.  If no real\n\t * transfers have been performed (n is probably already zero) and the\n\t * FIFO is not empty, waste some bytes....\n\t */\n\tif (in == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t}\n\nphasechange:\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"datain %d \", sc->sc_dleft)"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_dataout_pio",
          "args": [
            "sc",
            "sc->sc_dp",
            "sc->sc_dleft"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "aic_dataout_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "1378-1514",
          "snippet": "int\naic_dataout_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat = 0;\n\tint out = 0;\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO | WRITE);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO | WRITE);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* I have tried to make the main loop as tight as possible.  This\n\t * means that some of the code following the loop is a bit more\n\t * complex than otherwise.\n\t */\n\twhile (n > 0) {\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOEMP | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\n\t\tif (n >= DOUTAMOUNT) {\n\t\t\tn -= DOUTAMOUNT;\n\t\t\tout += DOUTAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DOUTAMOUNT >> 2);\n#else\n\t\t\tbus_space_write_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DOUTAMOUNT >> 1);\n#endif\n\n\t\t\tp += DOUTAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = n;\n\t\t\tAIC_MISC((\"%d> \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tout += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_write_multi_2(iot, ioh,  DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE | WRITE);\n\t\t\t\tbus_space_write_multi_1(iot, ioh,  DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO | WRITE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (out == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t} else {\n\t\t/* See the bytes off chip */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\t\tgoto phasechange;\n\t\t\tif ((dmastat & DFIFOEMP) != 0 &&\n\t\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & SEMPTY) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nphasechange:\n\tif ((dmastat & INTSTAT) != 0) {\n\t\t/* Some sort of phase change. */\n\t\tint amount;\n\n\t\t/* Stop transfers, do some accounting */\n\t\tamount = bus_space_read_1(iot, ioh, FIFOSTAT) +\n\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & 15);\n\t\tif (amount > 0) {\n\t\t\tout -= amount;\n\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t    RSTFIFO | WRITE);\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH);\n\t\t\tAIC_MISC((\"+%d \", amount));\n\t\t}\n\t}\n\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn out;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DOUTAMOUNT 128\t\t/* Full FIFO */",
            "#define AIC_USE_DWORDS\t\t0"
          ],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "int\taic_dataout_pio",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n#define AIC_USE_DWORDS\t\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint\taic_dataout_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nint\naic_dataout_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat = 0;\n\tint out = 0;\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO | WRITE);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO | WRITE);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* I have tried to make the main loop as tight as possible.  This\n\t * means that some of the code following the loop is a bit more\n\t * complex than otherwise.\n\t */\n\twhile (n > 0) {\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOEMP | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\n\t\tif (n >= DOUTAMOUNT) {\n\t\t\tn -= DOUTAMOUNT;\n\t\t\tout += DOUTAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DOUTAMOUNT >> 2);\n#else\n\t\t\tbus_space_write_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DOUTAMOUNT >> 1);\n#endif\n\n\t\t\tp += DOUTAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = n;\n\t\t\tAIC_MISC((\"%d> \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tout += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_write_multi_2(iot, ioh,  DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE | WRITE);\n\t\t\t\tbus_space_write_multi_1(iot, ioh,  DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO | WRITE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (out == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t} else {\n\t\t/* See the bytes off chip */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\t\tgoto phasechange;\n\t\t\tif ((dmastat & DFIFOEMP) != 0 &&\n\t\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & SEMPTY) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nphasechange:\n\tif ((dmastat & INTSTAT) != 0) {\n\t\t/* Some sort of phase change. */\n\t\tint amount;\n\n\t\t/* Stop transfers, do some accounting */\n\t\tamount = bus_space_read_1(iot, ioh, FIFOSTAT) +\n\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & 15);\n\t\tif (amount > 0) {\n\t\t\tout -= amount;\n\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t    RSTFIFO | WRITE);\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH);\n\t\t\tAIC_MISC((\"+%d \", amount));\n\t\t}\n\t}\n\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"dataout dleft=%d \", sc->sc_dleft)"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_msgin",
          "args": [
            "sc"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "aic_msgin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "905-1180",
          "snippet": "void\naic_msgin(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgin  \"));\n\n\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_flags &= ~AIC_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If parity error, just dump everything on the floor. */\n\t\tif ((sstat1 & SCSIPERR) != 0) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_flags & AIC_DROP_MSGIN) == 0) {\n\t\t\tif (n >= AIC_MAX_MSG_LEN) {\n\t\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = bus_space_read_1(iot, ioh,\n\t\t\t\t    SCSIDAT);\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t    n == sc->sc_imess[1] + 2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\t/* Ack the last byte read. */\n\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\t}\n\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n\n\t/* We now have a complete message.  Parse it. */\n\tswitch (sc->sc_state) {\n\t\tstruct aic_acb *acb;\n\t\tstruct scsi_link *sc_link;\n\t\tstruct aic_tinfo *ti;\n\n\tcase AIC_CONNECTED:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[acb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tacb->data_length = 0;\n\t\t\t}\n\t\t\tacb->xs->resid = acb->data_length = sc->sc_dleft;\n\t\t\tsc->sc_state = AIC_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_PARITY_ERROR:\n\t\t\t/* Resend the last message. */\n\t\t\taic_sched_msgout(sc, sc->sc_lastmsg);\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tAIC_MISC((\"message rejected %02x  \", sc->sc_lastmsg));\n\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tcase SEND_IDENTIFY:\n\t\t\t\tti->flags &= ~(DO_SYNC | DO_WIDE);\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase SEND_SDTR:\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\tcase SEND_WDTR:\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = AIC_DISCONNECT;\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tswitch (sc->sc_imess[2]) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tif (ti->offset == 0) {\n\t\t\t\t} else if (ti->period < sc->sc_minsync ||\n\t\t\t\t    ti->period > sc->sc_maxsync ||\n\t\t\t\t    ti->offset > 8) {\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_SDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"sync, offset %d, \",\n\t\t\t\t\t    ti->offset);\n\t\t\t\t\tprintf(\"period %dnsec\\n\",\n\t\t\t\t\t    ti->period * 4);\n\t\t\t\t}\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\t\t\tcase MSG_EXT_WDTR:\n\t\t\t\tif (sc->sc_imess[1] != 2)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->width = sc->sc_imess[3];\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tif (ti->width == 0) {\n\t\t\t\t} else if (ti->width > AIC_MAX_WIDTH) {\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_WDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"wide, width %d\\n\",\n\t\t\t\t\t    1 << (3 + ti->width));\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REJECT\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tAIC_BREAK();\n\t\treject:\n\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AIC_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY; \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\t\tAIC_BREAK();\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) aic_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\treset:\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\t\tbreak;\n\n#ifdef notdef\n\tabort:\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n#endif\n\t}\n\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t/* Ack the last message byte. */\n\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t;\n\n\t/* Go get the next message, if any. */\n\tgoto nextmsg;\n\nout:\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAIC_MAX_WIDTH\t\t0",
            "#define\tAIC_USE_WIDE\t\t0",
            "#define AIC_USE_SYNCHRONOUS\t0"
          ],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "int\taic_reselect",
            "void\taic_msgin",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_MAX_WIDTH\t\t0\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nint\taic_reselect;\nvoid\taic_msgin;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_msgin(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgin  \"));\n\n\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_flags &= ~AIC_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If parity error, just dump everything on the floor. */\n\t\tif ((sstat1 & SCSIPERR) != 0) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_flags & AIC_DROP_MSGIN) == 0) {\n\t\t\tif (n >= AIC_MAX_MSG_LEN) {\n\t\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = bus_space_read_1(iot, ioh,\n\t\t\t\t    SCSIDAT);\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t    n == sc->sc_imess[1] + 2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\t/* Ack the last byte read. */\n\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\t}\n\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n\n\t/* We now have a complete message.  Parse it. */\n\tswitch (sc->sc_state) {\n\t\tstruct aic_acb *acb;\n\t\tstruct scsi_link *sc_link;\n\t\tstruct aic_tinfo *ti;\n\n\tcase AIC_CONNECTED:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[acb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tacb->data_length = 0;\n\t\t\t}\n\t\t\tacb->xs->resid = acb->data_length = sc->sc_dleft;\n\t\t\tsc->sc_state = AIC_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_PARITY_ERROR:\n\t\t\t/* Resend the last message. */\n\t\t\taic_sched_msgout(sc, sc->sc_lastmsg);\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tAIC_MISC((\"message rejected %02x  \", sc->sc_lastmsg));\n\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tcase SEND_IDENTIFY:\n\t\t\t\tti->flags &= ~(DO_SYNC | DO_WIDE);\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase SEND_SDTR:\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\tcase SEND_WDTR:\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = AIC_DISCONNECT;\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tswitch (sc->sc_imess[2]) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tif (ti->offset == 0) {\n\t\t\t\t} else if (ti->period < sc->sc_minsync ||\n\t\t\t\t    ti->period > sc->sc_maxsync ||\n\t\t\t\t    ti->offset > 8) {\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_SDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"sync, offset %d, \",\n\t\t\t\t\t    ti->offset);\n\t\t\t\t\tprintf(\"period %dnsec\\n\",\n\t\t\t\t\t    ti->period * 4);\n\t\t\t\t}\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\t\t\tcase MSG_EXT_WDTR:\n\t\t\t\tif (sc->sc_imess[1] != 2)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->width = sc->sc_imess[3];\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tif (ti->width == 0) {\n\t\t\t\t} else if (ti->width > AIC_MAX_WIDTH) {\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_WDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"wide, width %d\\n\",\n\t\t\t\t\t    1 << (3 + ti->width));\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REJECT\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tAIC_BREAK();\n\t\treject:\n\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AIC_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY; \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\t\tAIC_BREAK();\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) aic_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\treset:\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\t\tbreak;\n\n#ifdef notdef\n\tabort:\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n#endif\n\t}\n\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t/* Ack the last message byte. */\n\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t;\n\n\t/* Go get the next message, if any. */\n\tgoto nextmsg;\n\nout:\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_msgout",
          "args": [
            "sc"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "aic_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "1185-1370",
          "snippet": "void\naic_msgout(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n#if AIC_USE_SYNCHRONOUS\n\tstruct aic_tinfo *ti;\n#endif\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgout  \"));\n\n\t/* Reset the FIFO. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\n\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tAIC_MISC((\"retransmitting  \"));\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\t/*\n\t\t\t * Set ATN.  If we're just sending a trivial 1-byte\n\t\t\t * message, we'll clear ATN later on anyway.\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, PH_MSGOUT | ATNO);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\tsc->sc_lastmsg = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_currmsg = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_currmsg;\n\tsc->sc_msgoutq |= sc->sc_currmsg;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_currmsg) {\n\tcase SEND_IDENTIFY:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tsc->sc_omess[0] =\n\t\t    MSG_IDENTIFY(sc->sc_nexus->xs->sc_link->lun, 1);\n\t\tn = 1;\n\t\tbreak;\n\n#if AIC_USE_SYNCHRONOUS\n\tcase SEND_SDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[4] = MSG_EXTENDED;\n\t\tsc->sc_omess[3] = 3;\n\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\tsc->sc_omess[1] = ti->period >> 2;\n\t\tsc->sc_omess[0] = ti->offset;\n\t\tn = 5;\n\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\tcase SEND_WDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[3] = MSG_EXTENDED;\n\t\tsc->sc_omess[2] = 2;\n\t\tsc->sc_omess[1] = MSG_EXT_WDTR;\n\t\tsc->sc_omess[0] = ti->width;\n\t\tn = 4;\n\t\tbreak;\n#endif\n\n\tcase SEND_DEV_RESET:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t *\n\t\t\t * If this is the last message being sent, then we\n\t\t\t * deassert ATN, since either the target is going to\n\t\t\t * ignore this message, or it's going to ask for a\n\t\t\t * retransmission via MESSAGE PARITY ERROR (in which\n\t\t\t * case we reassert ATN anyway).\n\t\t\t */\n\t\t\tif (sc->sc_msgpriq == 0)\n\t\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 1 && sc->sc_msgpriq == 0)\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t/* Send message byte. */\n\t\tbus_space_write_1(iot, ioh, SCSIDAT, *--sc->sc_omp);\n\t\t--n;\n\t\t/* Keep track of the last message we've sent any bytes of. */\n\t\tsc->sc_lastmsg = sc->sc_currmsg;\n\t\t/* Wait for ACK to be negated.  XXX Need timeout. */\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t}\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Disable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAIC_USE_WIDE\t\t0",
            "#define AIC_USE_SYNCHRONOUS\t0"
          ],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_msgout",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_msgout;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_msgout(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n#if AIC_USE_SYNCHRONOUS\n\tstruct aic_tinfo *ti;\n#endif\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgout  \"));\n\n\t/* Reset the FIFO. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\n\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tAIC_MISC((\"retransmitting  \"));\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\t/*\n\t\t\t * Set ATN.  If we're just sending a trivial 1-byte\n\t\t\t * message, we'll clear ATN later on anyway.\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, PH_MSGOUT | ATNO);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\tsc->sc_lastmsg = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_currmsg = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_currmsg;\n\tsc->sc_msgoutq |= sc->sc_currmsg;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_currmsg) {\n\tcase SEND_IDENTIFY:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tsc->sc_omess[0] =\n\t\t    MSG_IDENTIFY(sc->sc_nexus->xs->sc_link->lun, 1);\n\t\tn = 1;\n\t\tbreak;\n\n#if AIC_USE_SYNCHRONOUS\n\tcase SEND_SDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[4] = MSG_EXTENDED;\n\t\tsc->sc_omess[3] = 3;\n\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\tsc->sc_omess[1] = ti->period >> 2;\n\t\tsc->sc_omess[0] = ti->offset;\n\t\tn = 5;\n\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\tcase SEND_WDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[3] = MSG_EXTENDED;\n\t\tsc->sc_omess[2] = 2;\n\t\tsc->sc_omess[1] = MSG_EXT_WDTR;\n\t\tsc->sc_omess[0] = ti->width;\n\t\tn = 4;\n\t\tbreak;\n#endif\n\n\tcase SEND_DEV_RESET:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t *\n\t\t\t * If this is the last message being sent, then we\n\t\t\t * deassert ATN, since either the target is going to\n\t\t\t * ignore this message, or it's going to ask for a\n\t\t\t * retransmission via MESSAGE PARITY ERROR (in which\n\t\t\t * case we reassert ATN anyway).\n\t\t\t */\n\t\t\tif (sc->sc_msgpriq == 0)\n\t\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 1 && sc->sc_msgpriq == 0)\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t/* Send message byte. */\n\t\tbus_space_write_1(iot, ioh, SCSIDAT, *--sc->sc_omp);\n\t\t--n;\n\t\t/* Keep track of the last message we've sent any bytes of. */\n\t\tsc->sc_lastmsg = sc->sc_currmsg;\n\t\t/* Wait for ACK to be negated.  XXX Need timeout. */\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t}\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Disable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG",
            "sc->sc_phase"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRPHASECHG"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->nexus_list",
            "acb",
            "chain"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_sense",
          "args": [
            "sc",
            "acb"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "778-809",
          "snippet": "void\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_dequeue",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "void\taic_sense",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRBUSFREE | CLRPHASECHG"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT |\n\t\t    ENPHASECHG"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE0",
            "0"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRBUSFREE | CLRPHASECHG"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT0",
            "CLRSELDI | CLRSELDO"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "ENAUTOATNP"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "0"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | CLRSTCNT | CLRCH"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRSELTIMO"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "ENRESELI"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "0"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"selection timeout  \")"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "aic_timeout",
            "acb",
            "(acb->timeout * hz) / 1000"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "aic_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "2041-2068",
          "snippet": "void\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_timeout",
            "void\taic_abort",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_timeout;\nvoid\taic_abort;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"selected  \")"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SELID"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"backoff selector  \")"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"reselected  \")"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG",
            "0"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"sstat0:0x%02x \", sstat0)"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT0"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_sched_msgout",
          "args": [
            "sc",
            "SEND_INIT_DET_ERR"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "598-609",
          "snippet": "integrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "integrate void",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\naic_sched_msgout __P((struct aic_softc *, u_char));\nintegrate void;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRSCSIPERR"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"sstat1:0x%02x \", sstat1)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT1"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aicintr  \")"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "0"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_DEBUG\t\t1\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\nvoid \taic_init;\nvoid\taic_done;\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_timeout;\nvoid\taic_sched;\nvoid\taic_sense;\nvoid\taic_msgin;\nvoid\taic_msgout;\nint\taic_dataout_pio;\nint\taic_datain_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naicintr(arg)\n\tvoid *arg;\n{\n\tregister struct aic_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat0, sstat1;\n\tregister struct aic_acb *acb;\n\tregister struct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\tint n;\n\n\t/*\n\t * Clear INTEN.  We enable it again before returning.  This makes the\n\t * interrupt esssentially level-triggered.\n\t */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\tAIC_TRACE((\"aicintr  \"));\n\nloop:\n\t/*\n\t * First check for abnormal conditions, such as reset.\n\t */\n\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\tAIC_MISC((\"sstat1:0x%02x \", sstat1));\n\n\tif ((sstat1 & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: SCSI bus reset\\n\", sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Check for less serious errors.\n\t */\n\tif ((sstat1 & SCSIPERR) != 0) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSCSIPERR);\n\t\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t} else\n\t\t\taic_sched_msgout(sc, SEND_INIT_DET_ERR);\n\t}\n\n\t/*\n\t * If we're not already busy doing something test for the following\n\t * conditions:\n\t * 1) We have been reselected by something\n\t * 2) We have selected something successfully\n\t * 3) Our selection process has timed out\n\t * 4) This is really a bus free interrupt just to get a new command\n\t *    going?\n\t * 5) Spurious interrupt?\n\t */\n\tswitch (sc->sc_state) {\n\tcase AIC_IDLE:\n\tcase AIC_SELECTING:\n\t\tsstat0 = bus_space_read_1(iot, ioh, SSTAT0);\n\t\tAIC_MISC((\"sstat0:0x%02x \", sstat0));\n\n\t\tif ((sstat0 & TARGET) != 0) {\n\t\t\t/*\n\t\t\t * We don't currently support target mode.\n\t\t\t */\n\t\t\tprintf(\"%s: target mode selected; going to BUS FREE\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, 0);\n\n\t\t\tgoto sched;\n\t\t} else if ((sstat0 & SELDI) != 0) {\n\t\t\tAIC_MISC((\"reselected  \"));\n\n\t\t\t/*\n\t\t\t * If we're trying to select a target ourselves,\n\t\t\t * push our command back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == AIC_SELECTING) {\n\t\t\t\tAIC_MISC((\"backoff selector  \"));\n\t\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\t\tacb = sc->sc_nexus;\n\t\t\t\tsc->sc_nexus = NULL;\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\t\t}\n\n\t\t\t/* Save reselection ID. */\n\t\t\tsc->sc_selid = bus_space_read_1(iot, ioh, SELID);\n\n\t\t\tsc->sc_state = AIC_RESELECTED;\n\t\t} else if ((sstat0 & SELDO) != 0) {\n\t\t\tAIC_MISC((\"selected  \"));\n\n\t\t\t/* We have selected a target. Things to do:\n\t\t\t * a) Determine what message(s) to send.\n\t\t\t * b) Verify that we're still selecting the target.\n\t\t\t * c) Mark device as busy.\n\t\t\t */\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection out while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tsc_link = acb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tsc->sc_msgpriq = SEND_IDENTIFY;\n\t\t\tif (acb->flags & ACB_RESET)\n\t\t\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\t\telse if (acb->flags & ACB_ABORT)\n\t\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t\telse {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tif ((ti->flags & DO_SYNC) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_SDTR;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tif ((ti->flags & DO_WIDE) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_WDTR;\n#endif\n\t\t\t}\n\n\t\t\tacb->flags |= ACB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\t\t\t/* On our first connection, schedule a timeout. */\n\t\t\tif ((acb->xs->flags & SCSI_POLL) == 0)\n\t\t\t\ttimeout(aic_timeout, acb,\n\t\t\t\t    (acb->timeout * hz) / 1000);\n\n\t\t\tsc->sc_state = AIC_CONNECTED;\n\t\t} else if ((sstat1 & SELTO) != 0) {\n\t\t\tAIC_MISC((\"selection timeout  \"));\n\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection timeout while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSELTIMO);\n\t\t\tdelay(250);\n\n\t\t\tacb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\t\t} else {\n\t\t\tif (sc->sc_state != AIC_IDLE) {\n\t\t\t\tprintf(\"%s: BUS FREE while not idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"state=%d\\n\", sc->sc_state);\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto sched;\n\t\t}\n\n\t\t/*\n\t\t * Turn off selection stuff, and prepare to catch bus free\n\t\t * interrupts, parity errors, and phase changes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRSTCNT | CLRCH);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENAUTOATNP);\n\t\tbus_space_write_1(iot, ioh, CLRSINT0, CLRSELDI | CLRSELDO);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\t\tbus_space_write_1(iot, ioh, SIMODE0, 0);\n\t\tbus_space_write_1(iot, ioh, SIMODE1,\n\t\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT |\n\t\t    ENPHASECHG);\n\n\t\tsc->sc_flags = 0;\n\t\tsc->sc_prevphase = PH_INVALID;\n\t\tgoto dophase;\n\t}\n\n\tif ((sstat1 & BUSFREE) != 0) {\n\t\t/* We've gone to BUS FREE phase. */\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase AIC_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase AIC_CONNECTED:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\t\t\t/*\n\t\t\t\t * If the target went to BUS FREE phase during\n\t\t\t\t * or immediately after sending a SDTR or WDTR\n\t\t\t\t * message, disable negotiation.\n\t\t\t\t */\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tcase SEND_SDTR:\n\t\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tcase SEND_WDTR:\n\t\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tif ((sc->sc_flags & AIC_ABORTING) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec suggests\n\t\t\t\t * issuing a REQUEST SENSE following an\n\t\t\t\t * unexpected disconnect.  Some devices go into\n\t\t\t\t * a contingent allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary to\n\t\t\t\t * clean up their state.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\taic_sense(sc, acb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tgoto finish;\n\n\t\tcase AIC_DISCONNECT:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n#if 1 /* XXXX */\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n#endif\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, acb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase AIC_CMDCOMPLETE:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh, CLRSINT1, CLRPHASECHG);\n\ndophase:\n\tif ((sstat1 & REQINIT) == 0) {\n\t\t/* Wait for REQINIT. */\n\t\tgoto out;\n\t}\n\n\tsc->sc_phase = bus_space_read_1(iot, ioh, SCSISIG) & PH_MASK;\n\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase);\n\n\tswitch (sc->sc_phase) {\n\tcase PH_MSGOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgout(sc);\n\t\tsc->sc_prevphase = PH_MSGOUT;\n\t\tgoto loop;\n\n\tcase PH_MSGIN:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgin(sc);\n\t\tsc->sc_prevphase = PH_MSGIN;\n\t\tgoto loop;\n\n\tcase PH_CMD:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n#if AIC_DEBUG\n\t\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tprintf(\"cmd=0x%02x+%d \",\n\t\t\t    acb->scsi_cmd.opcode, acb->scsi_cmd_length-1);\n\t\t}\n#endif\n\t\tn = aic_dataout_pio(sc, sc->sc_cp, sc->sc_cleft);\n\t\tsc->sc_cp += n;\n\t\tsc->sc_cleft -= n;\n\t\tsc->sc_prevphase = PH_CMD;\n\t\tgoto loop;\n\n\tcase PH_DATAOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"dataout dleft=%d \", sc->sc_dleft));\n\t\tn = aic_dataout_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAOUT;\n\t\tgoto loop;\n\n\tcase PH_DATAIN:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"datain %d \", sc->sc_dleft));\n\t\tn = aic_datain_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAIN;\n\t\tgoto loop;\n\n\tcase PH_STAT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\tacb->target_stat = bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\tAIC_MISC((\"target_stat=0x%02x \", acb->target_stat));\n\t\tsc->sc_prevphase = PH_STAT;\n\t\tgoto loop;\n\t}\n\n\tprintf(\"%s: unexpected bus phase; resetting\\n\", sc->sc_dev.dv_xname);\n\tAIC_BREAK();\nreset:\n\taic_init(sc);\n\treturn 1;\n\nfinish:\n\tuntimeout(aic_timeout, acb);\n\taic_done(sc, acb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = AIC_IDLE;\n\taic_sched(sc);\n\tgoto out;\n\nout:\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n\treturn 1;\n}"
  },
  {
    "function_name": "aic_datain_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "1523-1640",
    "snippet": "int\naic_datain_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat;\n\tint in = 0;\n#define DINAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* We leave this loop if one or more of the following is true:\n\t * a) phase != PH_DATAIN && FIFOs are empty\n\t * b) SCSIRSTI is set (a reset has occurred) or busfree is detected.\n\t */\n\twhile (n > 0) {\n\t\t/* Wait for fifo half full or phase mismatch */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOFULL | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & DFIFOFULL) != 0) {\n\t\t\tn -= DINAMOUNT;\n\t\t\tin += DINAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DINAMOUNT >> 2);\n#else\n\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DINAMOUNT >> 1);\n#endif\n\n\t\t\tp += DINAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = min(bus_space_read_1(iot, ioh, FIFOSTAT), n);\n\t\t\tAIC_MISC((\">%d \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tin += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE);\n\t\t\t\tbus_space_read_multi_1(iot, ioh, DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO);\n\t\t\t}\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\t}\n\n\t/* Some SCSI-devices are rude enough to transfer more data than what\n\t * was requested, e.g. 2048 bytes from a CD-ROM instead of the\n\t * requested 512.  Test for progress, i.e. real transfers.  If no real\n\t * transfers have been performed (n is probably already zero) and the\n\t * FIFO is not empty, waste some bytes....\n\t */\n\tif (in == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t}\n\nphasechange:\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn in;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DINAMOUNT 128\t\t/* Full FIFO */",
      "#define AIC_USE_DWORDS\t\t0"
    ],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "int\taic_datain_pio",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "0"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"extra data  \")"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "0"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "BITBUCKET"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | DWORDPIO"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_1",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "p",
            "xfer"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | B8MODE"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_2",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "(u_int16_t *)p",
            "xfer >> 1"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_4",
          "args": [
            "iot",
            "ioh",
            "DMADATALONG",
            "(u_int32_t *)p",
            "xfer >> 2"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\">%d \", xfer)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bus_space_read_1(iot, ioh, FIFOSTAT)",
            "n"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "aic_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "555-564",
          "snippet": "void\naic_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tAIC_TRACE((\"aic_minphys  \"));\n\tif (bp->b_bcount > (AIC_NSEG << PGSHIFT))\n\t\tbp->b_bcount = (AIC_NSEG << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_minphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_minphys;\n\nvoid\naic_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tAIC_TRACE((\"aic_minphys  \"));\n\tif (bp->b_bcount > (AIC_NSEG << PGSHIFT))\n\t\tbp->b_bcount = (AIC_NSEG << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "FIFOSTAT"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_2",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "(u_int16_t *)p",
            "DINAMOUNT >> 1"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_4",
          "args": [
            "iot",
            "ioh",
            "DMADATALONG",
            "(u_int32_t *)p",
            "DINAMOUNT >> 2"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "SCSIEN | DMAEN | CHEN"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | DWORDPIO"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "RSTFIFO"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2))"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT2"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "FIFOSTAT"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DINAMOUNT 128\t\t/* Full FIFO */\n#define AIC_USE_DWORDS\t\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint\taic_datain_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nint\naic_datain_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat;\n\tint in = 0;\n#define DINAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* We leave this loop if one or more of the following is true:\n\t * a) phase != PH_DATAIN && FIFOs are empty\n\t * b) SCSIRSTI is set (a reset has occurred) or busfree is detected.\n\t */\n\twhile (n > 0) {\n\t\t/* Wait for fifo half full or phase mismatch */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOFULL | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & DFIFOFULL) != 0) {\n\t\t\tn -= DINAMOUNT;\n\t\t\tin += DINAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DINAMOUNT >> 2);\n#else\n\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DINAMOUNT >> 1);\n#endif\n\n\t\t\tp += DINAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = min(bus_space_read_1(iot, ioh, FIFOSTAT), n);\n\t\t\tAIC_MISC((\">%d \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tin += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_read_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_read_multi_2(iot, ioh, DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE);\n\t\t\t\tbus_space_read_multi_1(iot, ioh, DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO);\n\t\t\t}\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\t}\n\n\t/* Some SCSI-devices are rude enough to transfer more data than what\n\t * was requested, e.g. 2048 bytes from a CD-ROM instead of the\n\t * requested 512.  Test for progress, i.e. real transfers.  If no real\n\t * transfers have been performed (n is probably already zero) and the\n\t * FIFO is not empty, waste some bytes....\n\t */\n\tif (in == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t}\n\nphasechange:\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn in;\n}"
  },
  {
    "function_name": "aic_dataout_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "1378-1514",
    "snippet": "int\naic_dataout_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat = 0;\n\tint out = 0;\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO | WRITE);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO | WRITE);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* I have tried to make the main loop as tight as possible.  This\n\t * means that some of the code following the loop is a bit more\n\t * complex than otherwise.\n\t */\n\twhile (n > 0) {\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOEMP | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\n\t\tif (n >= DOUTAMOUNT) {\n\t\t\tn -= DOUTAMOUNT;\n\t\t\tout += DOUTAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DOUTAMOUNT >> 2);\n#else\n\t\t\tbus_space_write_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DOUTAMOUNT >> 1);\n#endif\n\n\t\t\tp += DOUTAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = n;\n\t\t\tAIC_MISC((\"%d> \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tout += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_write_multi_2(iot, ioh,  DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE | WRITE);\n\t\t\t\tbus_space_write_multi_1(iot, ioh,  DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO | WRITE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (out == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t} else {\n\t\t/* See the bytes off chip */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\t\tgoto phasechange;\n\t\t\tif ((dmastat & DFIFOEMP) != 0 &&\n\t\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & SEMPTY) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nphasechange:\n\tif ((dmastat & INTSTAT) != 0) {\n\t\t/* Some sort of phase change. */\n\t\tint amount;\n\n\t\t/* Stop transfers, do some accounting */\n\t\tamount = bus_space_read_1(iot, ioh, FIFOSTAT) +\n\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & 15);\n\t\tif (amount > 0) {\n\t\t\tout -= amount;\n\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t    RSTFIFO | WRITE);\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH);\n\t\t\tAIC_MISC((\"+%d \", amount));\n\t\t}\n\t}\n\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn out;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DOUTAMOUNT 128\t\t/* Full FIFO */",
      "#define AIC_USE_DWORDS\t\t0"
    ],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "int\taic_dataout_pio",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "0"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"+%d \", amount)"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | CLRCH"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "RSTFIFO | WRITE"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT2"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "FIFOSTAT"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT2"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"extra data  \")"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "0"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "BITBUCKET"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | DWORDPIO | WRITE"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_1",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "p",
            "xfer"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | B8MODE | WRITE"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_2",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "(u_int16_t *)p",
            "xfer >> 1"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_4",
          "args": [
            "iot",
            "ioh",
            "DMADATALONG",
            "(u_int32_t *)p",
            "xfer >> 2"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"%d> \", xfer)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_2",
          "args": [
            "iot",
            "ioh",
            "DMADATA",
            "(u_int16_t *)p",
            "DOUTAMOUNT >> 1"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_4",
          "args": [
            "iot",
            "ioh",
            "DMADATALONG",
            "(u_int32_t *)p",
            "DOUTAMOUNT >> 2"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "SCSIEN | DMAEN | CHEN"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "ENDMA | DWORDPIO | WRITE"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "RSTFIFO | WRITE"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2))"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT2"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "FIFOSTAT"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n#define AIC_USE_DWORDS\t\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\nint\taic_dataout_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nint\naic_dataout_pio(sc, p, n)\n\tregister struct aic_softc *sc;\n\tu_char *p;\n\tint n;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tregister u_char dmastat = 0;\n\tint out = 0;\n#define DOUTAMOUNT 128\t\t/* Full FIFO */\n\n\tAIC_MISC((\"%02x%02x  \", bus_space_read_1(iot, ioh, FIFOSTAT),\n\t    bus_space_read_1(iot, ioh, SSTAT2)));\n\n\t/* Clear host FIFO and counter. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO | WRITE);\n\t/* Enable FIFOs. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, ENDMA | DWORDPIO | WRITE);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, SCSIEN | DMAEN | CHEN);\n\n\t/* Turn off ENREQINIT for now. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENPHASECHG);\n\n\t/* I have tried to make the main loop as tight as possible.  This\n\t * means that some of the code following the loop is a bit more\n\t * complex than otherwise.\n\t */\n\twhile (n > 0) {\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & (DFIFOEMP | INTSTAT)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\tgoto phasechange;\n\n\t\tif (n >= DOUTAMOUNT) {\n\t\t\tn -= DOUTAMOUNT;\n\t\t\tout += DOUTAMOUNT;\n\n#if AIC_USE_DWORDS\n\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t    (u_int32_t *)p, DOUTAMOUNT >> 2);\n#else\n\t\t\tbus_space_write_multi_2(iot, ioh, DMADATA,\n\t\t\t    (u_int16_t *)p, DOUTAMOUNT >> 1);\n#endif\n\n\t\t\tp += DOUTAMOUNT;\n\t\t} else {\n\t\t\tregister int xfer;\n\n\t\t\txfer = n;\n\t\t\tAIC_MISC((\"%d> \", xfer));\n\n\t\t\tn -= xfer;\n\t\t\tout += xfer;\n\n#if AIC_USE_DWORDS\n\t\t\tif (xfer >= 12) {\n\t\t\t\tbus_space_write_multi_4(iot, ioh, DMADATALONG,\n\t\t\t\t    (u_int32_t *)p, xfer >> 2);\n\t\t\t\tp += xfer & ~3;\n\t\t\t\txfer &= 3;\n\t\t\t}\n#else\n\t\t\tif (xfer >= 8) {\n\t\t\t\tbus_space_write_multi_2(iot, ioh,  DMADATA,\n\t\t\t\t    (u_int16_t *)p, xfer >> 1);\n\t\t\t\tp += xfer & ~1;\n\t\t\t\txfer &= 1;\n\t\t\t}\n#endif\n\n\t\t\tif (xfer > 0) {\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | B8MODE | WRITE);\n\t\t\t\tbus_space_write_multi_1(iot, ioh,  DMADATA, p,\n\t\t\t\t    xfer);\n\t\t\t\tp += xfer;\n\t\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t\t    ENDMA | DWORDPIO | WRITE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (out == 0) {\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, BITBUCKET);\n\t\tfor (;;) {\n\t\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) !=\n\t\t\t    0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tAIC_MISC((\"extra data  \"));\n\t} else {\n\t\t/* See the bytes off chip */\n\t\tfor (;;) {\n\t\t\tdmastat = bus_space_read_1(iot, ioh, DMASTAT);\n\t\t\tif ((dmastat & INTSTAT) != 0)\n\t\t\t\tgoto phasechange;\n\t\t\tif ((dmastat & DFIFOEMP) != 0 &&\n\t\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & SEMPTY) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nphasechange:\n\tif ((dmastat & INTSTAT) != 0) {\n\t\t/* Some sort of phase change. */\n\t\tint amount;\n\n\t\t/* Stop transfers, do some accounting */\n\t\tamount = bus_space_read_1(iot, ioh, FIFOSTAT) +\n\t\t    (bus_space_read_1(iot, ioh, SSTAT2) & 15);\n\t\tif (amount > 0) {\n\t\t\tout -= amount;\n\t\t\tbus_space_write_1(iot, ioh, DMACNTRL0,\n\t\t\t    RSTFIFO | WRITE);\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH);\n\t\t\tAIC_MISC((\"+%d \", amount));\n\t\t}\n\t}\n\n\t/* Turn on ENREQINIT again. */\n\tbus_space_write_1(iot, ioh, SIMODE1,\n\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT | ENPHASECHG);\n\n\t/* Stop the FIFO data path. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\treturn out;\n}"
  },
  {
    "function_name": "aic_msgout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "1185-1370",
    "snippet": "void\naic_msgout(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n#if AIC_USE_SYNCHRONOUS\n\tstruct aic_tinfo *ti;\n#endif\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgout  \"));\n\n\t/* Reset the FIFO. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\n\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tAIC_MISC((\"retransmitting  \"));\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\t/*\n\t\t\t * Set ATN.  If we're just sending a trivial 1-byte\n\t\t\t * message, we'll clear ATN later on anyway.\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, PH_MSGOUT | ATNO);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\tsc->sc_lastmsg = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_currmsg = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_currmsg;\n\tsc->sc_msgoutq |= sc->sc_currmsg;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_currmsg) {\n\tcase SEND_IDENTIFY:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tsc->sc_omess[0] =\n\t\t    MSG_IDENTIFY(sc->sc_nexus->xs->sc_link->lun, 1);\n\t\tn = 1;\n\t\tbreak;\n\n#if AIC_USE_SYNCHRONOUS\n\tcase SEND_SDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[4] = MSG_EXTENDED;\n\t\tsc->sc_omess[3] = 3;\n\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\tsc->sc_omess[1] = ti->period >> 2;\n\t\tsc->sc_omess[0] = ti->offset;\n\t\tn = 5;\n\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\tcase SEND_WDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[3] = MSG_EXTENDED;\n\t\tsc->sc_omess[2] = 2;\n\t\tsc->sc_omess[1] = MSG_EXT_WDTR;\n\t\tsc->sc_omess[0] = ti->width;\n\t\tn = 4;\n\t\tbreak;\n#endif\n\n\tcase SEND_DEV_RESET:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t *\n\t\t\t * If this is the last message being sent, then we\n\t\t\t * deassert ATN, since either the target is going to\n\t\t\t * ignore this message, or it's going to ask for a\n\t\t\t * retransmission via MESSAGE PARITY ERROR (in which\n\t\t\t * case we reassert ATN anyway).\n\t\t\t */\n\t\t\tif (sc->sc_msgpriq == 0)\n\t\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 1 && sc->sc_msgpriq == 0)\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t/* Send message byte. */\n\t\tbus_space_write_1(iot, ioh, SCSIDAT, *--sc->sc_omp);\n\t\t--n;\n\t\t/* Keep track of the last message we've sent any bytes of. */\n\t\tsc->sc_lastmsg = sc->sc_currmsg;\n\t\t/* Wait for ACK to be negated.  XXX Need timeout. */\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t}\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Disable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAIC_USE_WIDE\t\t0",
      "#define AIC_USE_SYNCHRONOUS\t0"
    ],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_msgout",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT",
            "*--sc->sc_omp"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRATNO"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRATNO"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT1"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected MESSAGE OUT; sending NOOP\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSG_IDENTIFY",
          "args": [
            "sc->sc_nexus->xs->sc_link->lun",
            "1"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG",
            "PH_MSGOUT | ATNO"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"retransmitting  \")"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | SPIOEN"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "RSTFIFO"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_msgout  \")"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_msgout;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_msgout(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n#if AIC_USE_SYNCHRONOUS\n\tstruct aic_tinfo *ti;\n#endif\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgout  \"));\n\n\t/* Reset the FIFO. */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\t/* Enable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\n\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tAIC_MISC((\"retransmitting  \"));\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\t/*\n\t\t\t * Set ATN.  If we're just sending a trivial 1-byte\n\t\t\t * message, we'll clear ATN later on anyway.\n\t\t\t */\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, PH_MSGOUT | ATNO);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\tsc->sc_lastmsg = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_currmsg = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_currmsg;\n\tsc->sc_msgoutq |= sc->sc_currmsg;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_currmsg) {\n\tcase SEND_IDENTIFY:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tsc->sc_omess[0] =\n\t\t    MSG_IDENTIFY(sc->sc_nexus->xs->sc_link->lun, 1);\n\t\tn = 1;\n\t\tbreak;\n\n#if AIC_USE_SYNCHRONOUS\n\tcase SEND_SDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[4] = MSG_EXTENDED;\n\t\tsc->sc_omess[3] = 3;\n\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\tsc->sc_omess[1] = ti->period >> 2;\n\t\tsc->sc_omess[0] = ti->offset;\n\t\tn = 5;\n\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\tcase SEND_WDTR:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tti = &sc->sc_tinfo[sc->sc_nexus->xs->sc_link->target];\n\t\tsc->sc_omess[3] = MSG_EXTENDED;\n\t\tsc->sc_omess[2] = 2;\n\t\tsc->sc_omess[1] = MSG_EXT_WDTR;\n\t\tsc->sc_omess[0] = ti->width;\n\t\tn = 4;\n\t\tbreak;\n#endif\n\n\tcase SEND_DEV_RESET:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tsc->sc_flags |= AIC_ABORTING;\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t *\n\t\t\t * If this is the last message being sent, then we\n\t\t\t * deassert ATN, since either the target is going to\n\t\t\t * ignore this message, or it's going to ask for a\n\t\t\t * retransmission via MESSAGE PARITY ERROR (in which\n\t\t\t * case we reassert ATN anyway).\n\t\t\t */\n\t\t\tif (sc->sc_msgpriq == 0)\n\t\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 1 && sc->sc_msgpriq == 0)\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRATNO);\n\t\t/* Send message byte. */\n\t\tbus_space_write_1(iot, ioh, SCSIDAT, *--sc->sc_omp);\n\t\t--n;\n\t\t/* Keep track of the last message we've sent any bytes of. */\n\t\tsc->sc_lastmsg = sc->sc_currmsg;\n\t\t/* Wait for ACK to be negated.  XXX Need timeout. */\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t}\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Disable REQ/ACK protocol. */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n}"
  },
  {
    "function_name": "aic_msgin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "905-1180",
    "snippet": "void\naic_msgin(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgin  \"));\n\n\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_flags &= ~AIC_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If parity error, just dump everything on the floor. */\n\t\tif ((sstat1 & SCSIPERR) != 0) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_flags & AIC_DROP_MSGIN) == 0) {\n\t\t\tif (n >= AIC_MAX_MSG_LEN) {\n\t\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = bus_space_read_1(iot, ioh,\n\t\t\t\t    SCSIDAT);\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t    n == sc->sc_imess[1] + 2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\t/* Ack the last byte read. */\n\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\t}\n\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n\n\t/* We now have a complete message.  Parse it. */\n\tswitch (sc->sc_state) {\n\t\tstruct aic_acb *acb;\n\t\tstruct scsi_link *sc_link;\n\t\tstruct aic_tinfo *ti;\n\n\tcase AIC_CONNECTED:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[acb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tacb->data_length = 0;\n\t\t\t}\n\t\t\tacb->xs->resid = acb->data_length = sc->sc_dleft;\n\t\t\tsc->sc_state = AIC_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_PARITY_ERROR:\n\t\t\t/* Resend the last message. */\n\t\t\taic_sched_msgout(sc, sc->sc_lastmsg);\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tAIC_MISC((\"message rejected %02x  \", sc->sc_lastmsg));\n\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tcase SEND_IDENTIFY:\n\t\t\t\tti->flags &= ~(DO_SYNC | DO_WIDE);\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase SEND_SDTR:\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\tcase SEND_WDTR:\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = AIC_DISCONNECT;\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tswitch (sc->sc_imess[2]) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tif (ti->offset == 0) {\n\t\t\t\t} else if (ti->period < sc->sc_minsync ||\n\t\t\t\t    ti->period > sc->sc_maxsync ||\n\t\t\t\t    ti->offset > 8) {\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_SDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"sync, offset %d, \",\n\t\t\t\t\t    ti->offset);\n\t\t\t\t\tprintf(\"period %dnsec\\n\",\n\t\t\t\t\t    ti->period * 4);\n\t\t\t\t}\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\t\t\tcase MSG_EXT_WDTR:\n\t\t\t\tif (sc->sc_imess[1] != 2)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->width = sc->sc_imess[3];\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tif (ti->width == 0) {\n\t\t\t\t} else if (ti->width > AIC_MAX_WIDTH) {\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_WDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"wide, width %d\\n\",\n\t\t\t\t\t    1 << (3 + ti->width));\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REJECT\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tAIC_BREAK();\n\t\treject:\n\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AIC_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY; \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\t\tAIC_BREAK();\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) aic_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\treset:\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\t\tbreak;\n\n#ifdef notdef\n\tabort:\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n#endif\n\t}\n\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t/* Ack the last message byte. */\n\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t;\n\n\t/* Go get the next message, if any. */\n\tgoto nextmsg;\n\nout:\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAIC_MAX_WIDTH\t\t0",
      "#define\tAIC_USE_WIDE\t\t0",
      "#define AIC_USE_SYNCHRONOUS\t0"
    ],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "int\taic_reselect",
      "void\taic_msgin",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"n=%d imess=0x%02x  \", n, sc->sc_imess[0])"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | SPIOEN"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "598-609",
          "snippet": "integrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "integrate void",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\naic_sched_msgout __P((struct aic_softc *, u_char));\nintegrate void;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_reselect",
          "args": [
            "sc",
            "sc->sc_imess[0]"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "aic_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "659-732",
          "snippet": "int\naic_reselect(sc, message)\n\tstruct aic_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_initiator);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x; \",\n\t\t    sc->sc_dev.dv_xname, selid);\n\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\tAIC_BREAK();\n\t\tgoto reset;\n\t}\n\n\t/* Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t     acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tif (sc_link->target == target && sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (acb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus; \",\n\t\t    sc->sc_dev.dv_xname, target, lun);\n\t\tprintf(\"sending ABORT\\n\");\n\t\tAIC_BREAK();\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\tsc->sc_state = AIC_CONNECTED;\n\tsc->sc_nexus = acb;\n\tti = &sc->sc_tinfo[target];\n\tti->lubusy |= (1 << lun);\n\taic_setsync(sc, ti);\n\n\tif (acb->flags & ACB_RESET)\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\telse if (acb->flags & ACB_ABORT)\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = acb->data_addr;\n\tsc->sc_dleft = acb->data_length;\n\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\treturn (0);\n\nreset:\n\taic_sched_msgout(sc, SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\taic_sched_msgout(sc, SEND_ABORT);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "int\taic_reselect",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nint\taic_reselect;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naic_reselect(sc, message)\n\tstruct aic_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_initiator);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x; \",\n\t\t    sc->sc_dev.dv_xname, selid);\n\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\tAIC_BREAK();\n\t\tgoto reset;\n\t}\n\n\t/* Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t     acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tif (sc_link->target == target && sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (acb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus; \",\n\t\t    sc->sc_dev.dv_xname, target, lun);\n\t\tprintf(\"sending ABORT\\n\");\n\t\tAIC_BREAK();\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\tsc->sc_state = AIC_CONNECTED;\n\tsc->sc_nexus = acb;\n\tti = &sc->sc_tinfo[target];\n\tti->lubusy |= (1 << lun);\n\taic_setsync(sc, ti);\n\n\tif (acb->flags & ACB_RESET)\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\telse if (acb->flags & ACB_ABORT)\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = acb->data_addr;\n\tsc->sc_dleft = acb->data_length;\n\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\treturn (0);\n\nreset:\n\taic_sched_msgout(sc, SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\taic_sched_msgout(sc, SEND_ABORT);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSG_ISIDENTIFY",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "acb->xs->sc_link"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "aic_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "614-629",
          "snippet": "integrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_USE_SYNCHRONOUS\t0",
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_USE_SYNCHRONOUS\t0\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "acb->xs->sc_link"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"message rejected %02x  \", sc->sc_lastmsg)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_ASSERT",
          "args": [
            "sc->sc_nexus != NULL"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"n=%d imess=0x%02x  \", n, sc->sc_imess[0])"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | SPIOEN"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISEXTMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS2BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS1BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDAT"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SSTAT1"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_msgin  \")"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_MAX_WIDTH\t\t0\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nint\taic_reselect;\nvoid\taic_msgin;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_msgin(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat1;\n\tint n;\n\n\tAIC_TRACE((\"aic_msgin  \"));\n\n\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_flags &= ~AIC_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\tfor (;;) {\n\t\t\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\t\t\tif ((sstat1 & (REQINIT | PHASECHG | BUSFREE)) != 0)\n\t\t\t\tbreak;\n\t\t\t/* Wait for REQINIT.  XXX Need timeout. */\n\t\t}\n\t\tif ((sstat1 & (PHASECHG | BUSFREE)) != 0) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If parity error, just dump everything on the floor. */\n\t\tif ((sstat1 & SCSIPERR) != 0) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_flags & AIC_DROP_MSGIN) == 0) {\n\t\t\tif (n >= AIC_MAX_MSG_LEN) {\n\t\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = bus_space_read_1(iot, ioh,\n\t\t\t\t    SCSIDAT);\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tbreak;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t    n == sc->sc_imess[1] + 2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\t/* Ack the last byte read. */\n\t\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t\t;\n\t}\n\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n\n\t/* We now have a complete message.  Parse it. */\n\tswitch (sc->sc_state) {\n\t\tstruct aic_acb *acb;\n\t\tstruct scsi_link *sc_link;\n\t\tstruct aic_tinfo *ti;\n\n\tcase AIC_CONNECTED:\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[acb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tacb->data_length = 0;\n\t\t\t}\n\t\t\tacb->xs->resid = acb->data_length = sc->sc_dleft;\n\t\t\tsc->sc_state = AIC_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_PARITY_ERROR:\n\t\t\t/* Resend the last message. */\n\t\t\taic_sched_msgout(sc, sc->sc_lastmsg);\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tAIC_MISC((\"message rejected %02x  \", sc->sc_lastmsg));\n\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tcase SEND_IDENTIFY:\n\t\t\t\tti->flags &= ~(DO_SYNC | DO_WIDE);\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase SEND_SDTR:\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\tcase SEND_WDTR:\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tti->width = 0;\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = AIC_DISCONNECT;\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tswitch (sc->sc_imess[2]) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\tif (ti->offset == 0) {\n\t\t\t\t} else if (ti->period < sc->sc_minsync ||\n\t\t\t\t    ti->period > sc->sc_maxsync ||\n\t\t\t\t    ti->offset > 8) {\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_SDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"sync, offset %d, \",\n\t\t\t\t\t    ti->offset);\n\t\t\t\t\tprintf(\"period %dnsec\\n\",\n\t\t\t\t\t    ti->period * 4);\n\t\t\t\t}\n\t\t\t\taic_setsync(sc, ti);\n\t\t\t\tbreak;\n#endif\n\n#if AIC_USE_WIDE\n\t\t\tcase MSG_EXT_WDTR:\n\t\t\t\tif (sc->sc_imess[1] != 2)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->width = sc->sc_imess[3];\n\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\tif (ti->width == 0) {\n\t\t\t\t} else if (ti->width > AIC_MAX_WIDTH) {\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\taic_sched_msgout(sc, SEND_WDTR);\n\t\t\t\t} else {\n\t\t\t\t\tsc_print_addr(acb->xs->sc_link);\n\t\t\t\t\tprintf(\"wide, width %d\\n\",\n\t\t\t\t\t    1 << (3 + ti->width));\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REJECT\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tAIC_BREAK();\n\t\treject:\n\t\t\taic_sched_msgout(sc, SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AIC_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY; \",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\t\tAIC_BREAK();\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) aic_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tAIC_BREAK();\n\treset:\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\t\tbreak;\n\n#ifdef notdef\n\tabort:\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n#endif\n\t}\n\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t/* Ack the last message byte. */\n\t(void) bus_space_read_1(iot, ioh, SCSIDAT);\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\twhile ((bus_space_read_1(iot, ioh, SCSISIG) & ACKI) != 0)\n\t\t;\n\n\t/* Go get the next message, if any. */\n\tgoto nextmsg;\n\nout:\n\tAIC_MISC((\"n=%d imess=0x%02x  \", n, sc->sc_imess[0]));\n}"
  },
  {
    "function_name": "aic_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "879-890",
    "snippet": "void\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_dequeue",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->nexus_list",
            "acb",
            "chain"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}"
  },
  {
    "function_name": "aic_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "814-877",
    "snippet": "void\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AIC_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\taic_done",
      "void\taic_dequeue",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_sched",
      "void\taic_free_acb",
      "void\taic_sense",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_free_acb",
          "args": [
            "sc",
            "acb",
            "xs->flags"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "aic_free_acb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "426-447",
          "snippet": "void\naic_free_acb(sc, acb, flags)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tacb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, acb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (acb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_free_acb",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_free_acb;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_free_acb(sc, acb, flags)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tacb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, acb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (acb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_dequeue",
          "args": [
            "sc",
            "acb"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "aic_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "879-890",
          "snippet": "void\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_dequeue",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_sched",
          "args": [
            "sc"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "740-776",
          "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"error=%d\\n\"",
            "xs->error"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_sense",
          "args": [
            "sc",
            "acb"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "778-809",
          "snippet": "void\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_dequeue",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "void\taic_sense",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_done  \")"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_DEBUG\t\t1\n\nvoid\taic_done;\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_sched;\nvoid\taic_free_acb;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "aic_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "778-809",
    "snippet": "void\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_dequeue",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_select",
      "void\taic_sched",
      "void\taic_sense",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_sched",
          "args": [
            "sc"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "740-776",
          "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_dequeue",
          "args": [
            "sc",
            "acb"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "aic_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "879-890",
          "snippet": "void\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_dequeue",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_dequeue(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\n\tif (acb->flags & ACB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_select",
          "args": [
            "sc",
            "acb"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "aic_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "635-657",
          "snippet": "void\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ss",
            "sizeof(*ss)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"requesting sense  \")"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_sense(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&acb->scsi_cmd;\n\n\tAIC_MISC((\"requesting sense  \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tacb->scsi_cmd_length = sizeof(*ss);\n\tacb->data_addr = (char *)&xs->sense;\n\tacb->data_length = sizeof(struct scsi_sense_data);\n\tacb->flags |= ACB_SENSE;\n\tti->senses++;\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\taic_select(sc, acb);\n\t} else {\n\t\taic_dequeue(sc, acb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\tif (sc->sc_state == AIC_IDLE)\n\t\t\taic_sched(sc);\n\t}\n}"
  },
  {
    "function_name": "aic_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "740-776",
    "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_select",
      "void\taic_sched",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "ENRESELI"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE0",
            "ENSELDI"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"idle  \")"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_select",
          "args": [
            "sc",
            "acb"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "aic_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "635-657",
          "snippet": "void\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_MISC",
          "args": [
            "(\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
  },
  {
    "function_name": "aic_reselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "659-732",
    "snippet": "int\naic_reselect(sc, message)\n\tstruct aic_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_initiator);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x; \",\n\t\t    sc->sc_dev.dv_xname, selid);\n\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\tAIC_BREAK();\n\t\tgoto reset;\n\t}\n\n\t/* Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t     acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tif (sc_link->target == target && sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (acb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus; \",\n\t\t    sc->sc_dev.dv_xname, target, lun);\n\t\tprintf(\"sending ABORT\\n\");\n\t\tAIC_BREAK();\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\tsc->sc_state = AIC_CONNECTED;\n\tsc->sc_nexus = acb;\n\tti = &sc->sc_tinfo[target];\n\tti->lubusy |= (1 << lun);\n\taic_setsync(sc, ti);\n\n\tif (acb->flags & ACB_RESET)\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\telse if (acb->flags & ACB_ABORT)\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = acb->data_addr;\n\tsc->sc_dleft = acb->data_length;\n\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\treturn (0);\n\nreset:\n\taic_sched_msgout(sc, SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\taic_sched_msgout(sc, SEND_ABORT);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "int\taic_reselect",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "598-609",
          "snippet": "integrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "integrate void",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\naic_sched_msgout __P((struct aic_softc *, u_char));\nintegrate void;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "aic_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "614-629",
          "snippet": "integrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_USE_SYNCHRONOUS\t0",
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_USE_SYNCHRONOUS\t0\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->nexus_list",
            "acb",
            "chain"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sending ABORT\\n\""
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "selid"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_BREAK",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nint\taic_reselect;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naic_reselect(sc, message)\n\tstruct aic_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_initiator);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x; \",\n\t\t    sc->sc_dev.dv_xname, selid);\n\t\tprintf(\"sending DEVICE RESET\\n\");\n\t\tAIC_BREAK();\n\t\tgoto reset;\n\t}\n\n\t/* Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (acb = sc->nexus_list.tqh_first; acb != NULL;\n\t     acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tif (sc_link->target == target && sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (acb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus; \",\n\t\t    sc->sc_dev.dv_xname, target, lun);\n\t\tprintf(\"sending ABORT\\n\");\n\t\tAIC_BREAK();\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, acb, chain);\n\tsc->sc_state = AIC_CONNECTED;\n\tsc->sc_nexus = acb;\n\tti = &sc->sc_tinfo[target];\n\tti->lubusy |= (1 << lun);\n\taic_setsync(sc, ti);\n\n\tif (acb->flags & ACB_RESET)\n\t\taic_sched_msgout(sc, SEND_DEV_RESET);\n\telse if (acb->flags & ACB_ABORT)\n\t\taic_sched_msgout(sc, SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = acb->data_addr;\n\tsc->sc_dleft = acb->data_length;\n\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\treturn (0);\n\nreset:\n\taic_sched_msgout(sc, SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\taic_sched_msgout(sc, SEND_ABORT);\n\treturn (1);\n}"
  },
  {
    "function_name": "aic_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "635-657",
    "snippet": "void\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_select",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "ENRESELI | ENSELO | ENAUTOATNO"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "ENSCSIRST | ENSELTIMO"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE0",
            "ENSELDI | ENSELDO"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "STIMO_256ms | ENSTIMER"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "aic_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "614-629",
          "snippet": "integrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_USE_SYNCHRONOUS\t0",
            "#define\tintegrate\tstatic inline",
            "#define\tintegrate"
          ],
          "globals_used": [
            "integrate void",
            "integrate void",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_USE_SYNCHRONOUS\t0\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIID",
            "sc->sc_initiator << OID_S | target"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_select(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct scsi_link *sc_link = acb->xs->sc_link;\n\tint target = sc_link->target;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[target];\n\n\tbus_space_write_1(iot, ioh, SCSIID,\n\t    sc->sc_initiator << OID_S | target);\n\taic_setsync(sc, ti);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, STIMO_256ms | ENSTIMER);\n\n\t/* Always enable reselections. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI | ENSELDO);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST | ENSELTIMO);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI | ENSELO | ENAUTOATNO);\n\n\tsc->sc_state = AIC_SELECTING;\n}"
  },
  {
    "function_name": "aic_setsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "614-629",
    "snippet": "integrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AIC_USE_SYNCHRONOUS\t0",
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "integrate void",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIRATE",
            "0"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIRATE",
            "((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_USE_SYNCHRONOUS\t0\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\nintegrate void;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_setsync(sc, ti)\n\tstruct aic_softc *sc;\n\tstruct aic_tinfo *ti;\n{\n#if AIC_USE_SYNCHRONOUS\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (ti->offset != 0)\n\t\tbus_space_write_1(iot, ioh, SCSIRATE,\n\t\t    ((ti->period * sc->sc_freq) / 250 - 2) << 4 | ti->offset);\n\telse\n\t\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n#endif\n}"
  },
  {
    "function_name": "aic_sched_msgout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "598-609",
    "snippet": "integrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tintegrate\tstatic inline",
      "#define\tintegrate"
    ],
    "globals_used": [
      "integrate void",
      "aic_sched_msgout __P((struct aic_softc *, u_char));",
      "integrate void",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISIG",
            "sc->sc_phase | ATNO"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tintegrate\tstatic inline\n#define\tintegrate\n\nintegrate void;\naic_sched_msgout __P((struct aic_softc *, u_char));\nintegrate void;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nintegrate void\naic_sched_msgout(sc, m)\n\tstruct aic_softc *sc;\n\tu_char m;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_msgpriq == 0)\n\t\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase | ATNO);\n\tsc->sc_msgpriq |= m;\n}"
  },
  {
    "function_name": "aic_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "569-592",
    "snippet": "int\naic_poll(sc, xs, count)\n\tstruct aic_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tAIC_TRACE((\"aic_poll  \"));\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) != 0)\n\t\t\taicintr(sc);\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\taic_poll",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aicintr",
          "args": [
            "sc"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "aicintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "1647-2014",
          "snippet": "int\naicintr(arg)\n\tvoid *arg;\n{\n\tregister struct aic_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat0, sstat1;\n\tregister struct aic_acb *acb;\n\tregister struct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\tint n;\n\n\t/*\n\t * Clear INTEN.  We enable it again before returning.  This makes the\n\t * interrupt esssentially level-triggered.\n\t */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\tAIC_TRACE((\"aicintr  \"));\n\nloop:\n\t/*\n\t * First check for abnormal conditions, such as reset.\n\t */\n\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\tAIC_MISC((\"sstat1:0x%02x \", sstat1));\n\n\tif ((sstat1 & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: SCSI bus reset\\n\", sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Check for less serious errors.\n\t */\n\tif ((sstat1 & SCSIPERR) != 0) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSCSIPERR);\n\t\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t} else\n\t\t\taic_sched_msgout(sc, SEND_INIT_DET_ERR);\n\t}\n\n\t/*\n\t * If we're not already busy doing something test for the following\n\t * conditions:\n\t * 1) We have been reselected by something\n\t * 2) We have selected something successfully\n\t * 3) Our selection process has timed out\n\t * 4) This is really a bus free interrupt just to get a new command\n\t *    going?\n\t * 5) Spurious interrupt?\n\t */\n\tswitch (sc->sc_state) {\n\tcase AIC_IDLE:\n\tcase AIC_SELECTING:\n\t\tsstat0 = bus_space_read_1(iot, ioh, SSTAT0);\n\t\tAIC_MISC((\"sstat0:0x%02x \", sstat0));\n\n\t\tif ((sstat0 & TARGET) != 0) {\n\t\t\t/*\n\t\t\t * We don't currently support target mode.\n\t\t\t */\n\t\t\tprintf(\"%s: target mode selected; going to BUS FREE\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, 0);\n\n\t\t\tgoto sched;\n\t\t} else if ((sstat0 & SELDI) != 0) {\n\t\t\tAIC_MISC((\"reselected  \"));\n\n\t\t\t/*\n\t\t\t * If we're trying to select a target ourselves,\n\t\t\t * push our command back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == AIC_SELECTING) {\n\t\t\t\tAIC_MISC((\"backoff selector  \"));\n\t\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\t\tacb = sc->sc_nexus;\n\t\t\t\tsc->sc_nexus = NULL;\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\t\t}\n\n\t\t\t/* Save reselection ID. */\n\t\t\tsc->sc_selid = bus_space_read_1(iot, ioh, SELID);\n\n\t\t\tsc->sc_state = AIC_RESELECTED;\n\t\t} else if ((sstat0 & SELDO) != 0) {\n\t\t\tAIC_MISC((\"selected  \"));\n\n\t\t\t/* We have selected a target. Things to do:\n\t\t\t * a) Determine what message(s) to send.\n\t\t\t * b) Verify that we're still selecting the target.\n\t\t\t * c) Mark device as busy.\n\t\t\t */\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection out while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tsc_link = acb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tsc->sc_msgpriq = SEND_IDENTIFY;\n\t\t\tif (acb->flags & ACB_RESET)\n\t\t\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\t\telse if (acb->flags & ACB_ABORT)\n\t\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t\telse {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tif ((ti->flags & DO_SYNC) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_SDTR;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tif ((ti->flags & DO_WIDE) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_WDTR;\n#endif\n\t\t\t}\n\n\t\t\tacb->flags |= ACB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\t\t\t/* On our first connection, schedule a timeout. */\n\t\t\tif ((acb->xs->flags & SCSI_POLL) == 0)\n\t\t\t\ttimeout(aic_timeout, acb,\n\t\t\t\t    (acb->timeout * hz) / 1000);\n\n\t\t\tsc->sc_state = AIC_CONNECTED;\n\t\t} else if ((sstat1 & SELTO) != 0) {\n\t\t\tAIC_MISC((\"selection timeout  \"));\n\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection timeout while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSELTIMO);\n\t\t\tdelay(250);\n\n\t\t\tacb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\t\t} else {\n\t\t\tif (sc->sc_state != AIC_IDLE) {\n\t\t\t\tprintf(\"%s: BUS FREE while not idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"state=%d\\n\", sc->sc_state);\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto sched;\n\t\t}\n\n\t\t/*\n\t\t * Turn off selection stuff, and prepare to catch bus free\n\t\t * interrupts, parity errors, and phase changes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRSTCNT | CLRCH);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENAUTOATNP);\n\t\tbus_space_write_1(iot, ioh, CLRSINT0, CLRSELDI | CLRSELDO);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\t\tbus_space_write_1(iot, ioh, SIMODE0, 0);\n\t\tbus_space_write_1(iot, ioh, SIMODE1,\n\t\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT |\n\t\t    ENPHASECHG);\n\n\t\tsc->sc_flags = 0;\n\t\tsc->sc_prevphase = PH_INVALID;\n\t\tgoto dophase;\n\t}\n\n\tif ((sstat1 & BUSFREE) != 0) {\n\t\t/* We've gone to BUS FREE phase. */\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase AIC_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase AIC_CONNECTED:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\t\t\t/*\n\t\t\t\t * If the target went to BUS FREE phase during\n\t\t\t\t * or immediately after sending a SDTR or WDTR\n\t\t\t\t * message, disable negotiation.\n\t\t\t\t */\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tcase SEND_SDTR:\n\t\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tcase SEND_WDTR:\n\t\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tif ((sc->sc_flags & AIC_ABORTING) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec suggests\n\t\t\t\t * issuing a REQUEST SENSE following an\n\t\t\t\t * unexpected disconnect.  Some devices go into\n\t\t\t\t * a contingent allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary to\n\t\t\t\t * clean up their state.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\taic_sense(sc, acb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tgoto finish;\n\n\t\tcase AIC_DISCONNECT:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n#if 1 /* XXXX */\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n#endif\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, acb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase AIC_CMDCOMPLETE:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh, CLRSINT1, CLRPHASECHG);\n\ndophase:\n\tif ((sstat1 & REQINIT) == 0) {\n\t\t/* Wait for REQINIT. */\n\t\tgoto out;\n\t}\n\n\tsc->sc_phase = bus_space_read_1(iot, ioh, SCSISIG) & PH_MASK;\n\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase);\n\n\tswitch (sc->sc_phase) {\n\tcase PH_MSGOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgout(sc);\n\t\tsc->sc_prevphase = PH_MSGOUT;\n\t\tgoto loop;\n\n\tcase PH_MSGIN:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgin(sc);\n\t\tsc->sc_prevphase = PH_MSGIN;\n\t\tgoto loop;\n\n\tcase PH_CMD:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n#if AIC_DEBUG\n\t\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tprintf(\"cmd=0x%02x+%d \",\n\t\t\t    acb->scsi_cmd.opcode, acb->scsi_cmd_length-1);\n\t\t}\n#endif\n\t\tn = aic_dataout_pio(sc, sc->sc_cp, sc->sc_cleft);\n\t\tsc->sc_cp += n;\n\t\tsc->sc_cleft -= n;\n\t\tsc->sc_prevphase = PH_CMD;\n\t\tgoto loop;\n\n\tcase PH_DATAOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"dataout dleft=%d \", sc->sc_dleft));\n\t\tn = aic_dataout_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAOUT;\n\t\tgoto loop;\n\n\tcase PH_DATAIN:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"datain %d \", sc->sc_dleft));\n\t\tn = aic_datain_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAIN;\n\t\tgoto loop;\n\n\tcase PH_STAT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\tacb->target_stat = bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\tAIC_MISC((\"target_stat=0x%02x \", acb->target_stat));\n\t\tsc->sc_prevphase = PH_STAT;\n\t\tgoto loop;\n\t}\n\n\tprintf(\"%s: unexpected bus phase; resetting\\n\", sc->sc_dev.dv_xname);\n\tAIC_BREAK();\nreset:\n\taic_init(sc);\n\treturn 1;\n\nfinish:\n\tuntimeout(aic_timeout, acb);\n\taic_done(sc, acb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = AIC_IDLE;\n\taic_sched(sc);\n\tgoto out;\n\nout:\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_DEBUG\t\t1",
            "#define\tAIC_USE_WIDE\t\t0",
            "#define AIC_USE_SYNCHRONOUS\t0"
          ],
          "globals_used": [
            "void \taic_init",
            "void\taic_done",
            "aic_sched_msgout __P((struct aic_softc *, u_char));",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_timeout",
            "void\taic_sched",
            "void\taic_sense",
            "void\taic_msgin",
            "void\taic_msgout",
            "int\taic_dataout_pio",
            "int\taic_datain_pio",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_DEBUG\t\t1\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_USE_SYNCHRONOUS\t0\n\nvoid \taic_init;\nvoid\taic_done;\naic_sched_msgout __P((struct aic_softc *, u_char));\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_timeout;\nvoid\taic_sched;\nvoid\taic_sense;\nvoid\taic_msgin;\nvoid\taic_msgout;\nint\taic_dataout_pio;\nint\taic_datain_pio;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naicintr(arg)\n\tvoid *arg;\n{\n\tregister struct aic_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_char sstat0, sstat1;\n\tregister struct aic_acb *acb;\n\tregister struct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\tint n;\n\n\t/*\n\t * Clear INTEN.  We enable it again before returning.  This makes the\n\t * interrupt esssentially level-triggered.\n\t */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\tAIC_TRACE((\"aicintr  \"));\n\nloop:\n\t/*\n\t * First check for abnormal conditions, such as reset.\n\t */\n\tsstat1 = bus_space_read_1(iot, ioh, SSTAT1);\n\tAIC_MISC((\"sstat1:0x%02x \", sstat1));\n\n\tif ((sstat1 & SCSIRSTI) != 0) {\n\t\tprintf(\"%s: SCSI bus reset\\n\", sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Check for less serious errors.\n\t */\n\tif ((sstat1 & SCSIPERR) != 0) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSCSIPERR);\n\t\tif (sc->sc_prevphase == PH_MSGIN) {\n\t\t\tsc->sc_flags |= AIC_DROP_MSGIN;\n\t\t\taic_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t} else\n\t\t\taic_sched_msgout(sc, SEND_INIT_DET_ERR);\n\t}\n\n\t/*\n\t * If we're not already busy doing something test for the following\n\t * conditions:\n\t * 1) We have been reselected by something\n\t * 2) We have selected something successfully\n\t * 3) Our selection process has timed out\n\t * 4) This is really a bus free interrupt just to get a new command\n\t *    going?\n\t * 5) Spurious interrupt?\n\t */\n\tswitch (sc->sc_state) {\n\tcase AIC_IDLE:\n\tcase AIC_SELECTING:\n\t\tsstat0 = bus_space_read_1(iot, ioh, SSTAT0);\n\t\tAIC_MISC((\"sstat0:0x%02x \", sstat0));\n\n\t\tif ((sstat0 & TARGET) != 0) {\n\t\t\t/*\n\t\t\t * We don't currently support target mode.\n\t\t\t */\n\t\t\tprintf(\"%s: target mode selected; going to BUS FREE\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tbus_space_write_1(iot, ioh, SCSISIG, 0);\n\n\t\t\tgoto sched;\n\t\t} else if ((sstat0 & SELDI) != 0) {\n\t\t\tAIC_MISC((\"reselected  \"));\n\n\t\t\t/*\n\t\t\t * If we're trying to select a target ourselves,\n\t\t\t * push our command back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == AIC_SELECTING) {\n\t\t\t\tAIC_MISC((\"backoff selector  \"));\n\t\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\t\tacb = sc->sc_nexus;\n\t\t\t\tsc->sc_nexus = NULL;\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);\n\t\t\t}\n\n\t\t\t/* Save reselection ID. */\n\t\t\tsc->sc_selid = bus_space_read_1(iot, ioh, SELID);\n\n\t\t\tsc->sc_state = AIC_RESELECTED;\n\t\t} else if ((sstat0 & SELDO) != 0) {\n\t\t\tAIC_MISC((\"selected  \"));\n\n\t\t\t/* We have selected a target. Things to do:\n\t\t\t * a) Determine what message(s) to send.\n\t\t\t * b) Verify that we're still selecting the target.\n\t\t\t * c) Mark device as busy.\n\t\t\t */\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection out while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tsc_link = acb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tsc->sc_msgpriq = SEND_IDENTIFY;\n\t\t\tif (acb->flags & ACB_RESET)\n\t\t\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\t\telse if (acb->flags & ACB_ABORT)\n\t\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t\telse {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tif ((ti->flags & DO_SYNC) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_SDTR;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tif ((ti->flags & DO_WIDE) != 0)\n\t\t\t\t\tsc->sc_msgpriq |= SEND_WDTR;\n#endif\n\t\t\t}\n\n\t\t\tacb->flags |= ACB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = acb->data_addr;\n\t\t\tsc->sc_dleft = acb->data_length;\n\t\t\tsc->sc_cp = (u_char *)&acb->scsi_cmd;\n\t\t\tsc->sc_cleft = acb->scsi_cmd_length;\n\n\t\t\t/* On our first connection, schedule a timeout. */\n\t\t\tif ((acb->xs->flags & SCSI_POLL) == 0)\n\t\t\t\ttimeout(aic_timeout, acb,\n\t\t\t\t    (acb->timeout * hz) / 1000);\n\n\t\t\tsc->sc_state = AIC_CONNECTED;\n\t\t} else if ((sstat1 & SELTO) != 0) {\n\t\t\tAIC_MISC((\"selection timeout  \"));\n\n\t\t\tif (sc->sc_state != AIC_SELECTING) {\n\t\t\t\tprintf(\"%s: selection timeout while idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n\t\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n\t\t\tbus_space_write_1(iot, ioh, CLRSINT1, CLRSELTIMO);\n\t\t\tdelay(250);\n\n\t\t\tacb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\t\t} else {\n\t\t\tif (sc->sc_state != AIC_IDLE) {\n\t\t\t\tprintf(\"%s: BUS FREE while not idle; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"state=%d\\n\", sc->sc_state);\n\t\t\t\tAIC_BREAK();\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgoto sched;\n\t\t}\n\n\t\t/*\n\t\t * Turn off selection stuff, and prepare to catch bus free\n\t\t * interrupts, parity errors, and phase changes.\n\t\t */\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRSTCNT | CLRCH);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\t\tbus_space_write_1(iot, ioh, SCSISEQ, ENAUTOATNP);\n\t\tbus_space_write_1(iot, ioh, CLRSINT0, CLRSELDI | CLRSELDO);\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\t\tbus_space_write_1(iot, ioh, SIMODE0, 0);\n\t\tbus_space_write_1(iot, ioh, SIMODE1,\n\t\t    ENSCSIRST | ENSCSIPERR | ENBUSFREE | ENREQINIT |\n\t\t    ENPHASECHG);\n\n\t\tsc->sc_flags = 0;\n\t\tsc->sc_prevphase = PH_INVALID;\n\t\tgoto dophase;\n\t}\n\n\tif ((sstat1 & BUSFREE) != 0) {\n\t\t/* We've gone to BUS FREE phase. */\n\t\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t\t    CLRBUSFREE | CLRPHASECHG);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase AIC_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase AIC_CONNECTED:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\n#if AIC_USE_SYNCHRONOUS + AIC_USE_WIDE\n\t\t\tif (sc->sc_prevphase == PH_MSGOUT) {\n\t\t\t\t/*\n\t\t\t\t * If the target went to BUS FREE phase during\n\t\t\t\t * or immediately after sending a SDTR or WDTR\n\t\t\t\t * message, disable negotiation.\n\t\t\t\t */\n\t\t\t\tsc_link = acb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tswitch (sc->sc_lastmsg) {\n#if AIC_USE_SYNCHRONOUS\n\t\t\t\tcase SEND_SDTR:\n\t\t\t\t\tti->flags &= ~DO_SYNC;\n\t\t\t\t\tti->period = ti->offset = 0;\n\t\t\t\t\tbreak;\n#endif\n#if AIC_USE_WIDE\n\t\t\t\tcase SEND_WDTR:\n\t\t\t\t\tti->flags &= ~DO_WIDE;\n\t\t\t\t\tti->width = 0;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tif ((sc->sc_flags & AIC_ABORTING) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec suggests\n\t\t\t\t * issuing a REQUEST SENSE following an\n\t\t\t\t * unexpected disconnect.  Some devices go into\n\t\t\t\t * a contingent allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary to\n\t\t\t\t * clean up their state.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tAIC_BREAK();\n\t\t\t\taic_sense(sc, acb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tgoto finish;\n\n\t\tcase AIC_DISCONNECT:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n#if 1 /* XXXX */\n\t\t\tacb->data_addr = sc->sc_dp;\n\t\t\tacb->data_length = sc->sc_dleft;\n#endif\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, acb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase AIC_CMDCOMPLETE:\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh, CLRSINT1, CLRPHASECHG);\n\ndophase:\n\tif ((sstat1 & REQINIT) == 0) {\n\t\t/* Wait for REQINIT. */\n\t\tgoto out;\n\t}\n\n\tsc->sc_phase = bus_space_read_1(iot, ioh, SCSISIG) & PH_MASK;\n\tbus_space_write_1(iot, ioh, SCSISIG, sc->sc_phase);\n\n\tswitch (sc->sc_phase) {\n\tcase PH_MSGOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgout(sc);\n\t\tsc->sc_prevphase = PH_MSGOUT;\n\t\tgoto loop;\n\n\tcase PH_MSGIN:\n\t\tif (sc->sc_state != AIC_CONNECTED &&\n\t\t    sc->sc_state != AIC_RESELECTED)\n\t\t\tbreak;\n\t\taic_msgin(sc);\n\t\tsc->sc_prevphase = PH_MSGIN;\n\t\tgoto loop;\n\n\tcase PH_CMD:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n#if AIC_DEBUG\n\t\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\t\tacb = sc->sc_nexus;\n\t\t\tprintf(\"cmd=0x%02x+%d \",\n\t\t\t    acb->scsi_cmd.opcode, acb->scsi_cmd_length-1);\n\t\t}\n#endif\n\t\tn = aic_dataout_pio(sc, sc->sc_cp, sc->sc_cleft);\n\t\tsc->sc_cp += n;\n\t\tsc->sc_cleft -= n;\n\t\tsc->sc_prevphase = PH_CMD;\n\t\tgoto loop;\n\n\tcase PH_DATAOUT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"dataout dleft=%d \", sc->sc_dleft));\n\t\tn = aic_dataout_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAOUT;\n\t\tgoto loop;\n\n\tcase PH_DATAIN:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_MISC((\"datain %d \", sc->sc_dleft));\n\t\tn = aic_datain_pio(sc, sc->sc_dp, sc->sc_dleft);\n\t\tsc->sc_dp += n;\n\t\tsc->sc_dleft -= n;\n\t\tsc->sc_prevphase = PH_DATAIN;\n\t\tgoto loop;\n\n\tcase PH_STAT:\n\t\tif (sc->sc_state != AIC_CONNECTED)\n\t\t\tbreak;\n\t\tAIC_ASSERT(sc->sc_nexus != NULL);\n\t\tacb = sc->sc_nexus;\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | SPIOEN);\n\t\tacb->target_stat = bus_space_read_1(iot, ioh, SCSIDAT);\n\t\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN);\n\t\tAIC_MISC((\"target_stat=0x%02x \", acb->target_stat));\n\t\tsc->sc_prevphase = PH_STAT;\n\t\tgoto loop;\n\t}\n\n\tprintf(\"%s: unexpected bus phase; resetting\\n\", sc->sc_dev.dv_xname);\n\tAIC_BREAK();\nreset:\n\taic_init(sc);\n\treturn 1;\n\nfinish:\n\tuntimeout(aic_timeout, acb);\n\taic_done(sc, acb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = AIC_IDLE;\n\taic_sched(sc);\n\tgoto out;\n\nout:\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "DMASTAT"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_poll  \")"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\taic_poll;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naic_poll(sc, xs, count)\n\tstruct aic_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tAIC_TRACE((\"aic_poll  \"));\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) != 0)\n\t\t\taicintr(sc);\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "aic_minphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "555-564",
    "snippet": "void\naic_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tAIC_TRACE((\"aic_minphys  \"));\n\tif (bp->b_bcount > (AIC_NSEG << PGSHIFT))\n\t\tbp->b_bcount = (AIC_NSEG << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_minphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "aic_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "555-564",
          "snippet": "void\naic_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tAIC_TRACE((\"aic_minphys  \"));\n\tif (bp->b_bcount > (AIC_NSEG << PGSHIFT))\n\t\tbp->b_bcount = (AIC_NSEG << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_minphys  \")"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_minphys;\n\nvoid\naic_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tAIC_TRACE((\"aic_minphys  \"));\n\tif (bp->b_bcount > (AIC_NSEG << PGSHIFT))\n\t\tbp->b_bcount = (AIC_NSEG << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "aic_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "497-550",
    "snippet": "int\naic_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tstruct aic_acb *acb;\n\tint s, flags;\n\n\tAIC_TRACE((\"aic_scsi_cmd  \"));\n\tAIC_CMDS((\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target));\n\n\tflags = xs->flags;\n\tif ((acb = aic_get_acb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\n\t/* Initialize acb */\n\tacb->xs = xs;\n\tacb->timeout = xs->timeout;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\tacb->flags |= ACB_RESET;\n\t\tacb->scsi_cmd_length = 0;\n\t\tacb->data_length = 0;\n\t} else {\n\t\tbcopy(xs->cmd, &acb->scsi_cmd, xs->cmdlen);\n\t\tacb->scsi_cmd_length = xs->cmdlen;\n\t\tacb->data_addr = xs->data;\n\t\tacb->data_length = xs->datalen;\n\t}\n\tacb->target_stat = 0;\n\n\ts = splbio();\n\n\tTAILQ_INSERT_TAIL(&sc->ready_list, acb, chain);\n\tif (sc->sc_state == AIC_IDLE)\n\t\taic_sched(sc);\n\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/* Not allowed to use interrupts, use polling instead */\n\tif (aic_poll(sc, xs, acb->timeout)) {\n\t\taic_timeout(acb);\n\t\tif (aic_poll(sc, xs, acb->timeout))\n\t\t\taic_timeout(acb);\n\t}\n\treturn COMPLETE;\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\taic_scsi_cmd",
      "int\taic_poll",
      "void\taic_timeout",
      "void\taic_sched",
      "struct aic_acb* aic_get_acb",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aic_timeout",
          "args": [
            "acb"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "aic_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "2041-2068",
          "snippet": "void\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_timeout",
            "void\taic_abort",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_timeout;\nvoid\taic_abort;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aic_acb *acb = arg;\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (acb->flags & ACB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tacb->xs->error = XS_TIMEOUT;\n\t\taic_abort(sc, acb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_poll",
          "args": [
            "sc",
            "xs",
            "acb->timeout"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "aic_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "569-592",
          "snippet": "int\naic_poll(sc, xs, count)\n\tstruct aic_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tAIC_TRACE((\"aic_poll  \"));\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) != 0)\n\t\t\taicintr(sc);\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\taic_poll",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\taic_poll;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naic_poll(sc, xs, count)\n\tstruct aic_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tAIC_TRACE((\"aic_poll  \"));\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif ((bus_space_read_1(iot, ioh, DMASTAT) & INTSTAT) != 0)\n\t\t\taicintr(sc);\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_sched",
          "args": [
            "sc"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "aic_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "740-776",
          "snippet": "void\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_select",
            "void\taic_sched",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_select;\nvoid\taic_sched;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_sched(sc)\n\tregister struct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tstruct scsi_link *sc_link;\n\tstruct aic_tinfo *ti;\n\n\t/*\n\t * Find first acb in ready queue that is for a target/lunit pair that\n\t * is not busy.\n\t */\n\tbus_space_write_1(iot, ioh, CLRSINT1,\n\t    CLRSELTIMO | CLRBUSFREE | CLRSCSIPERR);\n\tfor (acb = sc->ready_list.tqh_first; acb != NULL;\n\t    acb = acb->chain.tqe_next) {\n\t\tsc_link = acb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tAIC_MISC((\"selecting %d:%d  \",\n\t\t\t    sc_link->target, sc_link->lun));\n\t\t\tTAILQ_REMOVE(&sc->ready_list, acb, chain);\n\t\t\tsc->sc_nexus = acb;\n\t\t\taic_select(sc, acb);\n\t\t\treturn;\n\t\t} else\n\t\t\tAIC_MISC((\"%d:%d busy\\n\",\n\t\t\t    sc_link->target, sc_link->lun));\n\t}\n\tAIC_MISC((\"idle  \"));\n\t/* Nothing to start; just enable reselections and wait. */\n\tbus_space_write_1(iot, ioh, SIMODE0, ENSELDI);\n\tbus_space_write_1(iot, ioh, SIMODE1, ENSCSIRST);\n\tbus_space_write_1(iot, ioh, SCSISEQ, ENRESELI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->ready_list",
            "acb",
            "chain"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&acb->scsi_cmd",
            "xs->cmdlen"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_get_acb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_CMDS",
          "args": [
            "(\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic_scsi_cmd  \")"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\taic_scsi_cmd;\nint\taic_poll;\nvoid\taic_timeout;\nvoid\taic_sched;\nstruct aic_acb* aic_get_acb;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nint\naic_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_softc *sc = sc_link->adapter_softc;\n\tstruct aic_acb *acb;\n\tint s, flags;\n\n\tAIC_TRACE((\"aic_scsi_cmd  \"));\n\tAIC_CMDS((\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target));\n\n\tflags = xs->flags;\n\tif ((acb = aic_get_acb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\n\t/* Initialize acb */\n\tacb->xs = xs;\n\tacb->timeout = xs->timeout;\n\n\tif (xs->flags & SCSI_RESET) {\n\t\tacb->flags |= ACB_RESET;\n\t\tacb->scsi_cmd_length = 0;\n\t\tacb->data_length = 0;\n\t} else {\n\t\tbcopy(xs->cmd, &acb->scsi_cmd, xs->cmdlen);\n\t\tacb->scsi_cmd_length = xs->cmdlen;\n\t\tacb->data_addr = xs->data;\n\t\tacb->data_length = xs->datalen;\n\t}\n\tacb->target_stat = 0;\n\n\ts = splbio();\n\n\tTAILQ_INSERT_TAIL(&sc->ready_list, acb, chain);\n\tif (sc->sc_state == AIC_IDLE)\n\t\taic_sched(sc);\n\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/* Not allowed to use interrupts, use polling instead */\n\tif (aic_poll(sc, xs, acb->timeout)) {\n\t\taic_timeout(acb);\n\t\tif (aic_poll(sc, xs, acb->timeout))\n\t\t\taic_timeout(acb);\n\t}\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "aic_free_acb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "426-447",
    "snippet": "void\naic_free_acb(sc, acb, flags)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tacb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, acb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (acb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_free_acb",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->free_list"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->free_list",
            "acb",
            "chain"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_free_acb;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_free_acb(sc, acb, flags)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tacb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, acb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (acb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aic_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "361-424",
    "snippet": "void\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAIC_MAX_WIDTH\t\t0",
      "#define\tAIC_USE_WIDE\t\t0",
      "#define AIC_SYNC_REQ_ACK_OFS \t8",
      "#define AIC_USE_SYNCHRONOUS\t0"
    ],
    "globals_used": [
      "void \taic_init",
      "void\taic_done",
      "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
      "void\taic_timeout",
      "void\taic_scsi_reset",
      "void\taic_reset",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "INTEN"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_done",
          "args": [
            "sc",
            "acb"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "aic_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "814-877",
          "snippet": "void\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AIC_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\taic_done",
            "void\taic_dequeue",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_sched",
            "void\taic_free_acb",
            "void\taic_sense",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AIC_DEBUG\t\t1\n\nvoid\taic_done;\nvoid\taic_dequeue;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_sched;\nvoid\taic_free_acb;\nvoid\taic_sense;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_done(sc, acb)\n\tstruct aic_softc *sc;\n\tstruct aic_acb *acb;\n{\n\tstruct scsi_xfer *xs = acb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aic_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tAIC_TRACE((\"aic_done  \"));\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\tif (acb->flags & ACB_ABORT) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t} else if (acb->flags & ACB_SENSE) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if (acb->target_stat == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = acb->data_length;\n\t\t\txs->status = acb->target_stat;\n\t\t\taic_sense(sc, acb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = acb->data_length;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#if AIC_DEBUG\n\tif ((aic_debug & AIC_SHOWMISC) != 0) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ACB from whatever queue it happens to be on.\n\t */\n\tif (acb->flags & ACB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (acb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tsc->sc_state = AIC_IDLE;\n\t\taic_sched(sc);\n\t} else\n\t\taic_dequeue(sc, acb);\n\n\taic_free_acb(sc, acb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "aic_timeout",
            "acb"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "aic_timeout",
            "acb"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sc->sc_tinfo",
            "sizeof(sc->sc_tinfo)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->free_list",
            "acb",
            "chain"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "acb",
            "sizeof(sc->sc_acb)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->free_list"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->nexus_list"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->ready_list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_reset",
          "args": [
            "sc"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "aic_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "298-342",
          "snippet": "void\naic_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/*\n\t * Doc. recommends to clear these two registers before operations\n\t * commence\n\t */\n\tbus_space_write_1(iot, ioh, SCSITEST, 0);\n\tbus_space_write_1(iot, ioh, TEST, 0);\n\n\t/* Reset SCSI-FIFO and abort any transfers */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH | CLRSTCNT);\n\n\t/* Reset DMA-FIFO */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n\n\t/* Disable all selection features */\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\n\t/* Disable some interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE0, 0x00);\n\t/* Clear a slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT0, 0x7f);\n\n\t/* Disable some more interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE1, 0x00);\n\t/* Clear another slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT1, 0xef);\n\n\t/* Disable synchronous transfers */\n\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n\n\t/* Haven't seen ant errors (yet) */\n\tbus_space_write_1(iot, ioh, CLRSERR, 0x07);\n\n\t/* Set our SCSI-ID */\n\tbus_space_write_1(iot, ioh, SCSIID, sc->sc_initiator << OID_S);\n\tbus_space_write_1(iot, ioh, BRSTCNTRL, EISA_BRST_TIM);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define EISA_BRST_TIM ((15<<4) + 1)\t/* 15us on, 1us off */"
          ],
          "globals_used": [
            "void\taic_reset",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define EISA_BRST_TIM ((15<<4) + 1)\t/* 15us on, 1us off */\n\nvoid\taic_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/*\n\t * Doc. recommends to clear these two registers before operations\n\t * commence\n\t */\n\tbus_space_write_1(iot, ioh, SCSITEST, 0);\n\tbus_space_write_1(iot, ioh, TEST, 0);\n\n\t/* Reset SCSI-FIFO and abort any transfers */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH | CLRSTCNT);\n\n\t/* Reset DMA-FIFO */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n\n\t/* Disable all selection features */\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\n\t/* Disable some interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE0, 0x00);\n\t/* Clear a slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT0, 0x7f);\n\n\t/* Disable some more interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE1, 0x00);\n\t/* Clear another slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT1, 0xef);\n\n\t/* Disable synchronous transfers */\n\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n\n\t/* Haven't seen ant errors (yet) */\n\tbus_space_write_1(iot, ioh, CLRSERR, 0x07);\n\n\t/* Set our SCSI-ID */\n\tbus_space_write_1(iot, ioh, SCSIID, sc->sc_initiator << OID_S);\n\tbus_space_write_1(iot, ioh, BRSTCNTRL, EISA_BRST_TIM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aic_scsi_reset",
          "args": [
            "sc"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "aic_scsi_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "345-356",
          "snippet": "void\naic_scsi_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_1(iot, ioh, SCSISEQ, SCSIRSTO);\n\tdelay(500);\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tdelay(50);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\taic_scsi_reset",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_scsi_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_scsi_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_1(iot, ioh, SCSISEQ, SCSIRSTO);\n\tdelay(500);\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tdelay(50);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_MAX_WIDTH\t\t0\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_SYNC_REQ_ACK_OFS \t8\n#define AIC_USE_SYNCHRONOUS\t0\n\nvoid \taic_init;\nvoid\taic_done;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_timeout;\nvoid\taic_scsi_reset;\nvoid\taic_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}"
  },
  {
    "function_name": "aic_scsi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "345-356",
    "snippet": "void\naic_scsi_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_1(iot, ioh, SCSISEQ, SCSIRSTO);\n\tdelay(500);\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tdelay(50);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\taic_scsi_reset",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "0"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "SCSIRSTO"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\taic_scsi_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_scsi_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tbus_space_write_1(iot, ioh, SCSISEQ, SCSIRSTO);\n\tdelay(500);\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tdelay(50);\n}"
  },
  {
    "function_name": "aic_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "298-342",
    "snippet": "void\naic_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/*\n\t * Doc. recommends to clear these two registers before operations\n\t * commence\n\t */\n\tbus_space_write_1(iot, ioh, SCSITEST, 0);\n\tbus_space_write_1(iot, ioh, TEST, 0);\n\n\t/* Reset SCSI-FIFO and abort any transfers */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH | CLRSTCNT);\n\n\t/* Reset DMA-FIFO */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n\n\t/* Disable all selection features */\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\n\t/* Disable some interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE0, 0x00);\n\t/* Clear a slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT0, 0x7f);\n\n\t/* Disable some more interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE1, 0x00);\n\t/* Clear another slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT1, 0xef);\n\n\t/* Disable synchronous transfers */\n\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n\n\t/* Haven't seen ant errors (yet) */\n\tbus_space_write_1(iot, ioh, CLRSERR, 0x07);\n\n\t/* Set our SCSI-ID */\n\tbus_space_write_1(iot, ioh, SCSIID, sc->sc_initiator << OID_S);\n\tbus_space_write_1(iot, ioh, BRSTCNTRL, EISA_BRST_TIM);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define EISA_BRST_TIM ((15<<4) + 1)\t/* 15us on, 1us off */"
    ],
    "globals_used": [
      "void\taic_reset",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "BRSTCNTRL",
            "EISA_BRST_TIM"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIID",
            "sc->sc_initiator << OID_S"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSERR",
            "0x07"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSIRATE",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT1",
            "0xef"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE1",
            "0x00"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "CLRSINT0",
            "0x7f"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SIMODE0",
            "0x00"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL1",
            "0"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSISEQ",
            "0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL1",
            "0"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "RSTFIFO"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SXFRCTL0",
            "CHEN | CLRCH | CLRSTCNT"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "TEST",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "SCSITEST",
            "0"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define EISA_BRST_TIM ((15<<4) + 1)\t/* 15us on, 1us off */\n\nvoid\taic_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naic_reset(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\t/*\n\t * Doc. recommends to clear these two registers before operations\n\t * commence\n\t */\n\tbus_space_write_1(iot, ioh, SCSITEST, 0);\n\tbus_space_write_1(iot, ioh, TEST, 0);\n\n\t/* Reset SCSI-FIFO and abort any transfers */\n\tbus_space_write_1(iot, ioh, SXFRCTL0, CHEN | CLRCH | CLRSTCNT);\n\n\t/* Reset DMA-FIFO */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, RSTFIFO);\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n\n\t/* Disable all selection features */\n\tbus_space_write_1(iot, ioh, SCSISEQ, 0);\n\tbus_space_write_1(iot, ioh, SXFRCTL1, 0);\n\n\t/* Disable some interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE0, 0x00);\n\t/* Clear a slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT0, 0x7f);\n\n\t/* Disable some more interrupts */\n\tbus_space_write_1(iot, ioh, SIMODE1, 0x00);\n\t/* Clear another slew of interrupts */\n\tbus_space_write_1(iot, ioh, CLRSINT1, 0xef);\n\n\t/* Disable synchronous transfers */\n\tbus_space_write_1(iot, ioh, SCSIRATE, 0);\n\n\t/* Haven't seen ant errors (yet) */\n\tbus_space_write_1(iot, ioh, CLRSERR, 0x07);\n\n\t/* Set our SCSI-ID */\n\tbus_space_write_1(iot, ioh, SCSIID, sc->sc_initiator << OID_S);\n\tbus_space_write_1(iot, ioh, BRSTCNTRL, EISA_BRST_TIM);\n}"
  },
  {
    "function_name": "aicattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "257-291",
    "snippet": "void\naicattach(sc)\n\tstruct aic_softc *sc;\n{\n\tAIC_TRACE((\"aicattach  \"));\n\tsc->sc_state = AIC_INIT;\n\n\tsc->sc_initiator = 7;\n\tsc->sc_freq = 20;\t/* XXXX assume 20 MHz. */\n\n\t/*\n\t * These are the bounds of the sync period, based on the frequency of\n\t * the chip's clock input and the size and offset of the sync period\n\t * register.\n\t *\n\t * For a 20Mhz clock, this gives us 25, or 100nS, or 10MB/s, as a\n\t * maximum transfer rate, and 112.5, or 450nS, or 2.22MB/s, as a\n\t * minimum transfer rate.\n\t */\n\tsc->sc_minsync = (2 * 250) / sc->sc_freq;\n\tsc->sc_maxsync = (9 * 250) / sc->sc_freq;\n\n\taic_init(sc);\t/* init chip and driver */\n\n\t/*\n\t * Fill in the prototype scsi_link\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_initiator;\n\tsc->sc_link.adapter = &aic_switch;\n\tsc->sc_link.device = &aic_dev;\n\tsc->sc_link.openings = 2;\n\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void \taic_init",
      "struct scsi_adapter aic_switch = {\n\taic_scsi_cmd,\n\taic_minphys,\n\t0,\n\t0,\n};",
      "struct scsi_device aic_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aic_init",
          "args": [
            "sc"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "aic_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
          "lines": "361-424",
          "snippet": "void\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}",
          "includes": [
            "#include <dev/ic/aic6360var.h>",
            "#include <dev/ic/aic6360reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAIC_MAX_WIDTH\t\t0",
            "#define\tAIC_USE_WIDE\t\t0",
            "#define AIC_SYNC_REQ_ACK_OFS \t8",
            "#define AIC_USE_SYNCHRONOUS\t0"
          ],
          "globals_used": [
            "void \taic_init",
            "void\taic_done",
            "aic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));",
            "void\taic_timeout",
            "void\taic_scsi_reset",
            "void\taic_reset",
            "struct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAIC_MAX_WIDTH\t\t0\n#define\tAIC_USE_WIDE\t\t0\n#define AIC_SYNC_REQ_ACK_OFS \t8\n#define AIC_USE_SYNCHRONOUS\t0\n\nvoid \taic_init;\nvoid\taic_done;\naic_setsync\t__P((struct aic_softc *, struct aic_tinfo *));\nvoid\taic_timeout;\nvoid\taic_scsi_reset;\nvoid\taic_reset;\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\nint flags;\n\nvoid\naic_init(sc)\n\tstruct aic_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct aic_acb *acb;\n\tint r;\n\n\taic_reset(sc);\n\taic_scsi_reset(sc);\n\taic_reset(sc);\n\n\tif (sc->sc_state == AIC_INIT) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tacb = sc->sc_acb;\n\t\tbzero(acb, sizeof(sc->sc_acb));\n\t\tfor (r = 0; r < sizeof(sc->sc_acb) / sizeof(*acb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, acb, chain);\n\t\t\tacb++;\n\t\t}\n\t\tbzero(&sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = AIC_CLEANING;\n\t\tif ((acb = sc->sc_nexus) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t\twhile ((acb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tacb->xs->error = XS_DRIVER_STUFFUP;\n\t\t\tuntimeout(aic_timeout, acb);\n\t\t\taic_done(sc, acb);\n\t\t}\n\t}\n\n\tsc->sc_prevphase = PH_INVALID;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct aic_tinfo *ti = &sc->sc_tinfo[r];\n\n\t\tti->flags = 0;\n#if AIC_USE_SYNCHRONOUS\n\t\tti->flags |= DO_SYNC;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = AIC_SYNC_REQ_ACK_OFS;\n#else\n\t\tti->period = ti->offset = 0;\n#endif\n#if AIC_USE_WIDE\n\t\tti->flags |= DO_WIDE;\n\t\tti->width = AIC_MAX_WIDTH;\n#else\n\t\tti->width = 0;\n#endif\n\t}\n\n\tsc->sc_state = AIC_IDLE;\n\tbus_space_write_1(iot, ioh, DMACNTRL0, INTEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aicattach  \")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \taic_init;\nstruct scsi_adapter aic_switch = {\n\taic_scsi_cmd,\n\taic_minphys,\n\t0,\n\t0,\n};\nstruct scsi_device aic_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstruct aic_acb *\naic_get_acb(sc, flags)\n\tstruct aic_softc *sc;\n\nvoid\naicattach(sc)\n\tstruct aic_softc *sc;\n{\n\tAIC_TRACE((\"aicattach  \"));\n\tsc->sc_state = AIC_INIT;\n\n\tsc->sc_initiator = 7;\n\tsc->sc_freq = 20;\t/* XXXX assume 20 MHz. */\n\n\t/*\n\t * These are the bounds of the sync period, based on the frequency of\n\t * the chip's clock input and the size and offset of the sync period\n\t * register.\n\t *\n\t * For a 20Mhz clock, this gives us 25, or 100nS, or 10MB/s, as a\n\t * maximum transfer rate, and 112.5, or 450nS, or 2.22MB/s, as a\n\t * minimum transfer rate.\n\t */\n\tsc->sc_minsync = (2 * 250) / sc->sc_freq;\n\tsc->sc_maxsync = (9 * 250) / sc->sc_freq;\n\n\taic_init(sc);\t/* init chip and driver */\n\n\t/*\n\t * Fill in the prototype scsi_link\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_initiator;\n\tsc->sc_link.adapter = &aic_switch;\n\tsc->sc_link.device = &aic_dev;\n\tsc->sc_link.openings = 2;\n\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}"
  },
  {
    "function_name": "aic_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic6360.c",
    "lines": "207-252",
    "snippet": "int\naic_find(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tchar chip_id[sizeof(IDSTRING)];\t/* For chips that support it */\n\tint i;\n\n\t/* Remove aic6360 from possible powerdown mode */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\t/* Thanks to mark@aggregate.com for the new method for detecting\n\t * whether the chip is present or not.  Bonus: may also work for\n\t * the AIC-6260!\n \t */\n\tAIC_TRACE((\"aic: probing for aic-chip\\n\"));\n \t/*\n \t * Linux also init's the stack to 1-16 and then clears it,\n     \t *  6260's don't appear to have an ID reg - mpg\n \t */\n\t/* Push the sequence 0,1,..,15 on the stack */\n#define STSIZE 16\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0); /* Reset stack pointer */\n\tfor (i = 0; i < STSIZE; i++)\n\t\tbus_space_write_1(iot, ioh, STACK, i);\n\n\t/* See if we can pull out the same sequence */\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n \tfor (i = 0; i < STSIZE && bus_space_read_1(iot, ioh, STACK) == i; i++)\n\t\t;\n\tif (i != STSIZE) {\n\t\tAIC_START((\"STACK futzed at %d.\\n\", i));\n\t\treturn (0);\n\t}\n\n\t/* See if we can pull the id string out of the ID register,\n\t * now only used for informational purposes.\n\t */\n\tbzero(chip_id, sizeof(chip_id));\n\tbus_space_read_multi_1(iot, ioh, ID, chip_id, sizeof(IDSTRING) - 1);\n\tAIC_START((\"AIC ID: %s \", chip_id));\n\tAIC_START((\"chip revision %d\\n\",\n\t    (int)bus_space_read_1(iot, ioh, REV)));\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/aic6360var.h>",
      "#include <dev/ic/aic6360reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STSIZE 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AIC_START",
          "args": [
            "(\"chip revision %d\\n\",\n\t    (int)bus_space_read_1(iot, ioh, REV))"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "REV"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_START",
          "args": [
            "(\"AIC ID: %s \", chip_id)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_1",
          "args": [
            "iot",
            "ioh",
            "ID",
            "chip_id",
            "sizeof(IDSTRING) - 1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "chip_id",
            "sizeof(chip_id)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_START",
          "args": [
            "(\"STACK futzed at %d.\\n\", i)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "STACK"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL1",
            "0"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "STACK",
            "i"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL1",
            "0"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIC_TRACE",
          "args": [
            "(\"aic: probing for aic-chip\\n\")"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "DMACNTRL0",
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/aic6360var.h>\n#include <dev/ic/aic6360reg.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STSIZE 16\n\nint\naic_find(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tchar chip_id[sizeof(IDSTRING)];\t/* For chips that support it */\n\tint i;\n\n\t/* Remove aic6360 from possible powerdown mode */\n\tbus_space_write_1(iot, ioh, DMACNTRL0, 0);\n\n\t/* Thanks to mark@aggregate.com for the new method for detecting\n\t * whether the chip is present or not.  Bonus: may also work for\n\t * the AIC-6260!\n \t */\n\tAIC_TRACE((\"aic: probing for aic-chip\\n\"));\n \t/*\n \t * Linux also init's the stack to 1-16 and then clears it,\n     \t *  6260's don't appear to have an ID reg - mpg\n \t */\n\t/* Push the sequence 0,1,..,15 on the stack */\n#define STSIZE 16\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0); /* Reset stack pointer */\n\tfor (i = 0; i < STSIZE; i++)\n\t\tbus_space_write_1(iot, ioh, STACK, i);\n\n\t/* See if we can pull out the same sequence */\n\tbus_space_write_1(iot, ioh, DMACNTRL1, 0);\n \tfor (i = 0; i < STSIZE && bus_space_read_1(iot, ioh, STACK) == i; i++)\n\t\t;\n\tif (i != STSIZE) {\n\t\tAIC_START((\"STACK futzed at %d.\\n\", i));\n\t\treturn (0);\n\t}\n\n\t/* See if we can pull the id string out of the ID register,\n\t * now only used for informational purposes.\n\t */\n\tbzero(chip_id, sizeof(chip_id));\n\tbus_space_read_multi_1(iot, ioh, ID, chip_id, sizeof(IDSTRING) - 1);\n\tAIC_START((\"AIC ID: %s \", chip_id));\n\tAIC_START((\"chip revision %d\\n\",\n\t    (int)bus_space_read_1(iot, ioh, REV)));\n\n\treturn (1);\n}"
  }
]