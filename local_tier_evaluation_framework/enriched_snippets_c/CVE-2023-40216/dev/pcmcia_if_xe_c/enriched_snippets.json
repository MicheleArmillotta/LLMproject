[
  {
    "function_name": "xe_reg_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1558-1595",
    "snippet": "void\nxe_reg_dump(sc)\n\tstruct xe_softc *sc;\n{\n\tint page, i;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tprintf(\"%x: Common registers: \", sc->sc_dev.dv_xname);\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\" %2.2x\", bus_space_read_1(bst, bsh, offset + i));\n\t}\n\tprintf(\"\\n\");\n\n\tfor (page = 0; page < 8; page++) {\n\t\tprintf(\"%s: Register page %2.2x: \", sc->sc_dev.dv_xname, page);\n\t\tPAGE(sc, page);\n\t\tfor (i = 8; i < 16; i++) {\n\t\t\tprintf(\" %2.2x\",\n\t\t\t    bus_space_read_1(bst, bsh, offset + i));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (page = 0x40; page < 0x5f; page++) {\n\t\tif (page == 0x43 || (page >= 0x46 && page <= 0x4f) ||\n\t\t    (page >= 0x51 && page <= 0x5e))\n\t\t\tcontinue;\n\t\tprintf(\"%s: Register page %2.2x: \", sc->sc_dev.dv_xname, page);\n\t\tPAGE(sc, page);\n\t\tfor (i = 8; i < 16; i++) {\n\t\t\tprintf(\" %2.2x\",\n\t\t\t    bus_space_read_1(bst, bsh, offset + i));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + i"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "page"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + i"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "page"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + i"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_reg_dump(sc)\n\tstruct xe_softc *sc;\n{\n\tint page, i;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tprintf(\"%x: Common registers: \", sc->sc_dev.dv_xname);\n\tfor (i = 0; i < 8; i++) {\n\t\tprintf(\" %2.2x\", bus_space_read_1(bst, bsh, offset + i));\n\t}\n\tprintf(\"\\n\");\n\n\tfor (page = 0; page < 8; page++) {\n\t\tprintf(\"%s: Register page %2.2x: \", sc->sc_dev.dv_xname, page);\n\t\tPAGE(sc, page);\n\t\tfor (i = 8; i < 16; i++) {\n\t\t\tprintf(\" %2.2x\",\n\t\t\t    bus_space_read_1(bst, bsh, offset + i));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (page = 0x40; page < 0x5f; page++) {\n\t\tif (page == 0x43 || (page >= 0x46 && page <= 0x4f) ||\n\t\t    (page >= 0x51 && page <= 0x5e))\n\t\t\tcontinue;\n\t\tprintf(\"%s: Register page %2.2x: \", sc->sc_dev.dv_xname, page);\n\t\tPAGE(sc, page);\n\t\tfor (i = 8; i < 16; i++) {\n\t\t\tprintf(\" %2.2x\",\n\t\t\t    bus_space_read_1(bst, bsh, offset + i));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "xe_full_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1406-1555",
    "snippet": "void\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_MODEM\t0x004",
      "#define XEF_DINGO\t0x002",
      "#define XEF_MOHAWK\t0x001"
    ],
    "globals_used": [
      "void\txe_cycle_power",
      "void\txe_full_reset",
      "void\txe_set_address",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + 0x10",
            "0x11"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + 0x10"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + CR",
            "ENABLE_INT"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IMR1",
            "1"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IMR0",
            "0xff"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "1"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + CMD0",
            "ENABLE_RX | ONLINE"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x40"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + LED3",
            "LED_100MB_LINK << LED3_SHIFT"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + LED",
            "LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "2"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50000"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + SWC1",
            "SWC1_AUTO_MEDIA"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x42"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20000"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + MSR",
            "bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + MSR"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "2"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + TXST1",
            "0"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + TXST0",
            "0"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + RXST0",
            "0"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + TX1MSK",
            "0xb0"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + TX0MSK",
            "CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + RX0MSK",
            "PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x40"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "offset + DO0",
            "DO_CHG_OFFSET"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_set_address",
          "args": [
            "sc"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "xe_set_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1325-1384",
          "snippet": "void\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "offset + RBS0",
            "0x2000"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "2"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + SWC0",
            "0x20"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x42"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IMR1",
            "1"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IMR0",
            "0xff"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IMR0",
            "ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "1"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "40000"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP0",
            "GP1_OUT"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "4"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + BV"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500000"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP0",
            "GP1_OUT | GP2_OUT | GP2_WR"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "4"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20000"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + CR",
            "0"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20000"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + CR",
            "SOFT_RESET"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_cycle_power",
          "args": [
            "sc"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "xe_cycle_power",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1386-1404",
          "snippet": "void\nxe_cycle_power(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tPAGE(sc, 4);\n\tDELAY(1);\n\tbus_space_write_1(bst, bsh, offset + GP1, 0);\n\tDELAY(40000);\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP);\n\telse\n\t\t/* XXX What is bit 2 (aka AIC)? */\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP | 4);\n\tDELAY(20000);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_cycle_power",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_cycle_power;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_cycle_power(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tPAGE(sc, 4);\n\tDELAY(1);\n\tbus_space_write_1(bst, bsh, offset + GP1, 0);\n\tDELAY(40000);\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP);\n\telse\n\t\t/* XXX What is bit 2 (aka AIC)? */\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP | 4);\n\tDELAY(20000);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MODEM\t0x004\n#define XEF_DINGO\t0x002\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_cycle_power;\nvoid\txe_full_reset;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}"
  },
  {
    "function_name": "xe_cycle_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1386-1404",
    "snippet": "void\nxe_cycle_power(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tPAGE(sc, 4);\n\tDELAY(1);\n\tbus_space_write_1(bst, bsh, offset + GP1, 0);\n\tDELAY(40000);\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP);\n\telse\n\t\t/* XXX What is bit 2 (aka AIC)? */\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP | 4);\n\tDELAY(20000);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_MOHAWK\t0x001"
    ],
    "globals_used": [
      "void\txe_cycle_power",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20000"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP1",
            "POWER_UP | 4"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP1",
            "POWER_UP"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "40000"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP1",
            "0"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "4"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_cycle_power;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_cycle_power(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\tPAGE(sc, 4);\n\tDELAY(1);\n\tbus_space_write_1(bst, bsh, offset + GP1, 0);\n\tDELAY(40000);\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP);\n\telse\n\t\t/* XXX What is bit 2 (aka AIC)? */\n\t\tbus_space_write_1(bst, bsh, offset + GP1, POWER_UP | 4);\n\tDELAY(20000);\n}"
  },
  {
    "function_name": "xe_set_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1325-1384",
    "snippet": "void\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_MOHAWK\t0x001"
    ],
    "globals_used": [
      "void\txe_set_address",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "page"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + pos",
            "enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "arp",
            "enm"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + SWC1",
            "SWC1_PROMISC | SWC1_MCAST_PROM"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x42"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + IA + i",
            "sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x50"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xe_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1242-1323",
    "snippet": "int\nxe_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n\t\terror = xe_ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\t\t\t\n\t\tPAGE(sc, 0x42);\n\t\tif ((ifp->if_flags & IFF_PROMISC) ||\n\t\t    (ifp->if_flags & IFF_ALLMULTI))\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\telse\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1, 0);\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * XXX If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\txe_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\txe_stop(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tsc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (!sc->sc_all_mcasts &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC))\n\t\t\t\txe_set_address(sc);\n\n\t\t\t/*\n\t\t\t * xe_set_address() can turn on all_mcasts if we run\n\t\t\t * out of space, so check it again rather than else {}.\n\t\t\t */\n\t\t\tif (sc->sc_all_mcasts)\n\t\t\t\txe_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror =\n\t\t    ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_ether_ioctl",
      "void\txe_init",
      "int\txe_ioctl",
      "void\txe_set_address",
      "void\txe_stop",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_mii.mii_media",
            "command"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "sc"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_set_address",
          "args": [
            "sc"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "xe_set_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1325-1384",
          "snippet": "void\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_stop",
          "args": [
            "sc"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "xe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1065-1083",
          "snippet": "void\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\txe_stop",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + SWC1",
            "0"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + SWC1",
            "SWC1_PROMISC | SWC1_MCAST_PROM"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0x42"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "xe_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1190-1240",
          "snippet": "int\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\txe_ether_ioctl",
            "void\txe_init",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_ether_ioctl;\nvoid\txe_init;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_ether_ioctl;\nvoid\txe_init;\nint\txe_ioctl;\nvoid\txe_set_address;\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n\t\terror = xe_ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\t\t\t\n\t\tPAGE(sc, 0x42);\n\t\tif ((ifp->if_flags & IFF_PROMISC) ||\n\t\t    (ifp->if_flags & IFF_ALLMULTI))\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\telse\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1, 0);\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * XXX If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\txe_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\txe_stop(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tsc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (!sc->sc_all_mcasts &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC))\n\t\t\t\txe_set_address(sc);\n\n\t\t\t/*\n\t\t\t * xe_set_address() can turn on all_mcasts if we run\n\t\t\t * out of space, so check it again rather than else {}.\n\t\t\t */\n\t\t\tif (sc->sc_all_mcasts)\n\t\t\t\txe_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror =\n\t\t    ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "xe_ether_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1190-1240",
    "snippet": "int\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_ether_ioctl",
      "void\txe_init",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "sc"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "sc->sc_arpcom.ac_enaddr",
            "ifp->if_addrlen"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_ether_ioctl;\nvoid\txe_init;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct xe_softc *sc = ifp->if_softc;\n#ifdef NS\n\tstruct ns_addr *ina;\n#endif\t/* NS */\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\n#ifdef NS\n\t\tcase AF_NS:\n\t\t\tina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)sc->sc_arpcom.ac_enaddr;\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);\n\t\t\t/* Set new address. */\n\t\t\txe_init(sc);\n\t\t\tbreak;\n#endif\t/* NS */\n\n\t\tdefault:\n\t\t\txe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "xe_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1110-1188",
    "snippet": "void\nxe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tunsigned int s, len, pad = 0;\n\tstruct mbuf *m0, *m;\n\tu_int16_t space;\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\t/* Peek at the next packet. */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif (!(m0->m_flags & M_PKTHDR))\n\t\tpanic(\"xe_start: no header mbuf\");\n\n\tlen = m0->m_pkthdr.len;\n\n\t/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */\n\tif (len < ETHER_MIN_LEN - ETHER_CRC_LEN)\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n\n\tspace = bus_space_read_2(bst, bsh, offset + TSO0) & 0x7fff;\n\tif (len + pad + 2 > space) {\n\t\tDPRINTF(XED_FIFO,\n\t\t    (\"%s: not enough space in output FIFO (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad + 2, space));\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\ts = splhigh();\n\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + TSO2, (u_int16_t)len + pad + 2);\n\tbus_space_write_2(bst, bsh, offset + EDP, (u_int16_t)len + pad);\n\tfor (m = m0; m; ) {\n\t\tif (m->m_len > 1)\n\t\t\tbus_space_write_raw_multi_2(bst, bsh, offset + EDP,\n\t\t\t    mtod(m, u_int8_t *), m->m_len & ~1);\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP,\n\t\t\t    *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + CR, TX_PKT | ENABLE_INT);\n\telse {\n\t\tfor (; pad > 1; pad -= 2)\n\t\t\tbus_space_write_2(bst, bsh, offset + EDP, 0);\n\t\tif (pad == 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP, 0);\n\t}\n\n\tsplx(s);\n\n\tifp->if_timer = 5;\n\t++ifp->if_opackets;\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_MOHAWK\t0x001",
      "#define XED_FIFO\t0x8",
      "#define ETHER_CRC_LEN 4",
      "#define ETHER_MIN_LEN 64"
    ],
    "globals_used": [
      "void\txe_start",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + EDP",
            "0"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "offset + EDP",
            "0"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + CR",
            "TX_PKT | ENABLE_INT"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + EDP",
            "*(mtod(m, u_int8_t *) + m->m_len - 1)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "bst",
            "bsh",
            "offset + EDP",
            "mtod(m, u_int8_t *)",
            "m->m_len & ~1"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "offset + EDP",
            "(u_int16_t)len + pad"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "bst",
            "bsh",
            "offset + TSO2",
            "(u_int16_t)len + pad + 2"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_FIFO",
            "(\"%s: not enough space in output FIFO (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad + 2, space)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "bst",
            "bsh",
            "offset + TSO0"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"xe_start: no header mbuf\""
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n#define XED_FIFO\t0x8\n#define ETHER_CRC_LEN 4\n#define ETHER_MIN_LEN 64\n\nvoid\txe_start;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tunsigned int s, len, pad = 0;\n\tstruct mbuf *m0, *m;\n\tu_int16_t space;\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\t/* Peek at the next packet. */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif (!(m0->m_flags & M_PKTHDR))\n\t\tpanic(\"xe_start: no header mbuf\");\n\n\tlen = m0->m_pkthdr.len;\n\n\t/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */\n\tif (len < ETHER_MIN_LEN - ETHER_CRC_LEN)\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n\n\tspace = bus_space_read_2(bst, bsh, offset + TSO0) & 0x7fff;\n\tif (len + pad + 2 > space) {\n\t\tDPRINTF(XED_FIFO,\n\t\t    (\"%s: not enough space in output FIFO (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad + 2, space));\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\ts = splhigh();\n\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + TSO2, (u_int16_t)len + pad + 2);\n\tbus_space_write_2(bst, bsh, offset + EDP, (u_int16_t)len + pad);\n\tfor (m = m0; m; ) {\n\t\tif (m->m_len > 1)\n\t\t\tbus_space_write_raw_multi_2(bst, bsh, offset + EDP,\n\t\t\t    mtod(m, u_int8_t *), m->m_len & ~1);\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP,\n\t\t\t    *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + CR, TX_PKT | ENABLE_INT);\n\telse {\n\t\tfor (; pad > 1; pad -= 2)\n\t\t\tbus_space_write_2(bst, bsh, offset + EDP, 0);\n\t\tif (pad == 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP, 0);\n\t}\n\n\tsplx(s);\n\n\tifp->if_timer = 5;\n\t++ifp->if_opackets;\n}"
  },
  {
    "function_name": "xe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1085-1104",
    "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XED_CONFIG\t0x1"
    ],
    "globals_used": [
      "void\txe_init",
      "void\txe_set_address",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_set_address",
          "args": [
            "sc"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "xe_set_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1325-1384",
          "snippet": "void\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_set_address(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tstruct arpcom *arp = &sc->sc_arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, page, pos, num;\n\n\tPAGE(sc, 0x50);\n\tfor (i = 0; i < 6; i++) {\n\t\tbus_space_write_1(bst, bsh, offset + IA + i,\n\t\t    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?\n\t\t    5 - i : i]);\n\t}\n\t\t\n\tif (arp->ac_multicnt > 0) {\n\t\tif (arp->ac_multicnt > 9) {\n\t\t\tPAGE(sc, 0x42);\n\t\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + SWC1,\n\t\t\t    SWC1_PROMISC | SWC1_MCAST_PROM);\n\t\t\treturn;\n\t\t}\n\n\t\tETHER_FIRST_MULTI(step, arp, enm);\n\n\t\tpos = IA + 6;\n\t\tfor (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;\n\t\t    num--) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\t/*\n\t\t\t\t * The multicast address is really a range;\n\t\t\t\t * it's easier just to accept all multicasts.\n\t\t\t\t * XXX should we be setting IFF_ALLMULTI here?\n\t\t\t\t */\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tsc->sc_all_mcasts=1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\tbus_space_write_1(bst, bsh, offset + pos,\n\t\t\t\t    enm->enm_addrlo[\n\t\t\t\t    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);\n\n\t\t\t\tif (++pos > 15) {\n\t\t\t\t\tpos = IA;\n\t\t\t\t\tpage++;\n\t\t\t\t\tPAGE(sc, page);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_CONFIG",
            "(\"xe_init\\n\")"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
  },
  {
    "function_name": "xe_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1065-1083",
    "snippet": "void\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_stop",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "40000"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + GP1",
            "0"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "4"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + IMR0",
            "0"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "1"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + CR",
            "0"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
  },
  {
    "function_name": "xe_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1053-1063",
    "snippet": "void\nxe_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\txe_reset(sc);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_reset",
      "void\txe_watchdog",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xe_reset",
          "args": [
            "sc"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "xe_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1040-1051",
          "snippet": "void\nxe_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\txe_stop(sc);\n\txe_full_reset(sc);\n\txe_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\txe_full_reset",
            "void\txe_init",
            "void\txe_reset",
            "void\txe_stop",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_full_reset;\nvoid\txe_init;\nvoid\txe_reset;\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\txe_stop(sc);\n\txe_full_reset(sc);\n\txe_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_reset;\nvoid\txe_watchdog;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\txe_reset(sc);\n}"
  },
  {
    "function_name": "xe_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1040-1051",
    "snippet": "void\nxe_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\txe_stop(sc);\n\txe_full_reset(sc);\n\txe_init(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_full_reset",
      "void\txe_init",
      "void\txe_reset",
      "void\txe_stop",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "sc"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_full_reset",
          "args": [
            "sc"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "xe_full_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1406-1555",
          "snippet": "void\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MODEM\t0x004",
            "#define XEF_DINGO\t0x002",
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_cycle_power",
            "void\txe_full_reset",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MODEM\t0x004\n#define XEF_DINGO\t0x002\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_cycle_power;\nvoid\txe_full_reset;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_stop",
          "args": [
            "sc"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "xe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1065-1083",
          "snippet": "void\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\txe_stop",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_full_reset;\nvoid\txe_init;\nvoid\txe_reset;\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\txe_stop(sc);\n\txe_full_reset(sc);\n\txe_init(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "xe_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1028-1038",
    "snippet": "void\nxe_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_mediastatus",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_mediastatus;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}"
  },
  {
    "function_name": "xe_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1016-1023",
    "snippet": "int\nxe_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tif (ifp->if_flags & IFF_UP)\n\t\txe_init(ifp->if_softc);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_init",
      "int\txe_mediachange"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "ifp->if_softc"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_init;\nint\txe_mediachange;\n\nint\nxe_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tif (ifp->if_flags & IFF_UP)\n\t\txe_init(ifp->if_softc);\n\treturn (0);\n}"
  },
  {
    "function_name": "xe_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "1006-1011",
    "snippet": "void\nxe_statchg(self)\n\tstruct device *self;\n{\n\t/* XXX Update ifp->if_baudrate */\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\txe_statchg"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_statchg;\n\nvoid\nxe_statchg(self)\n\tstruct device *self;\n{\n\t/* XXX Update ifp->if_baudrate */\n}"
  },
  {
    "function_name": "xe_mdi_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "982-1004",
    "snippet": "void\nxe_mdi_write(self, phy, reg, value)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n\tint value;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x05, 4); /* Start + Write opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_pulse_bits(sc, 0x02, 2); /* Turn around. */\n\txe_mdi_pulse_bits(sc, value, 16);\t/* Write the data */\n\txe_mdi_idle(sc);\t\t/* Idle away. */\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_write: phy %d reg %d val %x\\n\", phy, reg, value));\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XED_MII\t\t0x2"
    ],
    "globals_used": [
      "void\txe_mdi_write",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_MII",
            "(\"xe_mdi_write: phy %d reg %d val %x\\n\", phy, reg, value)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_mdi_idle",
          "args": [
            "sc"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "875-890",
          "snippet": "static INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define INLINE",
            "#define INLINE\t__inline"
          ],
          "globals_used": [
            "static INLINE void",
            "xe_mdi_idle __P((struct xe_softc *));",
            "static INLINE void",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "static INLINE int",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "static INLINE void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_mdi_pulse_bits",
          "args": [
            "sc",
            "value",
            "16"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_pulse_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "938-948",
          "snippet": "static INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define INLINE",
            "#define INLINE\t__inline"
          ],
          "globals_used": [
            "static INLINE void",
            "xe_mdi_idle __P((struct xe_softc *));",
            "static INLINE void",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "static INLINE int",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "static INLINE void",
            "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nstatic INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "2"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_MII\t\t0x2\n\nvoid\txe_mdi_write;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_mdi_write(self, phy, reg, value)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n\tint value;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x05, 4); /* Start + Write opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_pulse_bits(sc, 0x02, 2); /* Turn around. */\n\txe_mdi_pulse_bits(sc, value, 16);\t/* Write the data */\n\txe_mdi_idle(sc);\t\t/* Idle away. */\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_write: phy %d reg %d val %x\\n\", phy, reg, value));\n}"
  },
  {
    "function_name": "xe_mdi_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "951-979",
    "snippet": "int\nxe_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\tu_int32_t mask;\n\tu_int32_t data = 0;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x06, 4); /* Start + Read opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_idle(sc);\t\t/* Turn around. */\n\txe_mdi_probe(sc);\t\t/* Drop initial zero bit. */\n\n\tfor (mask = 1 << 15; mask; mask >>= 1)\n\t\tif (xe_mdi_probe(sc))\n\t\t\tdata |= mask;\n\txe_mdi_idle(sc);\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_read: phy %d reg %d -> %x\\n\", phy, reg, data));\n\treturn (data);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XED_MII\t\t0x2"
    ],
    "globals_used": [
      "int\txe_mdi_read",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));",
      "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_MII",
            "(\"xe_mdi_read: phy %d reg %d -> %x\\n\", phy, reg, data)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_mdi_idle",
          "args": [
            "sc"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "875-890",
          "snippet": "static INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define INLINE",
            "#define INLINE\t__inline"
          ],
          "globals_used": [
            "static INLINE void",
            "xe_mdi_idle __P((struct xe_softc *));",
            "static INLINE void",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "static INLINE int",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "static INLINE void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_mdi_probe",
          "args": [
            "sc"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "915-934",
          "snippet": "static INLINE int\nxe_mdi_probe(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t x;\n\n\t/* Pull clock bit MDCK low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* Read data and drive clock high again. */\n\tx = bus_space_read_1(bst, bsh, offset + GP2) & MDIO;\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n\n\treturn (x);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define INLINE",
            "#define INLINE\t__inline"
          ],
          "globals_used": [
            "static INLINE void",
            "xe_mdi_idle __P((struct xe_softc *));",
            "static INLINE void",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "static INLINE int",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "static INLINE void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE int\nxe_mdi_probe(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t x;\n\n\t/* Pull clock bit MDCK low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* Read data and drive clock high again. */\n\tx = bus_space_read_1(bst, bsh, offset + GP2) & MDIO;\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n\n\treturn (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_mdi_pulse_bits",
          "args": [
            "sc",
            "reg",
            "5"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_pulse_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "938-948",
          "snippet": "static INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define INLINE",
            "#define INLINE\t__inline"
          ],
          "globals_used": [
            "static INLINE void",
            "xe_mdi_idle __P((struct xe_softc *));",
            "static INLINE void",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "static INLINE int",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "static INLINE void",
            "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nstatic INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "2"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_MII\t\t0x2\n\nint\txe_mdi_read;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nint\nxe_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\tu_int32_t mask;\n\tu_int32_t data = 0;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x06, 4); /* Start + Read opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_idle(sc);\t\t/* Turn around. */\n\txe_mdi_probe(sc);\t\t/* Drop initial zero bit. */\n\n\tfor (mask = 1 << 15; mask; mask >>= 1)\n\t\tif (xe_mdi_probe(sc))\n\t\t\tdata |= mask;\n\txe_mdi_idle(sc);\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_read: phy %d reg %d -> %x\\n\", phy, reg, data));\n\treturn (data);\n}"
  },
  {
    "function_name": "xe_mdi_pulse_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "938-948",
    "snippet": "static INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define INLINE",
      "#define INLINE\t__inline"
    ],
    "globals_used": [
      "static INLINE void",
      "xe_mdi_idle __P((struct xe_softc *));",
      "static INLINE void",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "static INLINE int",
      "xe_mdi_probe __P((struct xe_softc *sc));",
      "static INLINE void",
      "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xe_mdi_pulse",
          "args": [
            "sc",
            "data & mask"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_pulse_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "938-948",
          "snippet": "static INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nstatic INLINE void\nxe_mdi_pulse_bits(sc, data, len)\n\tstruct xe_softc *sc;\n\tu_int32_t data;\n\tint len;\n{\n\tu_int32_t mask;\n\n\tfor (mask = 1 << (len - 1); mask; mask >>= 1)\n\t\txe_mdi_pulse(sc, data & mask);\n}"
  },
  {
    "function_name": "xe_mdi_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "915-934",
    "snippet": "static INLINE int\nxe_mdi_probe(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t x;\n\n\t/* Pull clock bit MDCK low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* Read data and drive clock high again. */\n\tx = bus_space_read_1(bst, bsh, offset + GP2) & MDIO;\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n\n\treturn (x);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define INLINE",
      "#define INLINE\t__inline"
    ],
    "globals_used": [
      "static INLINE void",
      "xe_mdi_idle __P((struct xe_softc *));",
      "static INLINE void",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "static INLINE int",
      "xe_mdi_probe __P((struct xe_softc *sc));",
      "static INLINE void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "MDC_HIGH"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "MDC_LOW"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE int\nxe_mdi_probe(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t x;\n\n\t/* Pull clock bit MDCK low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* Read data and drive clock high again. */\n\tx = bus_space_read_1(bst, bsh, offset + GP2) & MDIO;\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n\n\treturn (x);\n}"
  },
  {
    "function_name": "xe_mdi_pulse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "894-911",
    "snippet": "static INLINE void\nxe_mdi_pulse(sc, data)\n\tstruct xe_softc *sc;\n\tint data;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t bit = data ? MDIO_HIGH : MDIO_LOW;\n\n\t/* First latch the data bit MDIO with clock bit MDC low...*/\n\tbus_space_write_1(bst, bsh, offset + GP2, bit | MDC_LOW);\n\tDELAY(1);\n\n\t/* then raise the clock again, preserving the data bit. */\n\tbus_space_write_1(bst, bsh, offset + GP2, bit | MDC_HIGH);\n\tDELAY(1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define INLINE",
      "#define INLINE\t__inline"
    ],
    "globals_used": [
      "static INLINE void",
      "xe_mdi_idle __P((struct xe_softc *));",
      "static INLINE void",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "static INLINE int",
      "xe_mdi_probe __P((struct xe_softc *sc));",
      "static INLINE void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "bit | MDC_HIGH"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "bit | MDC_LOW"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE void\nxe_mdi_pulse(sc, data)\n\tstruct xe_softc *sc;\n\tint data;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tu_int8_t bit = data ? MDIO_HIGH : MDIO_LOW;\n\n\t/* First latch the data bit MDIO with clock bit MDC low...*/\n\tbus_space_write_1(bst, bsh, offset + GP2, bit | MDC_LOW);\n\tDELAY(1);\n\n\t/* then raise the clock again, preserving the data bit. */\n\tbus_space_write_1(bst, bsh, offset + GP2, bit | MDC_HIGH);\n\tDELAY(1);\n}"
  },
  {
    "function_name": "xe_mdi_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "875-890",
    "snippet": "static INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define INLINE",
      "#define INLINE\t__inline"
    ],
    "globals_used": [
      "static INLINE void",
      "xe_mdi_idle __P((struct xe_softc *));",
      "static INLINE void",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "static INLINE int",
      "xe_mdi_probe __P((struct xe_softc *sc));",
      "static INLINE void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "MDC_HIGH"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "bst",
            "bsh",
            "offset + GP2",
            "MDC_LOW"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define INLINE\n#define INLINE\t__inline\n\nstatic INLINE void;\nxe_mdi_idle __P((struct xe_softc *));\nstatic INLINE void;\nxe_mdi_pulse __P((struct xe_softc *, int));\nstatic INLINE int;\nxe_mdi_probe __P((struct xe_softc *sc));\nstatic INLINE void;\n\nstatic INLINE void\nxe_mdi_idle(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Drive MDC low... */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);\n\tDELAY(1);\n\n\t/* and high again. */\n\tbus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);\n\tDELAY(1);\n}"
  },
  {
    "function_name": "xe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "771-863",
    "snippet": "u_int16_t\nxe_get(sc)\n\tstruct xe_softc *sc;\n{\n\tu_int8_t rsr;\n\tstruct mbuf *top, **mp, *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t pktlen, len, recvcount = 0;\n\tu_int8_t *data;\n\tstruct ether_header *eh;\n\t\n\tPAGE(sc, 0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\n\tpktlen =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RBC0) &\n\t    RBC_COUNT_MASK;\n\tif (pktlen == 0) {\n\t\t/*\n\t\t * XXX At least one CE2 sets RBC0 == 0 occasionally, and only\n\t\t * when MPE is set.  It is not known why.\n\t\t */\n\t\treturn (0);\n\t}\n\trecvcount += pktlen;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (recvcount);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\t\n\twhile (pktlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (pktlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (!(m->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tif (!top) {\n\t\t\tcaddr_t newdata = (caddr_t)ALIGN(m->m_data +\n\t\t\t    sizeof (struct ether_header)) -\n\t\t\t    sizeof (struct ether_header);\n\t\t\tlen -= newdata - m->m_data;\n\t\t\tm->m_data = newdata;\n\t\t}\n\t\tlen = min(pktlen, len);\n\n\t\tdata = mtod(m, u_int8_t *);\n\t\tif (len > 1) {\n\t\t        len &= ~1;\n\t\t\tbus_space_read_raw_multi_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP, data, len);\n\t\t} else\n\t\t\t*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP);\n\t\tm->m_len = len;\n\t\tpktlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\t/* Skip Rx packet. */\n\tbus_space_write_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + DO0,\n\t    DO_SKIP_RX_PKT);\n\t\n\tifp->if_ipackets++;\n\t\n\teh = mtod(top, struct ether_header *);\n\t\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\t\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn (recvcount);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t xe_get",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "top"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "top",
            "sizeof(struct ether_header)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "top"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "top",
            "structether_header*"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + DO0",
            "DO_SKIP_RX_PKT"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + EDP"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_raw_multi_2",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + EDP",
            "data",
            "len"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pktlen",
            "len"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "m->m_data +\n\t\t\t    sizeof (struct ether_header)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + RBC0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + RSR"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t xe_get;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nu_int16_t\nxe_get(sc)\n\tstruct xe_softc *sc;\n{\n\tu_int8_t rsr;\n\tstruct mbuf *top, **mp, *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t pktlen, len, recvcount = 0;\n\tu_int8_t *data;\n\tstruct ether_header *eh;\n\t\n\tPAGE(sc, 0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\n\tpktlen =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RBC0) &\n\t    RBC_COUNT_MASK;\n\tif (pktlen == 0) {\n\t\t/*\n\t\t * XXX At least one CE2 sets RBC0 == 0 occasionally, and only\n\t\t * when MPE is set.  It is not known why.\n\t\t */\n\t\treturn (0);\n\t}\n\trecvcount += pktlen;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (recvcount);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\t\n\twhile (pktlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (pktlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (!(m->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tif (!top) {\n\t\t\tcaddr_t newdata = (caddr_t)ALIGN(m->m_data +\n\t\t\t    sizeof (struct ether_header)) -\n\t\t\t    sizeof (struct ether_header);\n\t\t\tlen -= newdata - m->m_data;\n\t\t\tm->m_data = newdata;\n\t\t}\n\t\tlen = min(pktlen, len);\n\n\t\tdata = mtod(m, u_int8_t *);\n\t\tif (len > 1) {\n\t\t        len &= ~1;\n\t\t\tbus_space_read_raw_multi_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP, data, len);\n\t\t} else\n\t\t\t*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP);\n\t\tm->m_len = len;\n\t\tpktlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\t/* Skip Rx packet. */\n\tbus_space_write_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + DO0,\n\t    DO_SKIP_RX_PKT);\n\t\n\tifp->if_ipackets++;\n\t\n\teh = mtod(top, struct ether_header *);\n\t\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\t\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn (recvcount);\n}"
  },
  {
    "function_name": "xe_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "652-769",
    "snippet": "int\nxe_intr(arg)\n\tvoid *arg;\n{\n\tstruct xe_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t esr, rsr, isr, rx_status, savedpage;\n\tu_int16_t tx_status, recvcount = 0, tempint;\n\n\tifp->if_timer = 0;\t/* turn watchdog timer off */\n\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\t/* Disable interrupt (Linux does it). */\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    0);\n\t}\n\n\tsavedpage =\n\t    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + PR);\n\n\tPAGE(sc, 0);\n\tesr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ESR);\n\tisr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ISR0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\t\t\t\t\n\t/* Check to see if card has been ejected. */\n\tif (isr == 0xff) {\n\t\tprintf(\"%s: interrupt for dead card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto end;\n\t}\n\n\tPAGE(sc, 40);\n\trx_status =\n\t    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RXST0);\n\ttx_status =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + TXST0);\n\n\t/*\n\t * XXX Linux writes to RXST0 and TXST* here.  My CE2 works just fine\n\t * without it, and I can't see an obvious reason for it.\n\t */\n\n\tPAGE(sc, 0);\n\twhile (esr & FULL_PKT_RCV) {\n\t\tif (!(rsr & RSR_RX_OK))\n\t\t\tbreak;\n\n\t\t/* Compare bytes read this interrupt to hard maximum. */\n\t\tif (recvcount > MAX_BYTES_INTR) {\n\t\t\tDPRINTF(XED_INTR,\n\t\t\t    (\"%s: too many bytes this interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname));\n\t\t\tifp->if_iqdrops++;\n\t\t\t/* Drop packet. */\n\t\t\tbus_space_write_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + DO0, DO_SKIP_RX_PKT);\n\t\t}\n\t\ttempint = xe_get(sc);\n\t\trecvcount += tempint;\n\t\tifp->if_ibytes += tempint;\n\t\tesr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t    sc->sc_offset + ESR);\n\t\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t    sc->sc_offset + RSR);\n\t}\n\t\n\t/* Packet too long? */\n\tif (rsr & RSR_TOO_LONG) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: packet too long\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* CRC error? */\n\tif (rsr & RSR_CRCERR) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: CRC error detected\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* Alignment error? */\n\tif (rsr & RSR_ALIGNERR) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: alignment error detected\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* Check for rx overrun. */\n\tif (rx_status & RX_OVERRUN) {\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    CLR_RX_OVERRUN);\n\t\tDPRINTF(XED_INTR, (\"overrun cleared\\n\"));\n\t}\n\t\t\t\n\t/* Try to start more packets transmitting. */\n\tif (ifp->if_snd.ifq_head)\n\t\txe_start(ifp);\n\n\t/* Detected excessive collisions? */\n\tif ((tx_status & EXCESSIVE_COLL) && ifp->if_opackets > 0) {\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: excessive collisions\\n\", sc->sc_dev.dv_xname));\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    RESTART_TX);\n\t\tifp->if_oerrors++;\n\t}\n\t\n\tif ((tx_status & TX_ABORT) && ifp->if_opackets > 0)\n\t\tifp->if_oerrors++;\n\nend:\n\t/* Reenable interrupts. */\n\tPAGE(sc, savedpage);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t    ENABLE_INT);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_MOHAWK\t0x001",
      "#define XED_INTR\t0x4",
      "#define MAX_BYTES_INTR 12000"
    ],
    "globals_used": [
      "int\txe_intr",
      "u_int16_t xe_get",
      "void\txe_start",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + CR",
            "ENABLE_INT"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "savedpage"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + CR",
            "RESTART_TX"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"%s: excessive collisions\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_start",
          "args": [
            "ifp"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "xe_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1110-1188",
          "snippet": "void\nxe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tunsigned int s, len, pad = 0;\n\tstruct mbuf *m0, *m;\n\tu_int16_t space;\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\t/* Peek at the next packet. */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif (!(m0->m_flags & M_PKTHDR))\n\t\tpanic(\"xe_start: no header mbuf\");\n\n\tlen = m0->m_pkthdr.len;\n\n\t/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */\n\tif (len < ETHER_MIN_LEN - ETHER_CRC_LEN)\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n\n\tspace = bus_space_read_2(bst, bsh, offset + TSO0) & 0x7fff;\n\tif (len + pad + 2 > space) {\n\t\tDPRINTF(XED_FIFO,\n\t\t    (\"%s: not enough space in output FIFO (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad + 2, space));\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\ts = splhigh();\n\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + TSO2, (u_int16_t)len + pad + 2);\n\tbus_space_write_2(bst, bsh, offset + EDP, (u_int16_t)len + pad);\n\tfor (m = m0; m; ) {\n\t\tif (m->m_len > 1)\n\t\t\tbus_space_write_raw_multi_2(bst, bsh, offset + EDP,\n\t\t\t    mtod(m, u_int8_t *), m->m_len & ~1);\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP,\n\t\t\t    *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + CR, TX_PKT | ENABLE_INT);\n\telse {\n\t\tfor (; pad > 1; pad -= 2)\n\t\t\tbus_space_write_2(bst, bsh, offset + EDP, 0);\n\t\tif (pad == 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP, 0);\n\t}\n\n\tsplx(s);\n\n\tifp->if_timer = 5;\n\t++ifp->if_opackets;\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MOHAWK\t0x001",
            "#define XED_FIFO\t0x8",
            "#define ETHER_CRC_LEN 4",
            "#define ETHER_MIN_LEN 64"
          ],
          "globals_used": [
            "void\txe_start",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n#define XED_FIFO\t0x8\n#define ETHER_CRC_LEN 4\n#define ETHER_MIN_LEN 64\n\nvoid\txe_start;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xe_softc *sc = ifp->if_softc;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\tunsigned int s, len, pad = 0;\n\tstruct mbuf *m0, *m;\n\tu_int16_t space;\n\n\t/* Don't transmit if interface is busy or not running. */\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\t/* Peek at the next packet. */\n\tm0 = ifp->if_snd.ifq_head;\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header. */\n\tif (!(m0->m_flags & M_PKTHDR))\n\t\tpanic(\"xe_start: no header mbuf\");\n\n\tlen = m0->m_pkthdr.len;\n\n\t/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */\n\tif (len < ETHER_MIN_LEN - ETHER_CRC_LEN)\n\t\tpad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;\n\n\tspace = bus_space_read_2(bst, bsh, offset + TSO0) & 0x7fff;\n\tif (len + pad + 2 > space) {\n\t\tDPRINTF(XED_FIFO,\n\t\t    (\"%s: not enough space in output FIFO (%d > %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, len + pad + 2, space));\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/*\n\t * Do the output at splhigh() so that an interrupt from another device\n\t * won't cause a FIFO underrun.\n\t */\n\ts = splhigh();\n\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + TSO2, (u_int16_t)len + pad + 2);\n\tbus_space_write_2(bst, bsh, offset + EDP, (u_int16_t)len + pad);\n\tfor (m = m0; m; ) {\n\t\tif (m->m_len > 1)\n\t\t\tbus_space_write_raw_multi_2(bst, bsh, offset + EDP,\n\t\t\t    mtod(m, u_int8_t *), m->m_len & ~1);\n\t\tif (m->m_len & 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP,\n\t\t\t    *(mtod(m, u_int8_t *) + m->m_len - 1));\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\tif (sc->sc_flags & XEF_MOHAWK)\n\t\tbus_space_write_1(bst, bsh, offset + CR, TX_PKT | ENABLE_INT);\n\telse {\n\t\tfor (; pad > 1; pad -= 2)\n\t\t\tbus_space_write_2(bst, bsh, offset + EDP, 0);\n\t\tif (pad == 1)\n\t\t\tbus_space_write_1(bst, bsh, offset + EDP, 0);\n\t}\n\n\tsplx(s);\n\n\tifp->if_timer = 5;\n\t++ifp->if_opackets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"overrun cleared\\n\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + CR",
            "CLR_RX_OVERRUN"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"%s: alignment error detected\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"%s: CRC error detected\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"%s: packet too long\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + RSR"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + ESR"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_get",
          "args": [
            "sc"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "xe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "771-863",
          "snippet": "u_int16_t\nxe_get(sc)\n\tstruct xe_softc *sc;\n{\n\tu_int8_t rsr;\n\tstruct mbuf *top, **mp, *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t pktlen, len, recvcount = 0;\n\tu_int8_t *data;\n\tstruct ether_header *eh;\n\t\n\tPAGE(sc, 0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\n\tpktlen =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RBC0) &\n\t    RBC_COUNT_MASK;\n\tif (pktlen == 0) {\n\t\t/*\n\t\t * XXX At least one CE2 sets RBC0 == 0 occasionally, and only\n\t\t * when MPE is set.  It is not known why.\n\t\t */\n\t\treturn (0);\n\t}\n\trecvcount += pktlen;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (recvcount);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\t\n\twhile (pktlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (pktlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (!(m->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tif (!top) {\n\t\t\tcaddr_t newdata = (caddr_t)ALIGN(m->m_data +\n\t\t\t    sizeof (struct ether_header)) -\n\t\t\t    sizeof (struct ether_header);\n\t\t\tlen -= newdata - m->m_data;\n\t\t\tm->m_data = newdata;\n\t\t}\n\t\tlen = min(pktlen, len);\n\n\t\tdata = mtod(m, u_int8_t *);\n\t\tif (len > 1) {\n\t\t        len &= ~1;\n\t\t\tbus_space_read_raw_multi_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP, data, len);\n\t\t} else\n\t\t\t*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP);\n\t\tm->m_len = len;\n\t\tpktlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\t/* Skip Rx packet. */\n\tbus_space_write_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + DO0,\n\t    DO_SKIP_RX_PKT);\n\t\n\tifp->if_ipackets++;\n\t\n\teh = mtod(top, struct ether_header *);\n\t\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\t\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn (recvcount);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t xe_get",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t xe_get;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nu_int16_t\nxe_get(sc)\n\tstruct xe_softc *sc;\n{\n\tu_int8_t rsr;\n\tstruct mbuf *top, **mp, *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int16_t pktlen, len, recvcount = 0;\n\tu_int8_t *data;\n\tstruct ether_header *eh;\n\t\n\tPAGE(sc, 0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\n\tpktlen =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RBC0) &\n\t    RBC_COUNT_MASK;\n\tif (pktlen == 0) {\n\t\t/*\n\t\t * XXX At least one CE2 sets RBC0 == 0 occasionally, and only\n\t\t * when MPE is set.  It is not known why.\n\t\t */\n\t\treturn (0);\n\t}\n\trecvcount += pktlen;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (recvcount);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = pktlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\t\n\twhile (pktlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (pktlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (!(m->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m);\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (recvcount);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tif (!top) {\n\t\t\tcaddr_t newdata = (caddr_t)ALIGN(m->m_data +\n\t\t\t    sizeof (struct ether_header)) -\n\t\t\t    sizeof (struct ether_header);\n\t\t\tlen -= newdata - m->m_data;\n\t\t\tm->m_data = newdata;\n\t\t}\n\t\tlen = min(pktlen, len);\n\n\t\tdata = mtod(m, u_int8_t *);\n\t\tif (len > 1) {\n\t\t        len &= ~1;\n\t\t\tbus_space_read_raw_multi_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP, data, len);\n\t\t} else\n\t\t\t*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + EDP);\n\t\tm->m_len = len;\n\t\tpktlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\t/* Skip Rx packet. */\n\tbus_space_write_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + DO0,\n\t    DO_SKIP_RX_PKT);\n\t\n\tifp->if_ipackets++;\n\t\n\teh = mtod(top, struct ether_header *);\n\t\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\t\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn (recvcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + DO0",
            "DO_SKIP_RX_PKT"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_INTR",
            "(\"%s: too many bytes this interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + TXST0"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + RXST0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "40"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: interrupt for dead card\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + RSR"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + ISR0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + ESR"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE",
          "args": [
            "sc",
            "0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + PR"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_bst",
            "sc->sc_bsh",
            "sc->sc_offset + CR",
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MOHAWK\t0x001\n#define XED_INTR\t0x4\n#define MAX_BYTES_INTR 12000\n\nint\txe_intr;\nu_int16_t xe_get;\nvoid\txe_start;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_intr(arg)\n\tvoid *arg;\n{\n\tstruct xe_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t esr, rsr, isr, rx_status, savedpage;\n\tu_int16_t tx_status, recvcount = 0, tempint;\n\n\tifp->if_timer = 0;\t/* turn watchdog timer off */\n\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\t/* Disable interrupt (Linux does it). */\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    0);\n\t}\n\n\tsavedpage =\n\t    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + PR);\n\n\tPAGE(sc, 0);\n\tesr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ESR);\n\tisr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ISR0);\n\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);\n\t\t\t\t\n\t/* Check to see if card has been ejected. */\n\tif (isr == 0xff) {\n\t\tprintf(\"%s: interrupt for dead card\\n\", sc->sc_dev.dv_xname);\n\t\tgoto end;\n\t}\n\n\tPAGE(sc, 40);\n\trx_status =\n\t    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RXST0);\n\ttx_status =\n\t    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + TXST0);\n\n\t/*\n\t * XXX Linux writes to RXST0 and TXST* here.  My CE2 works just fine\n\t * without it, and I can't see an obvious reason for it.\n\t */\n\n\tPAGE(sc, 0);\n\twhile (esr & FULL_PKT_RCV) {\n\t\tif (!(rsr & RSR_RX_OK))\n\t\t\tbreak;\n\n\t\t/* Compare bytes read this interrupt to hard maximum. */\n\t\tif (recvcount > MAX_BYTES_INTR) {\n\t\t\tDPRINTF(XED_INTR,\n\t\t\t    (\"%s: too many bytes this interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname));\n\t\t\tifp->if_iqdrops++;\n\t\t\t/* Drop packet. */\n\t\t\tbus_space_write_2(sc->sc_bst, sc->sc_bsh,\n\t\t\t    sc->sc_offset + DO0, DO_SKIP_RX_PKT);\n\t\t}\n\t\ttempint = xe_get(sc);\n\t\trecvcount += tempint;\n\t\tifp->if_ibytes += tempint;\n\t\tesr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t    sc->sc_offset + ESR);\n\t\trsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,\n\t\t    sc->sc_offset + RSR);\n\t}\n\t\n\t/* Packet too long? */\n\tif (rsr & RSR_TOO_LONG) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: packet too long\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* CRC error? */\n\tif (rsr & RSR_CRCERR) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: CRC error detected\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* Alignment error? */\n\tif (rsr & RSR_ALIGNERR) {\n\t\tifp->if_ierrors++;\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: alignment error detected\\n\", sc->sc_dev.dv_xname));\n\t}\n\n\t/* Check for rx overrun. */\n\tif (rx_status & RX_OVERRUN) {\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    CLR_RX_OVERRUN);\n\t\tDPRINTF(XED_INTR, (\"overrun cleared\\n\"));\n\t}\n\t\t\t\n\t/* Try to start more packets transmitting. */\n\tif (ifp->if_snd.ifq_head)\n\t\txe_start(ifp);\n\n\t/* Detected excessive collisions? */\n\tif ((tx_status & EXCESSIVE_COLL) && ifp->if_opackets > 0) {\n\t\tDPRINTF(XED_INTR,\n\t\t    (\"%s: excessive collisions\\n\", sc->sc_dev.dv_xname));\n\t\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t\t    RESTART_TX);\n\t\tifp->if_oerrors++;\n\t}\n\t\n\tif ((tx_status & TX_ABORT) && ifp->if_opackets > 0)\n\t\tifp->if_oerrors++;\n\nend:\n\t/* Reenable interrupts. */\n\tPAGE(sc, savedpage);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,\n\t    ENABLE_INT);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "xe_pcmcia_manfid_ciscallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "595-650",
    "snippet": "int\nxe_pcmcia_manfid_ciscallback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tu_int32_t *flagsp = arg;\n\tu_int8_t media, product;\n\n\tif (tuple->code == PCMCIA_CISTPL_MANFID) {\n\t\tif (tuple->length < 2)\n\t\t\treturn (0);\n\n\t\tmedia = pcmcia_tuple_read_1(tuple, 3);\n\t\tproduct = pcmcia_tuple_read_1(tuple, 4);\n\n\t\tif (!(product & XEPROD_CREDITCARD) ||\n\t\t    !(media & XEMEDIA_ETHER)) {\n\t\t\t*flagsp |= XEF_UNSUPPORTED;\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (media & XEMEDIA_MODEM)\n\t\t\t*flagsp |= XEF_MODEM;\n\n\t\tswitch (product & XEPROD_IDMASK) {\n\t\tcase 1:\n\t\t\t/* XXX Can be CE2 too (we double-check later). */\n\t\t\t*flagsp |= XEF_CE | XEF_UNSUPPORTED;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*flagsp |= XEF_CE2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (!(*flagsp & XEF_MODEM))\n\t\t\t\t*flagsp |= XEF_MOHAWK;\n\t\t\t*flagsp |= XEF_CE3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*flagsp |= XEF_CE33;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t*flagsp |= XEF_CE56 | XEF_MOHAWK;\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\t*flagsp |= XEF_CE56 | XEF_MOHAWK | XEF_DINGO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*flagsp |= XEF_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_CE56\t0x100",
      "#define XEF_CE33\t0x080",
      "#define XEF_CE3\t\t0x040",
      "#define XEF_CE2\t\t0x020",
      "#define XEF_CE\t\t0x010",
      "#define XEF_UNSUPPORTED 0x008",
      "#define XEF_MODEM\t0x004",
      "#define XEF_DINGO\t0x002",
      "#define XEF_MOHAWK\t0x001"
    ],
    "globals_used": [
      "int\txe_pcmcia_manfid_ciscallback",
      "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "4"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "3"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_CE56\t0x100\n#define XEF_CE33\t0x080\n#define XEF_CE3\t\t0x040\n#define XEF_CE2\t\t0x020\n#define XEF_CE\t\t0x010\n#define XEF_UNSUPPORTED 0x008\n#define XEF_MODEM\t0x004\n#define XEF_DINGO\t0x002\n#define XEF_MOHAWK\t0x001\n\nint\txe_pcmcia_manfid_ciscallback;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nint\nxe_pcmcia_manfid_ciscallback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tu_int32_t *flagsp = arg;\n\tu_int8_t media, product;\n\n\tif (tuple->code == PCMCIA_CISTPL_MANFID) {\n\t\tif (tuple->length < 2)\n\t\t\treturn (0);\n\n\t\tmedia = pcmcia_tuple_read_1(tuple, 3);\n\t\tproduct = pcmcia_tuple_read_1(tuple, 4);\n\n\t\tif (!(product & XEPROD_CREDITCARD) ||\n\t\t    !(media & XEMEDIA_ETHER)) {\n\t\t\t*flagsp |= XEF_UNSUPPORTED;\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (media & XEMEDIA_MODEM)\n\t\t\t*flagsp |= XEF_MODEM;\n\n\t\tswitch (product & XEPROD_IDMASK) {\n\t\tcase 1:\n\t\t\t/* XXX Can be CE2 too (we double-check later). */\n\t\t\t*flagsp |= XEF_CE | XEF_UNSUPPORTED;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*flagsp |= XEF_CE2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (!(*flagsp & XEF_MODEM))\n\t\t\t\t*flagsp |= XEF_MOHAWK;\n\t\t\t*flagsp |= XEF_CE3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*flagsp |= XEF_CE33;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t*flagsp |= XEF_CE56 | XEF_MOHAWK;\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\t*flagsp |= XEF_CE56 | XEF_MOHAWK | XEF_DINGO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*flagsp |= XEF_UNSUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "xe_pcmcia_interpret_manfid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "572-593",
    "snippet": "u_int32_t\nxe_pcmcia_interpret_manfid (parent)\n\tstruct device *parent;\n{\n\tu_int32_t flags = 0;\n\tstruct pcmcia_softc *psc = (struct pcmcia_softc *)parent;\n\tchar *tptr;\n\n\tif (!pcmcia_scan_cis(parent, xe_pcmcia_manfid_ciscallback, &flags))\n\t\treturn (XEF_UNSUPPORTED);\n\n\tif (flags & XEF_CE) {\n\t\ttptr = memchr(psc->card.cis1_info[2], 'C',\n\t\t    strlen(psc->card.cis1_info[2]));\n\t\t/* XXX not sure if other CE2s hide \"CE2\" in different places */\n\t\tif (tptr && *(tptr + 1) == 'E' && *(tptr + 2) == '2') {\n\t\t\tflags ^= (XEF_CE | XEF_UNSUPPORTED);\n\t\t\tflags |= XEF_CE2;\n\t\t}\n\t}\n\treturn (flags);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_CE2\t\t0x020",
      "#define XEF_CE\t\t0x010",
      "#define XEF_UNSUPPORTED 0x008"
    ],
    "globals_used": [
      "u_int32_t xe_pcmcia_interpret_manfid",
      "int\txe_pcmcia_manfid_ciscallback",
      "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "psc->card.cis1_info[2]",
            "'C'",
            "strlen(psc->card.cis1_info[2])"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "psc->card.cis1_info[2]"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_scan_cis",
          "args": [
            "parent",
            "xe_pcmcia_manfid_ciscallback",
            "&flags"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_scan_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "91-433",
          "snippet": "int\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCMCIA_CIS_SIZE\t\t1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCMCIA_CIS_SIZE\t\t1024\n\nint\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_CE2\t\t0x020\n#define XEF_CE\t\t0x010\n#define XEF_UNSUPPORTED 0x008\n\nu_int32_t xe_pcmcia_interpret_manfid;\nint\txe_pcmcia_manfid_ciscallback;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nu_int32_t\nxe_pcmcia_interpret_manfid (parent)\n\tstruct device *parent;\n{\n\tu_int32_t flags = 0;\n\tstruct pcmcia_softc *psc = (struct pcmcia_softc *)parent;\n\tchar *tptr;\n\n\tif (!pcmcia_scan_cis(parent, xe_pcmcia_manfid_ciscallback, &flags))\n\t\treturn (XEF_UNSUPPORTED);\n\n\tif (flags & XEF_CE) {\n\t\ttptr = memchr(psc->card.cis1_info[2], 'C',\n\t\t    strlen(psc->card.cis1_info[2]));\n\t\t/* XXX not sure if other CE2s hide \"CE2\" in different places */\n\t\tif (tptr && *(tptr + 1) == 'E' && *(tptr + 2) == '2') {\n\t\t\tflags ^= (XEF_CE | XEF_UNSUPPORTED);\n\t\t\tflags |= XEF_CE2;\n\t\t}\n\t}\n\treturn (flags);\n}"
  },
  {
    "function_name": "xe_pcmcia_lan_nid_ciscallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "526-570",
    "snippet": "int\nxe_pcmcia_lan_nid_ciscallback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tu_int8_t *myla = arg;\n\tint i;\n\n\tif (tuple->code == PCMCIA_CISTPL_FUNCE) {\n\t\tif (tuple->length < 2)\n\t\t\treturn (0);\n\n\t\tswitch (pcmcia_tuple_read_1(tuple, 0)) {\n\t\tcase PCMCIA_TPLFE_TYPE_LAN_NID:\n\t\t\tif (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN)\n\t\t\t\treturn (0);\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\t\t\t/*\n\t\t\t * Not sure about this, I don't have a CE2\n\t\t\t * that puts the ethernet addr here.\n\t\t\t */\n\t\t \tif (pcmcia_tuple_read_1(tuple, 1) != 13)\n\t\t\t\treturn (0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\tmyla[i] = pcmcia_tuple_read_1(tuple, i + 2);\n\t\treturn (1);\n\t}\n\n\t/* Yet another spot where this might be. */\n\tif (tuple->code == 0x89) {\n\t\tpcmcia_tuple_read_1(tuple, 1);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\tmyla[i] = pcmcia_tuple_read_1(tuple, i + 2);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_pcmcia_lan_nid_ciscallback"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "i + 2"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "i + 2"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "1"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_tuple_read_1",
          "args": [
            "tuple",
            "0"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_lan_nid_ciscallback;\n\nint\nxe_pcmcia_lan_nid_ciscallback(tuple, arg)\n\tstruct pcmcia_tuple *tuple;\n\tvoid *arg;\n{\n\tu_int8_t *myla = arg;\n\tint i;\n\n\tif (tuple->code == PCMCIA_CISTPL_FUNCE) {\n\t\tif (tuple->length < 2)\n\t\t\treturn (0);\n\n\t\tswitch (pcmcia_tuple_read_1(tuple, 0)) {\n\t\tcase PCMCIA_TPLFE_TYPE_LAN_NID:\n\t\t\tif (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN)\n\t\t\t\treturn (0);\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\t\t\t/*\n\t\t\t * Not sure about this, I don't have a CE2\n\t\t\t * that puts the ethernet addr here.\n\t\t\t */\n\t\t \tif (pcmcia_tuple_read_1(tuple, 1) != 13)\n\t\t\t\treturn (0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\tmyla[i] = pcmcia_tuple_read_1(tuple, i + 2);\n\t\treturn (1);\n\t}\n\n\t/* Yet another spot where this might be. */\n\tif (tuple->code == 0x89) {\n\t\tpcmcia_tuple_read_1(tuple, 1);\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\t\tmyla[i] = pcmcia_tuple_read_1(tuple, i + 2);\n\t\treturn (1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "xe_pcmcia_funce_enaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "517-524",
    "snippet": "int\nxe_pcmcia_funce_enaddr(parent, myla)\n\tstruct device *parent;\n\tu_int8_t *myla;\n{\n\t/* XXX The Linux driver has more ways to do this in case of failure. */\n\treturn (pcmcia_scan_cis(parent, xe_pcmcia_lan_nid_ciscallback, myla));\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_pcmcia_funce_enaddr",
      "int\txe_pcmcia_lan_nid_ciscallback"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_scan_cis",
          "args": [
            "parent",
            "xe_pcmcia_lan_nid_ciscallback",
            "myla"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_scan_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "91-433",
          "snippet": "int\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCMCIA_CIS_SIZE\t\t1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCMCIA_CIS_SIZE\t\t1024\n\nint\npcmcia_scan_cis(dev, fct, arg)\n\tstruct device *dev;\n\tint (*fct) __P((struct pcmcia_tuple *, void *));\n\tvoid *arg;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tpcmcia_chipset_tag_t pct;\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n\tstruct pcmcia_mem_handle pcmh;\n\tstruct pcmcia_tuple tuple;\n\tint longlink_present;\n\tint longlink_common;\n\tu_long longlink_addr;\n\tint mfc_count;\n\tint mfc_index;\n\tstruct {\n\t\tint\tcommon;\n\t\tu_long\taddr;\n\t} mfc[256 / 5];\n\tint ret;\n\n\tret = 0;\n\n\tpct = sc->pct;\n\tpch = sc->pch;\n\n\t/* allocate some memory */\n\n\tif (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't alloc memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\ttuple.memt = pcmh.memt;\n\ttuple.memh = pcmh.memh;\n\n\t/* initialize state for the primary tuple chain */\n\tif (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,\n\t    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {\n\t\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n#ifdef DIAGNOSTIC\n\t\tprintf(\"%s: can't map memory to read attributes\\n\",\n\t\t    sc->dev.dv_xname);\n#endif\n\t\treturn -1;\n\t}\n\tDPRINTF((\"cis mem map %x\\n\", (unsigned int) tuple.memh));\n\n\ttuple.mult = 2;\n\n\tlonglink_present = 1;\n\tlonglink_common = 1;\n\tlonglink_addr = 0;\n\n\tmfc_count = 0;\n\tmfc_index = 0;\n\n\tDPRINTF((\"%s: CIS tuple chain:\\n\", sc->dev.dv_xname));\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\t/* get the tuple code */\n\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\n\t\t\t/* two special-case tuples */\n\n\t\t\tif (tuple.code == PCMCIA_CISTPL_NULL) {\n\t\t\t\tDPRINTF((\"CISTPL_NONE\\n 00\\n\"));\n\t\t\t\ttuple.ptr++;\n\t\t\t\tcontinue;\n\t\t\t} else if (tuple.code == PCMCIA_CISTPL_END) {\n\t\t\t\tDPRINTF((\"CISTPL_END\\n ff\\n\"));\n\t\t\t\t/* Call the function for the END tuple, since\n\t\t\t\t   the CIS semantics depend on it */\n\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\tpcmcia_chip_mem_unmap(pct, pch,\n\t\t\t\t\t\t\t      window);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\ttuple.ptr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now all the normal tuples */\n\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tswitch (tuple.code) {\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_A:\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_C:\n\t\t\t\tif (tuple.length < 4) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s too \"\n\t\t\t\t\t    \"short %d\\n\",\n\t\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t\t    tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlonglink_present = 1;\n\t\t\t\tlonglink_common = (tuple.code ==\n\t\t\t\t    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;\n\t\t\t\tlonglink_addr = pcmcia_tuple_read_4(&tuple, 0);\n\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_%s %lx\\n\",\n\t\t\t\t    longlink_common ? \"C\" : \"A\",\n\t\t\t\t    longlink_addr));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_NO_LINK:\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tDPRINTF((\"CISTPL_NO_LINK\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_CHECKSUM:\n\t\t\t\tif (tuple.length < 5) {\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t} {\n\t\t\t\t\tint16_t offset;\n\t\t\t\t\tu_long addr, length;\n\t\t\t\t\tu_int cksum, sum;\n\t\t\t\t\tint i;\n\n\t\t\t\t\t*((u_int16_t *) & offset) =\n\t\t\t\t\t    pcmcia_tuple_read_2(&tuple, 0);\n\t\t\t\t\tlength = pcmcia_tuple_read_2(&tuple, 2);\n\t\t\t\t\tcksum = pcmcia_tuple_read_1(&tuple, 4);\n\n\t\t\t\t\taddr = tuple.ptr + offset;\n\n\t\t\t\t\tDPRINTF((\"CISTPL_CHECKSUM addr=%lx \"\n\t\t\t\t\t    \"len=%lx cksum=%x\",\n\t\t\t\t\t    addr, length, cksum));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX do more work to deal with\n\t\t\t\t\t * distant regions\n\t\t\t\t\t */\n\t\t\t\t\tif ((addr >= PCMCIA_CIS_SIZE) ||\n\t\t\t\t\t    ((addr + length) < 0) ||\n\t\t\t\t\t    ((addr + length) >=\n\t\t\t\t\t      PCMCIA_CIS_SIZE)) {\n\t\t\t\t\t\tDPRINTF((\" skipped, \"\n\t\t\t\t\t\t    \"too distant\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum = 0;\n\t\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\t\tsum +=\n\t\t\t\t\t\t    bus_space_read_1(tuple.memt,\n\t\t\t\t\t\t    tuple.memh,\n\t\t\t\t\t\t    addr + tuple.mult * i);\n\t\t\t\t\tif (cksum != (sum & 0xff)) {\n\t\t\t\t\t\tDPRINTF((\" failed sum=%x\\n\",\n\t\t\t\t\t\t    sum));\n\t\t\t\t\t\tprintf(\"%s: CIS checksum \"\n\t\t\t\t\t\t    \"failed\\n\",\n\t\t\t\t\t\t    sc->dev.dv_xname);\n#if 0\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX Some working cards have\n\t\t\t\t\t\t * XXX bad checksums!!\n\t\t\t\t\t\t */\n\t\t\t\t\t\tret = -1;\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDPRINTF((\" ok\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PCMCIA_CISTPL_LONGLINK_MFC:\n\t\t\t\tif (tuple.length < 1) {\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC too \"\n\t\t\t\t\t    \"short %d\\n\", tuple.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * this is kind of ad hoc, as I don't have\n\t\t\t\t * any real documentation\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tmfc_count =\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0);\n\t\t\t\t\tDPRINTF((\"CISTPL_LONGLINK_MFC %d\",\n\t\t\t\t\t    mfc_count));\n\t\t\t\t\tfor (i = 0; i < mfc_count; i++) {\n\t\t\t\t\t\tmfc[i].common =\n\t\t\t\t\t\t    (pcmcia_tuple_read_1(&tuple,\n\t\t\t\t\t\t    1 + 5 * i) ==\n\t\t\t\t\t\t    PCMCIA_MFC_MEM_COMMON) ?\n\t\t\t\t\t\t    1 : 0;\n\t\t\t\t\t\tmfc[i].addr =\n\t\t\t\t\t\t    pcmcia_tuple_read_4(&tuple,\n\t\t\t\t\t\t    1 + 5 * i + 1);\n\t\t\t\t\t\tDPRINTF((\" %s:%lx\",\n\t\t\t\t\t\t    mfc[i].common ? \"common\" :\n\t\t\t\t\t\t    \"attr\", mfc[i].addr));\n\t\t\t\t\t}\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * for LONGLINK_MFC, fall through to the\n\t\t\t\t * function.  This tuple has structural and\n\t\t\t\t * semantic content.\n\t\t\t\t */\n\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tif ((*fct) (&tuple, arg)) {\n\t\t\t\t\t\tpcmcia_chip_mem_unmap(pct,\n\t\t\t\t\t\t    pch, window);\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\t/* switch */\n#ifdef PCMCIACISDEBUG\n\t\t\t/* print the tuple */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\tDPRINTF((\" %02x %02x\", tuple.code,\n\t\t\t\t    tuple.length));\n\n\t\t\t\tfor (i = 0; i < tuple.length; i++) {\n\t\t\t\t\tDPRINTF((\" %02x\",\n\t\t\t\t\t    pcmcia_tuple_read_1(&tuple, i)));\n\t\t\t\t\tif ((i % 16) == 13)\n\t\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tif ((i % 16) != 14)\n\t\t\t\t\tDPRINTF((\"\\n\"));\n\t\t\t}\n#endif\n\t\t\t/* skip to the next tuple */\n\t\t\ttuple.ptr += 2 + tuple.length;\n\t\t}\n\n\t\t/*\n\t\t * the chain is done.  Clean up and move onto the next one,\n\t\t * if any.  The loop is here in the case that there is an MFC\n\t\t * card with no longlink (which defaults to existing, == 0).\n\t\t * In general, this means that if one pointer fails, it will\n\t\t * try the next one, instead of just bailing.\n\t\t */\n\n\t\twhile (1) {\n\t\t\tpcmcia_chip_mem_unmap(pct, pch, window);\n\n\t\t\tif (longlink_present) {\n\t\t\t\t/*\n\t\t\t\t * if the longlink is to attribute memory,\n\t\t\t\t * then it is unindexed.  That is, if the\n\t\t\t\t * link value is 0x100, then the actual\n\t\t\t\t * memory address is 0x200.  This means that\n\t\t\t\t * we need to multiply by 2 before calling\n\t\t\t\t * mem_map, and then divide the resulting ptr\n\t\t\t\t * by 2 after.\n\t\t\t\t */\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\tlonglink_addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch, longlink_common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    longlink_addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!longlink_common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\ttuple.mult = longlink_common ? 1 : 2;\n\t\t\t\tlonglink_present = 0;\n\t\t\t\tlonglink_common = 1;\n\t\t\t\tlonglink_addr = 0;\n\t\t\t} else if (mfc_count && (mfc_index < mfc_count)) {\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\tmfc[mfc_index].addr *= 2;\n\n\t\t\t\tpcmcia_chip_mem_map(pct, pch,\n\t\t\t\t    mfc[mfc_index].common ?\n\t\t\t\t    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,\n\t\t\t\t    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,\n\t\t\t\t    &pcmh, &tuple.ptr, &window);\n\n\t\t\t\tif (!mfc[mfc_index].common)\n\t\t\t\t\ttuple.ptr /= 2;\n\n\t\t\t\tDPRINTF((\"cis mem map %x\\n\",\n\t\t\t\t    (unsigned int) tuple.memh));\n\n\t\t\t\t/* set parse state, and point at the next one */\n\n\t\t\t\ttuple.mult = mfc[mfc_index].common ? 1 : 2;\n\n\t\t\t\tmfc_index++;\n\t\t\t} else {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* make sure that the link is valid */\n\t\t\ttuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);\n\t\t\tif (tuple.code != PCMCIA_CISTPL_LINKTARGET) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET expected, \"\n\t\t\t\t    \"code %02x observed\\n\", tuple.code));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);\n\t\t\tif (tuple.length < 3) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET too short %d\\n\",\n\t\t\t\t    tuple.length));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||\n\t\t\t    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {\n\t\t\t\tDPRINTF((\"CISTPL_LINKTARGET magic \"\n\t\t\t\t    \"%02x%02x%02x incorrect\\n\",\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 0),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 1),\n\t\t\t\t    pcmcia_tuple_read_1(&tuple, 2)));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttuple.ptr += 2 + tuple.length;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpcmcia_chip_mem_unmap(pct, pch, window);\n\ndone:\n\t/* Last, free the allocated memory block */\n\tpcmcia_chip_mem_free(pct, pch, &pcmh);\n\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_funce_enaddr;\nint\txe_pcmcia_lan_nid_ciscallback;\n\nint\nxe_pcmcia_funce_enaddr(parent, myla)\n\tstruct device *parent;\n\tu_int8_t *myla;\n{\n\t/* XXX The Linux driver has more ways to do this in case of failure. */\n\treturn (pcmcia_scan_cis(parent, xe_pcmcia_lan_nid_ciscallback, myla));\n}"
  },
  {
    "function_name": "xe_pcmcia_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "481-511",
    "snippet": "int\nxe_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct xe_pcmcia_softc *sc = (struct xe_pcmcia_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_xe.sc_arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_xe.sc_dev.dv_xname);\n\t\tsc->sc_xe.sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, xe_intr, sc);\n\t\tprintf(\"\\n\");\n\t\txe_init(&sc->sc_xe);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\txe_stop(&sc->sc_xe);\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_pcmcia_activate",
      "void\txe_init",
      "int\txe_intr",
      "void\txe_stop",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_xe.sc_ih"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_stop",
          "args": [
            "&sc->sc_xe"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "xe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1065-1083",
          "snippet": "void\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\txe_stop",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "&sc->sc_xe"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_NET",
            "xe_intr",
            "sc"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_activate;\nvoid\txe_init;\nint\txe_intr;\nvoid\txe_stop;\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct xe_pcmcia_softc *sc = (struct xe_pcmcia_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_xe.sc_arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_xe.sc_dev.dv_xname);\n\t\tsc->sc_xe.sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, xe_intr, sc);\n\t\tprintf(\"\\n\");\n\t\txe_init(&sc->sc_xe);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\txe_stop(&sc->sc_xe);\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "xe_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "457-479",
    "snippet": "int\nxe_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)dev;\n\tstruct xe_softc *sc = &psc->sc_xe;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mii_softc *msc;\n\tint rv = 0;\n\n\tfor (msc = LIST_FIRST(&sc->sc_mii.mii_phys); msc;\n\t    msc = LIST_FIRST(&sc->sc_mii.mii_phys))\n\t\trv |= mii_detach(msc, flags);\n\n\tpcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);\n\tpcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_pcmcia_detach",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_detach",
          "args": [
            "ifp"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifdetach",
          "args": [
            "ifp"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "psc->sc_pf",
            "&psc->sc_pcioh"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "psc->sc_pf",
            "psc->sc_io_window"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_detach",
          "args": [
            "msc",
            "flags"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "mii_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "124-134",
          "snippet": "int\nmii_detach(msc, flags)\n\tstruct mii_softc *msc;\n\tint flags;\n{\n\tLIST_REMOVE(msc, mii_list);\n\t/* XXX The following condition should always be true.  */\n\tif (msc->mii_inst == msc->mii_pdata->mii_instance - 1)\n\t\tmsc->mii_pdata->mii_instance--;\n\treturn config_detach(&msc->mii_dev, flags);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_detach(msc, flags)\n\tstruct mii_softc *msc;\n\tint flags;\n{\n\tLIST_REMOVE(msc, mii_list);\n\t/* XXX The following condition should always be true.  */\n\tif (msc->mii_inst == msc->mii_pdata->mii_instance - 1)\n\t\tmsc->mii_pdata->mii_instance--;\n\treturn config_detach(&msc->mii_dev, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_detach;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nint\nxe_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)dev;\n\tstruct xe_softc *sc = &psc->sc_xe;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mii_softc *msc;\n\tint rv = 0;\n\n\tfor (msc = LIST_FIRST(&sc->sc_mii.mii_phys); msc;\n\t    msc = LIST_FIRST(&sc->sc_mii.mii_phys))\n\t\trv |= mii_detach(msc, flags);\n\n\tpcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);\n\tpcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "xe_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "231-455",
    "snippet": "void\nxe_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)self;\n\tstruct xe_softc *sc = &psc->sc_xe;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_function *pf = pa->pf;\n\tstruct pcmcia_config_entry *cfe;\n\tstruct ifnet *ifp;\n\tu_int8_t myla[ETHER_ADDR_LEN], *enaddr = NULL;\n\tint state = 0;\n\tstruct pcmcia_mem_handle pcmh;\n\tint ccr_window;\n\tbus_addr_t ccr_offset;\n\n\n\tpsc->sc_pf = pf;\n\n#if 0\n\t/* Figure out what card we are. */\n\tsc->sc_flags = xe_pcmcia_interpret_manfid(parent);\n#endif\n\tif (sc->sc_flags & XEF_UNSUPPORTED) {\n\t\tprintf(\": card unsupported\\n\");\n\t\tgoto bad;\n\t}\n\n\t/* Tell the pcmcia framework where the CCR is. */\n\tpf->ccr_base = 0x800;\n\tpf->ccr_mask = 0x67;\n\n\t/* Fake a cfe. */\n\tSIMPLEQ_FIRST(&pa->pf->cfe_head) = cfe = (struct pcmcia_config_entry *)\n\t    malloc(sizeof *cfe, M_DEVBUF, M_NOWAIT);\n\tif (!cfe) {\n\t\tprintf(\": function enable failed\\n\");\n\t\treturn;\n\t}\n\tbzero(cfe, sizeof *cfe);\n\n\t/*\n\t * XXX Use preprocessor symbols instead.\n\t * Enable ethernet & its interrupts, wiring them to -INT\n\t * No I/O base.\n\t */\n\tcfe->number = 0x5;\n\tcfe->flags = 0;\t\t/* XXX Check! */\n\tcfe->iftype = PCMCIA_IFTYPE_IO;\n\tcfe->num_iospace = 0;\n\tcfe->num_memspace = 0;\n\tcfe->irqmask = 0x8eb0;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (pcmcia_function_enable(pa->pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tstate++;\n\n\tif (pcmcia_io_alloc(pa->pf, 0, 16, 16, &psc->sc_pcioh)) {\n\t\tprintf(\": io allocation failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tstate++;\n\n\tif (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, 0, 16, &psc->sc_pcioh,\n\t\t&psc->sc_io_window)) {\n\t\tprintf(\": can't map io space\\n\");\n\t\tgoto bad;\n\t}\n\tsc->sc_bst = psc->sc_pcioh.iot;\n\tsc->sc_bsh = psc->sc_pcioh.ioh;\n\tsc->sc_offset = 0;\n\n\tprintf(\" port 0x%lx/%d\", psc->sc_pcioh.addr, 16);\n\n#if 0\n\tif (pcmcia_mem_alloc(pf, 16, &psc->sc_pcmh)) {\n\t\tprintf(\": pcmcia memory allocation failed\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, 0x300, 16, &psc->sc_pcmh,\n\t    &sc->sc_offset, &psc->sc_mem_window)) {\n\t\tprintf(\": pcmcia memory mapping failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tsc->sc_bst = psc->sc_pcmh.memt;\n\tsc->sc_bsh = psc->sc_pcmh.memh;\n#endif\n\n\t/* Figure out what card we are. */\n\tsc->sc_flags = xe_pcmcia_interpret_manfid(parent);\n\n\t/*\n\t * Configuration as adviced by DINGO documentation.\n\t * We only know about this flag after the manfid interpretation.\n\t * Dingo has some extra configuration registers in the CCR space.\n\t */\n\tif (sc->sc_flags & XEF_DINGO) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE_DINGO, &pcmh)) {\n\t\t\tDPRINTF(XED_CONFIG, (\"bad mem alloc\\n\"));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE_DINGO, &pcmh, &ccr_offset,\n\t\t    &ccr_window)) {\n\t\t\tDPRINTF(XED_CONFIG, (\"bad mem map\\n\"));\n\t\t\tpcmcia_mem_free(pf, &pcmh);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR0, PCMCIA_CCR_DCOR0_SFINT);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR1,\n\t\t    PCMCIA_CCR_DCOR1_FORCE_LEVIREQ | PCMCIA_CCR_DCOR1_D6);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR2, 0);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR3, 0);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR4, 0);\n\n\t\t/* We don't need them anymore and can free them (I think). */\n\t\tpcmcia_mem_unmap(pf, ccr_window);\n\t\tpcmcia_mem_free(pf, &pcmh);\n\t}\n\n\t/*\n\t * Try to get the ethernet address from FUNCE/LAN_NID tuple.\n\t */\n\tif (xe_pcmcia_funce_enaddr(parent, myla))\n\t\tenaddr = myla;\n\tifp = &sc->sc_arpcom.ac_if;\n\tif (enaddr)\n\t\tbcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\telse {\n\t\tprintf(\", unable to get ethernet address\\n\");\n\t\tgoto bad;\n\t}\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_NOTRAILERS | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xe_ioctl;\n\tifp->if_start = xe_start;\n\tifp->if_watchdog = xe_watchdog;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Establish the interrupt. */\n\tsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\", couldn't establish interrupt\\n\");\n\t\tgoto bad;\n\t}\n\n\tprintf(\": address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Reset and initialize the card. */\n\txe_full_reset(sc);\n\n\t/* Initialize our media structures and probe the phy. */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = xe_mdi_read;\n\tsc->sc_mii.mii_writereg = xe_mdi_write;\n\tsc->sc_mii.mii_statchg = xe_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, xe_mediachange,\n\t    xe_mediastatus);\n\tDPRINTF(XED_MII | XED_CONFIG,\n\t    (\"bmsr %x\\n\", xe_mdi_read(&sc->sc_dev, 0, 1)));\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL)\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO, 0,\n\t\t    NULL);\n\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\t/* NBPFILTER > 0 */\n\n\t/*\n\t * Reset and initialize the card again for DINGO (as found in Linux\n\t * driver).  Without this Dingo will get a watchdog timeout the first\n\t * time.  The ugly media tickling seems to be necessary for getting\n\t * autonegotiation to work too.\n\t */\n\tif (sc->sc_flags & XEF_DINGO) {\n\t\txe_full_reset(sc);\n\t\txe_init(sc);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);\n\t\txe_stop(sc);\n\t}\n\n#ifdef notyet\n\tpcmcia_function_disable(pa->pf);\n#endif\t/* notyet */\n\n\treturn;\n\nbad:\n\tif (state > 2)\n\t\tpcmcia_io_unmap(pf, psc->sc_io_window);\n\tif (state > 1)\n\t\tpcmcia_io_free(pf, &psc->sc_pcioh);\n\tif (state > 0)\n\t\tpcmcia_function_disable(pa->pf);\n\tfree(cfe, M_DEVBUF);\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XEF_UNSUPPORTED 0x008",
      "#define XEF_DINGO\t0x002",
      "#define XED_MII\t\t0x2",
      "#define XED_CONFIG\t0x1"
    ],
    "globals_used": [
      "void\txe_pcmcia_attach",
      "void\txe_full_reset",
      "void\txe_init",
      "int\txe_intr",
      "int\txe_ioctl",
      "int\txe_mdi_read",
      "void\txe_mdi_write",
      "int\txe_mediachange",
      "void\txe_mediastatus",
      "int\txe_pcmcia_funce_enaddr",
      "u_int32_t xe_pcmcia_interpret_manfid",
      "void\txe_start",
      "void\txe_statchg",
      "void\txe_stop",
      "void\txe_watchdog",
      "xe_mdi_idle __P((struct xe_softc *));",
      "xe_mdi_pulse __P((struct xe_softc *, int));",
      "xe_mdi_probe __P((struct xe_softc *sc));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cfe",
            "M_DEVBUF"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ray_free_ccs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_ray.c",
          "lines": "2156-2172",
          "snippet": "u_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}",
          "includes": [
            "#include <dev/pcmcia/if_rayreg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_llc.h>",
            "#include <net/if_media.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/timeout.h>",
            "#include <sys/callout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define\tsc_xname\tsc_dev.dv_xname"
          ],
          "globals_used": [
            "u_int8_t ray_free_ccs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_rayreg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_ieee80211.h>\t/* here, since ETHER_ADDR_LEN is in netinet */\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_llc.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/timeout.h>\n#include <sys/callout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"opt_inet.h\"\n\n#define\tsc_xname\tsc_dev.dv_xname\n\nu_int8_t ray_free_ccs;\n\nu_int8_t\nray_free_ccs(sc, ccs)\n\tstruct ray_softc *sc;\n\tbus_size_t ccs;\n{\n\tu_int8_t stat;\n\n\tRAY_DPRINTF((\"%s: free_ccs idx %ld\\n\", sc->sc_xname,\n\t    RAY_GET_INDEX(ccs)));\n\n\tstat = SRAM_READ_FIELD_1(sc, ccs, ray_cmd, c_status);\n\tSRAM_WRITE_FIELD_1(sc, ccs, ray_cmd, c_status, RAY_CCS_STATUS_FREE);\n\tif (ccs <= RAY_GET_CCS(RAY_CCS_LAST))\n\t\tsc->sc_ccsinuse[RAY_GET_INDEX(ccs)] = 0;\n\n\treturn (stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "pa->pf"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "pf",
            "&psc->sc_pcioh"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "pf",
            "psc->sc_io_window"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_stop",
          "args": [
            "sc"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "xe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1065-1083",
          "snippet": "void\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\txe_stop",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\txe_stop;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_stop(sc)\n\tregister struct xe_softc *sc;\n{\n\t/* Disable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);\n\n\tPAGE(sc, 1);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);\n\t\n\t/* Power down, wait. */\n\tPAGE(sc, 4);\n\tbus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);\n\tDELAY(40000);\n\t\n\t/* Cancel watchdog timer. */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER | IFM_NONE"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER | IFM_AUTO"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_init",
          "args": [
            "sc"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "xe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1085-1104",
          "snippet": "void\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_CONFIG\t0x1"
          ],
          "globals_used": [
            "void\txe_init",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_CONFIG\t0x1\n\nvoid\txe_init;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_init(sc)\n\tstruct xe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\tDPRINTF(XED_CONFIG, (\"xe_init\\n\"));\n\n\ts = splimp();\n\n\txe_set_address(sc);\n\n\t/* Set current media. */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_full_reset",
          "args": [
            "sc"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "xe_full_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "1406-1555",
          "snippet": "void\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_MODEM\t0x004",
            "#define XEF_DINGO\t0x002",
            "#define XEF_MOHAWK\t0x001"
          ],
          "globals_used": [
            "void\txe_cycle_power",
            "void\txe_full_reset",
            "void\txe_set_address",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_MODEM\t0x004\n#define XEF_DINGO\t0x002\n#define XEF_MOHAWK\t0x001\n\nvoid\txe_cycle_power;\nvoid\txe_full_reset;\nvoid\txe_set_address;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_full_reset(sc)\n\tstruct xe_softc *sc;\n{\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tbus_addr_t offset = sc->sc_offset;\n\n\t/* Do an as extensive reset as possible on all functions. */\n\txe_cycle_power(sc);\n\tbus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);\n\tDELAY(20000);\n\tbus_space_write_1(bst, bsh, offset + CR, 0);\n\tDELAY(20000);\n\tif (sc->sc_flags & XEF_MOHAWK) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * Drive GP1 low to power up ML6692 and GP2 high to power up\n\t\t * the 10Mhz chip.  XXX What chip is that?  The phy?\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0,\n\t\t    GP1_OUT | GP2_OUT | GP2_WR);\n\t}\n\tDELAY(500000);\n\n\t/* Get revision information.  XXX Symbolic constants. */\n\tsc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &\n\t    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;\n\n\t/* Media selection.  XXX Maybe manual overriding too? */\n\tif (!(sc->sc_flags & XEF_MOHAWK)) {\n\t\tPAGE(sc, 4);\n\t\t/*\n\t\t * XXX I have no idea what this really does, it is from the\n\t\t * Linux driver.\n\t\t */\n\t\tbus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);\n\t}\n\tDELAY(40000);\n\n\t/* Setup the ethernet interrupt mask. */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0,\n\t    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */\n\t    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);\n#if 0\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n#endif\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n\n\t/*\n\t * Disable source insertion.\n\t * XXX Dingo does not have this bit, but Linux does it unconditionally.\n\t */\n\tif (!(sc->sc_flags & XEF_DINGO)) {\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC0, 0x20);\n\t}\n\n\t/* Set the local memory dividing line. */\n\tif (sc->sc_rev != 1) {\n\t\tPAGE(sc, 2);\n\t\t/* XXX Symbolic constant preferrable. */\n\t\tbus_space_write_2(bst, bsh, offset + RBS0, 0x2000);\n\t}\n\n\txe_set_address(sc);\n\n\t/*\n\t * Apparently the receive byte pointer can be bad after a reset, so\n\t * we hardwire it correctly.\n\t */\n\tPAGE(sc, 0);\n\tbus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);\n\n\t/* Setup ethernet MAC registers. XXX Symbolic constants. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + RX0MSK,\n\t    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);\n\tbus_space_write_1(bst, bsh, offset + TX0MSK,\n\t    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |\n\t    SQE | TX_ABORT | TX_OK);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX From Linux, dunno what 0xb0 means. */\n\t\tbus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);\n\tbus_space_write_1(bst, bsh, offset + RXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST0, 0);\n\tbus_space_write_1(bst, bsh, offset + TXST1, 0);\n\n\t/* Enable MII function if available. */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys)) {\n\t\tPAGE(sc, 2);\n\t\tbus_space_write_1(bst, bsh, offset + MSR,\n\t\t    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);\n\t\tDELAY(20000);\n\t} else {\n\t\tPAGE(sc, 0);\n\t\t\t\t\n\t\t/* XXX Do we need to do this? */\n\t\tPAGE(sc, 0x42);\n\t\tbus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);\n\t\tDELAY(50000);\n\n\t\t/* XXX Linux probes the media here. */\n\t}\n\n\t/* Configure the LED registers. */\n\tPAGE(sc, 2);\n\n\t/* XXX This is not good for 10base2. */\n\tbus_space_write_1(bst, bsh, offset + LED,\n\t    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);\n\tif (sc->sc_flags & XEF_DINGO)\n\t\tbus_space_write_1(bst, bsh, offset + LED3,\n\t\t    LED_100MB_LINK << LED3_SHIFT);\n\n\t/* Enable receiver and go online. */\n\tPAGE(sc, 0x40);\n\tbus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);\n\n#if 0\n\t/* XXX Linux does this here - is it necessary? */\n\tPAGE(sc, 1);\n\tbus_space_write_1(bst, bsh, offset + IMR0, 0xff);\n\tif (!(sc->sc_flags & XEF_DINGO))\n\t\t/* XXX What is this?  Not for Dingo at least. */\n\t\tbus_space_write_1(bst, bsh, offset + IMR1, 1);\n#endif\n\n       /* Enable interrupts. */\n\tPAGE(sc, 0);\n\tbus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);\n\n\t/* XXX This is pure magic for me, found in the Linux driver. */\n\tif ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {\n\t\tif ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)\n\t\t\t/* Unmask the master interrupt bit. */\n\t\t\tbus_space_write_1(bst, bsh, offset + 0x10, 0x11);\n\t}\n\n\t/*\n\t * The Linux driver says this:\n\t * We should switch back to page 0 to avoid a bug in revision 0\n\t * where regs with offset below 8 can't be read after an access\n\t * to the MAC registers.\n\t */\n\tPAGE(sc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER | IFM_AUTO"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER | IFM_AUTO",
            "0",
            "NULL"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "self",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_MII | XED_CONFIG",
            "(\"bmsr %x\\n\", xe_mdi_read(&sc->sc_dev, 0, 1))"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xe_mdi_read",
          "args": [
            "&sc->sc_dev",
            "0",
            "1"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "xe_mdi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "951-979",
          "snippet": "int\nxe_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\tu_int32_t mask;\n\tu_int32_t data = 0;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x06, 4); /* Start + Read opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_idle(sc);\t\t/* Turn around. */\n\txe_mdi_probe(sc);\t\t/* Drop initial zero bit. */\n\n\tfor (mask = 1 << 15; mask; mask >>= 1)\n\t\tif (xe_mdi_probe(sc))\n\t\t\tdata |= mask;\n\txe_mdi_idle(sc);\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_read: phy %d reg %d -> %x\\n\", phy, reg, data));\n\treturn (data);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XED_MII\t\t0x2"
          ],
          "globals_used": [
            "int\txe_mdi_read",
            "xe_mdi_idle __P((struct xe_softc *));",
            "xe_mdi_pulse __P((struct xe_softc *, int));",
            "xe_mdi_probe __P((struct xe_softc *sc));",
            "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XED_MII\t\t0x2\n\nint\txe_mdi_read;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nint\nxe_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct xe_softc *sc = (struct xe_softc *)self;\n\tint i;\n\tu_int32_t mask;\n\tu_int32_t data = 0;\n\n\tPAGE(sc, 2);\n\tfor (i = 0; i < 32; i++)\t/* Synchronize. */\n\t\txe_mdi_pulse(sc, 1);\n\txe_mdi_pulse_bits(sc, 0x06, 4); /* Start + Read opcode */\n\txe_mdi_pulse_bits(sc, phy, 5);\t/* PHY address */\n\txe_mdi_pulse_bits(sc, reg, 5);\t/* PHY register */\n\txe_mdi_idle(sc);\t\t/* Turn around. */\n\txe_mdi_probe(sc);\t\t/* Drop initial zero bit. */\n\n\tfor (mask = 1 << 15; mask; mask >>= 1)\n\t\tif (xe_mdi_probe(sc))\n\t\t\tdata |= mask;\n\txe_mdi_idle(sc);\n\n\tDPRINTF(XED_MII,\n\t    (\"xe_mdi_read: phy %d reg %d -> %x\\n\", phy, reg, data));\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_IMASK",
            "xe_mediachange",
            "xe_mediastatus"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": address %s\\n\"",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "pa->pf",
            "IPL_NET",
            "xe_intr",
            "sc"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_pcmcia_funce_enaddr",
          "args": [
            "parent",
            "myla"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xe_pcmcia_funce_enaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "517-524",
          "snippet": "int\nxe_pcmcia_funce_enaddr(parent, myla)\n\tstruct device *parent;\n\tu_int8_t *myla;\n{\n\t/* XXX The Linux driver has more ways to do this in case of failure. */\n\treturn (pcmcia_scan_cis(parent, xe_pcmcia_lan_nid_ciscallback, myla));\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\txe_pcmcia_funce_enaddr",
            "int\txe_pcmcia_lan_nid_ciscallback"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_funce_enaddr;\nint\txe_pcmcia_lan_nid_ciscallback;\n\nint\nxe_pcmcia_funce_enaddr(parent, myla)\n\tstruct device *parent;\n\tu_int8_t *myla;\n{\n\t/* XXX The Linux driver has more ways to do this in case of failure. */\n\treturn (pcmcia_scan_cis(parent, xe_pcmcia_lan_nid_ciscallback, myla));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "pf",
            "&pcmh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_unmap",
          "args": [
            "pf",
            "ccr_window"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2584-2601",
          "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pcmh.memt",
            "pcmh.memh",
            "ccr_offset + PCMCIA_CCR_DCOR4",
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pcmh.memt",
            "pcmh.memh",
            "ccr_offset + PCMCIA_CCR_DCOR3",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pcmh.memt",
            "pcmh.memh",
            "ccr_offset + PCMCIA_CCR_DCOR2",
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pcmh.memt",
            "pcmh.memh",
            "ccr_offset + PCMCIA_CCR_DCOR1",
            "PCMCIA_CCR_DCOR1_FORCE_LEVIREQ | PCMCIA_CCR_DCOR1_D6"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "pcmh.memt",
            "pcmh.memh",
            "ccr_offset + PCMCIA_CCR_DCOR0",
            "PCMCIA_CCR_DCOR0_SFINT"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_CONFIG",
            "(\"bad mem map\\n\")"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_map",
          "args": [
            "pf",
            "PCMCIA_MEM_ATTR",
            "pf->ccr_base",
            "PCMCIA_CCR_SIZE_DINGO",
            "&pcmh",
            "&ccr_offset",
            "&ccr_window"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2509-2575",
          "snippet": "STATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "XED_CONFIG",
            "(\"bad mem alloc\\n\")"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_alloc",
          "args": [
            "pf",
            "PCMCIA_CCR_SIZE_DINGO",
            "&pcmh"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2307-2373",
          "snippet": "STATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xe_pcmcia_interpret_manfid",
          "args": [
            "parent"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xe_pcmcia_interpret_manfid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
          "lines": "572-593",
          "snippet": "u_int32_t\nxe_pcmcia_interpret_manfid (parent)\n\tstruct device *parent;\n{\n\tu_int32_t flags = 0;\n\tstruct pcmcia_softc *psc = (struct pcmcia_softc *)parent;\n\tchar *tptr;\n\n\tif (!pcmcia_scan_cis(parent, xe_pcmcia_manfid_ciscallback, &flags))\n\t\treturn (XEF_UNSUPPORTED);\n\n\tif (flags & XEF_CE) {\n\t\ttptr = memchr(psc->card.cis1_info[2], 'C',\n\t\t    strlen(psc->card.cis1_info[2]));\n\t\t/* XXX not sure if other CE2s hide \"CE2\" in different places */\n\t\tif (tptr && *(tptr + 1) == 'E' && *(tptr + 2) == '2') {\n\t\t\tflags ^= (XEF_CE | XEF_UNSUPPORTED);\n\t\t\tflags |= XEF_CE2;\n\t\t}\n\t}\n\treturn (flags);\n}",
          "includes": [
            "#include <dev/pcmcia/if_xereg.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define XEF_CE2\t\t0x020",
            "#define XEF_CE\t\t0x010",
            "#define XEF_UNSUPPORTED 0x008"
          ],
          "globals_used": [
            "u_int32_t xe_pcmcia_interpret_manfid",
            "int\txe_pcmcia_manfid_ciscallback",
            "xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_CE2\t\t0x020\n#define XEF_CE\t\t0x010\n#define XEF_UNSUPPORTED 0x008\n\nu_int32_t xe_pcmcia_interpret_manfid;\nint\txe_pcmcia_manfid_ciscallback;\nxe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));\n\nu_int32_t\nxe_pcmcia_interpret_manfid (parent)\n\tstruct device *parent;\n{\n\tu_int32_t flags = 0;\n\tstruct pcmcia_softc *psc = (struct pcmcia_softc *)parent;\n\tchar *tptr;\n\n\tif (!pcmcia_scan_cis(parent, xe_pcmcia_manfid_ciscallback, &flags))\n\t\treturn (XEF_UNSUPPORTED);\n\n\tif (flags & XEF_CE) {\n\t\ttptr = memchr(psc->card.cis1_info[2], 'C',\n\t\t    strlen(psc->card.cis1_info[2]));\n\t\t/* XXX not sure if other CE2s hide \"CE2\" in different places */\n\t\tif (tptr && *(tptr + 1) == 'E' && *(tptr + 2) == '2') {\n\t\t\tflags ^= (XEF_CE | XEF_UNSUPPORTED);\n\t\t\tflags |= XEF_CE2;\n\t\t}\n\t}\n\treturn (flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_map",
          "args": [
            "pa->pf",
            "PCMCIA_WIDTH_IO16",
            "0",
            "16",
            "&psc->sc_pcioh",
            "&psc->sc_io_window"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "624-679",
          "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_alloc",
          "args": [
            "pa->pf",
            "0",
            "16",
            "16",
            "&psc->sc_pcioh"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1803-1863",
          "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "STATIC void",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "STATIC int",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "pa->pf"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "pa->pf",
            "cfe"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cfe",
            "sizeof *cfe"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *cfe",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pa->pf->cfe_head"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XEF_UNSUPPORTED 0x008\n#define XEF_DINGO\t0x002\n#define XED_MII\t\t0x2\n#define XED_CONFIG\t0x1\n\nvoid\txe_pcmcia_attach;\nvoid\txe_full_reset;\nvoid\txe_init;\nint\txe_intr;\nint\txe_ioctl;\nint\txe_mdi_read;\nvoid\txe_mdi_write;\nint\txe_mediachange;\nvoid\txe_mediastatus;\nint\txe_pcmcia_funce_enaddr;\nu_int32_t xe_pcmcia_interpret_manfid;\nvoid\txe_start;\nvoid\txe_statchg;\nvoid\txe_stop;\nvoid\txe_watchdog;\nxe_mdi_idle __P((struct xe_softc *));\nxe_mdi_pulse __P((struct xe_softc *, int));\nxe_mdi_probe __P((struct xe_softc *sc));\n\nvoid\nxe_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)self;\n\tstruct xe_softc *sc = &psc->sc_xe;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_function *pf = pa->pf;\n\tstruct pcmcia_config_entry *cfe;\n\tstruct ifnet *ifp;\n\tu_int8_t myla[ETHER_ADDR_LEN], *enaddr = NULL;\n\tint state = 0;\n\tstruct pcmcia_mem_handle pcmh;\n\tint ccr_window;\n\tbus_addr_t ccr_offset;\n\n\n\tpsc->sc_pf = pf;\n\n#if 0\n\t/* Figure out what card we are. */\n\tsc->sc_flags = xe_pcmcia_interpret_manfid(parent);\n#endif\n\tif (sc->sc_flags & XEF_UNSUPPORTED) {\n\t\tprintf(\": card unsupported\\n\");\n\t\tgoto bad;\n\t}\n\n\t/* Tell the pcmcia framework where the CCR is. */\n\tpf->ccr_base = 0x800;\n\tpf->ccr_mask = 0x67;\n\n\t/* Fake a cfe. */\n\tSIMPLEQ_FIRST(&pa->pf->cfe_head) = cfe = (struct pcmcia_config_entry *)\n\t    malloc(sizeof *cfe, M_DEVBUF, M_NOWAIT);\n\tif (!cfe) {\n\t\tprintf(\": function enable failed\\n\");\n\t\treturn;\n\t}\n\tbzero(cfe, sizeof *cfe);\n\n\t/*\n\t * XXX Use preprocessor symbols instead.\n\t * Enable ethernet & its interrupts, wiring them to -INT\n\t * No I/O base.\n\t */\n\tcfe->number = 0x5;\n\tcfe->flags = 0;\t\t/* XXX Check! */\n\tcfe->iftype = PCMCIA_IFTYPE_IO;\n\tcfe->num_iospace = 0;\n\tcfe->num_memspace = 0;\n\tcfe->irqmask = 0x8eb0;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (pcmcia_function_enable(pa->pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tstate++;\n\n\tif (pcmcia_io_alloc(pa->pf, 0, 16, 16, &psc->sc_pcioh)) {\n\t\tprintf(\": io allocation failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tstate++;\n\n\tif (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, 0, 16, &psc->sc_pcioh,\n\t\t&psc->sc_io_window)) {\n\t\tprintf(\": can't map io space\\n\");\n\t\tgoto bad;\n\t}\n\tsc->sc_bst = psc->sc_pcioh.iot;\n\tsc->sc_bsh = psc->sc_pcioh.ioh;\n\tsc->sc_offset = 0;\n\n\tprintf(\" port 0x%lx/%d\", psc->sc_pcioh.addr, 16);\n\n#if 0\n\tif (pcmcia_mem_alloc(pf, 16, &psc->sc_pcmh)) {\n\t\tprintf(\": pcmcia memory allocation failed\\n\");\n\t\tgoto bad;\n\t}\n\tstate++;\n\n\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, 0x300, 16, &psc->sc_pcmh,\n\t    &sc->sc_offset, &psc->sc_mem_window)) {\n\t\tprintf(\": pcmcia memory mapping failed\\n\");\n\t\tgoto bad;\n\t}\n\n\tsc->sc_bst = psc->sc_pcmh.memt;\n\tsc->sc_bsh = psc->sc_pcmh.memh;\n#endif\n\n\t/* Figure out what card we are. */\n\tsc->sc_flags = xe_pcmcia_interpret_manfid(parent);\n\n\t/*\n\t * Configuration as adviced by DINGO documentation.\n\t * We only know about this flag after the manfid interpretation.\n\t * Dingo has some extra configuration registers in the CCR space.\n\t */\n\tif (sc->sc_flags & XEF_DINGO) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE_DINGO, &pcmh)) {\n\t\t\tDPRINTF(XED_CONFIG, (\"bad mem alloc\\n\"));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE_DINGO, &pcmh, &ccr_offset,\n\t\t    &ccr_window)) {\n\t\t\tDPRINTF(XED_CONFIG, (\"bad mem map\\n\"));\n\t\t\tpcmcia_mem_free(pf, &pcmh);\n\t\t\tgoto bad;\n\t\t}\n\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR0, PCMCIA_CCR_DCOR0_SFINT);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR1,\n\t\t    PCMCIA_CCR_DCOR1_FORCE_LEVIREQ | PCMCIA_CCR_DCOR1_D6);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR2, 0);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR3, 0);\n\t\tbus_space_write_1(pcmh.memt, pcmh.memh,\n\t\t    ccr_offset + PCMCIA_CCR_DCOR4, 0);\n\n\t\t/* We don't need them anymore and can free them (I think). */\n\t\tpcmcia_mem_unmap(pf, ccr_window);\n\t\tpcmcia_mem_free(pf, &pcmh);\n\t}\n\n\t/*\n\t * Try to get the ethernet address from FUNCE/LAN_NID tuple.\n\t */\n\tif (xe_pcmcia_funce_enaddr(parent, myla))\n\t\tenaddr = myla;\n\tifp = &sc->sc_arpcom.ac_if;\n\tif (enaddr)\n\t\tbcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\telse {\n\t\tprintf(\", unable to get ethernet address\\n\");\n\t\tgoto bad;\n\t}\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_NOTRAILERS | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xe_ioctl;\n\tifp->if_start = xe_start;\n\tifp->if_watchdog = xe_watchdog;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Establish the interrupt. */\n\tsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\", couldn't establish interrupt\\n\");\n\t\tgoto bad;\n\t}\n\n\tprintf(\": address %s\\n\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Reset and initialize the card. */\n\txe_full_reset(sc);\n\n\t/* Initialize our media structures and probe the phy. */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = xe_mdi_read;\n\tsc->sc_mii.mii_writereg = xe_mdi_write;\n\tsc->sc_mii.mii_statchg = xe_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, xe_mediachange,\n\t    xe_mediastatus);\n\tDPRINTF(XED_MII | XED_CONFIG,\n\t    (\"bmsr %x\\n\", xe_mdi_read(&sc->sc_dev, 0, 1)));\n\tmii_phy_probe(self, &sc->sc_mii, 0xffffffff);\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL)\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO, 0,\n\t\t    NULL);\n\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\t/* NBPFILTER > 0 */\n\n\t/*\n\t * Reset and initialize the card again for DINGO (as found in Linux\n\t * driver).  Without this Dingo will get a watchdog timeout the first\n\t * time.  The ugly media tickling seems to be necessary for getting\n\t * autonegotiation to work too.\n\t */\n\tif (sc->sc_flags & XEF_DINGO) {\n\t\txe_full_reset(sc);\n\t\txe_init(sc);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);\n\t\txe_stop(sc);\n\t}\n\n#ifdef notyet\n\tpcmcia_function_disable(pa->pf);\n#endif\t/* notyet */\n\n\treturn;\n\nbad:\n\tif (state > 2)\n\t\tpcmcia_io_unmap(pf, psc->sc_io_window);\n\tif (state > 1)\n\t\tpcmcia_io_free(pf, &psc->sc_pcioh);\n\tif (state > 0)\n\t\tpcmcia_function_disable(pa->pf);\n\tfree(cfe, M_DEVBUF);\n}"
  },
  {
    "function_name": "xe_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_xe.c",
    "lines": "206-229",
    "snippet": "int\nxe_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\t\n\tif (pa->pf->function != PCMCIA_FUNCTION_NETWORK)\n\t\treturn (0);\n\n\tswitch (pa->manufacturer) {\n\tcase PCMCIA_VENDOR_COMPAQ:\n\tcase PCMCIA_VENDOR_COMPAQ2:\n\t\treturn (0);\n\n\tcase PCMCIA_VENDOR_INTEL:\n\tcase PCMCIA_VENDOR_XIRCOM:\n\t\t/* XXX Per-productid checking here. */\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (0);\n\t}\n}",
    "includes": [
      "#include <dev/pcmcia/if_xereg.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\txe_pcmcia_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pcmcia/if_xereg.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/mii/miivar.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\txe_pcmcia_match;\n\nint\nxe_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\t\n\tif (pa->pf->function != PCMCIA_FUNCTION_NETWORK)\n\t\treturn (0);\n\n\tswitch (pa->manufacturer) {\n\tcase PCMCIA_VENDOR_COMPAQ:\n\tcase PCMCIA_VENDOR_COMPAQ2:\n\t\treturn (0);\n\n\tcase PCMCIA_VENDOR_INTEL:\n\tcase PCMCIA_VENDOR_XIRCOM:\n\t\t/* XXX Per-productid checking here. */\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (0);\n\t}\n}"
  }
]