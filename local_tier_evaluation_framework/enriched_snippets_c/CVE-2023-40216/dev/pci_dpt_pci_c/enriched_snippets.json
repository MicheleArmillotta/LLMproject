[
  {
    "function_name": "dpt_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/dpt_pci.c",
    "lines": "101-163",
    "snippet": "void\ndpt_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa;\n\tstruct dpt_softc *sc;\n\tpci_chipset_tag_t pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\tpcireg_t csr;\n\n\tsc = (struct dpt_softc *)self;\n\tpa = (struct pci_attach_args *)aux;\n\tpc = pa->pa_pc;\n\tprintf(\": \");\n\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot, \n\t    &sc->sc_ioh, NULL, NULL)) {\n\t\tprintf(\"can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_dmat = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"can't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n#ifdef __NetBSD__\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, dpt_intr, sc);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, dpt_intr, sc,\n\t\t\t\t       sc->sc_dv.dv_xname);\n#endif /* __OpenBSD__ */\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"can't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/* Read the EATA configuration */\n\tif (dpt_readcfg(sc)) {\n\t\tprintf(\"%s: readcfg failed - see dpt(4)\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\t\n\t}\n\n\t/* Now attach to the bus-independant code */\n\tdpt_init(sc, intrstr);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/endian.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define\tPCI_CBIO\t0x10\t/* Configuration base I/O address */"
    ],
    "globals_used": [
      "void\tdpt_pci_attach",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_init",
          "args": [
            "sc",
            "intrstr"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_init_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "706-728",
          "snippet": "int\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: readcfg failed - see dpt(4)\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_readcfg",
          "args": [
            "sc"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_readcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "563-668",
          "snippet": "int\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\n\nint\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_BIO",
            "dpt_intr",
            "sc",
            "sc->sc_dv.dv_xname"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_BIO",
            "dpt_intr",
            "sc"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBIO",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&sc->sc_iot",
            "&sc->sc_ioh",
            "NULL",
            "NULL"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/endian.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define\tPCI_CBIO\t0x10\t/* Configuration base I/O address */\n\nvoid\tdpt_pci_attach;\nvoid *aux;\n\nvoid\ndpt_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa;\n\tstruct dpt_softc *sc;\n\tpci_chipset_tag_t pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\tpcireg_t csr;\n\n\tsc = (struct dpt_softc *)self;\n\tpa = (struct pci_attach_args *)aux;\n\tpc = pa->pa_pc;\n\tprintf(\": \");\n\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot, \n\t    &sc->sc_ioh, NULL, NULL)) {\n\t\tprintf(\"can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_dmat = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"can't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n#ifdef __NetBSD__\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, dpt_intr, sc);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, dpt_intr, sc,\n\t\t\t\t       sc->sc_dv.dv_xname);\n#endif /* __OpenBSD__ */\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"can't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/* Read the EATA configuration */\n\tif (dpt_readcfg(sc)) {\n\t\tprintf(\"%s: readcfg failed - see dpt(4)\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\t\n\t}\n\n\t/* Now attach to the bus-independant code */\n\tdpt_init(sc, intrstr);\n}"
  }
]