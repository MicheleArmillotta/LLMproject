[
  {
    "function_name": "wsmouse_rem_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "662-674",
    "snippet": "int\nwsmouse_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_detach_sc",
          "args": [
            "muxsc",
            "&sc->sc_dv"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouse_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
  },
  {
    "function_name": "wsmouse_add_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "644-660",
    "snippet": "int\nwsmouse_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmouse_muxops));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_attach_sc",
          "args": [
            "muxsc",
            "WSMUX_KBD",
            "&sc->sc_dv",
            "&sc->sc_events",
            "&sc->sc_mux",
            "&wsmouse_muxops"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouse_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmouse_muxops));\n}"
  },
  {
    "function_name": "wsmouseselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "628-641",
    "snippet": "int\nwsmouseselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n#else\n\treturn (0);\n#endif /* NWSMOUSE > 0 */\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_poll",
          "args": [
            "&sc->sc_events",
            "events",
            "p"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "183-201",
          "snippet": "int\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouseselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n#else\n\treturn (0);\n#endif /* NWSMOUSE > 0 */\n}"
  },
  {
    "function_name": "wsmouse_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "588-625",
    "snippet": "int\nwsmouse_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wsmouse_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/*\n\t * Try the generic ioctls that the wsmouse interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,\n\t    data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmouse_do_ioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_do_ioctl;\n\nint\nwsmouse_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wsmouse_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/*\n\t * Try the generic ioctls that the wsmouse interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,\n\t    data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}"
  },
  {
    "function_name": "wsmousedoioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "570-586",
    "snippet": "int\nwsmousedoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wsmouse_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmouse_do_ioctl",
      "int\twsmousedoioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmouse_do_ioctl",
          "args": [
            "sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "wsmouse_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
          "lines": "588-625",
          "snippet": "int\nwsmouse_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wsmouse_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/*\n\t * Try the generic ioctls that the wsmouse interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,\n\t    data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\"",
            "#include \"wsmouse.h\"",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsmousevar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\twsmouse_do_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_do_ioctl;\n\nint\nwsmouse_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wsmouse_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/*\n\t * Try the generic ioctls that the wsmouse interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,\n\t    data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_do_ioctl;\nint\twsmousedoioctl;\n\nint\nwsmousedoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wsmouse_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}"
  },
  {
    "function_name": "wsmouseioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "552-566",
    "snippet": "int\nwsmouseioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\treturn (wsmousedoioctl(wsmouse_cd.cd_devs[minor(dev)],\n\t\t\t       cmd, data, flag, p));\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmousedoioctl",
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmousedoioctl",
          "args": [
            "wsmouse_cd.cd_devs[minor(dev)]",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "wsmousedoioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
          "lines": "570-586",
          "snippet": "int\nwsmousedoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wsmouse_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\"",
            "#include \"wsmouse.h\"",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsmousevar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\twsmouse_do_ioctl",
            "int\twsmousedoioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_do_ioctl;\nint\twsmousedoioctl;\n\nint\nwsmousedoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wsmouse_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmousedoioctl;\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouseioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\treturn (wsmousedoioctl(wsmouse_cd.cd_devs[minor(dev)],\n\t\t\t       cmd, data, flag, p));\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}"
  },
  {
    "function_name": "wsmouseread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "527-550",
    "snippet": "int\nwsmouseread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = wsevent_read(&sc->sc_events, uio, flags);\n\tif (--sc->sc_refcnt < 0) {\n\t\twakeup(sc);\n\t\terror = EIO;\n\t}\n\treturn (error);\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsevent_read",
          "args": [
            "&sc->sc_events",
            "uio",
            "flags"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "125-181",
          "snippet": "int\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouseread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = wsevent_read(&sc->sc_events, uio, flags);\n\tif (--sc->sc_refcnt < 0) {\n\t\twakeup(sc);\n\t\terror = EIO;\n\t}\n\treturn (error);\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}"
  },
  {
    "function_name": "wsmousedoclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "507-524",
    "snippet": "int\nwsmousedoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* see wsmouseopen() */\n\n\t(*sc->sc_accessops->disable)(sc->sc_accesscookie);\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmousedoclose"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_fini",
          "args": [
            "&sc->sc_events"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "113-119",
          "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmousedoclose;\n\nint\nwsmousedoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* see wsmouseopen() */\n\n\t(*sc->sc_accessops->disable)(sc->sc_accesscookie);\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmouseclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "492-504",
    "snippet": "int\nwsmouseclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\treturn (wsmousedoclose(wsmouse_cd.cd_devs[minor(dev)], \n\t\t\t       flags, mode, p));\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmousedoclose",
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmousedoclose",
          "args": [
            "wsmouse_cd.cd_devs[minor(dev)]",
            "flags",
            "mode",
            "p"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "wsmousedoclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
          "lines": "507-524",
          "snippet": "int\nwsmousedoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* see wsmouseopen() */\n\n\t(*sc->sc_accessops->disable)(sc->sc_accesscookie);\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\"",
            "#include \"wsmouse.h\"",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsmousevar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\twsmousedoclose"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmousedoclose;\n\nint\nwsmousedoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)dv;\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* see wsmouseopen() */\n\n\t(*sc->sc_accessops->disable)(sc->sc_accesscookie);\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmousedoclose;\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouseclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\treturn (wsmousedoclose(wsmouse_cd.cd_devs[minor(dev)], \n\t\t\t       flags, mode, p));\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}"
  },
  {
    "function_name": "wsmouseopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "439-490",
    "snippet": "int\nwsmouseopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc;\n\tint error, unit;\n\n\tunit = minor(dev);\n\tif (unit >= wsmouse_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* always allow open for write\n\t\t\t\t\t\t   so ioctl() is possible. */\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\treturn (EBUSY);\n#endif\n\n\tif (sc->sc_events.io)\t\t\t/* and that it's not in use */\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tsc->sc_ready = 1;\t\t\t/* start accepting events */\n\tsc->sc_x = INVALID_X;\n\tsc->sc_y = INVALID_Y;\n\tsc->sc_z = INVALID_Z;\n\n\t/* enable the device, and punt if that's not possible */\n\terror = (*sc->sc_accessops->enable)(sc->sc_accesscookie);\n\tif (error) {\n\t\tsc->sc_ready = 0;\t\t/* stop accepting events */\n\t\twsevent_fini(&sc->sc_events);\n\t\tsc->sc_events.io = NULL;\n\t\treturn (error);\n\t}\n\n\treturn (0);\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define\tINVALID_Z\tINT_MAX",
      "#define\tINVALID_Y\tINT_MAX",
      "#define\tINVALID_X\tINT_MAX"
    ],
    "globals_used": [
      "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_fini",
          "args": [
            "&sc->sc_events"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "113-119",
          "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsevent_init",
          "args": [
            "&sc->sc_events"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "99-108",
          "snippet": "void\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define\tINVALID_Z\tINT_MAX\n#define\tINVALID_Y\tINT_MAX\n#define\tINVALID_X\tINT_MAX\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouseopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n#if NWSMOUSE > 0\n\tstruct wsmouse_softc *sc;\n\tint error, unit;\n\n\tunit = minor(dev);\n\tif (unit >= wsmouse_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif ((flags & (FREAD | FWRITE)) == FWRITE)\n\t\treturn (0);\t\t\t/* always allow open for write\n\t\t\t\t\t\t   so ioctl() is possible. */\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\treturn (EBUSY);\n#endif\n\n\tif (sc->sc_events.io)\t\t\t/* and that it's not in use */\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tsc->sc_ready = 1;\t\t\t/* start accepting events */\n\tsc->sc_x = INVALID_X;\n\tsc->sc_y = INVALID_Y;\n\tsc->sc_z = INVALID_Z;\n\n\t/* enable the device, and punt if that's not possible */\n\terror = (*sc->sc_accessops->enable)(sc->sc_accesscookie);\n\tif (error) {\n\t\tsc->sc_ready = 0;\t\t/* stop accepting events */\n\t\twsevent_fini(&sc->sc_events);\n\t\tsc->sc_events.io = NULL;\n\t\treturn (error);\n\t}\n\n\treturn (0);\n#else\n\treturn (ENXIO);\n#endif /* NWSMOUSE > 0 */\n}"
  },
  {
    "function_name": "wsmouse_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "286-437",
    "snippet": "void\nwsmouse_input(wsmousedev, btns, x, y, z, flags)\n\tstruct device *wsmousedev;\n\tu_int btns;\t\t\t/* 0 is up */\n\tint x, y, z;\n\tu_int flags;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)wsmousedev;\n\tstruct wscons_event *ev;\n\tstruct wseventvar *evar;\n\tint mb, ub, d, get, put, any;\n\n        /*\n         * Discard input if not ready.\n         */\n\tif (sc->sc_ready == 0)\n\t\treturn;\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\tevar = &sc->sc_mux->sc_events;\n\telse\n#endif\n\t\tevar = &sc->sc_events;\n\n\tsc->sc_mb = btns;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_X))\n\t\tsc->sc_dx += x;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_Y))\n\t\tsc->sc_dy += y;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_Z))\n\t\tsc->sc_dz += z;\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = evar->get;\n\tput = evar->put;\n\tev = &evar->q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT\t\t\t\t\t\t\t\t\\\n\tif ((++put) % WSEVENT_QSIZE == get) {\t\t\t\t\\\n\t\tput--;\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE\t\t\t\t\t\t\t\t\\\n\tev++;\t\t\t\t\t\t\t\t\\\n\tif (put >= WSEVENT_QSIZE) {\t\t\t\t\t\\\n\t\tput = 0;\t\t\t\t\t\t\\\n\t\tev = &evar->q[0];\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tany = 1\n\t/* TIMESTAMP sets `time' field of the event to the current time */\n#define TIMESTAMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint s;\t\t\t\t\t\t\t\\\n\t\ts = splhigh();\t\t\t\t\t\t\\\n\t\tTIMEVAL_TO_TIMESPEC(&time, &ev->time);\t\t\t\\\n\t\tsplx(s);\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_X) {\n\t\tif (sc->sc_x != x) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_X;\n\t\t\tev->value = x;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_x = x;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dx) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_X;\n\t\t\tev->value = sc->sc_dx;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dx = 0;\n\t\t}\n\t}\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_Y) {\n\t\tif (sc->sc_y != y) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Y;\n\t\t\tev->value = y;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_y = y;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dy) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_Y;\n\t\t\tev->value = sc->sc_dy;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dy = 0;\n\t\t}\n\t}\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_Z) {\n\t\tif (sc->sc_z != z) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Z;\n\t\t\tev->value = z;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_z = z;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dz) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_Z;\n\t\t\tev->value = sc->sc_dz;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dz = 0;\n\t\t}\n\t}\n\n\tmb = sc->sc_mb;\n\tub = sc->sc_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Find the first change and drop\n\t\t * it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\tev->value = ffs(d) - 1;\n\n\t\tKASSERT(ev->value >= 0);\n\n\t\td = 1 << ev->value;\n\t\tev->type =\n\t\t    (mb & d) ? WSCONS_EVENT_MOUSE_DOWN : WSCONS_EVENT_MOUSE_UP;\n\t\tTIMESTAMP;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\nout:\n\tif (any) {\n\t\tsc->sc_ub = ub;\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define TIMESTAMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint s;\t\t\t\t\t\t\t\\\n\t\ts = splhigh();\t\t\t\t\t\t\\\n\t\tTIMEVAL_TO_TIMESPEC(&time, &ev->time);\t\t\t\\\n\t\tsplx(s);\t\t\t\t\t\t\\\n\t} while (0)",
      "#define\tADVANCE\t\t\t\t\t\t\t\t\\\n\tev++;\t\t\t\t\t\t\t\t\\\n\tif (put >= WSEVENT_QSIZE) {\t\t\t\t\t\\\n\t\tput = 0;\t\t\t\t\t\t\\\n\t\tev = &evar->q[0];\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tany = 1",
      "#define\tNEXT\t\t\t\t\t\t\t\t\\\n\tif ((++put) % WSEVENT_QSIZE == get) {\t\t\t\t\\\n\t\tput--;\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSEVENT_WAKEUP",
          "args": [
            "evar"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "ev->value >= 0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "d"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define TIMESTAMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint s;\t\t\t\t\t\t\t\\\n\t\ts = splhigh();\t\t\t\t\t\t\\\n\t\tTIMEVAL_TO_TIMESPEC(&time, &ev->time);\t\t\t\\\n\t\tsplx(s);\t\t\t\t\t\t\\\n\t} while (0)\n#define\tADVANCE\t\t\t\t\t\t\t\t\\\n\tev++;\t\t\t\t\t\t\t\t\\\n\tif (put >= WSEVENT_QSIZE) {\t\t\t\t\t\\\n\t\tput = 0;\t\t\t\t\t\t\\\n\t\tev = &evar->q[0];\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tany = 1\n#define\tNEXT\t\t\t\t\t\t\t\t\\\n\tif ((++put) % WSEVENT_QSIZE == get) {\t\t\t\t\\\n\t\tput--;\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\n\nvoid\nwsmouse_input(wsmousedev, btns, x, y, z, flags)\n\tstruct device *wsmousedev;\n\tu_int btns;\t\t\t/* 0 is up */\n\tint x, y, z;\n\tu_int flags;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)wsmousedev;\n\tstruct wscons_event *ev;\n\tstruct wseventvar *evar;\n\tint mb, ub, d, get, put, any;\n\n        /*\n         * Discard input if not ready.\n         */\n\tif (sc->sc_ready == 0)\n\t\treturn;\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\tevar = &sc->sc_mux->sc_events;\n\telse\n#endif\n\t\tevar = &sc->sc_events;\n\n\tsc->sc_mb = btns;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_X))\n\t\tsc->sc_dx += x;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_Y))\n\t\tsc->sc_dy += y;\n\tif (!(flags & WSMOUSE_INPUT_ABSOLUTE_Z))\n\t\tsc->sc_dz += z;\n\n\t/*\n\t * We have at least one event (mouse button, delta-X, or\n\t * delta-Y; possibly all three, and possibly three separate\n\t * button events).  Deliver these events until we are out\n\t * of changes or out of room.  As events get delivered,\n\t * mark them `unchanged'.\n\t */\n\tany = 0;\n\tget = evar->get;\n\tput = evar->put;\n\tev = &evar->q[put];\n\n\t/* NEXT prepares to put the next event, backing off if necessary */\n#define\tNEXT\t\t\t\t\t\t\t\t\\\n\tif ((++put) % WSEVENT_QSIZE == get) {\t\t\t\t\\\n\t\tput--;\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\n\t/* ADVANCE completes the `put' of the event */\n#define\tADVANCE\t\t\t\t\t\t\t\t\\\n\tev++;\t\t\t\t\t\t\t\t\\\n\tif (put >= WSEVENT_QSIZE) {\t\t\t\t\t\\\n\t\tput = 0;\t\t\t\t\t\t\\\n\t\tev = &evar->q[0];\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tany = 1\n\t/* TIMESTAMP sets `time' field of the event to the current time */\n#define TIMESTAMP\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint s;\t\t\t\t\t\t\t\\\n\t\ts = splhigh();\t\t\t\t\t\t\\\n\t\tTIMEVAL_TO_TIMESPEC(&time, &ev->time);\t\t\t\\\n\t\tsplx(s);\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_X) {\n\t\tif (sc->sc_x != x) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_X;\n\t\t\tev->value = x;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_x = x;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dx) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_X;\n\t\t\tev->value = sc->sc_dx;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dx = 0;\n\t\t}\n\t}\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_Y) {\n\t\tif (sc->sc_y != y) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Y;\n\t\t\tev->value = y;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_y = y;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dy) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_Y;\n\t\t\tev->value = sc->sc_dy;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dy = 0;\n\t\t}\n\t}\n\tif (flags & WSMOUSE_INPUT_ABSOLUTE_Z) {\n\t\tif (sc->sc_z != z) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Z;\n\t\t\tev->value = z;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_z = z;\n\t\t}\n\t} else {\n\t\tif (sc->sc_dz) {\n\t\t\tNEXT;\n\t\t\tev->type = WSCONS_EVENT_MOUSE_DELTA_Z;\n\t\t\tev->value = sc->sc_dz;\n\t\t\tTIMESTAMP;\n\t\t\tADVANCE;\n\t\t\tsc->sc_dz = 0;\n\t\t}\n\t}\n\n\tmb = sc->sc_mb;\n\tub = sc->sc_ub;\n\twhile ((d = mb ^ ub) != 0) {\n\t\t/*\n\t\t * Mouse button change.  Find the first change and drop\n\t\t * it into the event queue.\n\t\t */\n\t\tNEXT;\n\t\tev->value = ffs(d) - 1;\n\n\t\tKASSERT(ev->value >= 0);\n\n\t\td = 1 << ev->value;\n\t\tev->type =\n\t\t    (mb & d) ? WSCONS_EVENT_MOUSE_DOWN : WSCONS_EVENT_MOUSE_UP;\n\t\tTIMESTAMP;\n\t\tADVANCE;\n\t\tub ^= d;\n\t}\nout:\n\tif (any) {\n\t\tsc->sc_ub = ub;\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t}\n}"
  },
  {
    "function_name": "wsmouse_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "237-284",
    "snippet": "int\nwsmouse_detach(self, flags)\n\tstruct device  *self;\n\tint flags;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)self;\n\tstruct wseventvar *evar;\n\tint maj, mn;\n\tint s;\n#if NWSMUX > 0\n\tint mux;\n#endif\n\n\tsc->sc_dying = 1;\n\n#if NWSMUX > 0\n\tmux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT)\n\t\twsmux_detach(mux, &sc->sc_dv);\n#endif\n\n\tevar = &sc->sc_events;\n\tif (evar->io) {\n\t\ts = spltty();\n\t\tif (--sc->sc_refcnt >= 0) {\n\t\t\t/* Wake everyone by generating a dummy event. */\n\t\t\tif (++evar->put >= WSEVENT_QSIZE)\n\t\t\t\tevar->put = 0;\n\t\t\tWSEVENT_WAKEUP(evar);\n\t\t\t/* Wait for processes to go away. */\n\t\t\tif (tsleep(sc, PZERO, \"wsmdet\", hz * 60))\n\t\t\t\tprintf(\"wsmouse_detach: %s didn't detach\\n\",\n\t\t\t\t       sc->sc_dv.dv_xname);\n\t\t}\n\t\tsplx(s);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsmouseopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances (calls close). */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmouse_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdevgone",
          "args": [
            "maj",
            "mn",
            "mn",
            "VCHR"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsmouse_detach: %s didn't detach\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "PZERO",
            "\"wsmdet\"",
            "hz * 60"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSEVENT_WAKEUP",
          "args": [
            "evar"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_detach",
          "args": [
            "mux",
            "&sc->sc_dv"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_detach;\n\nint\nwsmouse_detach(self, flags)\n\tstruct device  *self;\n\tint flags;\n{\n\tstruct wsmouse_softc *sc = (struct wsmouse_softc *)self;\n\tstruct wseventvar *evar;\n\tint maj, mn;\n\tint s;\n#if NWSMUX > 0\n\tint mux;\n#endif\n\n\tsc->sc_dying = 1;\n\n#if NWSMUX > 0\n\tmux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT)\n\t\twsmux_detach(mux, &sc->sc_dv);\n#endif\n\n\tevar = &sc->sc_events;\n\tif (evar->io) {\n\t\ts = spltty();\n\t\tif (--sc->sc_refcnt >= 0) {\n\t\t\t/* Wake everyone by generating a dummy event. */\n\t\t\tif (++evar->put >= WSEVENT_QSIZE)\n\t\t\t\tevar->put = 0;\n\t\t\tWSEVENT_WAKEUP(evar);\n\t\t\t/* Wait for processes to go away. */\n\t\t\tif (tsleep(sc, PZERO, \"wsmdet\", hz * 60))\n\t\t\t\tprintf(\"wsmouse_detach: %s didn't detach\\n\",\n\t\t\t\t       sc->sc_dv.dv_xname);\n\t\t}\n\t\tsplx(s);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsmouseopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances (calls close). */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmouse_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "220-227",
    "snippet": "int\nwsmouse_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\t/* XXX should we do something more? */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmouse_activate"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_activate;\n\nint\nwsmouse_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\t/* XXX should we do something more? */\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmouse_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "193-218",
    "snippet": "void\nwsmouse_attach(parent, self, aux)\n        struct device *parent, *self;\n\tvoid *aux;\n{\n        struct wsmouse_softc *sc = (struct wsmouse_softc *)self;\n\tstruct wsmousedev_attach_args *ap = aux;\n#if NWSMUX > 0\n\tint mux;\n#endif\n\n\tsc->sc_accessops = ap->accessops;\n\tsc->sc_accesscookie = ap->accesscookie;\n\tsc->sc_ready = 0;\t\t\t\t/* sanity */\n\n#if NWSMUX > 0\n\tmux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT) {\n\t\twsmux_attach(mux, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events,\n\t\t\t     &sc->sc_mux, &wsmouse_muxops);\n\t\tprintf(\" mux %d\", mux);\n\t}\n#endif\n\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\twsmouse_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmux_attach",
          "args": [
            "mux",
            "WSMUX_MOUSE",
            "&sc->sc_dv",
            "&sc->sc_events",
            "&sc->sc_mux",
            "&wsmouse_muxops"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\twsmouse_attach;\n\nvoid\nwsmouse_attach(parent, self, aux)\n        struct device *parent, *self;\n\tvoid *aux;\n{\n        struct wsmouse_softc *sc = (struct wsmouse_softc *)self;\n\tstruct wsmousedev_attach_args *ap = aux;\n#if NWSMUX > 0\n\tint mux;\n#endif\n\n\tsc->sc_accessops = ap->accessops;\n\tsc->sc_accesscookie = ap->accesscookie;\n\tsc->sc_ready = 0;\t\t\t\t/* sanity */\n\n#if NWSMUX > 0\n\tmux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT) {\n\t\twsmux_attach(mux, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events,\n\t\t\t     &sc->sc_mux, &wsmouse_muxops);\n\t\tprintf(\" mux %d\", mux);\n\t}\n#endif\n\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "wsmouse_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "183-191",
    "snippet": "int\nwsmouse_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twsmouse_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twsmouse_match;\n\nint\nwsmouse_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\n\treturn (1);\n}"
  },
  {
    "function_name": "wsmousedevprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
    "lines": "172-181",
    "snippet": "int\nwsmousedevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\n\tif (pnp)\n\t\tprintf(\"wsmouse at %s\", pnp);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\"",
      "#include \"wsmouse.h\"",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsmousevar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsmouse at %s\"",
            "pnp"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsmousedevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\n\tif (pnp)\n\t\tprintf(\"wsmouse at %s\", pnp);\n\treturn (UNCONF);\n}"
  }
]