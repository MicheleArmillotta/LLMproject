[
  {
    "function_name": "pccbb_powerhook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "3065-3094",
    "snippet": "static void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pccbbintr",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "static void pccbb_powerhook",
      "void *arg;",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "void *arg;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "void *arg;",
      "void *arg;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;",
      "void *arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbbintr",
          "args": [
            "sc"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "pccbbintr_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "953-967",
          "snippet": "static int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pccbbintr_function",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbbintr_function;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_EVENT",
            "reg"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_EVENT"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_MASK",
            "reg"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_MASK"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why)"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pccbbintr;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_powerhook;\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nstatic void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}"
  },
  {
    "function_name": "pccbb_winset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2936-3061",
    "snippet": "static void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR",
            "bcr"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR",
            "bcr"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align)"
          ],
          "line": 3043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "offs + 12"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "offs + 8"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "offs + 4"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "offs"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "offs + 12",
            "win[1].win_limit"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "offs + 8",
            "win[1].win_start"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "offs + 4",
            "win[0].win_limit"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "offs",
            "win[0].win_start"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: overlapping windows\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "chainp",
            "wc_list"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "chainp",
            "wc_list"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&sc->sc_memwindow"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&sc->sc_iowindow"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pccbb_winlist_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2906-2934",
    "snippet": "static int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "chainp",
            "M_DEVBUF"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_rbus_cb_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2792-2812",
          "snippet": "static int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
            "pccbb_power __P((cardbus_chipset_tag_t, int));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "head",
            "chainp",
            "wc_list"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\"",
            "chainp->wc_start",
            "chainp->wc_end - chainp->wc_start",
            "size - 1"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "chainp",
            "wc_list"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "head"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}"
  },
  {
    "function_name": "pccbb_winlist_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2875-2904",
    "snippet": "static int\npccbb_winlist_insert(head, start, size, bsh, flags)\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain *chainp, *elem;\n\n\tif ((elem = malloc(sizeof(struct pccbb_win_chain), M_DEVBUF,\n\t    M_NOWAIT)) == NULL)\n\t\treturn (1);\t\t/* fail */\n\n\telem->wc_start = start;\n\telem->wc_end = start + (size - 1);\n\telem->wc_handle = bsh;\n\telem->wc_flags = flags;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t    chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_end < start)\n\t\t\tcontinue;\n\t\tTAILQ_INSERT_AFTER(head, chainp, elem, wc_list);\n\t\treturn (0);\n\t}\n\n\tTAILQ_INSERT_TAIL(head, elem, wc_list);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "head",
            "elem",
            "wc_list"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_AFTER",
          "args": [
            "head",
            "chainp",
            "elem",
            "wc_list"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "chainp",
            "wc_list"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "head"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct pccbb_win_chain)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\n\nstatic int\npccbb_winlist_insert(head, start, size, bsh, flags)\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain *chainp, *elem;\n\n\tif ((elem = malloc(sizeof(struct pccbb_win_chain), M_DEVBUF,\n\t    M_NOWAIT)) == NULL)\n\t\treturn (1);\t\t/* fail */\n\n\telem->wc_start = start;\n\telem->wc_end = start + (size - 1);\n\telem->wc_handle = bsh;\n\telem->wc_flags = flags;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t    chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_end < start)\n\t\t\tcontinue;\n\t\tTAILQ_INSERT_AFTER(head, chainp, elem, wc_list);\n\t\treturn (0);\n\t}\n\n\tTAILQ_INSERT_TAIL(head, elem, wc_list);\n\treturn (0);\n}"
  },
  {
    "function_name": "pccbb_close_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2848-2873",
    "snippet": "static int\npccbb_close_win(sc, bst, bsh, size)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t}\n\n\tif (pccbb_winlist_delete(head, bsh, size)) {\n\t\tprintf(\"%s: pccbb_close_win: %s winlist delete failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_winset",
          "args": [
            "align",
            "sc",
            "bst"
          ],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_winset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2936-3061",
          "snippet": "static void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: pccbb_close_win: %s winlist delete failed\\n\"",
            "sc->sc_dev.dv_xname",
            "(head == &sc->sc_memwindow) ? \"mem\" : \"io\""
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_winlist_delete",
          "args": [
            "head",
            "bsh",
            "size"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_winlist_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2906-2934",
          "snippet": "static int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic int\npccbb_close_win(sc, bst, bsh, size)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t}\n\n\tif (pccbb_winlist_delete(head, bsh, size)) {\n\t\tprintf(\"%s: pccbb_close_win: %s winlist delete failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_open_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2817-2846",
    "snippet": "static int\npccbb_open_win(sc, bst, addr, size, bsh, flags)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t\tDPRINTF((\"using memory window, %x %x %x\\n\\n\",\n\t\t    sc->sc_iot, sc->sc_memt, bst));\n\t}\n\n\tif (pccbb_winlist_insert(head, addr, size, bsh, flags)) {\n\t\tprintf(\"%s: pccbb_open_win: %s winlist insert failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_winset",
          "args": [
            "align",
            "sc",
            "bst"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_winset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2936-3061",
          "snippet": "static void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_winset(align, sc, bst)\n\tbus_addr_t align;\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n{\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_addr_t mask = ~(align - 1);\n\tstruct {\n\t\tcardbusreg_t win_start;\n\t\tcardbusreg_t win_limit;\n\t\tint win_flags;\n\t} win[2];\n\tstruct pccbb_win_chain *chainp;\n\tint offs;\n\n\twin[0].win_start = 0xffffffff;\n\twin[0].win_limit = 0;\n\twin[1].win_start = 0xffffffff;\n\twin[1].win_limit = 0;\n\n\tchainp = TAILQ_FIRST(&sc->sc_iowindow);\n\toffs = 0x2c;\n\tif (sc->sc_memt == bst) {\n\t\tchainp = TAILQ_FIRST(&sc->sc_memwindow);\n\t\toffs = 0x1c;\n\t}\n\n\tif (chainp != NULL) {\n\t\twin[0].win_start = chainp->wc_start & mask;\n\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\twin[0].win_flags = chainp->wc_flags;\n\t\tchainp = TAILQ_NEXT(chainp, wc_list);\n\t}\n\n\tfor (; chainp != NULL; chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (win[1].win_start == 0xffffffff) {\n\t\t\t/* window 1 is not used */\n\t\t\tif ((win[0].win_flags == chainp->wc_flags) &&\n\t\t\t    (win[0].win_limit + align >=\n\t\t\t    (chainp->wc_start & mask))) {\n\t\t\t\t/* concatenate */\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t} else {\n\t\t\t\t/* make new window */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Both windows are engaged. */\n\t\tif (win[0].win_flags == win[1].win_flags) {\n\t\t\t/* same flags */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\tif (win[1].win_start - (win[0].win_limit +\n\t\t\t\t    align) <\n\t\t\t\t    (chainp->wc_start & mask) -\n\t\t\t\t    ((chainp->wc_end & mask) + align)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * merge window 0 and 1, and set win1\n\t\t\t\t\t * to chainp\n\t\t\t\t\t */\n\t\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t\twin[1].win_start =\n\t\t\t\t\t    chainp->wc_start & mask;\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t} else {\n\t\t\t\t\twin[1].win_limit =\n\t\t\t\t\t    chainp->wc_end & mask;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* different flags */\n\n\t\t\t\t/* concatenate win0 and win1 */\n\t\t\t\twin[0].win_limit = win[1].win_limit;\n\t\t\t\t/* allocate win[1] to new space */\n\t\t\t\twin[1].win_start = chainp->wc_start & mask;\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t\twin[1].win_flags = chainp->wc_flags;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the flags of win[0] and win[1] is different */\n\t\t\tif (win[0].win_flags == chainp->wc_flags) {\n\t\t\t\twin[0].win_limit = chainp->wc_end & mask;\n\t\t\t\t/*\n\t\t\t\t * XXX this creates overlapping windows, so\n\t\t\t\t * what should the poor bridge do if one is\n\t\t\t\t * cachable, and the other is not?\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: overlapping windows\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t} else {\n\t\t\t\twin[1].win_limit = chainp->wc_end & mask;\n\t\t\t}\n\t\t}\n\t}\n\n\tpc = sc->sc_pc;\n\ttag = sc->sc_tag;\n\tpci_conf_write(pc, tag, offs, win[0].win_start);\n\tpci_conf_write(pc, tag, offs + 4, win[0].win_limit);\n\tpci_conf_write(pc, tag, offs + 8, win[1].win_start);\n\tpci_conf_write(pc, tag, offs + 12, win[1].win_limit);\n\tDPRINTF((\"--pccbb_winset: win0 [%x, %lx), win1 [%x, %lx)\\n\",\n\t    pci_conf_read(pc, tag, offs),\n\t    pci_conf_read(pc, tag, offs + 4) + align,\n\t    pci_conf_read(pc, tag, offs + 8),\n\t    pci_conf_read(pc, tag, offs + 12) + align));\n\n\tif (bst == sc->sc_memt) {\n\t\tif (win[0].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN0;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t\tif (win[1].win_flags & PCCBB_MEM_CACHABLE) {\n\t\t\tpcireg_t bcr = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\t\tbcr |= CB_BCR_PREFETCH_MEMWIN1;\n\t\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, bcr);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: pccbb_open_win: %s winlist insert failed\\n\"",
            "sc->sc_dev.dv_xname",
            "(head == &sc->sc_memwindow) ? \"mem\" : \"io\""
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_winlist_insert",
          "args": [
            "head",
            "addr",
            "size",
            "bsh",
            "flags"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_winlist_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2875-2904",
          "snippet": "static int\npccbb_winlist_insert(head, start, size, bsh, flags)\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain *chainp, *elem;\n\n\tif ((elem = malloc(sizeof(struct pccbb_win_chain), M_DEVBUF,\n\t    M_NOWAIT)) == NULL)\n\t\treturn (1);\t\t/* fail */\n\n\telem->wc_start = start;\n\telem->wc_end = start + (size - 1);\n\telem->wc_handle = bsh;\n\telem->wc_flags = flags;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t    chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_end < start)\n\t\t\tcontinue;\n\t\tTAILQ_INSERT_AFTER(head, chainp, elem, wc_list);\n\t\treturn (0);\n\t}\n\n\tTAILQ_INSERT_TAIL(head, elem, wc_list);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\n\nstatic int\npccbb_winlist_insert(head, start, size, bsh, flags)\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain *chainp, *elem;\n\n\tif ((elem = malloc(sizeof(struct pccbb_win_chain), M_DEVBUF,\n\t    M_NOWAIT)) == NULL)\n\t\treturn (1);\t\t/* fail */\n\n\telem->wc_start = start;\n\telem->wc_end = start + (size - 1);\n\telem->wc_handle = bsh;\n\telem->wc_flags = flags;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t    chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_end < start)\n\t\t\tcontinue;\n\t\tTAILQ_INSERT_AFTER(head, chainp, elem, wc_list);\n\t\treturn (0);\n\t}\n\n\tTAILQ_INSERT_TAIL(head, elem, wc_list);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"using memory window, %x %x %x\\n\\n\",\n\t\t    sc->sc_iot, sc->sc_memt, bst)"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic int\npccbb_open_win(sc, bst, addr, size, bsh, flags)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t\tDPRINTF((\"using memory window, %x %x %x\\n\\n\",\n\t\t    sc->sc_iot, sc->sc_memt, bst));\n\t}\n\n\tif (pccbb_winlist_insert(head, addr, size, bsh, flags)) {\n\t\tprintf(\"%s: pccbb_open_win: %s winlist insert failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_rbus_cb_space_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2792-2812",
    "snippet": "static int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbus_space_free",
          "args": [
            "rb",
            "bsh",
            "size",
            "NULL"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_close_win",
          "args": [
            "sc",
            "bt",
            "bsh",
            "size"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_close_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2848-2873",
          "snippet": "static int\npccbb_close_win(sc, bst, bsh, size)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t}\n\n\tif (pccbb_winlist_delete(head, bsh, size)) {\n\t\tprintf(\"%s: pccbb_close_win: %s winlist delete failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic int\npccbb_close_win(sc, bst, bsh, size)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t}\n\n\tif (pccbb_winlist_delete(head, bsh, size)) {\n\t\tprintf(\"%s: pccbb_close_win: %s winlist delete failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}"
  },
  {
    "function_name": "pccbb_rbus_cb_space_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2731-2783",
    "snippet": "static int\npccbb_rbus_cb_space_alloc(ct, rb, addr, size, mask, align, flags, addrp, bshp)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_addr_t mask;\n\tbus_size_t align;\n\tint flags;\n\tbus_addr_t *addrp;\n\tbus_space_handle_t *bshp;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tDPRINTF(\n\t    (\"pccbb_rbus_cb_space_alloc: adr %lx, size %lx, mask %lx, align %lx\\n\",\n\t    addr, size, mask, align));\n\n\tif (align == 0) {\n\t\talign = size;\n\t}\n\n\tif (rb->rb_bt == sc->sc_memt) {\n\t\tif (align < 16) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (rb->rb_bt == sc->sc_iot) {\n\t\tif (align < 4) {\n\t\t\treturn 1;\n\t\t}\n\t\t/* XXX: hack for avoiding ISA image */\n\t\tif (mask < 0x0100) {\n\t\t\tmask = 0x3ff;\n\t\t\taddr = 0x300;\n\t\t}\n\n\t} else {\n\t\tDPRINTF(\n\t\t    (\"pccbb_rbus_cb_space_alloc: Bus space tag %x is NOT used.\\n\",\n\t\t    rb->rb_bt));\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\tif (rbus_space_alloc(rb, addr, size, mask, align, flags, addrp, bshp)) {\n\t\tprintf(\"%s: <rbus> no bus space\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tpccbb_open_win(sc, rb->rb_bt, *addrp, size, *bshp, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_open_win",
          "args": [
            "sc",
            "rb->rb_bt",
            "*addrp",
            "size",
            "*bshp",
            "0"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_open_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2817-2846",
          "snippet": "static int\npccbb_open_win(sc, bst, addr, size, bsh, flags)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t\tDPRINTF((\"using memory window, %x %x %x\\n\\n\",\n\t\t    sc->sc_iot, sc->sc_memt, bst));\n\t}\n\n\tif (pccbb_winlist_insert(head, addr, size, bsh, flags)) {\n\t\tprintf(\"%s: pccbb_open_win: %s winlist insert failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic int\npccbb_open_win(sc, bst, addr, size, bsh, flags)\n\tstruct pccbb_softc *sc;\n\tbus_space_tag_t bst;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_space_handle_t bsh;\n\tint flags;\n{\n\tstruct pccbb_win_chain_head *head;\n\tbus_addr_t align;\n\n\thead = &sc->sc_iowindow;\n\talign = 0x04;\n\tif (sc->sc_memt == bst) {\n\t\thead = &sc->sc_memwindow;\n\t\talign = 0x1000;\n\t\tDPRINTF((\"using memory window, %x %x %x\\n\\n\",\n\t\t    sc->sc_iot, sc->sc_memt, bst));\n\t}\n\n\tif (pccbb_winlist_insert(head, addr, size, bsh, flags)) {\n\t\tprintf(\"%s: pccbb_open_win: %s winlist insert failed\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (head == &sc->sc_memwindow) ? \"mem\" : \"io\");\n\t}\n\tpccbb_winset(align, sc, bst);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: <rbus> no bus space\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbus_space_alloc",
          "args": [
            "rb",
            "addr",
            "size",
            "mask",
            "align",
            "flags",
            "addrp",
            "bshp"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_rbus_cb_space_alloc: Bus space tag %x is NOT used.\\n\",\n\t\t    rb->rb_bt)"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_rbus_cb_space_alloc: adr %lx, size %lx, mask %lx, align %lx\\n\",\n\t    addr, size, mask, align)"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic int\npccbb_rbus_cb_space_alloc(ct, rb, addr, size, mask, align, flags, addrp, bshp)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_addr_t addr;\n\tbus_size_t size;\n\tbus_addr_t mask;\n\tbus_size_t align;\n\tint flags;\n\tbus_addr_t *addrp;\n\tbus_space_handle_t *bshp;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tDPRINTF(\n\t    (\"pccbb_rbus_cb_space_alloc: adr %lx, size %lx, mask %lx, align %lx\\n\",\n\t    addr, size, mask, align));\n\n\tif (align == 0) {\n\t\talign = size;\n\t}\n\n\tif (rb->rb_bt == sc->sc_memt) {\n\t\tif (align < 16) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (rb->rb_bt == sc->sc_iot) {\n\t\tif (align < 4) {\n\t\t\treturn 1;\n\t\t}\n\t\t/* XXX: hack for avoiding ISA image */\n\t\tif (mask < 0x0100) {\n\t\t\tmask = 0x3ff;\n\t\t\taddr = 0x300;\n\t\t}\n\n\t} else {\n\t\tDPRINTF(\n\t\t    (\"pccbb_rbus_cb_space_alloc: Bus space tag %x is NOT used.\\n\",\n\t\t    rb->rb_bt));\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\tif (rbus_space_alloc(rb, addr, size, mask, align, flags, addrp, bshp)) {\n\t\tprintf(\"%s: <rbus> no bus space\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tpccbb_open_win(sc, rb->rb_bt, *addrp, size, *bshp, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2708-2717",
    "snippet": "STATIC void\npccbb_pcmcia_intr_disestablish(pch, ih)\n\tpcmcia_chipset_handle_t pch;\n\tvoid *ih;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\tpccbb_intr_disestablish(sc, ih);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "static void pccbb_intr_disestablish",
      "__P((cardbus_chipset_tag_t ct, void *ih));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_intr_disestablish",
          "args": [
            "sc",
            "ih"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1642-1684",
          "snippet": "static void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "static void pccbb_intr_disestablish",
            "__P((cardbus_chipset_tag_t ct, void *ih));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_intr_disestablish;\n__P((cardbus_chipset_tag_t ct, void *ih));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nstatic void pccbb_intr_disestablish;\n__P((cardbus_chipset_tag_t ct, void *ih));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_intr_disestablish(pch, ih)\n\tpcmcia_chipset_handle_t pch;\n\tvoid *ih;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\tpccbb_intr_disestablish(sc, ih);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_mem_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2584-2601",
    "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pcic_handle *ph = poll->ph;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_mem_unmap: window out of range\""
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2509-2575",
    "snippet": "STATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
      "STATIC void",
      "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
      "STATIC int",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "static void pccbb_pcmcia_do_mem_map",
      "struct pcic_handle *ph = poll->ph;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_pcmcia_do_mem_map",
          "args": [
            "ph",
            "win"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2403-2498",
          "snippet": "STATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)",
            "#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)",
            "#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT",
            "#define PCIC_CMA_HIGH 5",
            "#define PCIC_CMA_LOW 4",
            "#define PCIC_SMM_STOP_HIGH 3",
            "#define PCIC_SMM_STOP_LOW 2",
            "#define PCIC_SMM_START_HIGH 1",
            "#define PCIC_SMM_START_LOW 0",
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_CMA_HIGH 5\n#define PCIC_CMA_LOW 4\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_START_LOW 0\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr)"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_mem_map memt is bogus\""
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_do_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2403-2498",
    "snippet": "STATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)",
      "#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)",
      "#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT",
      "#define PCIC_CMA_HIGH 5",
      "#define PCIC_CMA_LOW 4",
      "#define PCIC_SMM_STOP_HIGH 3",
      "#define PCIC_SMM_STOP_LOW 2",
      "#define PCIC_SMM_START_HIGH 1",
      "#define PCIC_SMM_START_LOW 0",
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "static void pccbb_pcmcia_do_mem_map",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" %02x\", r7)"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6)"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "0x40 + win"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_CMA_HIGH"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_CMA_LOW"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_STOP_HIGH"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_STOP_LOW"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_START_HIGH"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_START_LOW"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_CMA_HIGH",
            "off_high"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_CMA_LOW",
            "off_low"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_STOP_HIGH",
            "stop_high"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_STOP_LOW",
            "stop_low"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "0x40 + win",
            "mem_window"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_START_HIGH",
            "start_high"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SMM_START_LOW",
            "start_low"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset)"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_CMA_HIGH 5\n#define PCIC_CMA_LOW 4\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_START_LOW 0\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}"
  },
  {
    "function_name": "pccbb_pcmcia_mem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2382-2395",
    "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
      "STATIC void",
      "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_free",
          "args": [
            "pcmhp->memt",
            "pcmhp->memh",
            "pcmhp->realsize"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
  },
  {
    "function_name": "pccbb_pcmcia_mem_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2307-2373",
    "snippet": "STATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
      "STATIC void",
      "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
      "STATIC int",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "sc->sc_memt",
            "sc->sc_mem_start",
            "sc->sc_mem_end",
            "sizepg * PCIC_MEM_PAGESIZE",
            "PCIC_MEM_PAGESIZE",
            "0",
            "/* boundary */0",
            "/* flags */&addr",
            "&memh"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_card_detect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2280-2289",
    "snippet": "STATIC int\npccbb_pcmcia_card_detect(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\tDPRINTF((\"pccbb_pcmcia_card_detect\\n\"));\n\treturn pccbb_detect_card(sc) == 1 ? 1 : 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "static int pccbb_detect_card",
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_detect_card",
          "args": [
            "sc"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_detect_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1271-1296",
          "snippet": "static int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pccbb_detect_card",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbb_detect_card;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_card_detect\\n\")"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nstatic int pccbb_detect_card;\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_card_detect(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\tDPRINTF((\"pccbb_pcmcia_card_detect\\n\"));\n\treturn pccbb_detect_card(sc) == 1 ? 1 : 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_socket_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2246-2272",
    "snippet": "STATIC void\npccbb_pcmcia_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tu_int8_t power, intr;\n\n\tDPRINTF((\"pccbb_pcmcia_socket_disable\\n\"));\n\n\t/* reset signal asserting... */\n\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\tdelay(2 * 1000);\n\n\t/* power down the socket */\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\t/* \n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "300 * 1000"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_power",
          "args": [
            "sc",
            "CARDBUS_VCC_0V | CARDBUS_VPP_0V"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_powerhook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "3065-3094",
          "snippet": "static void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pccbbintr",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "static void pccbb_powerhook",
            "void *arg;",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "void *arg;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "void *arg;",
            "void *arg;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;",
            "void *arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pccbbintr;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_powerhook;\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nstatic void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_PWRCTL",
            "power"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_PWRCTL"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_INTR",
            "intr"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_INTR"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_socket_disable\\n\")"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tu_int8_t power, intr;\n\n\tDPRINTF((\"pccbb_pcmcia_socket_disable\\n\"));\n\n\t/* reset signal asserting... */\n\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\tdelay(2 * 1000);\n\n\t/* power down the socket */\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\t/* \n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_socket_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2121-2238",
    "snippet": "STATIC void\npccbb_pcmcia_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tint cardtype, win;\n\tu_int8_t power, intr;\n\tpcireg_t spsr;\n\tint voltage;\n\n\t/* this bit is mostly stolen from pcic_attach_card */\n\n\tDPRINTF((\"pccbb_pcmcia_socket_enable: \"));\n\n\t/* get card Vcc info */\n\n\tspsr =\n\t    bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_STAT);\n\tif (spsr & CB_SOCKET_STAT_5VCARD) {\n\t\tDPRINTF((\"5V card\\n\"));\n\t\tvoltage = CARDBUS_VCC_5V | CARDBUS_VPP_VCC;\n\t} else if (spsr & CB_SOCKET_STAT_3VCARD) {\n\t\tDPRINTF((\"3V card\\n\"));\n\t\tvoltage = CARDBUS_VCC_3V | CARDBUS_VPP_VCC;\n\t} else {\n\t\tprintf(\"?V card, 0x%x\\n\", spsr);\t/* XXX */\n\t\treturn;\n\t}\n\n\t/* assert reset bit */\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_RESET | PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\t/* disable socket i/o: negate output enable bit */\n\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\n\t/* power down the socket to reset it, clear the card reset pin */\n\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\n\t/* \n\t * wait 200ms until power fails (Tpf).  Then, wait 100ms since\n\t * we are changing Vcc (Toff).\n\t */\n\t/* delay(300*1000); too much */\n\n\t/* power up the socket */\n\tpccbb_power(sc, voltage);\n\n\t/* \n\t * wait 100ms until power raise (Tpr) and 20ms to become\n\t * stable (Tsu(Vcc)).\n\t *\n\t * some machines require some more time to be settled\n\t * (another 200ms is added here).\n\t */\n\t/* delay((100 + 20 + 200)*1000); too much */\n\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower |= PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\n\t/* \n\t * hold RESET at least 10us.\n\t */\n\tdelay(10);\n\tdelay(2 * 1000);\t       /* XXX: TI1130 requires it. */\n\tdelay(20 * 1000);\t       /* XXX: TI1130 requires it. */\n\n\t/* clear the reset flag */\n\n\tintr |= PCIC_INTR_RESET;\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\n\tpccbb_pcmcia_wait_ready(ph);\n\n\t/* zero out the address windows */\n\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, 0);\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(ph->pcmcia);\n\n\tintr |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t    PCIC_INTR_CARDTYPE_IO : PCIC_INTR_CARDTYPE_MEM);\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\tDPRINTF((\"%s: pccbb_pcmcia_socket_enable %02x cardtype %s %02x\\n\",\n\t    ph->ph_parent->dv_xname, ph->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), intr));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif (ph->memalloc & (1 << win)) {\n\t\t\tpccbb_pcmcia_do_mem_map(ph, win);\n\t\t}\n\t}\n\n\tfor (win = 0; win < PCIC_IO_WINS; ++win) {\n\t\tif (ph->ioalloc & (1 << win)) {\n\t\t\tpccbb_pcmcia_do_io_map(ph, win);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "static void pccbb_pcmcia_do_io_map",
      "static void pccbb_pcmcia_wait_ready",
      "static void pccbb_pcmcia_do_mem_map",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "u_int32_t spsr;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;",
      "u_int32_t spsr;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_pcmcia_do_io_map",
          "args": [
            "ph",
            "win"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1979-2050",
          "snippet": "static void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define PCIC_SIA_STOP_HIGH 3",
            "#define PCIC_SIA_STOP_LOW 2",
            "#define PCIC_SIA_START_HIGH 1",
            "#define PCIC_SIA_START_LOW 0"
          ],
          "globals_used": [
            "static void pccbb_pcmcia_do_io_map",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_SIA_STOP_HIGH 3\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_START_LOW 0\n\nstatic void pccbb_pcmcia_do_io_map;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_pcmcia_do_mem_map",
          "args": [
            "ph",
            "win"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2403-2498",
          "snippet": "STATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)",
            "#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)",
            "#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT",
            "#define PCIC_CMA_HIGH 5",
            "#define PCIC_CMA_LOW 4",
            "#define PCIC_SMM_STOP_HIGH 3",
            "#define PCIC_SMM_STOP_LOW 2",
            "#define PCIC_SMM_START_HIGH 1",
            "#define PCIC_SMM_START_LOW 0",
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_CMA_HIGH 5\n#define PCIC_CMA_LOW 4\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_START_LOW 0\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_do_mem_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tint regbase_win;\n\tbus_addr_t phys_addr;\n\tbus_addr_t phys_end;\n\n#define PCIC_SMM_START_LOW 0\n#define PCIC_SMM_START_HIGH 1\n#define PCIC_SMM_STOP_LOW 2\n#define PCIC_SMM_STOP_HIGH 3\n#define PCIC_CMA_LOW 4\n#define PCIC_CMA_HIGH 5\n\n\tu_int8_t start_low, start_high = 0;\n\tu_int8_t stop_low, stop_high;\n\tu_int8_t off_low, off_high;\n\tu_int8_t mem_window;\n\tint reg;\n\n\tregbase_win = 0x10 + win * 0x08;\n\n\tphys_addr = ph->mem[win].addr;\n\tphys_end = phys_addr + ph->mem[win].size;\n\n\tDPRINTF((\"pccbb_pcmcia_do_mem_map: start 0x%lx end 0x%lx off 0x%lx\\n\",\n\t    phys_addr, phys_end, ph->mem[win].offset));\n\n#define PCIC_MEMREG_LSB_SHIFT PCIC_SYSMEM_ADDRX_SHIFT\n#define PCIC_MEMREG_MSB_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 8)\n#define PCIC_MEMREG_WIN_SHIFT (PCIC_SYSMEM_ADDRX_SHIFT + 12)\n\n\t/* bit 19:12 */\n\tstart_low = (phys_addr >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\t/* bit 23:20 and bit 7 on */\n\tstart_high = ((phys_addr >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT; /* bit 7 on */\n\t/* bit 31:24, for 32-bit address */\n\tmem_window = (phys_addr >> PCIC_MEMREG_WIN_SHIFT) & 0xff;\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_LOW, start_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_START_HIGH, start_high);\n\n\tif (((struct pccbb_softc *)ph->\n\t    ph_parent)->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\tPcic_write(ph, 0x40 + win, mem_window);\n\t}\n\n\tstop_low = (phys_end >> PCIC_MEMREG_LSB_SHIFT) & 0xff;\n\tstop_high = ((phys_end >> PCIC_MEMREG_MSB_SHIFT) & 0x0f)\n\t    | PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2;\t/* wait 2 cycles */\n\t/* XXX Geee, WAIT2!! Crazy!!  I must rewrite this routine. */\n\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_LOW, stop_low);\n\tPcic_write(ph, regbase_win + PCIC_SMM_STOP_HIGH, stop_high);\n\n\toff_low = (ph->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff;\n\toff_high = ((ph->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8))\n\t    & PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK)\n\t    | ((ph->mem[win].kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0);\n\n\tPcic_write(ph, regbase_win + PCIC_CMA_LOW, off_low);\n\tPcic_write(ph, regbase_win + PCIC_CMA_HIGH, off_high);\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg |= ((1 << win) | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n#if defined CBB_DEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6, r7 = 0;\n\n\t\tr1 = Pcic_read(ph, regbase_win + PCIC_SMM_START_LOW);\n\t\tr2 = Pcic_read(ph, regbase_win + PCIC_SMM_START_HIGH);\n\t\tr3 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_LOW);\n\t\tr4 = Pcic_read(ph, regbase_win + PCIC_SMM_STOP_HIGH);\n\t\tr5 = Pcic_read(ph, regbase_win + PCIC_CMA_LOW);\n\t\tr6 = Pcic_read(ph, regbase_win + PCIC_CMA_HIGH);\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tr7 = Pcic_read(ph, 0x40 + win);\n\t\t}\n\n\t\tDPRINTF((\"pccbb_pcmcia_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\", win, r1, r2, r3, r4, r5, r6));\n\t\tif (((struct pccbb_softc *)(ph->\n\t\t    ph_parent))->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32) {\n\t\t\tDPRINTF((\" %02x\", r7));\n\t\t}\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: pccbb_pcmcia_socket_enable %02x cardtype %s %02x\\n\",\n\t    ph->ph_parent->dv_xname, ph->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), intr)"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_INTR",
            "intr"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_gettype",
          "args": [
            "ph->pcmcia"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_gettype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "367-386",
          "snippet": "int \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE",
            "0"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pccbb_pcmcia_wait_ready",
          "args": [
            "ph"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_wait_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2089-2113",
          "snippet": "static void\npccbb_pcmcia_wait_ready(ph)\n\tstruct pcic_handle *ph;\n{\n\tint i;\n\n\tDPRINTF((\"pccbb_pcmcia_wait_ready: status 0x%02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS)));\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (Pcic_read(ph, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY) {\n\t\t\treturn;\n\t\t}\n\t\tdelay(500);\n#ifdef CBB_DEBUG\n\t\tif ((i > 5000) && (i % 100 == 99))\n\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS));\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pccbb_pcmcia_wait_ready",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void pccbb_pcmcia_wait_ready;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_wait_ready(ph)\n\tstruct pcic_handle *ph;\n{\n\tint i;\n\n\tDPRINTF((\"pccbb_pcmcia_wait_ready: status 0x%02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS)));\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (Pcic_read(ph, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY) {\n\t\t\treturn;\n\t\t}\n\t\tdelay(500);\n#ifdef CBB_DEBUG\n\t\tif ((i > 5000) && (i % 100 == 99))\n\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "20000"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_INTR",
            "intr"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_PWRCTL",
            "power"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_PWRCTL"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pccbb_power",
          "args": [
            "sc",
            "voltage"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_powerhook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "3065-3094",
          "snippet": "static void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pccbbintr",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "static void pccbb_powerhook",
            "void *arg;",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "void *arg;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "void *arg;",
            "void *arg;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;",
            "void *arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pccbbintr;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_powerhook;\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nstatic void\npccbb_powerhook(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = arg;\n\tu_int32_t reg;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\t/* socket regs memory */\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\n\tDPRINTF((\"%s: power: why %d\\n\", sc->sc_dev.dv_xname, why));\n\n\tif (why == PWR_RESUME) {\n\t\t/* CSC Interrupt: Card detect interrupt on */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\t\t/* Card detect intr is turned on. */\n\t\treg |= CB_SOCKET_MASK_CD;\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, reg);\n\t\t/* reset interrupt */\n\t\treg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT);\n\t\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT, reg);\n\n\t\t/*\n\t\t * check for card insertion or removal during suspend period.\n\t\t * XXX: the code can't cope with card swap (remove then\n\t\t * insert).  how can we detect such situation?\n\t\t */\n\t\t(void)pccbbintr(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_PWRCTL",
            "power"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_PWRCTL"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_INTR",
            "intr"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_INTR"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"?V card, 0x%x\\n\"",
            "spsr"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"3V card\\n\")"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"5V card\\n\")"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->sc_base_memt",
            "sc->sc_base_memh",
            "CB_SOCKET_STAT"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_socket_enable: \")"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_io_map;\nstatic void pccbb_pcmcia_wait_ready;\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nu_int32_t spsr;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nu_int32_t spsr;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tint cardtype, win;\n\tu_int8_t power, intr;\n\tpcireg_t spsr;\n\tint voltage;\n\n\t/* this bit is mostly stolen from pcic_attach_card */\n\n\tDPRINTF((\"pccbb_pcmcia_socket_enable: \"));\n\n\t/* get card Vcc info */\n\n\tspsr =\n\t    bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_STAT);\n\tif (spsr & CB_SOCKET_STAT_5VCARD) {\n\t\tDPRINTF((\"5V card\\n\"));\n\t\tvoltage = CARDBUS_VCC_5V | CARDBUS_VPP_VCC;\n\t} else if (spsr & CB_SOCKET_STAT_3VCARD) {\n\t\tDPRINTF((\"3V card\\n\"));\n\t\tvoltage = CARDBUS_VCC_3V | CARDBUS_VPP_VCC;\n\t} else {\n\t\tprintf(\"?V card, 0x%x\\n\", spsr);\t/* XXX */\n\t\treturn;\n\t}\n\n\t/* assert reset bit */\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_RESET | PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\t/* disable socket i/o: negate output enable bit */\n\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\n\t/* power down the socket to reset it, clear the card reset pin */\n\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\n\t/* \n\t * wait 200ms until power fails (Tpf).  Then, wait 100ms since\n\t * we are changing Vcc (Toff).\n\t */\n\t/* delay(300*1000); too much */\n\n\t/* power up the socket */\n\tpccbb_power(sc, voltage);\n\n\t/* \n\t * wait 100ms until power raise (Tpr) and 20ms to become\n\t * stable (Tsu(Vcc)).\n\t *\n\t * some machines require some more time to be settled\n\t * (another 200ms is added here).\n\t */\n\t/* delay((100 + 20 + 200)*1000); too much */\n\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower |= PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\n\t/* \n\t * hold RESET at least 10us.\n\t */\n\tdelay(10);\n\tdelay(2 * 1000);\t       /* XXX: TI1130 requires it. */\n\tdelay(20 * 1000);\t       /* XXX: TI1130 requires it. */\n\n\t/* clear the reset flag */\n\n\tintr |= PCIC_INTR_RESET;\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\n\tpccbb_pcmcia_wait_ready(ph);\n\n\t/* zero out the address windows */\n\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, 0);\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(ph->pcmcia);\n\n\tintr |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t    PCIC_INTR_CARDTYPE_IO : PCIC_INTR_CARDTYPE_MEM);\n\tPcic_write(ph, PCIC_INTR, intr);\n\n\tDPRINTF((\"%s: pccbb_pcmcia_socket_enable %02x cardtype %s %02x\\n\",\n\t    ph->ph_parent->dv_xname, ph->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), intr));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif (ph->memalloc & (1 << win)) {\n\t\t\tpccbb_pcmcia_do_mem_map(ph, win);\n\t\t}\n\t}\n\n\tfor (win = 0; win < PCIC_IO_WINS; ++win) {\n\t\tif (ph->ioalloc & (1 << win)) {\n\t\t\tpccbb_pcmcia_do_io_map(ph, win);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pccbb_pcmcia_wait_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2089-2113",
    "snippet": "static void\npccbb_pcmcia_wait_ready(ph)\n\tstruct pcic_handle *ph;\n{\n\tint i;\n\n\tDPRINTF((\"pccbb_pcmcia_wait_ready: status 0x%02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS)));\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (Pcic_read(ph, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY) {\n\t\t\treturn;\n\t\t}\n\t\tdelay(500);\n#ifdef CBB_DEBUG\n\t\tif ((i > 5000) && (i % 100 == 99))\n\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS));\n#endif\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pccbb_pcmcia_wait_ready",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcic_wait_ready: ready never happened, status = %02x\\n\"",
            "Pcic_read(ph, PCIC_IF_STATUS)"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_IF_STATUS"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "500"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_IF_STATUS"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_wait_ready: status 0x%02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS))"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_IF_STATUS"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void pccbb_pcmcia_wait_ready;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_wait_ready(ph)\n\tstruct pcic_handle *ph;\n{\n\tint i;\n\n\tDPRINTF((\"pccbb_pcmcia_wait_ready: status 0x%02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS)));\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (Pcic_read(ph, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY) {\n\t\t\treturn;\n\t\t}\n\t\tdelay(500);\n#ifdef CBB_DEBUG\n\t\tif ((i > 5000) && (i % 100 == 99))\n\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    Pcic_read(ph, PCIC_IF_STATUS));\n#endif\n}"
  },
  {
    "function_name": "pccbb_pcmcia_io_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "2057-2081",
    "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pcic_handle *ph = poll->ph;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_io_unmap: window out of range\""
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_do_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1979-2050",
    "snippet": "static void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define PCIC_SIA_STOP_HIGH 3",
      "#define PCIC_SIA_STOP_LOW 2",
      "#define PCIC_SIA_START_HIGH 1",
      "#define PCIC_SIA_START_LOW 0"
    ],
    "globals_used": [
      "static void pccbb_pcmcia_do_io_map",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\"",
            "start_low",
            "start_high",
            "stop_low",
            "stop_high",
            "ioctl",
            "enable"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_STOP_HIGH"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_STOP_LOW"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_START_HIGH"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_START_LOW"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE",
            "enable"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_IOCTL",
            "ioctl"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_IOCTL"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_STOP_HIGH",
            "((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_STOP_LOW",
            "(ph->io[win].addr + ph->io[win].size - 1) & 0xff"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_START_HIGH",
            "(ph->io[win].addr >> 8) & 0xff"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "regbase_win + PCIC_SIA_START_LOW",
            "ph->io[win].addr & 0xff"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8)"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_SIA_STOP_HIGH 3\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_START_LOW 0\n\nstatic void pccbb_pcmcia_do_io_map;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}"
  },
  {
    "function_name": "pccbb_pcmcia_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1911-1972",
    "snippet": "int\npccbb_pcmcia_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#if defined CBB_DEBUG\n\tstatic char *width_names[] = { \"dynamic\", \"io8\", \"io16\" };\n#endif\n\n\t/* Sanity check I/O handle. */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_iot != pcihp->iot) {\n\t\tpanic(\"pccbb_pcmcia_io_map iot is bogus\");\n\t}\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < PCIC_IO_WINS; i++) {\n\t\tif ((ph->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\tph->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tDPRINTF((\"pccbb_pcmcia_io_map window %d %s port %lx+%lx\\n\",\n\t    win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\t/* XXX wtf is this doing here? */\n\n#if 0\n\tprintf(\" port 0x%lx\", (u_long) ioaddr);\n\tif (size > 1) {\n\t\tprintf(\"-0x%lx\", (u_long) ioaddr + (u_long) size - 1);\n\t}\n#endif\n\n\tph->io[win].addr = ioaddr;\n\tph->io[win].size = size;\n\tph->io[win].width = width;\n\n\t/* actual dirty register-value changing in the function below. */\n\tpccbb_pcmcia_do_io_map(ph, win);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
      "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
      "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "static void pccbb_pcmcia_do_io_map",
      "int s;",
      "struct pcic_handle *ph = poll->ph;",
      "int s;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_pcmcia_do_io_map",
          "args": [
            "ph",
            "win"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1979-2050",
          "snippet": "static void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define PCIC_SIA_STOP_HIGH 3",
            "#define PCIC_SIA_STOP_LOW 2",
            "#define PCIC_SIA_START_HIGH 1",
            "#define PCIC_SIA_START_LOW 0"
          ],
          "globals_used": [
            "static void pccbb_pcmcia_do_io_map",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCIC_SIA_STOP_HIGH 3\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_START_LOW 0\n\nstatic void pccbb_pcmcia_do_io_map;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_do_io_map(ph, win)\n\tstruct pcic_handle *ph;\n\tint win;\n{\n\tstatic u_int8_t pcic_iowidth[3] = {\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t};\n\n#define PCIC_SIA_START_LOW 0\n#define PCIC_SIA_START_HIGH 1\n#define PCIC_SIA_STOP_LOW 2\n#define PCIC_SIA_STOP_HIGH 3\n\n\tint regbase_win = 0x8 + win * 0x04;\n\tu_int8_t ioctl, enable;\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_do_io_map win %d addr 0x%lx size 0x%lx width %d\\n\",\n\t    win, (long)ph->io[win].addr, (long)ph->io[win].size,\n\t    ph->io[win].width * 8));\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_LOW,\n\t    ph->io[win].addr & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_START_HIGH,\n\t    (ph->io[win].addr >> 8) & 0xff);\n\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_LOW,\n\t    (ph->io[win].addr + ph->io[win].size - 1) & 0xff);\n\tPcic_write(ph, regbase_win + PCIC_SIA_STOP_HIGH,\n\t    ((ph->io[win].addr + ph->io[win].size - 1) >> 8) & 0xff);\n\n\tioctl = Pcic_read(ph, PCIC_IOCTL);\n\tenable = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\tioctl &= ~(PCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO0_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO0_DATASIZE_MASK);\n\t\tioctl |= pcic_iowidth[ph->io[win].width];\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\tioctl &= ~(PCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\t    PCIC_IOCTL_IO1_IOCS16SRC_MASK |\n\t\t    PCIC_IOCTL_IO1_DATASIZE_MASK);\n\t\tioctl |= (pcic_iowidth[ph->io[win].width] << 4);\n\t\tenable |= PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_IOCTL, ioctl);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, enable);\n#if defined CBB_DEBUG\n\t{\n\t\tu_int8_t start_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_LOW);\n\t\tu_int8_t start_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_START_HIGH);\n\t\tu_int8_t stop_low =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_LOW);\n\t\tu_int8_t stop_high =\n\t\t    Pcic_read(ph, regbase_win + PCIC_SIA_STOP_HIGH);\n\t\tprintf\n\t\t    (\" start %02x %02x, stop %02x %02x, ioctl %02x enable %02x\\n\",\n\t\t    start_low, start_high, stop_low, stop_high, ioctl, enable);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-0x%lx\"",
            "(u_long) ioaddr + (u_long) size - 1"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_io_map window %d %s port %lx+%lx\\n\",\n\t    win, width_names[width], (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_io_map iot is bogus\""
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_io_map;\nint s;\nstruct pcic_handle *ph = poll->ph;\nint s;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nint\npccbb_pcmcia_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#if defined CBB_DEBUG\n\tstatic char *width_names[] = { \"dynamic\", \"io8\", \"io16\" };\n#endif\n\n\t/* Sanity check I/O handle. */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_iot != pcihp->iot) {\n\t\tpanic(\"pccbb_pcmcia_io_map iot is bogus\");\n\t}\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < PCIC_IO_WINS; i++) {\n\t\tif ((ph->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\tph->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tDPRINTF((\"pccbb_pcmcia_io_map window %d %s port %lx+%lx\\n\",\n\t    win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\t/* XXX wtf is this doing here? */\n\n#if 0\n\tprintf(\" port 0x%lx\", (u_long) ioaddr);\n\tif (size > 1) {\n\t\tprintf(\"-0x%lx\", (u_long) ioaddr + (u_long) size - 1);\n\t}\n#endif\n\n\tph->io[win].addr = ioaddr;\n\tph->io[win].size = size;\n\tph->io[win].width = width;\n\n\t/* actual dirty register-value changing in the function below. */\n\tpccbb_pcmcia_do_io_map(ph, win);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_io_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1873-1896",
    "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
      "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
      "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_free",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
  },
  {
    "function_name": "pccbb_pcmcia_io_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1803-1863",
    "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "STATIC void",
      "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC int",
      "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
      "STATIC void",
      "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
      "STATIC int",
      "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
      "STATIC void",
      "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
      "STATIC void",
      "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
      "STATIC void",
      "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
      "STATIC void",
      "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "iot",
            "0x700/* ph->sc->sc_iobase */",
            "0x800",
            "/* ph->sc->sc_iobase + ph->sc->sc_iosize */size",
            "align",
            "0",
            "0",
            "&ioaddr",
            "&ioh"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "start",
            "size",
            "0",
            "&ioh"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_conf_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1773-1783",
    "snippet": "static void\npccbb_conf_write(cc, tag, reg, val)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n\tint reg;\t\t       /* register offset */\n\tcardbusreg_t val;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\tpci_conf_write(sc->sc_pc, tag, reg, val);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "static void pccbb_conf_write",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "tag",
            "reg",
            "val"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstatic void pccbb_conf_write;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic void\npccbb_conf_write(cc, tag, reg, val)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n\tint reg;\t\t       /* register offset */\n\tcardbusreg_t val;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\tpci_conf_write(sc->sc_pc, tag, reg, val);\n}"
  },
  {
    "function_name": "pccbb_conf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1756-1765",
    "snippet": "static cardbusreg_t\npccbb_conf_read(cc, tag, offset)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n\tint offset;\t\t       /* register offset */\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\treturn pci_conf_read(sc->sc_pc, tag, offset);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "static cardbusreg_t pccbb_conf_read",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "tag",
            "offset"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstatic cardbusreg_t pccbb_conf_read;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic cardbusreg_t\npccbb_conf_read(cc, tag, offset)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n\tint offset;\t\t       /* register offset */\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\treturn pci_conf_read(sc->sc_pc, tag, offset);\n}"
  },
  {
    "function_name": "pccbb_free_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1743-1748",
    "snippet": "static void\npccbb_free_tag(cc, tag)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n{\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "static void pccbb_free_tag"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstatic void pccbb_free_tag;\n\nstatic void\npccbb_free_tag(cc, tag)\n\tcardbus_chipset_tag_t cc;\n\tcardbustag_t tag;\n{\n}"
  },
  {
    "function_name": "pccbb_make_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1733-1741",
    "snippet": "static cardbustag_t\npccbb_make_tag(cc, busno, devno, function)\n\tcardbus_chipset_tag_t cc;\n\tint busno, devno, function;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\treturn pci_make_tag(sc->sc_pc, busno, devno, function);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
      "static cardbustag_t pccbb_make_tag",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_make_tag",
          "args": [
            "sc->sc_pc",
            "busno",
            "devno",
            "function"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nstatic cardbustag_t pccbb_make_tag;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic cardbustag_t\npccbb_make_tag(cc, busno, devno, function)\n\tcardbus_chipset_tag_t cc;\n\tint busno, devno, function;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)cc;\n\n\treturn pci_make_tag(sc->sc_pc, busno, devno, function);\n}"
  },
  {
    "function_name": "cb_show_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1687-1724",
    "snippet": "static void\ncb_show_regs(pc, tag, memt, memh)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n{\n\tint i;\n\tprintf(\"PCI config regs:\");\n\tfor (i = 0; i < 0x50; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\tfor (i = 0x80; i < 0xb0; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\n\tif (memh == 0) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nsocket regs:\");\n\tfor (i = 0; i <= 0x10; i += 0x04) {\n\t\tprintf(\" %08x\", bus_space_read_4(memt, memh, i));\n\t}\n\tprintf(\"\\nExCA regs:\");\n\tfor (i = 0; i < 0x08; ++i) {\n\t\tprintf(\" %02x\", bus_space_read_1(memt, memh, 0x800 + i));\n\t}\n\tprintf(\"\\n\");\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "0x800 + i"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "i"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "i"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "i"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\ncb_show_regs(pc, tag, memt, memh)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n{\n\tint i;\n\tprintf(\"PCI config regs:\");\n\tfor (i = 0; i < 0x50; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\tfor (i = 0x80; i < 0xb0; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\n\tif (memh == 0) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nsocket regs:\");\n\tfor (i = 0; i <= 0x10; i += 0x04) {\n\t\tprintf(\" %08x\", bus_space_read_4(memt, memh, i));\n\t}\n\tprintf(\"\\nExCA regs:\");\n\tfor (i = 0; i < 0x08; ++i) {\n\t\tprintf(\" %02x\", bus_space_read_1(memt, memh, 0x800 + i));\n\t}\n\tprintf(\"\\n\");\n\treturn;\n}"
  },
  {
    "function_name": "pccbb_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1642-1684",
    "snippet": "static void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "static void pccbb_intr_disestablish",
      "__P((cardbus_chipset_tag_t ct, void *ih));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CBCTRL",
            "cbctrl"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CBCTRL"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_intr_disestablish: no interrupt handler\\n\")"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_intr_disestablish frees one pil\\n\")"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pil",
            "M_DEVBUF"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_rbus_cb_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2792-2812",
          "snippet": "static int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
            "pccbb_power __P((cardbus_chipset_tag_t, int));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_rbus_cb_space_free(ct, rb, bsh, size)\n\tcardbus_chipset_tag_t ct;\n\trbus_tag_t rb;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tbus_space_tag_t bt = rb->rb_bt;\n\n\tpccbb_close_win(sc, bt, bsh, size);\n\n\tif (bt == sc->sc_memt) {\n\t} else if (bt == sc->sc_iot) {\n\t} else {\n\t\treturn 1;\n\t\t/* XXX: panic here? */\n\t}\n\n\treturn rbus_space_free(rb, bsh, size, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_intr_disestablish;\n__P((cardbus_chipset_tag_t ct, void *ih));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pccbb_cb_intr_disestablish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1555-1563",
    "snippet": "static void\npccbb_cb_intr_disestablish(ct, ih)\n\tcardbus_chipset_tag_t ct;\n\tvoid *ih;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tpccbb_intr_disestablish(sc, ih);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "static void pccbb_intr_disestablish",
      "static void pccbb_cb_intr_disestablish",
      "__P((cardbus_chipset_tag_t ct, void *ih));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_intr_disestablish",
          "args": [
            "sc",
            "ih"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1642-1684",
          "snippet": "static void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "static void pccbb_intr_disestablish",
            "__P((cardbus_chipset_tag_t ct, void *ih));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_intr_disestablish;\n__P((cardbus_chipset_tag_t ct, void *ih));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic void\npccbb_intr_disestablish(sc, ih)\n\tstruct pccbb_softc *sc;\n\tvoid *ih;\n{\n\tstruct pccbb_intrhand_list *pil, **pil_prev;\n\n\tDPRINTF((\"pccbb_intr_disestablish start. %p\\n\", sc->sc_pil));\n\n\tpil_prev = &sc->sc_pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tif (pil == ih) {\n\t\t\t*pil_prev = pil->pil_next;\n\t\t\tfree(pil, M_DEVBUF);\n\t\t\tDPRINTF((\"pccbb_intr_disestablish frees one pil\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tpil_prev = &pil->pil_next;\n\t}\n\n\tif (sc->sc_pil == NULL) {\n\t\t/* No interrupt handlers */\n\n\t\tDPRINTF((\"pccbb_intr_disestablish: no interrupt handler\\n\"));\n\n\t\tswitch (sc->sc_chipset) {\n\t\tcase CB_TI113X:\n\t\t\t{\n\t\t\t\tpcireg_t cbctrl =\n\t\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL);\n\t\t\t\t/* functional intr disabled */\n\t\t\t\tcbctrl &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t\t    PCI_CBCTRL, cbctrl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstatic void pccbb_intr_disestablish;\nstatic void pccbb_cb_intr_disestablish;\n__P((cardbus_chipset_tag_t ct, void *ih));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic void\npccbb_cb_intr_disestablish(ct, ih)\n\tcardbus_chipset_tag_t ct;\n\tvoid *ih;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tpccbb_intr_disestablish(sc, ih);\n}"
  },
  {
    "function_name": "pccbb_mem_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1498-1520",
    "snippet": "static int\npccbb_mem_close(ct, win)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_mem_close: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x1c;\n\tlimitreg = win * 8 + 0x20;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "limitreg",
            "0"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "basereg",
            "0"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_mem_close: window out of range %d\\n\"",
            "win"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_mem_close(ct, win)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_mem_close: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x1c;\n\tlimitreg = win * 8 + 0x20;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "pccbb_mem_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1470-1493",
    "snippet": "static int\npccbb_mem_open(ct, win, start, end)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n\tu_int32_t start, end;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_mem_open: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x1c;\n\tlimitreg = win * 8 + 0x20;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "limitreg",
            "end"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "basereg",
            "start"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_mem_open: window out of range %d\\n\"",
            "win"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_mem_open(ct, win, start, end)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n\tu_int32_t start, end;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_mem_open: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x1c;\n\tlimitreg = win * 8 + 0x20;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);\n\treturn 1;\n}"
  },
  {
    "function_name": "pccbb_io_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1443-1465",
    "snippet": "static int\npccbb_io_close(ct, win)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_io_close: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x2c;\n\tlimitreg = win * 8 + 0x30;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "limitreg",
            "0"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "basereg",
            "0"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_io_close: window out of range %d\\n\"",
            "win"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_io_close(ct, win)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_io_close: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x2c;\n\tlimitreg = win * 8 + 0x30;\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, 0);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "pccbb_io_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1412-1438",
    "snippet": "static int\npccbb_io_open(ct, win, start, end)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n\tu_int32_t start, end;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_io_open: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x2c;\n\tlimitreg = win * 8 + 0x30;\n\n\tDPRINTF((\"pccbb_io_open: 0x%x[0x%x] - 0x%x[0x%x]\\n\",\n\t    start, basereg, end, limitreg));\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "limitreg",
            "end"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "basereg",
            "start"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_io_open: 0x%x[0x%x] - 0x%x[0x%x]\\n\",\n\t    start, basereg, end, limitreg)"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cardbus_io_open: window out of range %d\\n\"",
            "win"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\npccbb_power __P((cardbus_chipset_tag_t, int));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_io_open(ct, win, start, end)\n\tcardbus_chipset_tag_t ct;\n\tint win;\n\tu_int32_t start, end;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\tint basereg;\n\tint limitreg;\n\n\tif ((win < 0) || (win > 2)) {\n#if defined DIAGNOSTIC\n\t\tprintf(\"cardbus_io_open: window out of range %d\\n\", win);\n#endif\n\t\treturn 0;\n\t}\n\n\tbasereg = win * 8 + 0x2c;\n\tlimitreg = win * 8 + 0x30;\n\n\tDPRINTF((\"pccbb_io_open: 0x%x[0x%x] - 0x%x[0x%x]\\n\",\n\t    start, basereg, end, limitreg));\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, basereg, start);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, limitreg, end);\n\treturn 1;\n}"
  },
  {
    "function_name": "pccbb_cardenable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1371-1406",
    "snippet": "STATIC int\npccbb_cardenable(sc, function)\n\tstruct pccbb_softc *sc;\n\tint function;\n{\n\tu_int32_t command =\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tDPRINTF((\"pccbb_cardenable:\"));\n\tswitch (function) {\n\tcase CARDBUS_IO_ENABLE:\n\t\tcommand |= PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_IO_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\tDPRINTF((\" command reg 0x%x\\n\", command));\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" command reg 0x%x\\n\", command)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_cardenable:\")"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\npccbb_cardenable(sc, function)\n\tstruct pccbb_softc *sc;\n\tint function;\n{\n\tu_int32_t command =\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tDPRINTF((\"pccbb_cardenable:\"));\n\tswitch (function) {\n\tcase CARDBUS_IO_ENABLE:\n\t\tcommand |= PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_IO_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\tDPRINTF((\" command reg 0x%x\\n\", command));\n\treturn 1;\n}"
  },
  {
    "function_name": "cbbprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1352-1365",
    "snippet": "STATIC int\ncbbprint(aux, pcic)\n\tvoid *aux;\n\tconst char *pcic;\n{\n/*\n  struct cbslot_attach_args *cba = aux;\n\n  if (cba->cba_slot >= 0) {\n    printf(\" slot %d\", cba->cba_slot);\n  }\n*/\n\treturn UNCONF;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\n\nSTATIC int\ncbbprint(aux, pcic)\n\tvoid *aux;\n\tconst char *pcic;\n{\n/*\n  struct cbslot_attach_args *cba = aux;\n\n  if (cba->cba_slot >= 0) {\n    printf(\" slot %d\", cba->cba_slot);\n  }\n*/\n\treturn UNCONF;\n}"
  },
  {
    "function_name": "cb_detect_voltage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1331-1350",
    "snippet": "STATIC int\ncb_detect_voltage(sc)\n\tstruct pccbb_softc *sc;\n{\n\tu_int32_t psr;\t\t       /* socket present-state reg */\n\tbus_space_tag_t iot = sc->sc_base_memt;\n\tbus_space_handle_t ioh = sc->sc_base_memh;\n\tint vol = PCCARD_VCC_UKN;      /* set 0 */\n\n\tpsr = bus_space_read_4(iot, ioh, CB_SOCKET_STAT);\n\n\tif (0x400u & psr) {\n\t\tvol |= PCCARD_VCC_5V;\n\t}\n\tif (0x800u & psr) {\n\t\tvol |= PCCARD_VCC_3V;\n\t}\n\n\treturn vol;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "iot",
            "ioh",
            "CB_SOCKET_STAT"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\ncb_detect_voltage(sc)\n\tstruct pccbb_softc *sc;\n{\n\tu_int32_t psr;\t\t       /* socket present-state reg */\n\tbus_space_tag_t iot = sc->sc_base_memt;\n\tbus_space_handle_t ioh = sc->sc_base_memh;\n\tint vol = PCCARD_VCC_UKN;      /* set 0 */\n\n\tpsr = bus_space_read_4(iot, ioh, CB_SOCKET_STAT);\n\n\tif (0x400u & psr) {\n\t\tvol |= PCCARD_VCC_5V;\n\t}\n\tif (0x800u & psr) {\n\t\tvol |= PCCARD_VCC_3V;\n\t}\n\n\treturn vol;\n}"
  },
  {
    "function_name": "cb_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1302-1325",
    "snippet": "STATIC int\ncb_reset(sc)\n\tstruct pccbb_softc *sc;\n{\n\t/* \n\t * Reset Assert at least 20 ms \n\t * Some machines request longer duration.\n\t */\n\tint reset_duration =\n\t    (sc->sc_chipset == CB_RX5C47X ? 400 * 1000 : 40 * 1000);\n\tu_int32_t bcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);\n\n\tbcr |= (0x40 << 16);\t       /* Reset bit Assert (bit 6 at 0x3E) */\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\tdelay(reset_duration);\n\n\tif (CBB_CARDEXIST & sc->sc_flags) {\t/* A card exists.  Reset it! */\n\t\tbcr &= ~(0x40 << 16);  /* Reset bit Deassert (bit 6 at 0x3E) */\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\t\tdelay(reset_duration);\n\t}\n\t/* No card found on the slot. Keep Reset. */\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "reset_duration"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_BCR_INTR",
            "bcr"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_BCR_INTR",
            "bcr"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_BCR_INTR"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\ncb_reset(sc)\n\tstruct pccbb_softc *sc;\n{\n\t/* \n\t * Reset Assert at least 20 ms \n\t * Some machines request longer duration.\n\t */\n\tint reset_duration =\n\t    (sc->sc_chipset == CB_RX5C47X ? 400 * 1000 : 40 * 1000);\n\tu_int32_t bcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);\n\n\tbcr |= (0x40 << 16);\t       /* Reset bit Assert (bit 6 at 0x3E) */\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\tdelay(reset_duration);\n\n\tif (CBB_CARDEXIST & sc->sc_flags) {\t/* A card exists.  Reset it! */\n\t\tbcr &= ~(0x40 << 16);  /* Reset bit Deassert (bit 6 at 0x3E) */\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\t\tdelay(reset_duration);\n\t}\n\t/* No card found on the slot. Keep Reset. */\n\treturn 1;\n}"
  },
  {
    "function_name": "pccbb_detect_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1271-1296",
    "snippet": "static int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pccbb_detect_card",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_STAT"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbb_detect_card;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "pccbb_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1077-1203",
    "snippet": "STATIC int\npccbb_power(ct, command)\n\tcardbus_chipset_tag_t ct;\n\tint command;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tu_int32_t status, sock_ctrl;\n\tbus_space_tag_t memt = sc->sc_base_memt;\n\tbus_space_handle_t memh = sc->sc_base_memh;\n\n\tDPRINTF((\"pccbb_power: %s and %s [%x]\\n\",\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" :\n\t    \"UNKNOWN\",\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" :\n\t    \"UNKNOWN\", command));\n\n\tstatus = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\tsock_ctrl = bus_space_read_4(memt, memh, CB_SOCKET_CTRL);\n\n\tswitch (command & CARDBUS_VCCMASK) {\n\tcase CARDBUS_VCC_UC:\n\t\tbreak;\n\tcase CARDBUS_VCC_5V:\n\t\tif (CB_SOCKET_STAT_5VCARD & status) {\t/* check 5 V card */\n\t\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\t\tsock_ctrl |= CB_SOCKET_CTRL_VCC_5V;\n\t\t} else {\n\t\t\tprintf(\"%s: BAD voltage request: no 5 V card\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_VCC_3V:\n\t\tif (CB_SOCKET_STAT_3VCARD & status) {\n\t\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\t\tsock_ctrl |= CB_SOCKET_CTRL_VCC_3V;\n\t\t} else {\n\t\t\tprintf(\"%s: BAD voltage request: no 3.3 V card\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_VCC_0V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\t       /* power NEVER changed */\n\t\tbreak;\n\t}\n\n\tswitch (command & CARDBUS_VPPMASK) {\n\tcase CARDBUS_VPP_UC:\n\t\tbreak;\n\tcase CARDBUS_VPP_0V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tbreak;\n\tcase CARDBUS_VPP_VCC:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tsock_ctrl |= ((sock_ctrl >> 4) & 0x07);\n\t\tbreak;\n\tcase CARDBUS_VPP_12V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tsock_ctrl |= CB_SOCKET_CTRL_VPP_12V;\n\t\tbreak;\n\t}\n\n#if 0\n\tDPRINTF((\"sock_ctrl: %x\\n\", sock_ctrl));\n#endif\n\tbus_space_write_4(memt, memh, CB_SOCKET_CTRL, sock_ctrl);\n\tstatus = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\n\tdelay(20 * 1000);\t       /* wait 20 ms: Vcc setup time */\n\t/*\n\t * XXX delay 200 ms: though the standard defines that the Vcc set-up\n\t * time is 20 ms, some PC-Card bridge requires longer duration.\n\t */\n\tdelay(200 * 1000);\n\n\tif (status & CB_SOCKET_STAT_BADVCC) {\t/* bad Vcc request */\n\t\tprintf\n\t\t    (\"%s: bad Vcc request. sock_ctrl 0x%x, sock_status 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_ctrl, status);\n\t\tDPRINTF((\"pccbb_power: %s and %s [%x]\\n\",\n\t\t    (command & CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" : \"UNKNOWN\",\n\t\t    (command & CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" : \"UNKNOWN\", command));\n#if 0\n\t\tif (command == (CARDBUS_VCC_0V | CARDBUS_VPP_0V)) {\n\t\t\tu_int32_t force =\n\t\t\t    bus_space_read_4(memt, memh, CB_SOCKET_FORCE);\n\t\t\t/* Reset Bad Vcc request */\n\t\t\tforce &= ~CB_SOCKET_FORCE_BADVCC;\n\t\t\tbus_space_write_4(memt, memh, CB_SOCKET_FORCE, force);\n\t\t\tprintf(\"new status 0x%x\\n\", bus_space_read_4(memt, memh,\n\t\t\t    CB_SOCKET_STAT));\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\treturn 1;\t\t       /* power changed correctly */\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "STATIC int",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"new status 0x%x\\n\"",
            "bus_space_read_4(memt, memh,\n\t\t\t    CB_SOCKET_STAT)"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_STAT"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_FORCE",
            "force"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_FORCE"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_power: %s and %s [%x]\\n\",\n\t\t    (command & CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" : \"UNKNOWN\",\n\t\t    (command & CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" : \"UNKNOWN\", command)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200 * 1000"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_STAT"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_CTRL",
            "sock_ctrl"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sock_ctrl: %x\\n\", sock_ctrl)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_CTRL"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_STAT"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbb_power: %s and %s [%x]\\n\",\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" :\n\t    \"UNKNOWN\",\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" :\n\t    \"UNKNOWN\", command)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\nSTATIC int;\npccbb_power __P((cardbus_chipset_tag_t, int));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nSTATIC int\npccbb_power(ct, command)\n\tcardbus_chipset_tag_t ct;\n\tint command;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tu_int32_t status, sock_ctrl;\n\tbus_space_tag_t memt = sc->sc_base_memt;\n\tbus_space_handle_t memh = sc->sc_base_memh;\n\n\tDPRINTF((\"pccbb_power: %s and %s [%x]\\n\",\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" :\n\t    (command & CARDBUS_VCCMASK) == CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" :\n\t    \"UNKNOWN\",\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" :\n\t    (command & CARDBUS_VPPMASK) == CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" :\n\t    \"UNKNOWN\", command));\n\n\tstatus = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\tsock_ctrl = bus_space_read_4(memt, memh, CB_SOCKET_CTRL);\n\n\tswitch (command & CARDBUS_VCCMASK) {\n\tcase CARDBUS_VCC_UC:\n\t\tbreak;\n\tcase CARDBUS_VCC_5V:\n\t\tif (CB_SOCKET_STAT_5VCARD & status) {\t/* check 5 V card */\n\t\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\t\tsock_ctrl |= CB_SOCKET_CTRL_VCC_5V;\n\t\t} else {\n\t\t\tprintf(\"%s: BAD voltage request: no 5 V card\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_VCC_3V:\n\t\tif (CB_SOCKET_STAT_3VCARD & status) {\n\t\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\t\tsock_ctrl |= CB_SOCKET_CTRL_VCC_3V;\n\t\t} else {\n\t\t\tprintf(\"%s: BAD voltage request: no 3.3 V card\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_VCC_0V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VCCMASK;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\t       /* power NEVER changed */\n\t\tbreak;\n\t}\n\n\tswitch (command & CARDBUS_VPPMASK) {\n\tcase CARDBUS_VPP_UC:\n\t\tbreak;\n\tcase CARDBUS_VPP_0V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tbreak;\n\tcase CARDBUS_VPP_VCC:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tsock_ctrl |= ((sock_ctrl >> 4) & 0x07);\n\t\tbreak;\n\tcase CARDBUS_VPP_12V:\n\t\tsock_ctrl &= ~CB_SOCKET_CTRL_VPPMASK;\n\t\tsock_ctrl |= CB_SOCKET_CTRL_VPP_12V;\n\t\tbreak;\n\t}\n\n#if 0\n\tDPRINTF((\"sock_ctrl: %x\\n\", sock_ctrl));\n#endif\n\tbus_space_write_4(memt, memh, CB_SOCKET_CTRL, sock_ctrl);\n\tstatus = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\n\tdelay(20 * 1000);\t       /* wait 20 ms: Vcc setup time */\n\t/*\n\t * XXX delay 200 ms: though the standard defines that the Vcc set-up\n\t * time is 20 ms, some PC-Card bridge requires longer duration.\n\t */\n\tdelay(200 * 1000);\n\n\tif (status & CB_SOCKET_STAT_BADVCC) {\t/* bad Vcc request */\n\t\tprintf\n\t\t    (\"%s: bad Vcc request. sock_ctrl 0x%x, sock_status 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_ctrl, status);\n\t\tDPRINTF((\"pccbb_power: %s and %s [%x]\\n\",\n\t\t    (command & CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_UC ? \"CARDBUS_VCC_UC\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_5V ? \"CARDBUS_VCC_5V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_3V ? \"CARDBUS_VCC_3V\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_XV ? \"CARDBUS_VCC_XV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_YV ? \"CARDBUS_VCC_YV\" : (command &\n\t\t    CARDBUS_VCCMASK) ==\n\t\t    CARDBUS_VCC_0V ? \"CARDBUS_VCC_0V\" : \"UNKNOWN\",\n\t\t    (command & CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_UC ? \"CARDBUS_VPP_UC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_12V ? \"CARDBUS_VPP_12V\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_VCC ? \"CARDBUS_VPP_VCC\" : (command &\n\t\t    CARDBUS_VPPMASK) ==\n\t\t    CARDBUS_VPP_0V ? \"CARDBUS_VPP_0V\" : \"UNKNOWN\", command));\n#if 0\n\t\tif (command == (CARDBUS_VCC_0V | CARDBUS_VPP_0V)) {\n\t\t\tu_int32_t force =\n\t\t\t    bus_space_read_4(memt, memh, CB_SOCKET_FORCE);\n\t\t\t/* Reset Bad Vcc request */\n\t\t\tforce &= ~CB_SOCKET_FORCE_BADVCC;\n\t\t\tbus_space_write_4(memt, memh, CB_SOCKET_FORCE, force);\n\t\t\tprintf(\"new status 0x%x\\n\", bus_space_read_4(memt, memh,\n\t\t\t    CB_SOCKET_STAT));\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\treturn 1;\t\t       /* power changed correctly */\n}"
  },
  {
    "function_name": "pccbb_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1027-1070",
    "snippet": "STATIC int\npccbb_ctrl(ct, command)\n\tcardbus_chipset_tag_t ct;\n\tint command;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tswitch (command) {\n\tcase CARDBUS_CD:\n\t\tif (2 == pccbb_detect_card(sc)) {\n\t\t\tint retval = 0;\n\t\t\tint status = cb_detect_voltage(sc);\n\t\t\tif (PCCARD_VCC_5V & status) {\n\t\t\t\tretval |= CARDBUS_5V_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_3V & status) {\n\t\t\t\tretval |= CARDBUS_3V_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_XV & status) {\n\t\t\t\tretval |= CARDBUS_XV_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_YV & status) {\n\t\t\t\tretval |= CARDBUS_YV_CARD;\n\t\t\t}\n\t\t\treturn retval;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_RESET:\n\t\treturn cb_reset(sc);\n\t\tbreak;\n\tcase CARDBUS_IO_ENABLE:       /* fallthrough */\n\tcase CARDBUS_IO_DISABLE:      /* fallthrough */\n\tcase CARDBUS_MEM_ENABLE:      /* fallthrough */\n\tcase CARDBUS_MEM_DISABLE:     /* fallthrough */\n\tcase CARDBUS_BM_ENABLE:       /* fallthrough */\n\tcase CARDBUS_BM_DISABLE:      /* fallthrough */\n\t\treturn pccbb_cardenable(sc, command);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "static int pccbb_detect_card",
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "pccbb_ctrl __P((cardbus_chipset_tag_t, int));",
      "STATIC int",
      "pccbb_power __P((cardbus_chipset_tag_t, int));",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_cardenable",
          "args": [
            "sc",
            "command"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_cardenable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1371-1406",
          "snippet": "STATIC int\npccbb_cardenable(sc, function)\n\tstruct pccbb_softc *sc;\n\tint function;\n{\n\tu_int32_t command =\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tDPRINTF((\"pccbb_cardenable:\"));\n\tswitch (function) {\n\tcase CARDBUS_IO_ENABLE:\n\t\tcommand |= PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_IO_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\tDPRINTF((\" command reg 0x%x\\n\", command));\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\npccbb_cardenable(sc, function)\n\tstruct pccbb_softc *sc;\n\tint function;\n{\n\tu_int32_t command =\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tDPRINTF((\"pccbb_cardenable:\"));\n\tswitch (function) {\n\tcase CARDBUS_IO_ENABLE:\n\t\tcommand |= PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_IO_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_IO_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_MEM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MEM_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_ENABLE:\n\t\tcommand |= PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tcase CARDBUS_BM_DISABLE:\n\t\tcommand &= ~PCI_COMMAND_MASTER_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\tDPRINTF((\" command reg 0x%x\\n\", command));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_reset",
          "args": [
            "sc"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "cb_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1302-1325",
          "snippet": "STATIC int\ncb_reset(sc)\n\tstruct pccbb_softc *sc;\n{\n\t/* \n\t * Reset Assert at least 20 ms \n\t * Some machines request longer duration.\n\t */\n\tint reset_duration =\n\t    (sc->sc_chipset == CB_RX5C47X ? 400 * 1000 : 40 * 1000);\n\tu_int32_t bcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);\n\n\tbcr |= (0x40 << 16);\t       /* Reset bit Assert (bit 6 at 0x3E) */\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\tdelay(reset_duration);\n\n\tif (CBB_CARDEXIST & sc->sc_flags) {\t/* A card exists.  Reset it! */\n\t\tbcr &= ~(0x40 << 16);  /* Reset bit Deassert (bit 6 at 0x3E) */\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\t\tdelay(reset_duration);\n\t}\n\t/* No card found on the slot. Keep Reset. */\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\ncb_reset(sc)\n\tstruct pccbb_softc *sc;\n{\n\t/* \n\t * Reset Assert at least 20 ms \n\t * Some machines request longer duration.\n\t */\n\tint reset_duration =\n\t    (sc->sc_chipset == CB_RX5C47X ? 400 * 1000 : 40 * 1000);\n\tu_int32_t bcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR);\n\n\tbcr |= (0x40 << 16);\t       /* Reset bit Assert (bit 6 at 0x3E) */\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\tdelay(reset_duration);\n\n\tif (CBB_CARDEXIST & sc->sc_flags) {\t/* A card exists.  Reset it! */\n\t\tbcr &= ~(0x40 << 16);  /* Reset bit Deassert (bit 6 at 0x3E) */\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_BCR_INTR, bcr);\n\t\tdelay(reset_duration);\n\t}\n\t/* No card found on the slot. Keep Reset. */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_detect_voltage",
          "args": [
            "sc"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "cb_detect_voltage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1331-1350",
          "snippet": "STATIC int\ncb_detect_voltage(sc)\n\tstruct pccbb_softc *sc;\n{\n\tu_int32_t psr;\t\t       /* socket present-state reg */\n\tbus_space_tag_t iot = sc->sc_base_memt;\n\tbus_space_handle_t ioh = sc->sc_base_memh;\n\tint vol = PCCARD_VCC_UKN;      /* set 0 */\n\n\tpsr = bus_space_read_4(iot, ioh, CB_SOCKET_STAT);\n\n\tif (0x400u & psr) {\n\t\tvol |= PCCARD_VCC_5V;\n\t}\n\tif (0x800u & psr) {\n\t\tvol |= PCCARD_VCC_3V;\n\t}\n\n\treturn vol;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\ncb_detect_voltage(sc)\n\tstruct pccbb_softc *sc;\n{\n\tu_int32_t psr;\t\t       /* socket present-state reg */\n\tbus_space_tag_t iot = sc->sc_base_memt;\n\tbus_space_handle_t ioh = sc->sc_base_memh;\n\tint vol = PCCARD_VCC_UKN;      /* set 0 */\n\n\tpsr = bus_space_read_4(iot, ioh, CB_SOCKET_STAT);\n\n\tif (0x400u & psr) {\n\t\tvol |= PCCARD_VCC_5V;\n\t}\n\tif (0x800u & psr) {\n\t\tvol |= PCCARD_VCC_3V;\n\t}\n\n\treturn vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_detect_card",
          "args": [
            "sc"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_detect_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1271-1296",
          "snippet": "static int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pccbb_detect_card",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbb_detect_card;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbb_detect_card(sc)\n\tstruct pccbb_softc *sc;\n{\n\tbus_space_handle_t base_memh = sc->sc_base_memh;\n\tbus_space_tag_t base_memt = sc->sc_base_memt;\n\tu_int32_t sockstat =\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\tint retval = 0;\n\n\t/* CD1 and CD2 asserted */\n\tif (0x00 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t/* card must be present */\n\t\tif (!(CB_SOCKET_STAT_NOTCARD & sockstat)) {\n\t\t\t/* NOTACARD DEASSERTED */\n\t\t\tif (CB_SOCKET_STAT_CB & sockstat) {\n\t\t\t\t/* CardBus mode */\n\t\t\t\tretval = 2;\n\t\t\t} else if (CB_SOCKET_STAT_16BIT & sockstat) {\n\t\t\t\t/* 16-bit mode */\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nstatic int pccbb_detect_card;\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_ctrl __P((cardbus_chipset_tag_t, int));\nSTATIC int;\npccbb_power __P((cardbus_chipset_tag_t, int));\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_cb_intr_establish(ct, irq, level, func, arg)\n\tcardbus_chipset_tag_t ct;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nSTATIC int\npccbb_ctrl(ct, command)\n\tcardbus_chipset_tag_t ct;\n\tint command;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ct;\n\n\tswitch (command) {\n\tcase CARDBUS_CD:\n\t\tif (2 == pccbb_detect_card(sc)) {\n\t\t\tint retval = 0;\n\t\t\tint status = cb_detect_voltage(sc);\n\t\t\tif (PCCARD_VCC_5V & status) {\n\t\t\t\tretval |= CARDBUS_5V_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_3V & status) {\n\t\t\t\tretval |= CARDBUS_3V_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_XV & status) {\n\t\t\t\tretval |= CARDBUS_XV_CARD;\n\t\t\t}\n\t\t\tif (PCCARD_VCC_YV & status) {\n\t\t\t\tretval |= CARDBUS_YV_CARD;\n\t\t\t}\n\t\t\treturn retval;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase CARDBUS_RESET:\n\t\treturn cb_reset(sc);\n\t\tbreak;\n\tcase CARDBUS_IO_ENABLE:       /* fallthrough */\n\tcase CARDBUS_IO_DISABLE:      /* fallthrough */\n\tcase CARDBUS_MEM_ENABLE:      /* fallthrough */\n\tcase CARDBUS_MEM_DISABLE:     /* fallthrough */\n\tcase CARDBUS_BM_ENABLE:       /* fallthrough */\n\tcase CARDBUS_BM_DISABLE:      /* fallthrough */\n\t\treturn pccbb_cardenable(sc, command);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1014-1022",
    "snippet": "static void\npccbb_pcmcia_write(ph, reg, val)\n\tstruct pcic_handle *ph;\n\tint reg;\n\tu_int8_t val;\n{\n\tbus_space_write_1(ph->ph_bus_t, ph->ph_bus_h, PCCBB_PCMCIA_OFFSET + reg,\n\t    val);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define PCCBB_PCMCIA_OFFSET 0x800"
    ],
    "globals_used": [
      "static void pccbb_pcmcia_write",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "ph->ph_bus_t",
            "ph->ph_bus_h",
            "PCCBB_PCMCIA_OFFSET + reg",
            "val"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCCBB_PCMCIA_OFFSET 0x800\n\nstatic void pccbb_pcmcia_write;\nstruct pcic_handle *ph = poll->ph;\n\nstatic void\npccbb_pcmcia_write(ph, reg, val)\n\tstruct pcic_handle *ph;\n\tint reg;\n\tu_int8_t val;\n{\n\tbus_space_write_1(ph->ph_bus_t, ph->ph_bus_h, PCCBB_PCMCIA_OFFSET + reg,\n\t    val);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "1005-1012",
    "snippet": "static u_int8_t\npccbb_pcmcia_read(ph, reg)\n\tstruct pcic_handle *ph;\n\tint reg;\n{\n\treturn bus_space_read_1(ph->ph_bus_t, ph->ph_bus_h,\n\t    PCCBB_PCMCIA_OFFSET + reg);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define PCCBB_PCMCIA_OFFSET 0x800"
    ],
    "globals_used": [
      "static u_int8_t pccbb_pcmcia_read",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "ph->ph_bus_t",
            "ph->ph_bus_h",
            "PCCBB_PCMCIA_OFFSET + reg"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define PCCBB_PCMCIA_OFFSET 0x800\n\nstatic u_int8_t pccbb_pcmcia_read;\nstruct pcic_handle *ph = poll->ph;\n\nstatic u_int8_t\npccbb_pcmcia_read(ph, reg)\n\tstruct pcic_handle *ph;\n\tint reg;\n{\n\treturn bus_space_read_1(ph->ph_bus_t, ph->ph_bus_h,\n\t    PCCBB_PCMCIA_OFFSET + reg);\n}"
  },
  {
    "function_name": "pci113x_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "969-1002",
    "snippet": "static void\npci113x_insert(arg)\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)arg;\n\tu_int32_t sockevent, sockstate;\n\n\tsockevent = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_EVENT);\n\tsockstate = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_STAT);\n\n\tif (0 == (sockstate & CB_SOCKET_STAT_CD)) {\t/* card exist */\n\t\tDPRINTF((\"%s: 0x%08x\", sc->sc_dev.dv_xname, sockevent));\n\t\tDPRINTF((\" card inserted, 0x%08x\\n\", sockstate));\n\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t/* call pccard interrupt handler here */\n\t\tif (sockstate & CB_SOCKET_STAT_16BIT) {\n\t\t\t/* 16-bit card found */\n/*      pccbb_pcmcia_attach_card(&sc->sc_pcmcia_h); */\n\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t    CARDSLOT_EVENT_INSERTION_16);\n\t\t} else if (sockstate & CB_SOCKET_STAT_CB) {\n\t\t\t/* cardbus card found */\n/*      cardbus_attach_card(sc->sc_csc); */\n\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t    CARDSLOT_EVENT_INSERTION_CB);\n\t\t} else {\n\t\t\t/* who are you? */\n\t\t}\n\t} else {\n\t\ttimeout(pci113x_insert, sc, hz / 10);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pci113x_insert",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "void *arg;",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "void *arg;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "void *arg;",
      "void *arg;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;",
      "void *arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "pci113x_insert",
            "sc",
            "hz / 10"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardslot_event_throw",
          "args": [
            "sc->sc_csc",
            "CARDSLOT_EVENT_INSERTION_CB"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "cardslot_event_throw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
          "lines": "260-288",
          "snippet": "void\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/kthread.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" card inserted, 0x%08x\\n\", sockstate)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: 0x%08x\", sc->sc_dev.dv_xname, sockevent)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->sc_base_memt",
            "sc->sc_base_memh",
            "CB_SOCKET_STAT"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->sc_base_memt",
            "sc->sc_base_memh",
            "CB_SOCKET_EVENT"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void pci113x_insert;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nstatic void\npci113x_insert(arg)\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)arg;\n\tu_int32_t sockevent, sockstate;\n\n\tsockevent = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_EVENT);\n\tsockstate = bus_space_read_4(sc->sc_base_memt, sc->sc_base_memh,\n\t    CB_SOCKET_STAT);\n\n\tif (0 == (sockstate & CB_SOCKET_STAT_CD)) {\t/* card exist */\n\t\tDPRINTF((\"%s: 0x%08x\", sc->sc_dev.dv_xname, sockevent));\n\t\tDPRINTF((\" card inserted, 0x%08x\\n\", sockstate));\n\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t/* call pccard interrupt handler here */\n\t\tif (sockstate & CB_SOCKET_STAT_16BIT) {\n\t\t\t/* 16-bit card found */\n/*      pccbb_pcmcia_attach_card(&sc->sc_pcmcia_h); */\n\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t    CARDSLOT_EVENT_INSERTION_16);\n\t\t} else if (sockstate & CB_SOCKET_STAT_CB) {\n\t\t\t/* cardbus card found */\n/*      cardbus_attach_card(sc->sc_csc); */\n\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t    CARDSLOT_EVENT_INSERTION_CB);\n\t\t} else {\n\t\t\t/* who are you? */\n\t\t}\n\t} else {\n\t\ttimeout(pci113x_insert, sc, hz / 10);\n\t}\n}"
  },
  {
    "function_name": "pccbbintr_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "953-967",
    "snippet": "static int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int pccbbintr_function",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "pil->pil_arg"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbbintr_function;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "pccbbintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "881-945",
    "snippet": "int\npccbbintr(arg)\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)arg;\n\tu_int32_t sockevent, sockstate;\n\tbus_space_tag_t memt = sc->sc_base_memt;\n\tbus_space_handle_t memh = sc->sc_base_memh;\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n\n\tsockevent = bus_space_read_4(memt, memh, CB_SOCKET_EVENT);\n\tbus_space_write_4(memt, memh, CB_SOCKET_EVENT, sockevent);\n\tPcic_read(ph, PCIC_CSC);\n\n\tif (sockevent == 0) {\n\t\t/* This intr is not for me: it may be for my child devices. */\n\t\treturn (pccbbintr_function(sc));\n\t}\n\n\tif (sockevent & CB_SOCKET_EVENT_CD) {\n\t\tsockstate = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\t\tif (CB_SOCKET_STAT_CD == (sockstate & CB_SOCKET_STAT_CD)) {\n\t\t\t/* A card should be removed. */\n\t\t\tif (sc->sc_flags & CBB_CARDEXIST) {\n\t\t\t\tDPRINTF((\"%s: 0x%08x\", sc->sc_dev.dv_xname,\n\t\t\t\t    sockevent));\n\t\t\t\tDPRINTF((\" card removed, 0x%08x\\n\", sockstate));\n\t\t\t\tsc->sc_flags &= ~CBB_CARDEXIST;\n\t\t\t\tif (sc->sc_csc->sc_status &\n\t\t\t\t    CARDSLOT_STATUS_CARD_16) {\n#if 0\n\t\t\t\t\tstruct pcic_handle *ph =\n\t\t\t\t\t    &sc->sc_pcmcia_h;\n\n\t\t\t\t\tpcmcia_card_deactivate(ph->pcmcia);\n\t\t\t\t\tpccbb_pcmcia_socket_disable(ph);\n\t\t\t\t\tpccbb_pcmcia_detach_card(ph,\n\t\t\t\t\t    DETACH_FORCE);\n#endif\n\t\t\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t\t\t    CARDSLOT_EVENT_REMOVAL_16);\n\t\t\t\t} else if (sc->sc_csc->sc_status &\n\t\t\t\t    CARDSLOT_STATUS_CARD_CB) {\n\t\t\t\t\t/* Cardbus intr removed */\n\t\t\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t\t\t    CARDSLOT_EVENT_REMOVAL_CB);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (0x00 == (sockstate & CB_SOCKET_STAT_CD) &&\n\t\t    /*\n\t\t     * The pccbbintr may called from powerdown hook when\n\t\t     * the system resumed, to detect the card\n\t\t     * insertion/removal during suspension.\n\t\t     */\n\t\t    (sc->sc_flags & CBB_CARDEXIST) == 0) {\n\t\t\tif (sc->sc_flags & CBB_INSERTING) {\n\t\t\t\tuntimeout(pci113x_insert, sc);\n\t\t\t}\n\t\t\ttimeout(pci113x_insert, sc, hz / 10);\n\t\t\tsc->sc_flags |= CBB_INSERTING;\n\t\t}\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pccbbintr",
      "static void pci113x_insert",
      "static int pccbbintr_function",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "void *arg;",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "void *arg;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "void *arg;",
      "void *arg;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;",
      "void *arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "pci113x_insert",
            "sc",
            "hz / 10"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "pci113x_insert",
            "sc"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardslot_event_throw",
          "args": [
            "sc->sc_csc",
            "CARDSLOT_EVENT_REMOVAL_CB"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "cardslot_event_throw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardslot.c",
          "lines": "260-288",
          "snippet": "void\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/kthread.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <machine/bus.h>\n#include <sys/kthread.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\ncardslot_event_throw(sc, ev)\n     struct cardslot_softc *sc;\n     int ev;\n{\n  struct cardslot_event *ce;\n\n  DPRINTF((\"cardslot_event_throw: an event %s comes\\n\",\n\t   ev == CARDSLOT_EVENT_INSERTION_CB ? \"CardBus Card inserted\" :\n\t   ev == CARDSLOT_EVENT_INSERTION_16 ? \"16-bit Card inserted\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_CB ? \"CardBus Card removed\" :\n\t   ev == CARDSLOT_EVENT_REMOVAL_16 ? \"16-bit Card removed\" : \"???\"));\n\n  if (NULL == (ce = (struct cardslot_event *)malloc(sizeof (struct cardslot_event), M_TEMP, M_NOWAIT))) {\n    panic(\"cardslot_enevt\");\n  }\n\n  ce->ce_type = ev;\n\n  {\n    int s = spltty();\n    SIMPLEQ_INSERT_TAIL(&sc->sc_events, ce, ce_q);\n    splx(s);\n  }\n\n  wakeup(&sc->sc_events);\n\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_pcmcia_detach_card",
          "args": [
            "ph",
            "DETACH_FORCE"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_detach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "859-872",
          "snippet": "STATIC void\npccbb_pcmcia_detach_card(ph, flags)\n\tstruct pcic_handle *ph;\n\tint flags;\n{\n\tif (!(ph->flags & PCIC_FLAG_CARDP)) {\n\t\tpanic(\"pccbb_pcmcia_detach_card: already detached\");\n\t}\n\n\tph->flags &= ~PCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\tpcmcia_card_detach(ph->pcmcia, flags);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "struct pcic_handle *ph = poll->ph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_detach_card(ph, flags)\n\tstruct pcic_handle *ph;\n\tint flags;\n{\n\tif (!(ph->flags & PCIC_FLAG_CARDP)) {\n\t\tpanic(\"pccbb_pcmcia_detach_card: already detached\");\n\t}\n\n\tph->flags &= ~PCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\tpcmcia_card_detach(ph->pcmcia, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pccbb_pcmcia_socket_disable",
          "args": [
            "ph"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_socket_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2246-2272",
          "snippet": "STATIC void\npccbb_pcmcia_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tu_int8_t power, intr;\n\n\tDPRINTF((\"pccbb_pcmcia_socket_disable\\n\"));\n\n\t/* reset signal asserting... */\n\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\tdelay(2 * 1000);\n\n\t/* power down the socket */\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\t/* \n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\tu_int8_t power, intr;\n\n\tDPRINTF((\"pccbb_pcmcia_socket_disable\\n\"));\n\n\t/* reset signal asserting... */\n\n\tintr = Pcic_read(ph, PCIC_INTR);\n\tintr &= ~(PCIC_INTR_CARDTYPE_MASK);\n\tPcic_write(ph, PCIC_INTR, intr);\n\tdelay(2 * 1000);\n\n\t/* power down the socket */\n\tpower = Pcic_read(ph, PCIC_PWRCTL);\n\tpower &= ~PCIC_PWRCTL_OE;\n\tPcic_write(ph, PCIC_PWRCTL, power);\n\tpccbb_power(sc, CARDBUS_VCC_0V | CARDBUS_VPP_0V);\n\t/* \n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_card_deactivate",
          "args": [
            "ph->pcmcia"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "282-304",
          "snippet": "void\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" card removed, 0x%08x\\n\", sockstate)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: 0x%08x\", sc->sc_dev.dv_xname,\n\t\t\t\t    sockevent)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_STAT"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pccbbintr_function",
          "args": [
            "sc"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "pccbbintr_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "953-967",
          "snippet": "static int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pccbbintr_function",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int pccbbintr_function;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\n\nstatic int\npccbbintr_function(sc)\n\tstruct pccbb_softc *sc;\n{\n\tint retval = 0, val;\n\tstruct pccbb_intrhand_list *pil;\n\n\tfor (pil = sc->sc_pil; pil != NULL; pil = pil->pil_next) {\n\t\tval = (*pil->pil_func) (pil->pil_arg);\n\t\tretval = retval == 1 ? 1 :\n\t\t    retval == 0 ? val : val != 0 ? val : retval;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_CSC"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_EVENT",
            "sockevent"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "memt",
            "memh",
            "CB_SOCKET_EVENT"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pccbbintr;\nstatic void pci113x_insert;\nstatic int pccbbintr_function;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nint\npccbbintr(arg)\n\tvoid *arg;\n{\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)arg;\n\tu_int32_t sockevent, sockstate;\n\tbus_space_tag_t memt = sc->sc_base_memt;\n\tbus_space_handle_t memh = sc->sc_base_memh;\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n\n\tsockevent = bus_space_read_4(memt, memh, CB_SOCKET_EVENT);\n\tbus_space_write_4(memt, memh, CB_SOCKET_EVENT, sockevent);\n\tPcic_read(ph, PCIC_CSC);\n\n\tif (sockevent == 0) {\n\t\t/* This intr is not for me: it may be for my child devices. */\n\t\treturn (pccbbintr_function(sc));\n\t}\n\n\tif (sockevent & CB_SOCKET_EVENT_CD) {\n\t\tsockstate = bus_space_read_4(memt, memh, CB_SOCKET_STAT);\n\t\tif (CB_SOCKET_STAT_CD == (sockstate & CB_SOCKET_STAT_CD)) {\n\t\t\t/* A card should be removed. */\n\t\t\tif (sc->sc_flags & CBB_CARDEXIST) {\n\t\t\t\tDPRINTF((\"%s: 0x%08x\", sc->sc_dev.dv_xname,\n\t\t\t\t    sockevent));\n\t\t\t\tDPRINTF((\" card removed, 0x%08x\\n\", sockstate));\n\t\t\t\tsc->sc_flags &= ~CBB_CARDEXIST;\n\t\t\t\tif (sc->sc_csc->sc_status &\n\t\t\t\t    CARDSLOT_STATUS_CARD_16) {\n#if 0\n\t\t\t\t\tstruct pcic_handle *ph =\n\t\t\t\t\t    &sc->sc_pcmcia_h;\n\n\t\t\t\t\tpcmcia_card_deactivate(ph->pcmcia);\n\t\t\t\t\tpccbb_pcmcia_socket_disable(ph);\n\t\t\t\t\tpccbb_pcmcia_detach_card(ph,\n\t\t\t\t\t    DETACH_FORCE);\n#endif\n\t\t\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t\t\t    CARDSLOT_EVENT_REMOVAL_16);\n\t\t\t\t} else if (sc->sc_csc->sc_status &\n\t\t\t\t    CARDSLOT_STATUS_CARD_CB) {\n\t\t\t\t\t/* Cardbus intr removed */\n\t\t\t\t\tcardslot_event_throw(sc->sc_csc,\n\t\t\t\t\t    CARDSLOT_EVENT_REMOVAL_CB);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (0x00 == (sockstate & CB_SOCKET_STAT_CD) &&\n\t\t    /*\n\t\t     * The pccbbintr may called from powerdown hook when\n\t\t     * the system resumed, to detect the card\n\t\t     * insertion/removal during suspension.\n\t\t     */\n\t\t    (sc->sc_flags & CBB_CARDEXIST) == 0) {\n\t\t\tif (sc->sc_flags & CBB_INSERTING) {\n\t\t\t\tuntimeout(pci113x_insert, sc);\n\t\t\t}\n\t\t\ttimeout(pci113x_insert, sc, hz / 10);\n\t\t\tsc->sc_flags |= CBB_INSERTING;\n\t\t}\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_detach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "859-872",
    "snippet": "STATIC void\npccbb_pcmcia_detach_card(ph, flags)\n\tstruct pcic_handle *ph;\n\tint flags;\n{\n\tif (!(ph->flags & PCIC_FLAG_CARDP)) {\n\t\tpanic(\"pccbb_pcmcia_detach_card: already detached\");\n\t}\n\n\tph->flags &= ~PCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\tpcmcia_card_detach(ph->pcmcia, flags);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_card_detach",
          "args": [
            "ph->pcmcia",
            "flags"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "252-280",
          "snippet": "void\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_detach_card: already detached\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_detach_card(ph, flags)\n\tstruct pcic_handle *ph;\n\tint flags;\n{\n\tif (!(ph->flags & PCIC_FLAG_CARDP)) {\n\t\tpanic(\"pccbb_pcmcia_detach_card: already detached\");\n\t}\n\n\tph->flags &= ~PCIC_FLAG_CARDP;\n\n\t/* call the MI detach function */\n\tpcmcia_card_detach(ph->pcmcia, flags);\n}"
  },
  {
    "function_name": "pccbb_pcmcia_attach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "845-857",
    "snippet": "STATIC void\npccbb_pcmcia_attach_card(ph)\n\tstruct pcic_handle *ph;\n{\n\tif (ph->flags & PCIC_FLAG_CARDP) {\n\t\tpanic(\"pccbb_pcmcia_attach_card: already attached\");\n\t}\n\n\t/* call the MI attach function */\n\tpcmcia_card_attach(ph->pcmcia);\n\n\tph->flags |= PCIC_FLAG_CARDP;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "pccbb_cardenable __P((struct pccbb_softc * sc, int function));",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "struct pcic_handle *ph = poll->ph;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_card_attach",
          "args": [
            "ph->pcmcia"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "159-250",
          "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_submatch",
            "int\tpcmcia_print",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pccbb_pcmcia_attach_card: already attached\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_cardenable __P((struct pccbb_softc * sc, int function));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nstruct pcic_handle *ph = poll->ph;\n\nSTATIC void\npccbb_pcmcia_attach_card(ph)\n\tstruct pcic_handle *ph;\n{\n\tif (ph->flags & PCIC_FLAG_CARDP) {\n\t\tpanic(\"pccbb_pcmcia_attach_card: already attached\");\n\t}\n\n\t/* call the MI attach function */\n\tpcmcia_card_attach(ph->pcmcia);\n\n\tph->flags |= PCIC_FLAG_CARDP;\n}"
  },
  {
    "function_name": "pccbb_pcmcia_attach_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "792-842",
    "snippet": "STATIC void\npccbb_pcmcia_attach_setup(sc, paa)\n\tstruct pccbb_softc *sc;\n\tstruct pcmciabus_attach_args *paa;\n{\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* initialize pcmcia part in pccbb_softc */\n\tph->ph_parent = (struct device *)sc;\n\tph->sock = sc->sc_function;\n\tph->flags = 0;\n\tph->shutdown = 0;\n\tph->ih_irq = sc->sc_intrline;\n\tph->ph_bus_t = sc->sc_base_memt;\n\tph->ph_bus_h = sc->sc_base_memh;\n\tph->ph_read = pccbb_pcmcia_read;\n\tph->ph_write = pccbb_pcmcia_write;\n\tsc->sc_pct = &pccbb_pcmcia_funcs;\n\n\t/*\n\t * We need to do a few things here:\n\t * 1) Disable routing of CSC and functional interrupts to ISA IRQs by\n\t *    setting the IRQ numbers to 0.\n\t * 2) Set bit 4 of PCIC_INTR, which is needed on some chips to enable\n\t *    routing of CSC interrupts (e.g. card removal) to PCI while in\n\t *    PCMCIA mode.  We just leave this set all the time.\n\t * 3) Enable card insertion/removal interrupts in case the chip also\n\t *    needs that while in PCMCIA mode.\n\t * 4) Clear any pending CSC interrupt.\n\t */\n\tPcic_write(ph, PCIC_INTR, PCIC_INTR_ENABLE | PCIC_INTR_RESET);\n\tPcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);\n\tPcic_read(ph, PCIC_CSC);\n\n\t/* initialize pcmcia bus attachment */\n\tpaa->paa_busname = \"pcmcia\";\n\tpaa->pct = sc->sc_pct;\n\tpaa->pch = ph;\n\tpaa->iobase = 0;\t       /* I don't use them */\n\tpaa->iosize = 0;\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\tpaa->iobase = rb->rb_start + rb->rb_offset;\n\tpaa->iosize = rb->rb_end - rb->rb_start;\n#endif\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define STATIC static",
      "#define STATIC"
    ],
    "globals_used": [
      "static void pccbb_pcmcia_write",
      "static u_int8_t pccbb_pcmcia_read",
      "STATIC int",
      "cb_reset __P((struct pccbb_softc *));",
      "STATIC int",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "STATIC int",
      "STATIC void",
      "pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC int",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC void",
      "STATIC int",
      "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
      "static struct pcmcia_chip_functions pccbb_pcmcia_funcs = {\n\tpccbb_pcmcia_mem_alloc,\n\tpccbb_pcmcia_mem_free,\n\tpccbb_pcmcia_mem_map,\n\tpccbb_pcmcia_mem_unmap,\n\tpccbb_pcmcia_io_alloc,\n\tpccbb_pcmcia_io_free,\n\tpccbb_pcmcia_io_map,\n\tpccbb_pcmcia_io_unmap,\n\tpccbb_pcmcia_intr_establish,\n\tpccbb_pcmcia_intr_disestablish,\n\tpccbb_pcmcia_socket_enable,\n\tpccbb_pcmcia_socket_disable,\n\tpccbb_pcmcia_card_detect\n};",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pcic_handle *ph = poll->ph;",
      "struct pccbb_softc *sc = ph->sc;",
      "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Pcic_read",
          "args": [
            "ph",
            "PCIC_CSC"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_CSC_INTR",
            "PCIC_CSC_INTR_CD_ENABLE"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pcic_write",
          "args": [
            "ph",
            "PCIC_INTR",
            "PCIC_INTR_ENABLE | PCIC_INTR_RESET"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nstatic void pccbb_pcmcia_write;\nstatic u_int8_t pccbb_pcmcia_read;\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic struct pcmcia_chip_functions pccbb_pcmcia_funcs = {\n\tpccbb_pcmcia_mem_alloc,\n\tpccbb_pcmcia_mem_free,\n\tpccbb_pcmcia_mem_map,\n\tpccbb_pcmcia_mem_unmap,\n\tpccbb_pcmcia_io_alloc,\n\tpccbb_pcmcia_io_free,\n\tpccbb_pcmcia_io_map,\n\tpccbb_pcmcia_io_unmap,\n\tpccbb_pcmcia_intr_establish,\n\tpccbb_pcmcia_intr_disestablish,\n\tpccbb_pcmcia_socket_enable,\n\tpccbb_pcmcia_socket_disable,\n\tpccbb_pcmcia_card_detect\n};\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_attach_setup(sc, paa)\n\tstruct pccbb_softc *sc;\n\tstruct pcmciabus_attach_args *paa;\n{\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* initialize pcmcia part in pccbb_softc */\n\tph->ph_parent = (struct device *)sc;\n\tph->sock = sc->sc_function;\n\tph->flags = 0;\n\tph->shutdown = 0;\n\tph->ih_irq = sc->sc_intrline;\n\tph->ph_bus_t = sc->sc_base_memt;\n\tph->ph_bus_h = sc->sc_base_memh;\n\tph->ph_read = pccbb_pcmcia_read;\n\tph->ph_write = pccbb_pcmcia_write;\n\tsc->sc_pct = &pccbb_pcmcia_funcs;\n\n\t/*\n\t * We need to do a few things here:\n\t * 1) Disable routing of CSC and functional interrupts to ISA IRQs by\n\t *    setting the IRQ numbers to 0.\n\t * 2) Set bit 4 of PCIC_INTR, which is needed on some chips to enable\n\t *    routing of CSC interrupts (e.g. card removal) to PCI while in\n\t *    PCMCIA mode.  We just leave this set all the time.\n\t * 3) Enable card insertion/removal interrupts in case the chip also\n\t *    needs that while in PCMCIA mode.\n\t * 4) Clear any pending CSC interrupt.\n\t */\n\tPcic_write(ph, PCIC_INTR, PCIC_INTR_ENABLE | PCIC_INTR_RESET);\n\tPcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);\n\tPcic_read(ph, PCIC_CSC);\n\n\t/* initialize pcmcia bus attachment */\n\tpaa->paa_busname = \"pcmcia\";\n\tpaa->pct = sc->sc_pct;\n\tpaa->pch = ph;\n\tpaa->iobase = 0;\t       /* I don't use them */\n\tpaa->iosize = 0;\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\tpaa->iobase = rb->rb_start + rb->rb_offset;\n\tpaa->iosize = rb->rb_end - rb->rb_start;\n#endif\n\n\treturn;\n}"
  },
  {
    "function_name": "pccbb_chipinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "672-781",
    "snippet": "static void\npccbb_chipinit(sc)\n\tstruct pccbb_softc *sc;\n{\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tpcitag_t tag = sc->sc_tag;\n\tpcireg_t reg;\n\n\t/* \n\t * Set PCI command reg.\n\t * Some laptop's BIOSes (i.e. TICO) do not enable CardBus chip.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t/* I believe it is harmless. */\n\treg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);\n\n\t/* \n\t * Set CardBus latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_CB_LSCP_REG);\n\tif (PCI_CB_LATENCY(reg) < 0x20) {\n\t\treg &= ~(PCI_CB_LATENCY_MASK << PCI_CB_LATENCY_SHIFT);\n\t\treg |= (0x20 << PCI_CB_LATENCY_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_CB_LSCP_REG, reg);\n\t}\n\tDPRINTF((\"CardBus latency timer 0x%x (%x)\\n\",\n\t    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG)));\n\n\t/* \n\t * Set PCI latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\tif (PCI_LATTIMER(reg) < 0x10) {\n\t\treg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\t\treg |= (0x10 << PCI_LATTIMER_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_BHLC_REG, reg);\n\t}\n\tDPRINTF((\"PCI latency timer 0x%x (%x)\\n\",\n\t    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG)));\n\n\t/* Disable legacy register mapping. */\n\tswitch (sc->sc_chipset) {\n\tcase CB_RX5C46X:\t       /* fallthrough */\n#if 0\n\tcase CB_RX5C47X:\n#endif\n\t\t/* \n\t\t * The legacy pcic io-port on Ricoh CardBus bridges cannot be\n\t\t * disabled by substituting 0 into PCI_LEGACY register.  Ricoh\n\t\t * CardBus bridges have special bits on Bridge control reg (addr\n\t\t * 0x3e on PCI config space).\n\t\t */\n\t\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\treg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);\n\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\t\tbreak;\n\n\tdefault:\n\t\t/* XXX I don't know proper way to kill legacy I/O. */\n\t\tpci_conf_write(pc, tag, PCI_LEGACY, 0x0);\n\t\tbreak;\n\t}\n\n\t/* Route functional interrupts to PCI. */\n\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\treg &= ~CB_BCR_INTR_IREQ_ENABLE;\t/* use PCI Intr */\n\treg |= CB_BCR_WRITE_POST_ENABLE;\t/* enable write post */\n\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\n\tswitch (sc->sc_chipset) {\n\tcase CB_TI113X:\n\t\treg = pci_conf_read(pc, tag, PCI_CBCTRL);\n\t\t/* This bit is shared, but may read as 0 on some chips, so set\n\t\t   it explicitly on both functions. */\n\t\treg |= PCI113X_CBCTRL_PCI_IRQ_ENA;\n\t\t/* CSC intr enable */\n\t\treg |= PCI113X_CBCTRL_PCI_CSC;\n\t\t/* functional intr prohibit */\n\t\treg &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\tpci_conf_write(pc, tag, PCI_CBCTRL, reg);\n\t\tbreak;\n\n\tcase CB_TOPIC95B:\n\t\treg = pci_conf_read(pc, tag, TOPIC_SOCKET_CTRL);\n\t\treg |= TOPIC_SOCKET_CTRL_SCR_IRQSEL;\n\t\tpci_conf_write(pc, tag, TOPIC_SOCKET_CTRL, reg);\n\n\t\treg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);\n\t\tDPRINTF((\"%s: topic slot ctrl reg 0x%x -> \",\n\t\t    sc->sc_dev.dv_xname, reg));\n\t\treg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |\n\t\t    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);\n\t\treg &= ~TOPIC_SLOT_CTRL_SWDETECT;\n\t\tDPRINTF((\"0x%x\\n\", reg));\n\t\tpci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);\n\t\tbreak;\n\t}\n\n\t/* Close all memory and I/O windows. */\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT1, 0);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "static void pccbb_chipinit",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_IOLIMIT1",
            "0"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_IOBASE1",
            "0xffffffff"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_IOLIMIT0",
            "0"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_IOBASE0",
            "0xffffffff"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_MEMLIMIT1",
            "0"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_MEMBASE1",
            "0xffffffff"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_MEMLIMIT0",
            "0"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_MEMBASE0",
            "0xffffffff"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "TOPIC_SLOT_CTRL",
            "reg"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"0x%x\\n\", reg)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: topic slot ctrl reg 0x%x -> \",\n\t\t    sc->sc_dev.dv_xname, reg)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "TOPIC_SLOT_CTRL"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "TOPIC_SOCKET_CTRL",
            "reg"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "TOPIC_SOCKET_CTRL"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CBCTRL",
            "reg"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_CBCTRL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR",
            "reg"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_LEGACY",
            "0x0"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR",
            "reg"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BCR_INTR"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"PCI latency timer 0x%x (%x)\\n\",\n\t    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG))"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BHLC_REG"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_LATTIMER",
          "args": [
            "reg"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_BHLC_REG",
            "reg"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_LATTIMER",
          "args": [
            "reg"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BHLC_REG"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"CardBus latency timer 0x%x (%x)\\n\",\n\t    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG))"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_CB_LSCP_REG"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CB_LATENCY",
          "args": [
            "reg"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_CB_LSCP_REG",
            "reg"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CB_LATENCY",
          "args": [
            "reg"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_CB_LSCP_REG"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG",
            "reg"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_chipinit;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_chipinit(sc)\n\tstruct pccbb_softc *sc;\n{\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tpcitag_t tag = sc->sc_tag;\n\tpcireg_t reg;\n\n\t/* \n\t * Set PCI command reg.\n\t * Some laptop's BIOSes (i.e. TICO) do not enable CardBus chip.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t/* I believe it is harmless. */\n\treg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);\n\n\t/* \n\t * Set CardBus latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_CB_LSCP_REG);\n\tif (PCI_CB_LATENCY(reg) < 0x20) {\n\t\treg &= ~(PCI_CB_LATENCY_MASK << PCI_CB_LATENCY_SHIFT);\n\t\treg |= (0x20 << PCI_CB_LATENCY_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_CB_LSCP_REG, reg);\n\t}\n\tDPRINTF((\"CardBus latency timer 0x%x (%x)\\n\",\n\t    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG)));\n\n\t/* \n\t * Set PCI latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\tif (PCI_LATTIMER(reg) < 0x10) {\n\t\treg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\t\treg |= (0x10 << PCI_LATTIMER_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_BHLC_REG, reg);\n\t}\n\tDPRINTF((\"PCI latency timer 0x%x (%x)\\n\",\n\t    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG)));\n\n\t/* Disable legacy register mapping. */\n\tswitch (sc->sc_chipset) {\n\tcase CB_RX5C46X:\t       /* fallthrough */\n#if 0\n\tcase CB_RX5C47X:\n#endif\n\t\t/* \n\t\t * The legacy pcic io-port on Ricoh CardBus bridges cannot be\n\t\t * disabled by substituting 0 into PCI_LEGACY register.  Ricoh\n\t\t * CardBus bridges have special bits on Bridge control reg (addr\n\t\t * 0x3e on PCI config space).\n\t\t */\n\t\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\treg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);\n\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\t\tbreak;\n\n\tdefault:\n\t\t/* XXX I don't know proper way to kill legacy I/O. */\n\t\tpci_conf_write(pc, tag, PCI_LEGACY, 0x0);\n\t\tbreak;\n\t}\n\n\t/* Route functional interrupts to PCI. */\n\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\treg &= ~CB_BCR_INTR_IREQ_ENABLE;\t/* use PCI Intr */\n\treg |= CB_BCR_WRITE_POST_ENABLE;\t/* enable write post */\n\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\n\tswitch (sc->sc_chipset) {\n\tcase CB_TI113X:\n\t\treg = pci_conf_read(pc, tag, PCI_CBCTRL);\n\t\t/* This bit is shared, but may read as 0 on some chips, so set\n\t\t   it explicitly on both functions. */\n\t\treg |= PCI113X_CBCTRL_PCI_IRQ_ENA;\n\t\t/* CSC intr enable */\n\t\treg |= PCI113X_CBCTRL_PCI_CSC;\n\t\t/* functional intr prohibit */\n\t\treg &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\tpci_conf_write(pc, tag, PCI_CBCTRL, reg);\n\t\tbreak;\n\n\tcase CB_TOPIC95B:\n\t\treg = pci_conf_read(pc, tag, TOPIC_SOCKET_CTRL);\n\t\treg |= TOPIC_SOCKET_CTRL_SCR_IRQSEL;\n\t\tpci_conf_write(pc, tag, TOPIC_SOCKET_CTRL, reg);\n\n\t\treg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);\n\t\tDPRINTF((\"%s: topic slot ctrl reg 0x%x -> \",\n\t\t    sc->sc_dev.dv_xname, reg));\n\t\treg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |\n\t\t    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);\n\t\treg &= ~TOPIC_SLOT_CTRL_SWDETECT;\n\t\tDPRINTF((\"0x%x\\n\", reg));\n\t\tpci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);\n\t\tbreak;\n\t}\n\n\t/* Close all memory and I/O windows. */\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT1, 0);\n}"
  },
  {
    "function_name": "pccbb_pci_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "513-656",
    "snippet": "static void\npccbb_pci_callback(self)\n\tstruct device *self;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tbus_space_tag_t base_memt;\n\tbus_space_handle_t base_memh;\n\tu_int32_t maskreg;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t sockbase;\n\tstruct cbslot_attach_args cba;\n\tstruct pcmciabus_attach_args paa;\n\tstruct cardslot_attach_args caa;\n\tstruct cardslot_softc *csc;\n\n\tif (0 == sc->sc_base_memh) {\n\t\t/* The socket registers aren't mapped correctly. */\n#if rbus\n\t\tif (rbus_space_alloc(sc->sc_rbus_memt, 0, 0x1000, 0x0fff,\n\t\t    (sc->sc_chipset == CB_RX5C47X\n\t\t    || sc->sc_chipset == CB_TI113X) ? 0x10000 : 0x1000,\n\t\t    0, &sockbase, &sc->sc_base_memh)) {\n\t\t\treturn;\n\t\t}\n\t\tsc->sc_base_memt = sc->sc_memt;\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%lx -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,\n\t\t    PCI_SOCKBASE)));\n#else\n\t\tsc->sc_base_memt = sc->sc_memt;\n#if !defined CBB_PCI_BASE\n#define CBB_PCI_BASE 0x20000000\n#endif\n\t\tif (bus_space_alloc(sc->sc_base_memt, CBB_PCI_BASE, 0xffffffff,\n\t\t    0x1000, 0x1000, 0, 0, &sockbase, &sc->sc_base_memh)) {\n\t\t\t/* cannot allocate memory space */\n\t\t\treturn;\n\t\t}\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%x -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,\n\t\t    sc->sc_tag, PCI_SOCKBASE)));\n#endif\n\t}\n\n\t/* bus bridge initialization */\n\tpccbb_chipinit(sc);\n\n\tbase_memt = sc->sc_base_memt;  /* socket regs memory tag */\n\tbase_memh = sc->sc_base_memh;  /* socket regs memory handle */\n\n\t/* CSC Interrupt: Card detect interrupt on */\n\tmaskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\tmaskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);\n\t/* reset interrupt */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,\n\t    sc->sc_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,\n\t    sc->sc_dev.dv_xname);\n\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL) {\n\t\t\tprintf(\" at %s\", intrstr);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": %s\\n\", intrstr);\n\tpowerhook_establish(pccbb_powerhook, sc);\n\n\t{\n\t\tu_int32_t sockstat =\n\t\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\t\tif (0 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t}\n\t}\n\n\t/* \n\t * attach cardbus \n\t */\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tpcireg_t busreg = pci_conf_read(pc, sc->sc_tag, PCI_BUSNUM);\n\t\tpcireg_t bhlc = pci_conf_read(pc, sc->sc_tag, PCI_BHLC_REG);\n\n\t\t/* initialize cbslot_attach */\n\t\tcba.cba_busname = \"cardbus\";\n\t\tcba.cba_iot = sc->sc_iot;\n\t\tcba.cba_memt = sc->sc_memt;\n\t\tcba.cba_dmat = sc->sc_dmat;\n\t\tcba.cba_bus = (busreg >> 8) & 0x0ff;\n\t\tcba.cba_cc = (void *)sc;\n\t\tcba.cba_cf = &pccbb_funcs;\n\t\tcba.cba_intrline = sc->sc_intrline;\n\n#if rbus\n\t\tcba.cba_rbus_iot = sc->sc_rbus_iot;\n\t\tcba.cba_rbus_memt = sc->sc_rbus_memt;\n#endif\n\n\t\tcba.cba_cacheline = PCI_CACHELINE(bhlc);\n\t\tcba.cba_lattimer = PCI_CB_LATENCY(busreg);\n\n#if defined CBB_DEBUG\n\t\tprintf(\"%s: cacheline 0x%x lattimer 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, cba.cba_cacheline, cba.cba_lattimer);\n\t\tprintf(\"%s: bhlc 0x%x lscp 0x%x\\n\", sc->sc_dev.dv_xname, bhlc,\n\t\t    busreg);\n#endif\n#if defined SHOW_REGS\n\t\tcb_show_regs(sc->sc_pc, sc->sc_tag, sc->sc_base_memt,\n\t\t    sc->sc_base_memh);\n#endif\n\t}\n\n\tpccbb_pcmcia_attach_setup(sc, &paa);\n\tcaa.caa_cb_attach = NULL;\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tcaa.caa_cb_attach = &cba;\n\t}\n\tcaa.caa_16_attach = &paa;\n\tcaa.caa_ph = &sc->sc_pcmcia_h;\n\n\tif (NULL != (csc = (void *)config_found(self, &caa, cbbprint))) {\n\t\tDPRINTF((\"pccbbattach: found cardslot\\n\"));\n\t\tsc->sc_csc = csc;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define CBB_PCI_BASE 0x20000000"
    ],
    "globals_used": [
      "void pccbbattach",
      "int pccbbintr",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));",
      "__P((cardbus_chipset_tag_t ct, void *ih));",
      "static void pccbb_chipinit",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "static void pccbb_powerhook",
      "static void pccbb_pci_callback",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pccbbattach: found cardslot\\n\")"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&caa",
            "cbbprint"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pccbb_pcmcia_attach_setup",
          "args": [
            "sc",
            "&paa"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_attach_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "792-842",
          "snippet": "STATIC void\npccbb_pcmcia_attach_setup(sc, paa)\n\tstruct pccbb_softc *sc;\n\tstruct pcmciabus_attach_args *paa;\n{\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* initialize pcmcia part in pccbb_softc */\n\tph->ph_parent = (struct device *)sc;\n\tph->sock = sc->sc_function;\n\tph->flags = 0;\n\tph->shutdown = 0;\n\tph->ih_irq = sc->sc_intrline;\n\tph->ph_bus_t = sc->sc_base_memt;\n\tph->ph_bus_h = sc->sc_base_memh;\n\tph->ph_read = pccbb_pcmcia_read;\n\tph->ph_write = pccbb_pcmcia_write;\n\tsc->sc_pct = &pccbb_pcmcia_funcs;\n\n\t/*\n\t * We need to do a few things here:\n\t * 1) Disable routing of CSC and functional interrupts to ISA IRQs by\n\t *    setting the IRQ numbers to 0.\n\t * 2) Set bit 4 of PCIC_INTR, which is needed on some chips to enable\n\t *    routing of CSC interrupts (e.g. card removal) to PCI while in\n\t *    PCMCIA mode.  We just leave this set all the time.\n\t * 3) Enable card insertion/removal interrupts in case the chip also\n\t *    needs that while in PCMCIA mode.\n\t * 4) Clear any pending CSC interrupt.\n\t */\n\tPcic_write(ph, PCIC_INTR, PCIC_INTR_ENABLE | PCIC_INTR_RESET);\n\tPcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);\n\tPcic_read(ph, PCIC_CSC);\n\n\t/* initialize pcmcia bus attachment */\n\tpaa->paa_busname = \"pcmcia\";\n\tpaa->pct = sc->sc_pct;\n\tpaa->pch = ph;\n\tpaa->iobase = 0;\t       /* I don't use them */\n\tpaa->iosize = 0;\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\tpaa->iobase = rb->rb_start + rb->rb_offset;\n\tpaa->iosize = rb->rb_end - rb->rb_start;\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "static void pccbb_pcmcia_write",
            "static u_int8_t pccbb_pcmcia_read",
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "static struct pcmcia_chip_functions pccbb_pcmcia_funcs = {\n\tpccbb_pcmcia_mem_alloc,\n\tpccbb_pcmcia_mem_free,\n\tpccbb_pcmcia_mem_map,\n\tpccbb_pcmcia_mem_unmap,\n\tpccbb_pcmcia_io_alloc,\n\tpccbb_pcmcia_io_free,\n\tpccbb_pcmcia_io_map,\n\tpccbb_pcmcia_io_unmap,\n\tpccbb_pcmcia_intr_establish,\n\tpccbb_pcmcia_intr_disestablish,\n\tpccbb_pcmcia_socket_enable,\n\tpccbb_pcmcia_socket_disable,\n\tpccbb_pcmcia_card_detect\n};",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nstatic void pccbb_pcmcia_write;\nstatic u_int8_t pccbb_pcmcia_read;\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic struct pcmcia_chip_functions pccbb_pcmcia_funcs = {\n\tpccbb_pcmcia_mem_alloc,\n\tpccbb_pcmcia_mem_free,\n\tpccbb_pcmcia_mem_map,\n\tpccbb_pcmcia_mem_unmap,\n\tpccbb_pcmcia_io_alloc,\n\tpccbb_pcmcia_io_free,\n\tpccbb_pcmcia_io_map,\n\tpccbb_pcmcia_io_unmap,\n\tpccbb_pcmcia_intr_establish,\n\tpccbb_pcmcia_intr_disestablish,\n\tpccbb_pcmcia_socket_enable,\n\tpccbb_pcmcia_socket_disable,\n\tpccbb_pcmcia_card_detect\n};\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_attach_setup(sc, paa)\n\tstruct pccbb_softc *sc;\n\tstruct pcmciabus_attach_args *paa;\n{\n\tstruct pcic_handle *ph = &sc->sc_pcmcia_h;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* initialize pcmcia part in pccbb_softc */\n\tph->ph_parent = (struct device *)sc;\n\tph->sock = sc->sc_function;\n\tph->flags = 0;\n\tph->shutdown = 0;\n\tph->ih_irq = sc->sc_intrline;\n\tph->ph_bus_t = sc->sc_base_memt;\n\tph->ph_bus_h = sc->sc_base_memh;\n\tph->ph_read = pccbb_pcmcia_read;\n\tph->ph_write = pccbb_pcmcia_write;\n\tsc->sc_pct = &pccbb_pcmcia_funcs;\n\n\t/*\n\t * We need to do a few things here:\n\t * 1) Disable routing of CSC and functional interrupts to ISA IRQs by\n\t *    setting the IRQ numbers to 0.\n\t * 2) Set bit 4 of PCIC_INTR, which is needed on some chips to enable\n\t *    routing of CSC interrupts (e.g. card removal) to PCI while in\n\t *    PCMCIA mode.  We just leave this set all the time.\n\t * 3) Enable card insertion/removal interrupts in case the chip also\n\t *    needs that while in PCMCIA mode.\n\t * 4) Clear any pending CSC interrupt.\n\t */\n\tPcic_write(ph, PCIC_INTR, PCIC_INTR_ENABLE | PCIC_INTR_RESET);\n\tPcic_write(ph, PCIC_CSC_INTR, PCIC_CSC_INTR_CD_ENABLE);\n\tPcic_read(ph, PCIC_CSC);\n\n\t/* initialize pcmcia bus attachment */\n\tpaa->paa_busname = \"pcmcia\";\n\tpaa->pct = sc->sc_pct;\n\tpaa->pch = ph;\n\tpaa->iobase = 0;\t       /* I don't use them */\n\tpaa->iosize = 0;\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\tpaa->iobase = rb->rb_start + rb->rb_offset;\n\tpaa->iosize = rb->rb_end - rb->rb_start;\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_show_regs",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "sc->sc_base_memt",
            "sc->sc_base_memh"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "cb_show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1687-1724",
          "snippet": "static void\ncb_show_regs(pc, tag, memt, memh)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n{\n\tint i;\n\tprintf(\"PCI config regs:\");\n\tfor (i = 0; i < 0x50; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\tfor (i = 0x80; i < 0xb0; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\n\tif (memh == 0) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nsocket regs:\");\n\tfor (i = 0; i <= 0x10; i += 0x04) {\n\t\tprintf(\" %08x\", bus_space_read_4(memt, memh, i));\n\t}\n\tprintf(\"\\nExCA regs:\");\n\tfor (i = 0; i < 0x08; ++i) {\n\t\tprintf(\" %02x\", bus_space_read_1(memt, memh, 0x800 + i));\n\t}\n\tprintf(\"\\n\");\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\ncb_show_regs(pc, tag, memt, memh)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t memh;\n{\n\tint i;\n\tprintf(\"PCI config regs:\");\n\tfor (i = 0; i < 0x50; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\tfor (i = 0x80; i < 0xb0; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tprintf(\"\\n 0x%02x:\", i);\n\t\t}\n\t\tprintf(\" %08x\", pci_conf_read(pc, tag, i));\n\t}\n\n\tif (memh == 0) {\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nsocket regs:\");\n\tfor (i = 0; i <= 0x10; i += 0x04) {\n\t\tprintf(\" %08x\", bus_space_read_4(memt, memh, i));\n\t}\n\tprintf(\"\\nExCA regs:\");\n\tfor (i = 0; i < 0x08; ++i) {\n\t\tprintf(\" %02x\", bus_space_read_1(memt, memh, 0x800 + i));\n\t}\n\tprintf(\"\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bhlc 0x%x lscp 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "bhlc",
            "busreg"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_CB_LATENCY",
          "args": [
            "busreg"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CACHELINE",
          "args": [
            "bhlc"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_BHLC_REG"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_BUSNUM"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_STAT"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "pccbb_powerhook",
            "sc"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_BIO",
            "pccbbintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "sc->sc_intrtag",
            "sc->sc_intrpin",
            "sc->sc_intrline",
            "&ih"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_EVENT",
            "bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_EVENT"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_MASK",
            "maskreg"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "base_memt",
            "base_memh",
            "CB_SOCKET_MASK"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pccbb_chipinit",
          "args": [
            "sc"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_chipinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "672-781",
          "snippet": "static void\npccbb_chipinit(sc)\n\tstruct pccbb_softc *sc;\n{\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tpcitag_t tag = sc->sc_tag;\n\tpcireg_t reg;\n\n\t/* \n\t * Set PCI command reg.\n\t * Some laptop's BIOSes (i.e. TICO) do not enable CardBus chip.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t/* I believe it is harmless. */\n\treg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);\n\n\t/* \n\t * Set CardBus latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_CB_LSCP_REG);\n\tif (PCI_CB_LATENCY(reg) < 0x20) {\n\t\treg &= ~(PCI_CB_LATENCY_MASK << PCI_CB_LATENCY_SHIFT);\n\t\treg |= (0x20 << PCI_CB_LATENCY_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_CB_LSCP_REG, reg);\n\t}\n\tDPRINTF((\"CardBus latency timer 0x%x (%x)\\n\",\n\t    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG)));\n\n\t/* \n\t * Set PCI latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\tif (PCI_LATTIMER(reg) < 0x10) {\n\t\treg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\t\treg |= (0x10 << PCI_LATTIMER_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_BHLC_REG, reg);\n\t}\n\tDPRINTF((\"PCI latency timer 0x%x (%x)\\n\",\n\t    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG)));\n\n\t/* Disable legacy register mapping. */\n\tswitch (sc->sc_chipset) {\n\tcase CB_RX5C46X:\t       /* fallthrough */\n#if 0\n\tcase CB_RX5C47X:\n#endif\n\t\t/* \n\t\t * The legacy pcic io-port on Ricoh CardBus bridges cannot be\n\t\t * disabled by substituting 0 into PCI_LEGACY register.  Ricoh\n\t\t * CardBus bridges have special bits on Bridge control reg (addr\n\t\t * 0x3e on PCI config space).\n\t\t */\n\t\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\treg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);\n\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\t\tbreak;\n\n\tdefault:\n\t\t/* XXX I don't know proper way to kill legacy I/O. */\n\t\tpci_conf_write(pc, tag, PCI_LEGACY, 0x0);\n\t\tbreak;\n\t}\n\n\t/* Route functional interrupts to PCI. */\n\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\treg &= ~CB_BCR_INTR_IREQ_ENABLE;\t/* use PCI Intr */\n\treg |= CB_BCR_WRITE_POST_ENABLE;\t/* enable write post */\n\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\n\tswitch (sc->sc_chipset) {\n\tcase CB_TI113X:\n\t\treg = pci_conf_read(pc, tag, PCI_CBCTRL);\n\t\t/* This bit is shared, but may read as 0 on some chips, so set\n\t\t   it explicitly on both functions. */\n\t\treg |= PCI113X_CBCTRL_PCI_IRQ_ENA;\n\t\t/* CSC intr enable */\n\t\treg |= PCI113X_CBCTRL_PCI_CSC;\n\t\t/* functional intr prohibit */\n\t\treg &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\tpci_conf_write(pc, tag, PCI_CBCTRL, reg);\n\t\tbreak;\n\n\tcase CB_TOPIC95B:\n\t\treg = pci_conf_read(pc, tag, TOPIC_SOCKET_CTRL);\n\t\treg |= TOPIC_SOCKET_CTRL_SCR_IRQSEL;\n\t\tpci_conf_write(pc, tag, TOPIC_SOCKET_CTRL, reg);\n\n\t\treg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);\n\t\tDPRINTF((\"%s: topic slot ctrl reg 0x%x -> \",\n\t\t    sc->sc_dev.dv_xname, reg));\n\t\treg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |\n\t\t    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);\n\t\treg &= ~TOPIC_SLOT_CTRL_SWDETECT;\n\t\tDPRINTF((\"0x%x\\n\", reg));\n\t\tpci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);\n\t\tbreak;\n\t}\n\n\t/* Close all memory and I/O windows. */\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT1, 0);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "static void pccbb_chipinit",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic void pccbb_chipinit;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_chipinit(sc)\n\tstruct pccbb_softc *sc;\n{\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tpcitag_t tag = sc->sc_tag;\n\tpcireg_t reg;\n\n\t/* \n\t * Set PCI command reg.\n\t * Some laptop's BIOSes (i.e. TICO) do not enable CardBus chip.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t/* I believe it is harmless. */\n\treg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);\n\n\t/* \n\t * Set CardBus latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_CB_LSCP_REG);\n\tif (PCI_CB_LATENCY(reg) < 0x20) {\n\t\treg &= ~(PCI_CB_LATENCY_MASK << PCI_CB_LATENCY_SHIFT);\n\t\treg |= (0x20 << PCI_CB_LATENCY_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_CB_LSCP_REG, reg);\n\t}\n\tDPRINTF((\"CardBus latency timer 0x%x (%x)\\n\",\n\t    PCI_CB_LATENCY(reg), pci_conf_read(pc, tag, PCI_CB_LSCP_REG)));\n\n\t/* \n\t * Set PCI latency timer.\n\t */\n\treg = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\tif (PCI_LATTIMER(reg) < 0x10) {\n\t\treg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\t\treg |= (0x10 << PCI_LATTIMER_SHIFT);\n\t\tpci_conf_write(pc, tag, PCI_BHLC_REG, reg);\n\t}\n\tDPRINTF((\"PCI latency timer 0x%x (%x)\\n\",\n\t    PCI_LATTIMER(reg), pci_conf_read(pc, tag, PCI_BHLC_REG)));\n\n\t/* Disable legacy register mapping. */\n\tswitch (sc->sc_chipset) {\n\tcase CB_RX5C46X:\t       /* fallthrough */\n#if 0\n\tcase CB_RX5C47X:\n#endif\n\t\t/* \n\t\t * The legacy pcic io-port on Ricoh CardBus bridges cannot be\n\t\t * disabled by substituting 0 into PCI_LEGACY register.  Ricoh\n\t\t * CardBus bridges have special bits on Bridge control reg (addr\n\t\t * 0x3e on PCI config space).\n\t\t */\n\t\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\t\treg &= ~(CB_BCRI_RL_3E0_ENA | CB_BCRI_RL_3E2_ENA);\n\t\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\t\tbreak;\n\n\tdefault:\n\t\t/* XXX I don't know proper way to kill legacy I/O. */\n\t\tpci_conf_write(pc, tag, PCI_LEGACY, 0x0);\n\t\tbreak;\n\t}\n\n\t/* Route functional interrupts to PCI. */\n\treg = pci_conf_read(pc, tag, PCI_BCR_INTR);\n\treg &= ~CB_BCR_INTR_IREQ_ENABLE;\t/* use PCI Intr */\n\treg |= CB_BCR_WRITE_POST_ENABLE;\t/* enable write post */\n\tpci_conf_write(pc, tag, PCI_BCR_INTR, reg);\n\n\tswitch (sc->sc_chipset) {\n\tcase CB_TI113X:\n\t\treg = pci_conf_read(pc, tag, PCI_CBCTRL);\n\t\t/* This bit is shared, but may read as 0 on some chips, so set\n\t\t   it explicitly on both functions. */\n\t\treg |= PCI113X_CBCTRL_PCI_IRQ_ENA;\n\t\t/* CSC intr enable */\n\t\treg |= PCI113X_CBCTRL_PCI_CSC;\n\t\t/* functional intr prohibit */\n\t\treg &= ~PCI113X_CBCTRL_PCI_INTR;\n\t\tpci_conf_write(pc, tag, PCI_CBCTRL, reg);\n\t\tbreak;\n\n\tcase CB_TOPIC95B:\n\t\treg = pci_conf_read(pc, tag, TOPIC_SOCKET_CTRL);\n\t\treg |= TOPIC_SOCKET_CTRL_SCR_IRQSEL;\n\t\tpci_conf_write(pc, tag, TOPIC_SOCKET_CTRL, reg);\n\n\t\treg = pci_conf_read(pc, tag, TOPIC_SLOT_CTRL);\n\t\tDPRINTF((\"%s: topic slot ctrl reg 0x%x -> \",\n\t\t    sc->sc_dev.dv_xname, reg));\n\t\treg |= (TOPIC_SLOT_CTRL_SLOTON | TOPIC_SLOT_CTRL_SLOTEN |\n\t\t    TOPIC_SLOT_CTRL_ID_LOCK | TOPIC_SLOT_CTRL_CARDBUS);\n\t\treg &= ~TOPIC_SLOT_CTRL_SWDETECT;\n\t\tDPRINTF((\"0x%x\\n\", reg));\n\t\tpci_conf_write(pc, tag, TOPIC_SLOT_CTRL, reg);\n\t\tbreak;\n\t}\n\n\t/* Close all memory and I/O windows. */\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_MEMBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_MEMLIMIT1, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE0, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT0, 0);\n\tpci_conf_write(pc, tag, PCI_CB_IOBASE1, 0xffffffff);\n\tpci_conf_write(pc, tag, PCI_CB_IOLIMIT1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: CardBus resister address 0x%x -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,\n\t\t    sc->sc_tag, PCI_SOCKBASE))"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_SOCKBASE"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_SOCKBASE",
            "sockbase"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "sc->sc_base_memt",
            "CBB_PCI_BASE",
            "0xffffffff",
            "0x1000",
            "0x1000",
            "0",
            "0",
            "&sockbase",
            "&sc->sc_base_memh"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: CardBus resister address 0x%lx -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,\n\t\t    PCI_SOCKBASE))"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_SOCKBASE"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "sc->sc_tag",
            "PCI_SOCKBASE",
            "sockbase"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CBB_PCI_BASE 0x20000000\n\nvoid pccbbattach;\nint pccbbintr;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));\n__P((cardbus_chipset_tag_t ct, void *ih));\nstatic void pccbb_chipinit;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstatic void pccbb_powerhook;\nstatic void pccbb_pci_callback;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_pci_callback(self)\n\tstruct device *self;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tbus_space_tag_t base_memt;\n\tbus_space_handle_t base_memh;\n\tu_int32_t maskreg;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t sockbase;\n\tstruct cbslot_attach_args cba;\n\tstruct pcmciabus_attach_args paa;\n\tstruct cardslot_attach_args caa;\n\tstruct cardslot_softc *csc;\n\n\tif (0 == sc->sc_base_memh) {\n\t\t/* The socket registers aren't mapped correctly. */\n#if rbus\n\t\tif (rbus_space_alloc(sc->sc_rbus_memt, 0, 0x1000, 0x0fff,\n\t\t    (sc->sc_chipset == CB_RX5C47X\n\t\t    || sc->sc_chipset == CB_TI113X) ? 0x10000 : 0x1000,\n\t\t    0, &sockbase, &sc->sc_base_memh)) {\n\t\t\treturn;\n\t\t}\n\t\tsc->sc_base_memt = sc->sc_memt;\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%lx -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,\n\t\t    PCI_SOCKBASE)));\n#else\n\t\tsc->sc_base_memt = sc->sc_memt;\n#if !defined CBB_PCI_BASE\n#define CBB_PCI_BASE 0x20000000\n#endif\n\t\tif (bus_space_alloc(sc->sc_base_memt, CBB_PCI_BASE, 0xffffffff,\n\t\t    0x1000, 0x1000, 0, 0, &sockbase, &sc->sc_base_memh)) {\n\t\t\t/* cannot allocate memory space */\n\t\t\treturn;\n\t\t}\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%x -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,\n\t\t    sc->sc_tag, PCI_SOCKBASE)));\n#endif\n\t}\n\n\t/* bus bridge initialization */\n\tpccbb_chipinit(sc);\n\n\tbase_memt = sc->sc_base_memt;  /* socket regs memory tag */\n\tbase_memh = sc->sc_base_memh;  /* socket regs memory handle */\n\n\t/* CSC Interrupt: Card detect interrupt on */\n\tmaskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\tmaskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);\n\t/* reset interrupt */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,\n\t    sc->sc_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,\n\t    sc->sc_dev.dv_xname);\n\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL) {\n\t\t\tprintf(\" at %s\", intrstr);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": %s\\n\", intrstr);\n\tpowerhook_establish(pccbb_powerhook, sc);\n\n\t{\n\t\tu_int32_t sockstat =\n\t\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\t\tif (0 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t}\n\t}\n\n\t/* \n\t * attach cardbus \n\t */\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tpcireg_t busreg = pci_conf_read(pc, sc->sc_tag, PCI_BUSNUM);\n\t\tpcireg_t bhlc = pci_conf_read(pc, sc->sc_tag, PCI_BHLC_REG);\n\n\t\t/* initialize cbslot_attach */\n\t\tcba.cba_busname = \"cardbus\";\n\t\tcba.cba_iot = sc->sc_iot;\n\t\tcba.cba_memt = sc->sc_memt;\n\t\tcba.cba_dmat = sc->sc_dmat;\n\t\tcba.cba_bus = (busreg >> 8) & 0x0ff;\n\t\tcba.cba_cc = (void *)sc;\n\t\tcba.cba_cf = &pccbb_funcs;\n\t\tcba.cba_intrline = sc->sc_intrline;\n\n#if rbus\n\t\tcba.cba_rbus_iot = sc->sc_rbus_iot;\n\t\tcba.cba_rbus_memt = sc->sc_rbus_memt;\n#endif\n\n\t\tcba.cba_cacheline = PCI_CACHELINE(bhlc);\n\t\tcba.cba_lattimer = PCI_CB_LATENCY(busreg);\n\n#if defined CBB_DEBUG\n\t\tprintf(\"%s: cacheline 0x%x lattimer 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, cba.cba_cacheline, cba.cba_lattimer);\n\t\tprintf(\"%s: bhlc 0x%x lscp 0x%x\\n\", sc->sc_dev.dv_xname, bhlc,\n\t\t    busreg);\n#endif\n#if defined SHOW_REGS\n\t\tcb_show_regs(sc->sc_pc, sc->sc_tag, sc->sc_base_memt,\n\t\t    sc->sc_base_memh);\n#endif\n\t}\n\n\tpccbb_pcmcia_attach_setup(sc, &paa);\n\tcaa.caa_cb_attach = NULL;\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tcaa.caa_cb_attach = &cba;\n\t}\n\tcaa.caa_16_attach = &paa;\n\tcaa.caa_ph = &sc->sc_pcmcia_h;\n\n\tif (NULL != (csc = (void *)config_found(self, &caa, cbbprint))) {\n\t\tDPRINTF((\"pccbbattach: found cardslot\\n\"));\n\t\tsc->sc_csc = csc;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "pccbbattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "377-496",
    "snippet": "void\npccbbattach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpcireg_t sock_base, busreg;\n\tbus_addr_t sockbase;\n\tint flags;\n\n\tsc->sc_chipset = cb_chipset(pa->pa_id, &flags);\n\n#ifdef CBB_DEBUG\n\tprintf(\" (chipflags %x)\", flags);\n#endif\n\n\tTAILQ_INIT(&sc->sc_memwindow);\n\tTAILQ_INIT(&sc->sc_iowindow);\n\n#if rbus\n\tsc->sc_rbus_iot = rbus_pccbb_parent_io(pa);\n\tsc->sc_rbus_memt = rbus_pccbb_parent_mem(pa);\n#endif /* rbus */\n\n\tsc->sc_base_memh = 0;\n\n\t/* \n\t * MAP socket registers and ExCA registers on memory-space\n\t * When no valid address is set on socket base registers (on pci\n\t * config space), get it not polite way.\n\t */\n\tsock_base = pci_conf_read(pc, pa->pa_tag, PCI_SOCKBASE);\n\n\tif (PCI_MAPREG_MEM_ADDR(sock_base) >= 0x100000 &&\n\t    PCI_MAPREG_MEM_ADDR(sock_base) != 0xfffffff0) {\n\t\t/* The address must be valid. */\n\t\tif (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_MEM, 0,\n\t\t    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL)) {\n\t\t\tprintf(\"%s: can't map socket base address 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sock_base);\n\t\t\t/*\n\t\t\t * I think it's funny: socket base registers must be\n\t\t\t * mapped on memory space, but ...\n\t\t\t */\n\t\t\tif (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_IO,\n\t\t\t    0, &sc->sc_base_memt, &sc->sc_base_memh, &sockbase,\n\t\t\t    NULL)) {\n\t\t\t\tprintf(\"%s: can't map socket base address\"\n\t\t\t\t    \" 0x%lx: io mode\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sockbase);\n\t\t\t\t/* give up... allocate reg space via rbus. */\n\t\t\t\tsc->sc_base_memh = 0;\n\t\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_SOCKBASE, 0);\n\t\t \t}\n\t\t} else {\n\t\t\tDPRINTF((\"%s: socket base address 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sockbase));\n\t\t}\n\t}\n\n\tsc->sc_mem_start = 0;\t       /* XXX */\n\tsc->sc_mem_end = 0xffffffff;   /* XXX */\n\n\t/* \n\t * When interrupt isn't routed correctly, give up probing cbb and do\n\t * not kill pcic-compatible port.\n\t */\n\tif ((0 == pa->pa_intrline) || (255 == pa->pa_intrline)) {\n    \t\tprintf(\"\\n%s: NOT USED because of unconfigured interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* \n\t * When bus number isn't set correctly, give up using 32-bit CardBus\n\t * mode.\n\t */\n\tbusreg = pci_conf_read(pc, pa->pa_tag, PCI_BUSNUM);\n#if notyet\n\tif (((busreg >> 8) & 0xff) == 0) {\n    \t\tprintf(\"%s: CardBus support disabled because of unconfigured bus number\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tflags |= PCCBB_PCMCIA_16BITONLY;\n\t}\n#endif\n\n\t/* pccbb_machdep.c end */\n\n#if defined CBB_DEBUG\n\t{\n\t\tstatic char *intrname[5] = { \"NON\", \"A\", \"B\", \"C\", \"D\" };\n\t\tprintf(\"%s: intrpin %s, intrtag %d\\n\", sc->sc_dev.dv_xname,\n\t\t    intrname[pa->pa_intrpin], pa->pa_intrline);\n\t}\n#endif\n\n\t/* setup softc */\n\tsc->sc_pc = pc;\n\tsc->sc_iot = pa->pa_iot;\n\tsc->sc_memt = pa->pa_memt;\n\tsc->sc_dmat = pa->pa_dmat;\n\tsc->sc_tag = pa->pa_tag;\n\tsc->sc_function = pa->pa_function;\n\n\tsc->sc_intrline = pa->pa_intrline;\n\tsc->sc_intrtag = pa->pa_intrtag;\n\tsc->sc_intrpin = pa->pa_intrpin;\n\n\tsc->sc_pcmcia_flags = flags;   /* set PCMCIA facility */\n\n\tshutdownhook_establish(pccbb_shutdown, sc);\n\n#if 0\n\tconfig_defer(self, pccbb_pci_callback);\n#endif\n\tpccbb_pci_callback(self);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pccbbattach",
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "static int cb_chipset",
      "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
      "static void pccbb_pci_callback",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pccbb_pci_callback",
          "args": [
            "self"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pci_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "513-656",
          "snippet": "static void\npccbb_pci_callback(self)\n\tstruct device *self;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tbus_space_tag_t base_memt;\n\tbus_space_handle_t base_memh;\n\tu_int32_t maskreg;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t sockbase;\n\tstruct cbslot_attach_args cba;\n\tstruct pcmciabus_attach_args paa;\n\tstruct cardslot_attach_args caa;\n\tstruct cardslot_softc *csc;\n\n\tif (0 == sc->sc_base_memh) {\n\t\t/* The socket registers aren't mapped correctly. */\n#if rbus\n\t\tif (rbus_space_alloc(sc->sc_rbus_memt, 0, 0x1000, 0x0fff,\n\t\t    (sc->sc_chipset == CB_RX5C47X\n\t\t    || sc->sc_chipset == CB_TI113X) ? 0x10000 : 0x1000,\n\t\t    0, &sockbase, &sc->sc_base_memh)) {\n\t\t\treturn;\n\t\t}\n\t\tsc->sc_base_memt = sc->sc_memt;\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%lx -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,\n\t\t    PCI_SOCKBASE)));\n#else\n\t\tsc->sc_base_memt = sc->sc_memt;\n#if !defined CBB_PCI_BASE\n#define CBB_PCI_BASE 0x20000000\n#endif\n\t\tif (bus_space_alloc(sc->sc_base_memt, CBB_PCI_BASE, 0xffffffff,\n\t\t    0x1000, 0x1000, 0, 0, &sockbase, &sc->sc_base_memh)) {\n\t\t\t/* cannot allocate memory space */\n\t\t\treturn;\n\t\t}\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%x -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,\n\t\t    sc->sc_tag, PCI_SOCKBASE)));\n#endif\n\t}\n\n\t/* bus bridge initialization */\n\tpccbb_chipinit(sc);\n\n\tbase_memt = sc->sc_base_memt;  /* socket regs memory tag */\n\tbase_memh = sc->sc_base_memh;  /* socket regs memory handle */\n\n\t/* CSC Interrupt: Card detect interrupt on */\n\tmaskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\tmaskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);\n\t/* reset interrupt */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,\n\t    sc->sc_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,\n\t    sc->sc_dev.dv_xname);\n\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL) {\n\t\t\tprintf(\" at %s\", intrstr);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": %s\\n\", intrstr);\n\tpowerhook_establish(pccbb_powerhook, sc);\n\n\t{\n\t\tu_int32_t sockstat =\n\t\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\t\tif (0 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t}\n\t}\n\n\t/* \n\t * attach cardbus \n\t */\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tpcireg_t busreg = pci_conf_read(pc, sc->sc_tag, PCI_BUSNUM);\n\t\tpcireg_t bhlc = pci_conf_read(pc, sc->sc_tag, PCI_BHLC_REG);\n\n\t\t/* initialize cbslot_attach */\n\t\tcba.cba_busname = \"cardbus\";\n\t\tcba.cba_iot = sc->sc_iot;\n\t\tcba.cba_memt = sc->sc_memt;\n\t\tcba.cba_dmat = sc->sc_dmat;\n\t\tcba.cba_bus = (busreg >> 8) & 0x0ff;\n\t\tcba.cba_cc = (void *)sc;\n\t\tcba.cba_cf = &pccbb_funcs;\n\t\tcba.cba_intrline = sc->sc_intrline;\n\n#if rbus\n\t\tcba.cba_rbus_iot = sc->sc_rbus_iot;\n\t\tcba.cba_rbus_memt = sc->sc_rbus_memt;\n#endif\n\n\t\tcba.cba_cacheline = PCI_CACHELINE(bhlc);\n\t\tcba.cba_lattimer = PCI_CB_LATENCY(busreg);\n\n#if defined CBB_DEBUG\n\t\tprintf(\"%s: cacheline 0x%x lattimer 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, cba.cba_cacheline, cba.cba_lattimer);\n\t\tprintf(\"%s: bhlc 0x%x lscp 0x%x\\n\", sc->sc_dev.dv_xname, bhlc,\n\t\t    busreg);\n#endif\n#if defined SHOW_REGS\n\t\tcb_show_regs(sc->sc_pc, sc->sc_tag, sc->sc_base_memt,\n\t\t    sc->sc_base_memh);\n#endif\n\t}\n\n\tpccbb_pcmcia_attach_setup(sc, &paa);\n\tcaa.caa_cb_attach = NULL;\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tcaa.caa_cb_attach = &cba;\n\t}\n\tcaa.caa_16_attach = &paa;\n\tcaa.caa_ph = &sc->sc_pcmcia_h;\n\n\tif (NULL != (csc = (void *)config_found(self, &caa, cbbprint))) {\n\t\tDPRINTF((\"pccbbattach: found cardslot\\n\"));\n\t\tsc->sc_csc = csc;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define CBB_PCI_BASE 0x20000000"
          ],
          "globals_used": [
            "void pccbbattach",
            "int pccbbintr",
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));",
            "__P((cardbus_chipset_tag_t ct, void *ih));",
            "static void pccbb_chipinit",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "static void pccbb_powerhook",
            "static void pccbb_pci_callback",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "int s;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "int s;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CBB_PCI_BASE 0x20000000\n\nvoid pccbbattach;\nint pccbbintr;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_attach_setup __P((struct pccbb_softc *,\n    struct pcmciabus_attach_args *));\n__P((cardbus_chipset_tag_t ct, void *ih));\nstatic void pccbb_chipinit;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstatic void pccbb_powerhook;\nstatic void pccbb_pci_callback;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nstatic void\npccbb_pci_callback(self)\n\tstruct device *self;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tpci_chipset_tag_t pc = sc->sc_pc;\n\tbus_space_tag_t base_memt;\n\tbus_space_handle_t base_memh;\n\tu_int32_t maskreg;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t sockbase;\n\tstruct cbslot_attach_args cba;\n\tstruct pcmciabus_attach_args paa;\n\tstruct cardslot_attach_args caa;\n\tstruct cardslot_softc *csc;\n\n\tif (0 == sc->sc_base_memh) {\n\t\t/* The socket registers aren't mapped correctly. */\n#if rbus\n\t\tif (rbus_space_alloc(sc->sc_rbus_memt, 0, 0x1000, 0x0fff,\n\t\t    (sc->sc_chipset == CB_RX5C47X\n\t\t    || sc->sc_chipset == CB_TI113X) ? 0x10000 : 0x1000,\n\t\t    0, &sockbase, &sc->sc_base_memh)) {\n\t\t\treturn;\n\t\t}\n\t\tsc->sc_base_memt = sc->sc_memt;\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%lx -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sockbase, pci_conf_read(pc, sc->sc_tag,\n\t\t    PCI_SOCKBASE)));\n#else\n\t\tsc->sc_base_memt = sc->sc_memt;\n#if !defined CBB_PCI_BASE\n#define CBB_PCI_BASE 0x20000000\n#endif\n\t\tif (bus_space_alloc(sc->sc_base_memt, CBB_PCI_BASE, 0xffffffff,\n\t\t    0x1000, 0x1000, 0, 0, &sockbase, &sc->sc_base_memh)) {\n\t\t\t/* cannot allocate memory space */\n\t\t\treturn;\n\t\t}\n\t\tpci_conf_write(pc, sc->sc_tag, PCI_SOCKBASE, sockbase);\n\t\tDPRINTF((\"%s: CardBus resister address 0x%x -> 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sock_base, pci_conf_read(pc,\n\t\t    sc->sc_tag, PCI_SOCKBASE)));\n#endif\n\t}\n\n\t/* bus bridge initialization */\n\tpccbb_chipinit(sc);\n\n\tbase_memt = sc->sc_base_memt;  /* socket regs memory tag */\n\tbase_memh = sc->sc_base_memh;  /* socket regs memory handle */\n\n\t/* CSC Interrupt: Card detect interrupt on */\n\tmaskreg = bus_space_read_4(base_memt, base_memh, CB_SOCKET_MASK);\n\tmaskreg |= CB_SOCKET_MASK_CD;  /* Card detect intr is turned on. */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_MASK, maskreg);\n\t/* reset interrupt */\n\tbus_space_write_4(base_memt, base_memh, CB_SOCKET_EVENT,\n\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_EVENT));\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, sc->sc_intrtag, sc->sc_intrpin,\n\t    sc->sc_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, pccbbintr, sc,\n\t    sc->sc_dev.dv_xname);\n\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\", sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL) {\n\t\t\tprintf(\" at %s\", intrstr);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": %s\\n\", intrstr);\n\tpowerhook_establish(pccbb_powerhook, sc);\n\n\t{\n\t\tu_int32_t sockstat =\n\t\t    bus_space_read_4(base_memt, base_memh, CB_SOCKET_STAT);\n\t\tif (0 == (sockstat & CB_SOCKET_STAT_CD)) {\n\t\t\tsc->sc_flags |= CBB_CARDEXIST;\n\t\t}\n\t}\n\n\t/* \n\t * attach cardbus \n\t */\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tpcireg_t busreg = pci_conf_read(pc, sc->sc_tag, PCI_BUSNUM);\n\t\tpcireg_t bhlc = pci_conf_read(pc, sc->sc_tag, PCI_BHLC_REG);\n\n\t\t/* initialize cbslot_attach */\n\t\tcba.cba_busname = \"cardbus\";\n\t\tcba.cba_iot = sc->sc_iot;\n\t\tcba.cba_memt = sc->sc_memt;\n\t\tcba.cba_dmat = sc->sc_dmat;\n\t\tcba.cba_bus = (busreg >> 8) & 0x0ff;\n\t\tcba.cba_cc = (void *)sc;\n\t\tcba.cba_cf = &pccbb_funcs;\n\t\tcba.cba_intrline = sc->sc_intrline;\n\n#if rbus\n\t\tcba.cba_rbus_iot = sc->sc_rbus_iot;\n\t\tcba.cba_rbus_memt = sc->sc_rbus_memt;\n#endif\n\n\t\tcba.cba_cacheline = PCI_CACHELINE(bhlc);\n\t\tcba.cba_lattimer = PCI_CB_LATENCY(busreg);\n\n#if defined CBB_DEBUG\n\t\tprintf(\"%s: cacheline 0x%x lattimer 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, cba.cba_cacheline, cba.cba_lattimer);\n\t\tprintf(\"%s: bhlc 0x%x lscp 0x%x\\n\", sc->sc_dev.dv_xname, bhlc,\n\t\t    busreg);\n#endif\n#if defined SHOW_REGS\n\t\tcb_show_regs(sc->sc_pc, sc->sc_tag, sc->sc_base_memt,\n\t\t    sc->sc_base_memh);\n#endif\n\t}\n\n\tpccbb_pcmcia_attach_setup(sc, &paa);\n\tcaa.caa_cb_attach = NULL;\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_16BITONLY)) {\n\t\tcaa.caa_cb_attach = &cba;\n\t}\n\tcaa.caa_16_attach = &paa;\n\tcaa.caa_ph = &sc->sc_pcmcia_h;\n\n\tif (NULL != (csc = (void *)config_found(self, &caa, cbbprint))) {\n\t\tDPRINTF((\"pccbbattach: found cardslot\\n\"));\n\t\tsc->sc_csc = csc;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_defer",
          "args": [
            "self",
            "pccbb_pci_callback"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "pccbb_shutdown",
            "sc"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: intrpin %s, intrtag %d\\n\"",
            "sc->sc_dev.dv_xname",
            "intrname[pa->pa_intrpin]",
            "pa->pa_intrline"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_BUSNUM"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: socket base address 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sockbase)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_SOCKBASE",
            "0"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_SOCKBASE",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&sc->sc_base_memt",
            "&sc->sc_base_memh",
            "&sockbase",
            "NULL"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_ADDR",
          "args": [
            "sock_base"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_MAPREG_MEM_ADDR",
          "args": [
            "sock_base"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_SOCKBASE"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbus_pccbb_parent_mem",
          "args": [
            "pa"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbus_pccbb_parent_io",
          "args": [
            "pa"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_iowindow"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_memwindow"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb_chipset",
          "args": [
            "pa->pa_id",
            "&flags"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "cb_chipset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "340-357",
          "snippet": "static int\ncb_chipset(pci_id, flagp)\n\tu_int32_t pci_id;\n\tint *flagp;\n{\n\tstruct yenta_chipinfo *yc;\n\n\t/* Loop over except the last default entry. */\n\tfor (yc = yc_chipsets; yc < yc_chipsets +\n\t    sizeof(yc_chipsets) / sizeof(yc_chipsets[0]) - 1; yc++)\n\t\tif (pci_id != yc->yc_id)\n\t\t\tbreak;\n\n\tif (flagp != NULL)\n\t\t*flagp = yc->yc_flags;\n\n\treturn (yc->yc_chiptype);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cb_chipset",
            "struct yenta_chipinfo {\n\tpcireg_t yc_id;\t\t       /* vendor tag | product tag */\n\tint yc_chiptype;\n\tint yc_flags;\n} yc_chipsets[] = {\n\t/* Texas Instruments chips */\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1130), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1131), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1220), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1221), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1225), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1211), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1420), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1451), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\n\t/* Ricoh chips */\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C475), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C476), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C477), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C478), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C465), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C466), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\n\t/* Toshiba products */\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95),\n\t    CB_TOPIC95, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95B),\n\t    CB_TOPIC95B, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC97),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC100),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\n\t/* Cirrus Logic products */\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6832),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6833),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\n\t/* sentinel, or Generic chip */\n\t{ 0 /* null id */ , CB_UNKNOWN, PCCBB_PCMCIA_MEM_32},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cb_chipset;\nstruct yenta_chipinfo {\n\tpcireg_t yc_id;\t\t       /* vendor tag | product tag */\n\tint yc_chiptype;\n\tint yc_flags;\n} yc_chipsets[] = {\n\t/* Texas Instruments chips */\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1130), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1131), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1220), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1221), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1225), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1211), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1420), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1451), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\n\t/* Ricoh chips */\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C475), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C476), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C477), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C478), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C465), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C466), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\n\t/* Toshiba products */\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95),\n\t    CB_TOPIC95, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95B),\n\t    CB_TOPIC95B, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC97),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC100),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\n\t/* Cirrus Logic products */\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6832),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6833),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\n\t/* sentinel, or Generic chip */\n\t{ 0 /* null id */ , CB_UNKNOWN, PCCBB_PCMCIA_MEM_32},\n};\n\nstatic int\ncb_chipset(pci_id, flagp)\n\tu_int32_t pci_id;\n\tint *flagp;\n{\n\tstruct yenta_chipinfo *yc;\n\n\t/* Loop over except the last default entry. */\n\tfor (yc = yc_chipsets; yc < yc_chipsets +\n\t    sizeof(yc_chipsets) / sizeof(yc_chipsets[0]) - 1; yc++)\n\t\tif (pci_id != yc->yc_id)\n\t\t\tbreak;\n\n\tif (flagp != NULL)\n\t\t*flagp = yc->yc_flags;\n\n\treturn (yc->yc_chiptype);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid pccbbattach;\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nstatic int cb_chipset;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nstatic void pccbb_pci_callback;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nint s;\n\nvoid\npccbbattach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct pccbb_softc *sc = (void *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpcireg_t sock_base, busreg;\n\tbus_addr_t sockbase;\n\tint flags;\n\n\tsc->sc_chipset = cb_chipset(pa->pa_id, &flags);\n\n#ifdef CBB_DEBUG\n\tprintf(\" (chipflags %x)\", flags);\n#endif\n\n\tTAILQ_INIT(&sc->sc_memwindow);\n\tTAILQ_INIT(&sc->sc_iowindow);\n\n#if rbus\n\tsc->sc_rbus_iot = rbus_pccbb_parent_io(pa);\n\tsc->sc_rbus_memt = rbus_pccbb_parent_mem(pa);\n#endif /* rbus */\n\n\tsc->sc_base_memh = 0;\n\n\t/* \n\t * MAP socket registers and ExCA registers on memory-space\n\t * When no valid address is set on socket base registers (on pci\n\t * config space), get it not polite way.\n\t */\n\tsock_base = pci_conf_read(pc, pa->pa_tag, PCI_SOCKBASE);\n\n\tif (PCI_MAPREG_MEM_ADDR(sock_base) >= 0x100000 &&\n\t    PCI_MAPREG_MEM_ADDR(sock_base) != 0xfffffff0) {\n\t\t/* The address must be valid. */\n\t\tif (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_MEM, 0,\n\t\t    &sc->sc_base_memt, &sc->sc_base_memh, &sockbase, NULL)) {\n\t\t\tprintf(\"%s: can't map socket base address 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sock_base);\n\t\t\t/*\n\t\t\t * I think it's funny: socket base registers must be\n\t\t\t * mapped on memory space, but ...\n\t\t\t */\n\t\t\tif (pci_mapreg_map(pa, PCI_SOCKBASE, PCI_MAPREG_TYPE_IO,\n\t\t\t    0, &sc->sc_base_memt, &sc->sc_base_memh, &sockbase,\n\t\t\t    NULL)) {\n\t\t\t\tprintf(\"%s: can't map socket base address\"\n\t\t\t\t    \" 0x%lx: io mode\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sockbase);\n\t\t\t\t/* give up... allocate reg space via rbus. */\n\t\t\t\tsc->sc_base_memh = 0;\n\t\t\t\tpci_conf_write(pc, pa->pa_tag, PCI_SOCKBASE, 0);\n\t\t \t}\n\t\t} else {\n\t\t\tDPRINTF((\"%s: socket base address 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sockbase));\n\t\t}\n\t}\n\n\tsc->sc_mem_start = 0;\t       /* XXX */\n\tsc->sc_mem_end = 0xffffffff;   /* XXX */\n\n\t/* \n\t * When interrupt isn't routed correctly, give up probing cbb and do\n\t * not kill pcic-compatible port.\n\t */\n\tif ((0 == pa->pa_intrline) || (255 == pa->pa_intrline)) {\n    \t\tprintf(\"\\n%s: NOT USED because of unconfigured interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/* \n\t * When bus number isn't set correctly, give up using 32-bit CardBus\n\t * mode.\n\t */\n\tbusreg = pci_conf_read(pc, pa->pa_tag, PCI_BUSNUM);\n#if notyet\n\tif (((busreg >> 8) & 0xff) == 0) {\n    \t\tprintf(\"%s: CardBus support disabled because of unconfigured bus number\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tflags |= PCCBB_PCMCIA_16BITONLY;\n\t}\n#endif\n\n\t/* pccbb_machdep.c end */\n\n#if defined CBB_DEBUG\n\t{\n\t\tstatic char *intrname[5] = { \"NON\", \"A\", \"B\", \"C\", \"D\" };\n\t\tprintf(\"%s: intrpin %s, intrtag %d\\n\", sc->sc_dev.dv_xname,\n\t\t    intrname[pa->pa_intrpin], pa->pa_intrline);\n\t}\n#endif\n\n\t/* setup softc */\n\tsc->sc_pc = pc;\n\tsc->sc_iot = pa->pa_iot;\n\tsc->sc_memt = pa->pa_memt;\n\tsc->sc_dmat = pa->pa_dmat;\n\tsc->sc_tag = pa->pa_tag;\n\tsc->sc_function = pa->pa_function;\n\n\tsc->sc_intrline = pa->pa_intrline;\n\tsc->sc_intrtag = pa->pa_intrtag;\n\tsc->sc_intrpin = pa->pa_intrpin;\n\n\tsc->sc_pcmcia_flags = flags;   /* set PCMCIA facility */\n\n\tshutdownhook_establish(pccbb_shutdown, sc);\n\n#if 0\n\tconfig_defer(self, pccbb_pci_callback);\n#endif\n\tpccbb_pci_callback(self);\n}"
  },
  {
    "function_name": "pccbb_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "359-375",
    "snippet": "static void\npccbb_shutdown(void *arg)\n{\n\tstruct pccbb_softc *sc = arg;\n\tpcireg_t command;\n\n\tDPRINTF((\"%s: shutdown\\n\", sc->sc_dev.dv_xname));\n\tbus_space_write_4(sc->sc_base_memt, sc->sc_base_memh, CB_SOCKET_MASK,\n\t    0);\n\n\tcommand = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tcommand &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "cb_reset __P((struct pccbb_softc *));",
      "cb_detect_voltage __P((struct pccbb_softc *));",
      "void *arg;",
      "struct pccbb_softc *sc = psc->cpc_parent;",
      "int s;",
      "void *arg;",
      "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
      "void *arg;",
      "void *arg;",
      "struct pccbb_softc *sc = ph->sc;",
      "int s;",
      "void *arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_base_memt",
            "sc->sc_base_memh",
            "CB_SOCKET_MASK",
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: shutdown\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\nvoid *arg;\nstruct pccbb_softc *sc = psc->cpc_parent;\nint s;\nvoid *arg;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nvoid *arg;\nvoid *arg;\nstruct pccbb_softc *sc = ph->sc;\nint s;\nvoid *arg;\n\nstatic void\npccbb_shutdown(void *arg)\n{\n\tstruct pccbb_softc *sc = arg;\n\tpcireg_t command;\n\n\tDPRINTF((\"%s: shutdown\\n\", sc->sc_dev.dv_xname));\n\tbus_space_write_4(sc->sc_base_memt, sc->sc_base_memh, CB_SOCKET_MASK,\n\t    0);\n\n\tcommand = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);\n\n\tcommand &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, command);\n\n}"
  },
  {
    "function_name": "cb_chipset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "340-357",
    "snippet": "static int\ncb_chipset(pci_id, flagp)\n\tu_int32_t pci_id;\n\tint *flagp;\n{\n\tstruct yenta_chipinfo *yc;\n\n\t/* Loop over except the last default entry. */\n\tfor (yc = yc_chipsets; yc < yc_chipsets +\n\t    sizeof(yc_chipsets) / sizeof(yc_chipsets[0]) - 1; yc++)\n\t\tif (pci_id != yc->yc_id)\n\t\t\tbreak;\n\n\tif (flagp != NULL)\n\t\t*flagp = yc->yc_flags;\n\n\treturn (yc->yc_chiptype);\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cb_chipset",
      "struct yenta_chipinfo {\n\tpcireg_t yc_id;\t\t       /* vendor tag | product tag */\n\tint yc_chiptype;\n\tint yc_flags;\n} yc_chipsets[] = {\n\t/* Texas Instruments chips */\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1130), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1131), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1220), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1221), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1225), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1211), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1420), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1451), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\n\t/* Ricoh chips */\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C475), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C476), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C477), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C478), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C465), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C466), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\n\t/* Toshiba products */\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95),\n\t    CB_TOPIC95, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95B),\n\t    CB_TOPIC95B, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC97),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC100),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\n\t/* Cirrus Logic products */\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6832),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6833),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\n\t/* sentinel, or Generic chip */\n\t{ 0 /* null id */ , CB_UNKNOWN, PCCBB_PCMCIA_MEM_32},\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int cb_chipset;\nstruct yenta_chipinfo {\n\tpcireg_t yc_id;\t\t       /* vendor tag | product tag */\n\tint yc_chiptype;\n\tint yc_flags;\n} yc_chipsets[] = {\n\t/* Texas Instruments chips */\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1130), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1131), CB_TI113X,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1250), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1220), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1221), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1225), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1251B), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1211), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1420), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1450), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TI, PCI_PRODUCT_TI_PCI1451), CB_TI12XX,\n\t    PCCBB_PCMCIA_IO_RELOC | PCCBB_PCMCIA_MEM_32},\n\n\t/* Ricoh chips */\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C475), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C476), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C477), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C478), CB_RX5C47X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C465), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_RICOH, PCI_PRODUCT_RICOH_RF5C466), CB_RX5C46X,\n\t    PCCBB_PCMCIA_MEM_32},\n\n\t/* Toshiba products */\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95),\n\t    CB_TOPIC95, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC95B),\n\t    CB_TOPIC95B, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC97),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_TOSHIBA2, PCI_PRODUCT_TOSHIBA2_ToPIC100),\n\t    CB_TOPIC97, PCCBB_PCMCIA_MEM_32},\n\n\t/* Cirrus Logic products */\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6832),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\t{ MAKEID(PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CL_PD6833),\n\t    CB_CIRRUS, PCCBB_PCMCIA_MEM_32},\n\n\t/* sentinel, or Generic chip */\n\t{ 0 /* null id */ , CB_UNKNOWN, PCCBB_PCMCIA_MEM_32},\n};\n\nstatic int\ncb_chipset(pci_id, flagp)\n\tu_int32_t pci_id;\n\tint *flagp;\n{\n\tstruct yenta_chipinfo *yc;\n\n\t/* Loop over except the last default entry. */\n\tfor (yc = yc_chipsets; yc < yc_chipsets +\n\t    sizeof(yc_chipsets) / sizeof(yc_chipsets[0]) - 1; yc++)\n\t\tif (pci_id != yc->yc_id)\n\t\t\tbreak;\n\n\tif (flagp != NULL)\n\t\t*flagp = yc->yc_flags;\n\n\treturn (yc->yc_chiptype);\n}"
  },
  {
    "function_name": "pcicbbmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
    "lines": "255-270",
    "snippet": "int\npcicbbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_CARDBUS &&\n\t    PCI_INTERFACE(pa->pa_class) == 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pccbbvar.h>",
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <dev/cardbus/cardslotvar.h>",
      "#include <dev/pci/pccbbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcicbbmatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pa->pa_class"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SUBCLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcicbbmatch;\n\nint\npcicbbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_CARDBUS &&\n\t    PCI_INTERFACE(pa->pa_class) == 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  }
]