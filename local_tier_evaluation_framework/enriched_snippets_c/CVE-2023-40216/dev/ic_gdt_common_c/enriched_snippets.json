[
  {
    "function_name": "gdt_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1297-1309",
    "snippet": "void\ngdt_watchdog(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tGDT_LOCK_GDT(gdt);\n\tccb->gc_flags &= ~GDT_GCF_WATCHDOG;\n\tgdt_start_ccbs(gdt);\n\tGDT_UNLOCK_GDT(gdt);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_start_ccbs",
      "void\tgdt_watchdog",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_start_ccbs",
          "args": [
            "gdt"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1242-1266",
          "snippet": "void\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_exec_ccb",
            "void\tgdt_start_ccbs",
            "void\tgdt_timeout",
            "void\tgdt_watchdog",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_exec_ccb;\nvoid\tgdt_start_ccbs;\nvoid\tgdt_timeout;\nvoid\tgdt_watchdog;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nvoid\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_start_ccbs;\nvoid\tgdt_watchdog;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_watchdog(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tGDT_LOCK_GDT(gdt);\n\tccb->gc_flags &= ~GDT_GCF_WATCHDOG;\n\tgdt_start_ccbs(gdt);\n\tGDT_UNLOCK_GDT(gdt);\n}"
  },
  {
    "function_name": "gdt_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1278-1295",
    "snippet": "void\ngdt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tsc_print_addr(link);\n\tprintf(\"timed out\\n\");\n\n\t/* XXX Test for multiple timeouts */\n\n\tccb->gc_xs->error = XS_TIMEOUT;\n\tGDT_LOCK_GDT(gdt);\n\tgdt_enqueue_ccb(gdt, ccb);\n\tGDT_UNLOCK_GDT(gdt);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_enqueue_ccb",
      "void\tgdt_timeout",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_enqueue_ccb",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enqueue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1231-1240",
          "snippet": "void\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_enqueue_ccb",
            "void\tgdt_start_ccbs",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_start_ccbs;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"timed out\\n\""
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "link"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_timeout;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tsc_print_addr(link);\n\tprintf(\"timed out\\n\");\n\n\t/* XXX Test for multiple timeouts */\n\n\tccb->gc_xs->error = XS_TIMEOUT;\n\tGDT_LOCK_GDT(gdt);\n\tgdt_enqueue_ccb(gdt, ccb);\n\tGDT_UNLOCK_GDT(gdt);\n}"
  },
  {
    "function_name": "gdt_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1268-1276",
    "snippet": "void\ngdt_chain(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_chain(%p) \", gdt));\n\n\tif (LIST_FIRST(&gdt->sc_queue))\n\t\tgdt_scsi_cmd(LIST_FIRST(&gdt->sc_queue));\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_chain",
      "int\tgdt_scsi_cmd",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdt_scsi_cmd",
          "args": [
            "LIST_FIRST(&gdt->sc_queue)"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "461-657",
          "snippet": "int\ngdt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tstruct gdt_ccb *ccb;\n\tint dontqueue = 0;\n\tu_int32_t blockno, blockcnt;\n\tstruct scsi_rw *rw;\n\tstruct scsi_rw_big *rwb;\n\tbus_dmamap_t xfer;\n\tint error;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_scsi_cmd \"));\n\n\tif (target >= GDT_MAX_HDRIVES || !gdt->sc_hdr[target].hd_present ||\n\t    link->lun != 0) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txs->error = XS_NOERROR;\n\tccb = NULL;\n\n\tGDT_LOCK_GDT(gdt);\n\tif (!gdt_polling && gdt->sc_test_busy(gdt)) {\n\t\t/* Don't double enqueue if we came from gdt_chain. */\n\t\tif (xs != LIST_FIRST(&gdt->sc_queue))\n\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase REQUEST_SENSE:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase START_STOP:\n\tcase READ_CAPACITY:\n\tcase SYNCHRONIZE_CACHE:\n#if 0\n\tcase VERIFY:\n#endif\n\t\treturn (gdt_internal_cache_cmd(xs) ? COMPLETE :\n\t\t    TRY_AGAIN_LATER);\n\n\tcase PREVENT_ALLOW:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"PREVENT/ALLOW \"));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_NOERROR;\n\t\treturn (COMPLETE);\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\tGDT_LOCK_GDT(gdt);\n\n\t\t/*\n\t\t * When chaining commands we may get called with the\n\t\t * first command in the queue, recognize this case\n\t\t * easily.\n\t\t */\n\t\tif (xs == LIST_FIRST(&gdt->sc_queue))\n\t\t\txs = gdt_dequeue(gdt);\n\t\telse {\n\t\t\t/* A new command chain, start from the beginning.  */\n\t\t\tgdt->sc_cmd_off = 0;\n\n\t\t\t/* Don't resort to queuing if we are polling.  */\n\t\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t\t/*\n\t\t\t * The queue, if existent, must be processed first,\n\t\t\t * before the new command can be run.\n\t\t\t */\n\t\t\tif (LIST_FIRST(&gdt->sc_queue) != NULL) {\n\t\t\t\t/* If order cannot be preserved, punt.  */\n\t\t\t\tif (dontqueue) {\n\t\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Enqueue the new command, ponder on the front\n\t\t\t\t * command of the queue instead.\n\t\t\t\t */\n\t\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\t\t\txs = gdt_dequeue(gdt);\n\t\t\t}\n\t\t}\n\n\t\tif (xs->cmdlen == 6) {\n\t\t\trw = (struct scsi_rw *)xs->cmd;\n\t\t\tblockno =\n\t\t\t    _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);\n\t\t\tblockcnt = rw->length ? rw->length : 0x100;\n\t\t} else {\n\t\t\trwb = (struct scsi_rw_big *)xs->cmd;\n\t\t\tblockno = _4btol(rwb->addr);\n\t\t\tblockcnt = _2btol(rwb->length);\n\t\t}\n\t\tif (blockno >= gdt->sc_hdr[target].hd_size ||\n\t\t    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\tprintf(\"%s: out of bounds %u-%u >= %u\\n\",\n\t\t\t    gdt->sc_dev.dv_xname, blockno, blockcnt,\n\t\t\t    gdt->sc_hdr[target].hd_size);\n\t\t\tscsi_done(xs);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t}\n\n\t\tccb = gdt_get_ccb(gdt, xs->flags);\n\n\t\t/*\n\t\t * Are we out of commands, then queue.  If we cannot queue,\n\t\t * then punt.\n\t\t */\n\t\tif (ccb == NULL) {\n\t\t\tif (dontqueue) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\t\t\tif (xs->error) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\n\t\t\t/* Put back on the queue, in the front.  */\n\t\t\tgdt_enqueue(gdt, xs, 1);\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\t\t}\n\n\t\tccb->gc_blockno = blockno;\n\t\tccb->gc_blockcnt = blockcnt;\n\t\tccb->gc_xs = xs;\n\t\tccb->gc_timeout = xs->timeout;\n\t\tccb->gc_service = GDT_CACHESERVICE;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);\n\n\t\txfer = ccb->gc_dmamap_xfer;\n\t\terror = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, \n\t\t    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? \n\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tprintf(\"%s: gdt_scsi_cmd: \", gdt->sc_dev.dv_xname); \n\t\t\tif (error == EFBIG)\n\t\t\t\tprintf(\"more than %d dma segs\\n\",\n\t\t\t\t    GDT_MAXOFFSETS);\n\t\t\telse\n\t\t\t\tprintf(\"error %d loading dma map\\n\", error);\n\t\t\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tgdt_free_ccb(gdt, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(gdt->sc_dmat, xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\tgdt_enqueue_ccb(gdt, ccb);\n\t\t/* XXX what if enqueue did not start a transfer? */\n\t\tif (gdt_polling) {\n\t\t\tif (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tprintf(\"%s: command %d timed out\\n\",\n\t\t\t\t    gdt->sc_dev.dv_xname, ccb->gc_cmd_index);\n\t\t\t\txs->error = XS_TIMEOUT;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t}\n\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\t\tif (gdt_polling) {\n \t\t\tscsi_done(xs);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\tdefault:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"unknown opc %d \", xs->cmd->opcode));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_chain",
            "struct scsi_xfer *gdt_dequeue",
            "void\tgdt_enqueue",
            "void\tgdt_enqueue_ccb",
            "void\tgdt_free_ccb",
            "struct gdt_ccb *gdt_get_ccb",
            "int\tgdt_internal_cache_cmd",
            "int\tgdt_scsi_cmd",
            "int\tgdt_wait",
            "u_int8_t gdt_polling;",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_chain;\nstruct scsi_xfer *gdt_dequeue;\nvoid\tgdt_enqueue;\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_free_ccb;\nstruct gdt_ccb *gdt_get_ccb;\nint\tgdt_internal_cache_cmd;\nint\tgdt_scsi_cmd;\nint\tgdt_wait;\nu_int8_t gdt_polling;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tstruct gdt_ccb *ccb;\n\tint dontqueue = 0;\n\tu_int32_t blockno, blockcnt;\n\tstruct scsi_rw *rw;\n\tstruct scsi_rw_big *rwb;\n\tbus_dmamap_t xfer;\n\tint error;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_scsi_cmd \"));\n\n\tif (target >= GDT_MAX_HDRIVES || !gdt->sc_hdr[target].hd_present ||\n\t    link->lun != 0) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txs->error = XS_NOERROR;\n\tccb = NULL;\n\n\tGDT_LOCK_GDT(gdt);\n\tif (!gdt_polling && gdt->sc_test_busy(gdt)) {\n\t\t/* Don't double enqueue if we came from gdt_chain. */\n\t\tif (xs != LIST_FIRST(&gdt->sc_queue))\n\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase REQUEST_SENSE:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase START_STOP:\n\tcase READ_CAPACITY:\n\tcase SYNCHRONIZE_CACHE:\n#if 0\n\tcase VERIFY:\n#endif\n\t\treturn (gdt_internal_cache_cmd(xs) ? COMPLETE :\n\t\t    TRY_AGAIN_LATER);\n\n\tcase PREVENT_ALLOW:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"PREVENT/ALLOW \"));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_NOERROR;\n\t\treturn (COMPLETE);\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\tGDT_LOCK_GDT(gdt);\n\n\t\t/*\n\t\t * When chaining commands we may get called with the\n\t\t * first command in the queue, recognize this case\n\t\t * easily.\n\t\t */\n\t\tif (xs == LIST_FIRST(&gdt->sc_queue))\n\t\t\txs = gdt_dequeue(gdt);\n\t\telse {\n\t\t\t/* A new command chain, start from the beginning.  */\n\t\t\tgdt->sc_cmd_off = 0;\n\n\t\t\t/* Don't resort to queuing if we are polling.  */\n\t\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t\t/*\n\t\t\t * The queue, if existent, must be processed first,\n\t\t\t * before the new command can be run.\n\t\t\t */\n\t\t\tif (LIST_FIRST(&gdt->sc_queue) != NULL) {\n\t\t\t\t/* If order cannot be preserved, punt.  */\n\t\t\t\tif (dontqueue) {\n\t\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Enqueue the new command, ponder on the front\n\t\t\t\t * command of the queue instead.\n\t\t\t\t */\n\t\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\t\t\txs = gdt_dequeue(gdt);\n\t\t\t}\n\t\t}\n\n\t\tif (xs->cmdlen == 6) {\n\t\t\trw = (struct scsi_rw *)xs->cmd;\n\t\t\tblockno =\n\t\t\t    _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);\n\t\t\tblockcnt = rw->length ? rw->length : 0x100;\n\t\t} else {\n\t\t\trwb = (struct scsi_rw_big *)xs->cmd;\n\t\t\tblockno = _4btol(rwb->addr);\n\t\t\tblockcnt = _2btol(rwb->length);\n\t\t}\n\t\tif (blockno >= gdt->sc_hdr[target].hd_size ||\n\t\t    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\tprintf(\"%s: out of bounds %u-%u >= %u\\n\",\n\t\t\t    gdt->sc_dev.dv_xname, blockno, blockcnt,\n\t\t\t    gdt->sc_hdr[target].hd_size);\n\t\t\tscsi_done(xs);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t}\n\n\t\tccb = gdt_get_ccb(gdt, xs->flags);\n\n\t\t/*\n\t\t * Are we out of commands, then queue.  If we cannot queue,\n\t\t * then punt.\n\t\t */\n\t\tif (ccb == NULL) {\n\t\t\tif (dontqueue) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\t\t\tif (xs->error) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\n\t\t\t/* Put back on the queue, in the front.  */\n\t\t\tgdt_enqueue(gdt, xs, 1);\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\t\t}\n\n\t\tccb->gc_blockno = blockno;\n\t\tccb->gc_blockcnt = blockcnt;\n\t\tccb->gc_xs = xs;\n\t\tccb->gc_timeout = xs->timeout;\n\t\tccb->gc_service = GDT_CACHESERVICE;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);\n\n\t\txfer = ccb->gc_dmamap_xfer;\n\t\terror = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, \n\t\t    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? \n\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tprintf(\"%s: gdt_scsi_cmd: \", gdt->sc_dev.dv_xname); \n\t\t\tif (error == EFBIG)\n\t\t\t\tprintf(\"more than %d dma segs\\n\",\n\t\t\t\t    GDT_MAXOFFSETS);\n\t\t\telse\n\t\t\t\tprintf(\"error %d loading dma map\\n\", error);\n\t\t\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tgdt_free_ccb(gdt, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(gdt->sc_dmat, xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\tgdt_enqueue_ccb(gdt, ccb);\n\t\t/* XXX what if enqueue did not start a transfer? */\n\t\tif (gdt_polling) {\n\t\t\tif (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tprintf(\"%s: command %d timed out\\n\",\n\t\t\t\t    gdt->sc_dev.dv_xname, ccb->gc_cmd_index);\n\t\t\t\txs->error = XS_TIMEOUT;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t}\n\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\t\tif (gdt_polling) {\n \t\t\tscsi_done(xs);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\tdefault:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"unknown opc %d \", xs->cmd->opcode));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_chain(%p) \", gdt)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_chain;\nint\tgdt_scsi_cmd;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_chain(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_chain(%p) \", gdt));\n\n\tif (LIST_FIRST(&gdt->sc_queue))\n\t\tgdt_scsi_cmd(LIST_FIRST(&gdt->sc_queue));\n}"
  },
  {
    "function_name": "gdt_start_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1242-1266",
    "snippet": "void\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_exec_ccb",
      "void\tgdt_start_ccbs",
      "void\tgdt_timeout",
      "void\tgdt_watchdog",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "gdt_timeout",
            "ccb",
            "(ccb->gc_timeout * hz) / 1000"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1278-1295",
          "snippet": "void\ngdt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tsc_print_addr(link);\n\tprintf(\"timed out\\n\");\n\n\t/* XXX Test for multiple timeouts */\n\n\tccb->gc_xs->error = XS_TIMEOUT;\n\tGDT_LOCK_GDT(gdt);\n\tgdt_enqueue_ccb(gdt, ccb);\n\tGDT_UNLOCK_GDT(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_enqueue_ccb",
            "void\tgdt_timeout",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_timeout;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct gdt_ccb *ccb = arg;\n\tstruct scsi_link *link = ccb->gc_xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\n\tsc_print_addr(link);\n\tprintf(\"timed out\\n\");\n\n\t/* XXX Test for multiple timeouts */\n\n\tccb->gc_xs->error = XS_TIMEOUT;\n\tGDT_LOCK_GDT(gdt);\n\tgdt_enqueue_ccb(gdt, ccb);\n\tGDT_UNLOCK_GDT(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&gdt->sc_ccbq",
            "ccb",
            "gc_chain"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_exec_ccb",
          "args": [
            "ccb"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_exec_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "660-760",
          "snippet": "int\ngdt_exec_ccb(ccb)\n\tstruct gdt_ccb *ccb;\n{\n\tstruct scsi_xfer *xs = ccb->gc_xs;\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tu_int32_t sg_canz;\n\tbus_dmamap_t xfer;\n\tint i;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_exec_ccb(%p, %p) \", xs, ccb));\n\n\tgdt->sc_cmd_cnt = 0;\n\t/*\n\t * XXX Yeah I know it's a always-true condition, but that may change\n\t * later.\n\t */\n\tif (gdt->sc_cmd_cnt == 0)\n\t\tgdt->sc_set_sema0(gdt);\n\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,\n\t    target);\n\n\tswitch (xs->cmd->opcode) {\n\tcase PREVENT_ALLOW:\n\t\t/* XXX PREVENT_ALLOW support goes here */\n\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    1);\n\t\tsg_canz = 0;\n\t\tbreak;\n\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\t/* XXX WRITE_THR could be supported too */\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;\n\t\tbreak;\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;\n\t\tbreak;\n\t}\n\n\tif (xs->cmd->opcode != PREVENT_ALLOW) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    ccb->gc_blockno);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,\n\t\t    ccb->gc_blockcnt);\n\t}\n\n\txfer = ccb->gc_dmamap_xfer;\n\tif (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    0xffffffff);\n\t\tfor (i = 0; i < xfer->dm_nsegs; i++) {\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,\n\t\t\t    xfer->dm_segs[i].ds_addr);\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_LEN,\n\t\t\t    xfer->dm_segs[i].ds_len);\n\t\t\tGDT_DPRINTF(GDT_D_IO, (\"#%d va %p pa %p len %x\\n\", i,\n\t\t\t    buf, xfer->dm_segs[i].ds_addr,\n\t\t\t    xfer->dm_segs[i].ds_len));\n\t\t}\n\t\tsg_canz = xfer->dm_nsegs;\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +\n\t\t    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);\n\t} else {\n\t\t/* XXX Hardly correct */\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    xfer->dm_segs[0].ds_addr);\n\t\tsg_canz = 0;\n\t}\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);\n\n\tgdt->sc_cmd_len =\n\t    roundup(GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ,\n\t    sizeof (u_int32_t));\n\n\tif (gdt->sc_cmd_cnt > 0 &&\n\t    gdt->sc_cmd_off + gdt->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >\n\t    gdt->sc_ic_all_size) {\n\t\tprintf(\"%s: DPMEM overflow\\n\", gdt->sc_dev.dv_xname);\n\t\tgdt_free_ccb(gdt, ccb);\n\t\txs->error = XS_BUSY;\n\t\treturn (0);\n\t}\n\n\tgdt->sc_copy_cmd(gdt, ccb);\n\tgdt->sc_release_event(gdt, ccb);\n\n\txs->error = XS_NOERROR;\n\txs->resid = 0;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_exec_ccb",
            "void\tgdt_free_ccb",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_exec_ccb;\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_exec_ccb(ccb)\n\tstruct gdt_ccb *ccb;\n{\n\tstruct scsi_xfer *xs = ccb->gc_xs;\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tu_int32_t sg_canz;\n\tbus_dmamap_t xfer;\n\tint i;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_exec_ccb(%p, %p) \", xs, ccb));\n\n\tgdt->sc_cmd_cnt = 0;\n\t/*\n\t * XXX Yeah I know it's a always-true condition, but that may change\n\t * later.\n\t */\n\tif (gdt->sc_cmd_cnt == 0)\n\t\tgdt->sc_set_sema0(gdt);\n\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,\n\t    target);\n\n\tswitch (xs->cmd->opcode) {\n\tcase PREVENT_ALLOW:\n\t\t/* XXX PREVENT_ALLOW support goes here */\n\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    1);\n\t\tsg_canz = 0;\n\t\tbreak;\n\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\t/* XXX WRITE_THR could be supported too */\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;\n\t\tbreak;\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;\n\t\tbreak;\n\t}\n\n\tif (xs->cmd->opcode != PREVENT_ALLOW) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    ccb->gc_blockno);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,\n\t\t    ccb->gc_blockcnt);\n\t}\n\n\txfer = ccb->gc_dmamap_xfer;\n\tif (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    0xffffffff);\n\t\tfor (i = 0; i < xfer->dm_nsegs; i++) {\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,\n\t\t\t    xfer->dm_segs[i].ds_addr);\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_LEN,\n\t\t\t    xfer->dm_segs[i].ds_len);\n\t\t\tGDT_DPRINTF(GDT_D_IO, (\"#%d va %p pa %p len %x\\n\", i,\n\t\t\t    buf, xfer->dm_segs[i].ds_addr,\n\t\t\t    xfer->dm_segs[i].ds_len));\n\t\t}\n\t\tsg_canz = xfer->dm_nsegs;\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +\n\t\t    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);\n\t} else {\n\t\t/* XXX Hardly correct */\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    xfer->dm_segs[0].ds_addr);\n\t\tsg_canz = 0;\n\t}\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);\n\n\tgdt->sc_cmd_len =\n\t    roundup(GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ,\n\t    sizeof (u_int32_t));\n\n\tif (gdt->sc_cmd_cnt > 0 &&\n\t    gdt->sc_cmd_off + gdt->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >\n\t    gdt->sc_ic_all_size) {\n\t\tprintf(\"%s: DPMEM overflow\\n\", gdt->sc_dev.dv_xname);\n\t\tgdt_free_ccb(gdt, ccb);\n\t\txs->error = XS_BUSY;\n\t\treturn (0);\n\t}\n\n\tgdt->sc_copy_cmd(gdt, ccb);\n\tgdt->sc_release_event(gdt, ccb);\n\n\txs->error = XS_NOERROR;\n\txs->resid = 0;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "gdt_watchdog",
            "ccb"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&gdt->sc_ccbq"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_QUEUE",
            "(\"gdt_start_ccbs(%p) \", gdt)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_exec_ccb;\nvoid\tgdt_start_ccbs;\nvoid\tgdt_timeout;\nvoid\tgdt_watchdog;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nvoid\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}"
  },
  {
    "function_name": "gdt_enqueue_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1231-1240",
    "snippet": "void\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_enqueue_ccb",
      "void\tgdt_start_ccbs",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdt_start_ccbs",
          "args": [
            "gdt"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1242-1266",
          "snippet": "void\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_exec_ccb",
            "void\tgdt_start_ccbs",
            "void\tgdt_timeout",
            "void\tgdt_watchdog",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_exec_ccb;\nvoid\tgdt_start_ccbs;\nvoid\tgdt_timeout;\nvoid\tgdt_watchdog;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nvoid\ngdt_start_ccbs(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_start_ccbs(%p) \", gdt));\n\n\twhile ((ccb = TAILQ_FIRST(&gdt->sc_ccbq)) != NULL) {\n\t\tif (ccb->gc_flags & GDT_GCF_WATCHDOG)\n\t\t\tuntimeout(gdt_watchdog, ccb);\n\n\t\tif (gdt_exec_ccb(ccb) == 0) {\n\t\t\tccb->gc_flags |= GDT_GCF_WATCHDOG;\n\t\t\ttimeout(gdt_watchdog, ccb,\n\t\t\t    (GDT_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&gdt->sc_ccbq, ccb, gc_chain);\n\n\t\tif ((ccb->gc_xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(gdt_timeout, ccb,\n\t\t\t    (ccb->gc_timeout * hz) / 1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&gdt->sc_ccbq",
            "ccb",
            "gc_chain"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_QUEUE",
            "(\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_start_ccbs;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}"
  },
  {
    "function_name": "gdt_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1213-1229",
    "snippet": "void\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_free_ccb",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&gdt->sc_free_ccb"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "ccb",
            "gc_chain"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&gdt->sc_free_ccb",
            "ccb",
            "gc_chain"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_QUEUE",
            "(\"gdt_free_ccb(%p, %p) \", gdt, ccb)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}"
  },
  {
    "function_name": "gdt_internal_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1109-1184",
    "snippet": "int\ngdt_internal_cmd(gdt, service, opcode, arg1, arg2, arg3)\n\tstruct gdt_softc *gdt;\n\tu_int8_t service;\n\tu_int16_t opcode;\n\tu_int32_t arg1, arg2, arg3;\n{\n\tint retries;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cmd(%p, %d, %d, %d, %d, %d) \",\n\t    gdt, service, opcode, arg1, arg2, arg3));\n\n\tbzero(gdt->sc_cmd, GDT_CMD_SZ);\n\n\tfor (retries = GDT_RETRIES; ; ) {\n\t\tccb = gdt_get_ccb(gdt, SCSI_NOSLEEP);\n\t\tif (ccb == NULL) {\n\t\t\tprintf(\"%s: no free command index found\\n\",\n\t\t\t    gdt->sc_dev.dv_xname);\n\t\t\treturn (0);\n\t\t}\n\t\tccb->gc_service = service;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_INTERNAL);\n\n\t\tgdt->sc_set_sema0(gdt);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX,\n\t\t    ccb->gc_cmd_index);\n\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_OPCODE, opcode);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\n\t\tswitch (service) {\n\t\tcase GDT_CACHESERVICE:\n\t\t\tif (opcode == GDT_IOCTL) {\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_SUBFUNC, arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_CHANNEL, arg2);\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_PARAM_SIZE, (u_int16_t)arg3);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_P_PARAM,\n\t\t\t\t    vtophys(gdt->sc_scratch));\n\t\t\t} else {\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_DEVICENO, (u_int16_t)arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_BLOCKNO, arg2);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GDT_SCSIRAWSERVICE:\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_RAW_DIRECTION, arg1);\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =\n\t\t\t    (u_int8_t)arg2;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =\n\t\t\t    (u_int8_t)arg3;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =\n\t\t\t    (u_int8_t)(arg3 >> 8);\n\t\t}\n\n\t\tgdt->sc_cmd_len = GDT_CMD_SZ;\n\t\tgdt->sc_cmd_off = 0;\n\t\tgdt->sc_cmd_cnt = 0;\n\t\tgdt->sc_copy_cmd(gdt, ccb);\n\t\tgdt->sc_release_event(gdt, ccb);\n\t\tDELAY(20);\n\t\tif (!gdt_wait(gdt, ccb, GDT_POLL_TIMEOUT))\n\t\t\treturn (0);\n\t\tif (gdt->sc_status != GDT_S_BSY || --retries == 0)\n\t\t\tbreak;\n\t\tDELAY(1);\n\t}\n\treturn (gdt->sc_status == GDT_S_OK);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct gdt_ccb *gdt_get_ccb",
      "int\tgdt_internal_cmd",
      "int\tgdt_wait",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_wait",
          "args": [
            "gdt",
            "ccb",
            "GDT_POLL_TIMEOUT"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1081-1107",
          "snippet": "int\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_wait",
            "u_int8_t gdt_from_wait;",
            "struct gdt_softc *gdt_wait_gdt;",
            "int\tgdt_wait_index;",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_wait;\nu_int8_t gdt_from_wait;\nstruct gdt_softc *gdt_wait_gdt;\nint\tgdt_wait_index;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_release_event",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_copy_cmd",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg3 >> 8"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_enc32",
          "args": [
            "gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_RAW_DIRECTION",
            "arg1"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "245-251",
          "snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_enc16",
          "args": [
            "gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_DEVICENO",
            "(u_int16_t)arg1"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "237-243",
          "snippet": "static __inline__ void\ngdt_enc16(addr, value)\n\tu_int8_t *addr;\n\tu_int16_t value;\n{\n\t*(u_int16_t *)addr = htole16(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc16(addr, value)\n\tu_int8_t *addr;\n\tu_int16_t value;\n{\n\t*(u_int16_t *)addr = htole16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "gdt->sc_scratch"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_set_sema0",
          "args": [
            "gdt"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_ccb_set_cmd",
          "args": [
            "ccb",
            "GDT_GCF_INTERNAL"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_ccb_set_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "89-99",
          "snippet": "static __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}",
          "includes": [],
          "macros_used": [
            "#define GDT_GCF_CMD_MASK\t0x3"
          ],
          "globals_used": [
            "static __inline__ int gdt_ccb_set_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#define GDT_GCF_CMD_MASK\t0x3\n\nstatic __inline__ int gdt_ccb_set_cmd;\n\nstatic __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no free command index found\\n\"",
            "gdt->sc_dev.dv_xname"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_get_ccb",
          "args": [
            "gdt",
            "SCSI_NOSLEEP"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "gdt->sc_cmd",
            "GDT_CMD_SZ"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_internal_cmd(%p, %d, %d, %d, %d, %d) \",\n\t    gdt, service, opcode, arg1, arg2, arg3)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct gdt_ccb *gdt_get_ccb;\nint\tgdt_internal_cmd;\nint\tgdt_wait;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_internal_cmd(gdt, service, opcode, arg1, arg2, arg3)\n\tstruct gdt_softc *gdt;\n\tu_int8_t service;\n\tu_int16_t opcode;\n\tu_int32_t arg1, arg2, arg3;\n{\n\tint retries;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cmd(%p, %d, %d, %d, %d, %d) \",\n\t    gdt, service, opcode, arg1, arg2, arg3));\n\n\tbzero(gdt->sc_cmd, GDT_CMD_SZ);\n\n\tfor (retries = GDT_RETRIES; ; ) {\n\t\tccb = gdt_get_ccb(gdt, SCSI_NOSLEEP);\n\t\tif (ccb == NULL) {\n\t\t\tprintf(\"%s: no free command index found\\n\",\n\t\t\t    gdt->sc_dev.dv_xname);\n\t\t\treturn (0);\n\t\t}\n\t\tccb->gc_service = service;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_INTERNAL);\n\n\t\tgdt->sc_set_sema0(gdt);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX,\n\t\t    ccb->gc_cmd_index);\n\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_OPCODE, opcode);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\n\t\tswitch (service) {\n\t\tcase GDT_CACHESERVICE:\n\t\t\tif (opcode == GDT_IOCTL) {\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_SUBFUNC, arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_CHANNEL, arg2);\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_PARAM_SIZE, (u_int16_t)arg3);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_P_PARAM,\n\t\t\t\t    vtophys(gdt->sc_scratch));\n\t\t\t} else {\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_DEVICENO, (u_int16_t)arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_BLOCKNO, arg2);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GDT_SCSIRAWSERVICE:\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_RAW_DIRECTION, arg1);\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =\n\t\t\t    (u_int8_t)arg2;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =\n\t\t\t    (u_int8_t)arg3;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =\n\t\t\t    (u_int8_t)(arg3 >> 8);\n\t\t}\n\n\t\tgdt->sc_cmd_len = GDT_CMD_SZ;\n\t\tgdt->sc_cmd_off = 0;\n\t\tgdt->sc_cmd_cnt = 0;\n\t\tgdt->sc_copy_cmd(gdt, ccb);\n\t\tgdt->sc_release_event(gdt, ccb);\n\t\tDELAY(20);\n\t\tif (!gdt_wait(gdt, ccb, GDT_POLL_TIMEOUT))\n\t\t\treturn (0);\n\t\tif (gdt->sc_status != GDT_S_BSY || --retries == 0)\n\t\t\tbreak;\n\t\tDELAY(1);\n\t}\n\treturn (gdt->sc_status == GDT_S_OK);\n}"
  },
  {
    "function_name": "gdt_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1081-1107",
    "snippet": "int\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_wait",
      "u_int8_t gdt_from_wait;",
      "struct gdt_softc *gdt_wait_gdt;",
      "int\tgdt_wait_index;",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "0"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_test_busy",
          "args": [
            "gdt"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_intr",
          "args": [
            "gdt"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "960-1052",
          "snippet": "int\ngdt_intr(arg)\n\tvoid *arg;\n{\n\tstruct gdt_softc *gdt = arg;\n\tstruct gdt_intr_ctx ctx;\n\tint chain = 1, sync_val = 0;\n\tstruct scsi_xfer *xs;\n\tint prev_cmd;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_intr(%p) \", gdt));\n\n\t/* If polling and we were not called from gdt_wait, just return */\n\tif (gdt_polling && !gdt_from_wait)\n\t\treturn (0);\n\n\tif (!gdt_polling)\n\t\tGDT_LOCK_GDT(gdt);\n\n\tctx.istatus = gdt->sc_get_status(gdt);\n\tif (!ctx.istatus) {\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\tgdt->sc_status = GDT_S_NO_STATUS;\n\t\treturn (0);\n\t}\n\n\tgdt_wait_index = 0;\n\tctx.service = ctx.info2 = 0;\n\n\tgdt->sc_intr(gdt, &ctx);\n\n\tgdt->sc_status = ctx.cmd_status;\n\tgdt->sc_info = ctx.info;\n\tgdt->sc_info2 = ctx.info2;\n\n\tif (gdt_from_wait) {\n\t\tgdt_wait_gdt = gdt;\n\t\tgdt_wait_index = ctx.istatus;\n\t}\n\n\tswitch (ctx.istatus) {\n\tcase GDT_ASYNCINDEX:\n\t\tgdt_async_event(gdt, ctx.service);\n\t\tgoto finish;\n\n\tcase GDT_SPEZINDEX:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tccb = &gdt->sc_ccbs[ctx.istatus - 2];\n\txs = ccb->gc_xs;\n\tif (!gdt_polling)\n\t\tuntimeout(gdt_timeout, ccb);\n\tctx.service = ccb->gc_service;\n\tprev_cmd = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\tbus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,\n\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);\n\tgdt_free_ccb(gdt, ccb);\n\tswitch (prev_cmd) {\n\tcase GDT_GCF_UNUSED:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\tcase GDT_GCF_INTERNAL:\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tsync_val = gdt_sync_event(gdt, ctx.service, ctx.istatus, xs);\n\n finish:\n\tif (!gdt_polling)\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (sync_val) {\n\tcase 1:\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t\tbreak;\n\n\tcase 2:\n\t\tgdt_enqueue(gdt, xs, 0);\n\t}\n\n\tif (chain)\n\t\tgdt_chain(gdt);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_async_event",
            "void\tgdt_chain",
            "void\tgdt_enqueue",
            "void\tgdt_free_ccb",
            "int\tgdt_sync_event",
            "void\tgdt_timeout",
            "int\tgdt_wait",
            "u_int8_t gdt_polling;",
            "u_int8_t gdt_from_wait;",
            "struct gdt_softc *gdt_wait_gdt;",
            "int\tgdt_wait_index;",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_async_event;\nvoid\tgdt_chain;\nvoid\tgdt_enqueue;\nvoid\tgdt_free_ccb;\nint\tgdt_sync_event;\nvoid\tgdt_timeout;\nint\tgdt_wait;\nu_int8_t gdt_polling;\nu_int8_t gdt_from_wait;\nstruct gdt_softc *gdt_wait_gdt;\nint\tgdt_wait_index;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_intr(arg)\n\tvoid *arg;\n{\n\tstruct gdt_softc *gdt = arg;\n\tstruct gdt_intr_ctx ctx;\n\tint chain = 1, sync_val = 0;\n\tstruct scsi_xfer *xs;\n\tint prev_cmd;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_intr(%p) \", gdt));\n\n\t/* If polling and we were not called from gdt_wait, just return */\n\tif (gdt_polling && !gdt_from_wait)\n\t\treturn (0);\n\n\tif (!gdt_polling)\n\t\tGDT_LOCK_GDT(gdt);\n\n\tctx.istatus = gdt->sc_get_status(gdt);\n\tif (!ctx.istatus) {\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\tgdt->sc_status = GDT_S_NO_STATUS;\n\t\treturn (0);\n\t}\n\n\tgdt_wait_index = 0;\n\tctx.service = ctx.info2 = 0;\n\n\tgdt->sc_intr(gdt, &ctx);\n\n\tgdt->sc_status = ctx.cmd_status;\n\tgdt->sc_info = ctx.info;\n\tgdt->sc_info2 = ctx.info2;\n\n\tif (gdt_from_wait) {\n\t\tgdt_wait_gdt = gdt;\n\t\tgdt_wait_index = ctx.istatus;\n\t}\n\n\tswitch (ctx.istatus) {\n\tcase GDT_ASYNCINDEX:\n\t\tgdt_async_event(gdt, ctx.service);\n\t\tgoto finish;\n\n\tcase GDT_SPEZINDEX:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tccb = &gdt->sc_ccbs[ctx.istatus - 2];\n\txs = ccb->gc_xs;\n\tif (!gdt_polling)\n\t\tuntimeout(gdt_timeout, ccb);\n\tctx.service = ccb->gc_service;\n\tprev_cmd = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\tbus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,\n\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);\n\tgdt_free_ccb(gdt, ccb);\n\tswitch (prev_cmd) {\n\tcase GDT_GCF_UNUSED:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\tcase GDT_GCF_INTERNAL:\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tsync_val = gdt_sync_event(gdt, ctx.service, ctx.istatus, xs);\n\n finish:\n\tif (!gdt_polling)\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (sync_val) {\n\tcase 1:\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t\tbreak;\n\n\tcase 2:\n\t\tgdt_enqueue(gdt, xs, 0);\n\t}\n\n\tif (chain)\n\t\tgdt_chain(gdt);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_wait;\nu_int8_t gdt_from_wait;\nstruct gdt_softc *gdt_wait_gdt;\nint\tgdt_wait_index;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "gdtminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "1054-1079",
    "snippet": "void\ngdtminphys(bp)\n\tstruct buf *bp;\n{\n#if 0\n\tu_int8_t *buf = bp->b_data;\n\tpaddr_t pa;\n\tlong off;\n#endif\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdtminphys(0x%x) \", bp));\n\n#if 1\n\t/* As this is way more than MAXPHYS it's really not necessary. */\n\tif (bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((GDT_MAXOFFSETS - 1) * PAGE_SIZE);\n#else\n\tfor (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;\n\t    off += PAGE_SIZE)\n\t\tif (pa + off != vtophys(buf + off)) {\n\t\t\tbp->b_bcount = off;\n\t\t\tbreak;\n\t\t}\n#endif\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "gdtminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1054-1079",
          "snippet": "void\ngdtminphys(bp)\n\tstruct buf *bp;\n{\n#if 0\n\tu_int8_t *buf = bp->b_data;\n\tpaddr_t pa;\n\tlong off;\n#endif\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdtminphys(0x%x) \", bp));\n\n#if 1\n\t/* As this is way more than MAXPHYS it's really not necessary. */\n\tif (bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((GDT_MAXOFFSETS - 1) * PAGE_SIZE);\n#else\n\tfor (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;\n\t    off += PAGE_SIZE)\n\t\tif (pa + off != vtophys(buf + off)) {\n\t\t\tbp->b_bcount = off;\n\t\t\tbreak;\n\t\t}\n#endif\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "buf + off"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "buf"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdtminphys(0x%x) \", bp)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngdtminphys(bp)\n\tstruct buf *bp;\n{\n#if 0\n\tu_int8_t *buf = bp->b_data;\n\tpaddr_t pa;\n\tlong off;\n#endif\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdtminphys(0x%x) \", bp));\n\n#if 1\n\t/* As this is way more than MAXPHYS it's really not necessary. */\n\tif (bp->b_bcount > ((GDT_MAXOFFSETS - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((GDT_MAXOFFSETS - 1) * PAGE_SIZE);\n#else\n\tfor (off = PAGE_SIZE, pa = vtophys(buf); off < bp->b_bcount;\n\t    off += PAGE_SIZE)\n\t\tif (pa + off != vtophys(buf + off)) {\n\t\t\tbp->b_bcount = off;\n\t\t\tbreak;\n\t\t}\n#endif\n\tminphys(bp);\n}"
  },
  {
    "function_name": "gdt_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "960-1052",
    "snippet": "int\ngdt_intr(arg)\n\tvoid *arg;\n{\n\tstruct gdt_softc *gdt = arg;\n\tstruct gdt_intr_ctx ctx;\n\tint chain = 1, sync_val = 0;\n\tstruct scsi_xfer *xs;\n\tint prev_cmd;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_intr(%p) \", gdt));\n\n\t/* If polling and we were not called from gdt_wait, just return */\n\tif (gdt_polling && !gdt_from_wait)\n\t\treturn (0);\n\n\tif (!gdt_polling)\n\t\tGDT_LOCK_GDT(gdt);\n\n\tctx.istatus = gdt->sc_get_status(gdt);\n\tif (!ctx.istatus) {\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\tgdt->sc_status = GDT_S_NO_STATUS;\n\t\treturn (0);\n\t}\n\n\tgdt_wait_index = 0;\n\tctx.service = ctx.info2 = 0;\n\n\tgdt->sc_intr(gdt, &ctx);\n\n\tgdt->sc_status = ctx.cmd_status;\n\tgdt->sc_info = ctx.info;\n\tgdt->sc_info2 = ctx.info2;\n\n\tif (gdt_from_wait) {\n\t\tgdt_wait_gdt = gdt;\n\t\tgdt_wait_index = ctx.istatus;\n\t}\n\n\tswitch (ctx.istatus) {\n\tcase GDT_ASYNCINDEX:\n\t\tgdt_async_event(gdt, ctx.service);\n\t\tgoto finish;\n\n\tcase GDT_SPEZINDEX:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tccb = &gdt->sc_ccbs[ctx.istatus - 2];\n\txs = ccb->gc_xs;\n\tif (!gdt_polling)\n\t\tuntimeout(gdt_timeout, ccb);\n\tctx.service = ccb->gc_service;\n\tprev_cmd = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\tbus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,\n\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);\n\tgdt_free_ccb(gdt, ccb);\n\tswitch (prev_cmd) {\n\tcase GDT_GCF_UNUSED:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\tcase GDT_GCF_INTERNAL:\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tsync_val = gdt_sync_event(gdt, ctx.service, ctx.istatus, xs);\n\n finish:\n\tif (!gdt_polling)\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (sync_val) {\n\tcase 1:\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t\tbreak;\n\n\tcase 2:\n\t\tgdt_enqueue(gdt, xs, 0);\n\t}\n\n\tif (chain)\n\t\tgdt_chain(gdt);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_async_event",
      "void\tgdt_chain",
      "void\tgdt_enqueue",
      "void\tgdt_free_ccb",
      "int\tgdt_sync_event",
      "void\tgdt_timeout",
      "int\tgdt_wait",
      "u_int8_t gdt_polling;",
      "u_int8_t gdt_from_wait;",
      "struct gdt_softc *gdt_wait_gdt;",
      "int\tgdt_wait_index;",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdt_chain",
          "args": [
            "gdt"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1268-1276",
          "snippet": "void\ngdt_chain(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_chain(%p) \", gdt));\n\n\tif (LIST_FIRST(&gdt->sc_queue))\n\t\tgdt_scsi_cmd(LIST_FIRST(&gdt->sc_queue));\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_chain",
            "int\tgdt_scsi_cmd",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_chain;\nint\tgdt_scsi_cmd;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_chain(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_chain(%p) \", gdt));\n\n\tif (LIST_FIRST(&gdt->sc_queue))\n\t\tgdt_scsi_cmd(LIST_FIRST(&gdt->sc_queue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_enqueue",
          "args": [
            "gdt",
            "xs",
            "0"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enqueue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1231-1240",
          "snippet": "void\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_enqueue_ccb",
            "void\tgdt_start_ccbs",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_start_ccbs;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_sync_event",
          "args": [
            "gdt",
            "ctx.service",
            "ctx.istatus",
            "xs"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_sync_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "935-958",
          "snippet": "int\ngdt_sync_event(gdt, service, index, xs)\n\tstruct gdt_softc *gdt;\n\tint service;\n\tu_int8_t index;\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_INTR,\n\t    (\"gdt_sync_event(%p, %d, %d, %p) \", gdt, service, index, xs));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t\treturn (0);\n\t} else {\n\t\tif (gdt->sc_status == GDT_S_OK) {\n\t\t\t/* XXX To be implemented */\n\t\t} else {\n\t\t\t/* XXX To be implemented */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_sync_event",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_sync_event;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_sync_event(gdt, service, index, xs)\n\tstruct gdt_softc *gdt;\n\tint service;\n\tu_int8_t index;\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_INTR,\n\t    (\"gdt_sync_event(%p, %d, %d, %p) \", gdt, service, index, xs));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t\treturn (0);\n\t} else {\n\t\tif (gdt->sc_status == GDT_S_OK) {\n\t\t\t/* XXX To be implemented */\n\t\t} else {\n\t\t\t/* XXX To be implemented */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_free_ccb",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1213-1229",
          "snippet": "void\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_free_ccb",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "gdt->sc_dmat",
            "ccb->gc_dmamap_xfer"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "gdt->sc_dmat",
            "ccb->gc_dmamap_xfer",
            "(xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "gdt_timeout",
            "ccb"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_async_event",
          "args": [
            "gdt",
            "ctx.service"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_async_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "919-933",
          "snippet": "int\ngdt_async_event(gdt, service)\n\tstruct gdt_softc *gdt;\n\tint service;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_async_event(%p, %d) \", gdt, service));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t} else {\n\t\t/* XXX To be implemented */\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_async_event",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_async_event;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_async_event(gdt, service)\n\tstruct gdt_softc *gdt;\n\tint service;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_async_event(%p, %d) \", gdt, service));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t} else {\n\t\t/* XXX To be implemented */\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt->sc_intr",
          "args": [
            "gdt",
            "&ctx"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_get_status",
          "args": [
            "gdt"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_intr(%p) \", gdt)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_async_event;\nvoid\tgdt_chain;\nvoid\tgdt_enqueue;\nvoid\tgdt_free_ccb;\nint\tgdt_sync_event;\nvoid\tgdt_timeout;\nint\tgdt_wait;\nu_int8_t gdt_polling;\nu_int8_t gdt_from_wait;\nstruct gdt_softc *gdt_wait_gdt;\nint\tgdt_wait_index;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_intr(arg)\n\tvoid *arg;\n{\n\tstruct gdt_softc *gdt = arg;\n\tstruct gdt_intr_ctx ctx;\n\tint chain = 1, sync_val = 0;\n\tstruct scsi_xfer *xs;\n\tint prev_cmd;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_intr(%p) \", gdt));\n\n\t/* If polling and we were not called from gdt_wait, just return */\n\tif (gdt_polling && !gdt_from_wait)\n\t\treturn (0);\n\n\tif (!gdt_polling)\n\t\tGDT_LOCK_GDT(gdt);\n\n\tctx.istatus = gdt->sc_get_status(gdt);\n\tif (!ctx.istatus) {\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\tgdt->sc_status = GDT_S_NO_STATUS;\n\t\treturn (0);\n\t}\n\n\tgdt_wait_index = 0;\n\tctx.service = ctx.info2 = 0;\n\n\tgdt->sc_intr(gdt, &ctx);\n\n\tgdt->sc_status = ctx.cmd_status;\n\tgdt->sc_info = ctx.info;\n\tgdt->sc_info2 = ctx.info2;\n\n\tif (gdt_from_wait) {\n\t\tgdt_wait_gdt = gdt;\n\t\tgdt_wait_index = ctx.istatus;\n\t}\n\n\tswitch (ctx.istatus) {\n\tcase GDT_ASYNCINDEX:\n\t\tgdt_async_event(gdt, ctx.service);\n\t\tgoto finish;\n\n\tcase GDT_SPEZINDEX:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tccb = &gdt->sc_ccbs[ctx.istatus - 2];\n\txs = ccb->gc_xs;\n\tif (!gdt_polling)\n\t\tuntimeout(gdt_timeout, ccb);\n\tctx.service = ccb->gc_service;\n\tprev_cmd = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\tbus_dmamap_sync(gdt->sc_dmat, ccb->gc_dmamap_xfer,\n\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(gdt->sc_dmat, ccb->gc_dmamap_xfer);\n\tgdt_free_ccb(gdt, ccb);\n\tswitch (prev_cmd) {\n\tcase GDT_GCF_UNUSED:\n\t\t/* XXX Not yet implemented */\n\t\tchain = 0;\n\t\tgoto finish;\n\tcase GDT_GCF_INTERNAL:\n\t\tchain = 0;\n\t\tgoto finish;\n\t}\n\n\tsync_val = gdt_sync_event(gdt, ctx.service, ctx.istatus, xs);\n\n finish:\n\tif (!gdt_polling)\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (sync_val) {\n\tcase 1:\n\t\txs->flags |= ITSDONE;\n\t\tscsi_done(xs);\n\t\tbreak;\n\n\tcase 2:\n\t\tgdt_enqueue(gdt, xs, 0);\n\t}\n\n\tif (chain)\n\t\tgdt_chain(gdt);\n\treturn (1);\n}"
  },
  {
    "function_name": "gdt_sync_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "935-958",
    "snippet": "int\ngdt_sync_event(gdt, service, index, xs)\n\tstruct gdt_softc *gdt;\n\tint service;\n\tu_int8_t index;\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_INTR,\n\t    (\"gdt_sync_event(%p, %d, %d, %p) \", gdt, service, index, xs));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t\treturn (0);\n\t} else {\n\t\tif (gdt->sc_status == GDT_S_OK) {\n\t\t\t/* XXX To be implemented */\n\t\t} else {\n\t\t\t/* XXX To be implemented */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_sync_event",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_sync_event(%p, %d, %d, %p) \", gdt, service, index, xs)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_sync_event;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_sync_event(gdt, service, index, xs)\n\tstruct gdt_softc *gdt;\n\tint service;\n\tu_int8_t index;\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_INTR,\n\t    (\"gdt_sync_event(%p, %d, %d, %p) \", gdt, service, index, xs));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t\treturn (0);\n\t} else {\n\t\tif (gdt->sc_status == GDT_S_OK) {\n\t\t\t/* XXX To be implemented */\n\t\t} else {\n\t\t\t/* XXX To be implemented */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "gdt_async_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "919-933",
    "snippet": "int\ngdt_async_event(gdt, service)\n\tstruct gdt_softc *gdt;\n\tint service;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_async_event(%p, %d) \", gdt, service));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t} else {\n\t\t/* XXX To be implemented */\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_async_event",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_async_event(%p, %d) \", gdt, service)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_async_event;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_async_event(gdt, service)\n\tstruct gdt_softc *gdt;\n\tint service;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_async_event(%p, %d) \", gdt, service));\n\n\tif (service == GDT_SCREENSERVICE) {\n\t\t/* XXX To be implemented */\n\t} else {\n\t\t/* XXX To be implemented */\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "gdt_clear_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "910-917",
    "snippet": "void\ngdt_clear_events(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_clear_events(%p) \", gdt));\n\n\t/* XXX To be implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_clear_events",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_clear_events(%p) \", gdt)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_clear_events;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_clear_events(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_clear_events(%p) \", gdt));\n\n\t/* XXX To be implemented */\n}"
  },
  {
    "function_name": "gdt_raw_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "899-908",
    "snippet": "int\ngdt_raw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_raw_scsi_cmd \"));\n\n\t/* XXX Not yet implemented */\n\txs->error = XS_DRIVER_STUFFUP;\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_raw_scsi_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_raw_scsi_cmd \")"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_raw_scsi_cmd;\n\nint\ngdt_raw_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_raw_scsi_cmd \"));\n\n\t/* XXX Not yet implemented */\n\txs->error = XS_DRIVER_STUFFUP;\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "gdt_internal_cache_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "783-896",
    "snippet": "int\ngdt_internal_cache_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tstruct scsi_inquiry_data inq;\n\tstruct scsi_sense_data sd;\n\tstruct {\n\t\tstruct scsi_mode_header hd;\n\t\tstruct scsi_blk_desc bd;\n\t\tunion scsi_disk_pages dp;\n\t} mpd;\n\tstruct scsi_read_cap_data rcd;\n\tu_int8_t target = link->target;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cache_cmd \"));\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase START_STOP:\n#if 0\n\tcase VERIFY:\n#endif\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"opc %d tgt %d \", xs->cmd->opcode,\n\t\t    target));\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"SYNCHRONIZE CACHE tgt %d \", target));\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"REQUEST SENSE tgt %d \", target));\n\t\tbzero(&sd, sizeof sd);\n\t\tsd.error_code = 0x70;\n\t\tsd.segment = 0;\n\t\tsd.flags = SKEY_NO_SENSE;\n\t\tgdt_enc32(sd.info, 0);\n\t\tsd.extra_len = 0;\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);\n\t\tbreak;\n\n\tcase INQUIRY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"INQUIRY tgt %d devtype %x \", target,\n\t\t    gdt->sc_hdr[target].hd_devtype));\n\t\tbzero(&inq, sizeof inq);\n\t\tinq.device =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;\n\t\tinq.dev_qual2 =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;\n\t\tinq.version = 2;\n\t\tinq.response_format = 2;\n\t\tinq.additional_length = 32;\n\t\tstrcpy(inq.vendor, \"ICP    \");\n\t\tsprintf(inq.product, \"Host drive  #%02d\", target);\n\t\tstrcpy(inq.revision, \"   \");\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"MODE SENSE tgt %d \", target));\n\n\t\tbzero(&mpd, sizeof mpd);\n\t\tswitch (((struct scsi_mode_sense *)xs->cmd)->page) {\n\t\tcase 4:\n\t\t\t/* scsi_disk.h says this should be 0x16 */\n\t\t\tmpd.dp.rigid_geometry.pg_length = 0x16;\n\t\t\tmpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +\n\t\t\t    mpd.dp.rigid_geometry.pg_length;\n\t\t\tmpd.hd.blk_desc_len = sizeof mpd.bd;\n\n\t\t\t/* XXX */\n\t\t\tmpd.hd.dev_spec =\n\t\t\t    (gdt->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;\n\t\t\t_lto3b(GDT_SECTOR_SIZE, mpd.bd.blklen);\n\t\t\tmpd.dp.rigid_geometry.pg_code = 4;\n\t\t\t_lto3b(gdt->sc_hdr[target].hd_size /\n\t\t\t    gdt->sc_hdr[target].hd_heads /\n\t\t\t    gdt->sc_hdr[target].hd_secs,\n\t\t\t    mpd.dp.rigid_geometry.ncyl);\n\t\t\tmpd.dp.rigid_geometry.nheads =\n\t\t\t    gdt->sc_hdr[target].hd_heads;\n\t\t\tgdt_copy_internal_data(xs, (u_int8_t *)&mpd,\n\t\t\t    sizeof mpd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: mode sense page %d not simulated\\n\",\n\t\t\t    gdt->sc_dev.dv_xname,\n       \t\t\t    ((struct scsi_mode_sense *)xs->cmd)->page);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"READ CAPACITY tgt %d \", target));\n\t\tbzero(&rcd, sizeof rcd);\n\t\t_lto4b(gdt->sc_hdr[target].hd_size - 1, rcd.addr);\n\t\t_lto4b(GDT_SECTOR_SIZE, rcd.length);\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"gdt_internal_cache_cmd got bad opcode: %d\\n\",\n\t\t    xs->cmd->opcode);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (0);\n\t}\n\n\txs->error = XS_NOERROR;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_copy_internal_data",
      "int\tgdt_internal_cache_cmd",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"gdt_internal_cache_cmd got bad opcode: %d\\n\"",
            "xs->cmd->opcode"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_copy_internal_data",
          "args": [
            "xs",
            "(u_int8_t *)&rcd",
            "sizeof rcd"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_copy_internal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "762-780",
          "snippet": "void\ngdt_copy_internal_data(xs, data, size)\n\tstruct scsi_xfer *xs;\n\tu_int8_t *data;\n\tsize_t size;\n{\n\tsize_t copy_cnt;\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_copy_internal_data \"));\n\n\tif (!xs->datalen)\n\t\tprintf(\"uio move not yet supported\\n\");\n\telse {\n\t\tcopy_cnt = MIN(size, xs->datalen);\n\t\tbcopy(data, xs->data, copy_cnt);\n\t}\n\n\t\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_copy_internal_data"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_copy_internal_data;\n\nvoid\ngdt_copy_internal_data(xs, data, size)\n\tstruct scsi_xfer *xs;\n\tu_int8_t *data;\n\tsize_t size;\n{\n\tsize_t copy_cnt;\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_copy_internal_data \"));\n\n\tif (!xs->datalen)\n\t\tprintf(\"uio move not yet supported\\n\");\n\telse {\n\t\tcopy_cnt = MIN(size, xs->datalen);\n\t\tbcopy(data, xs->data, copy_cnt);\n\t}\n\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "_lto4b",
          "args": [
            "GDT_SECTOR_SIZE",
            "rcd.length"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lto4b",
          "args": [
            "gdt->sc_hdr[target].hd_size - 1",
            "rcd.addr"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&rcd",
            "sizeof rcd"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"READ CAPACITY tgt %d \", target)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lto3b",
          "args": [
            "gdt->sc_hdr[target].hd_size /\n\t\t\t    gdt->sc_hdr[target].hd_heads /\n\t\t\t    gdt->sc_hdr[target].hd_secs",
            "mpd.dp.rigid_geometry.ncyl"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lto3b",
          "args": [
            "GDT_SECTOR_SIZE",
            "mpd.bd.blklen"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&mpd",
            "sizeof mpd"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"MODE SENSE tgt %d \", target)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "inq.revision",
            "\"   \""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "inq.product",
            "\"Host drive  #%02d\"",
            "target"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "inq.vendor",
            "\"ICP    \""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&inq",
            "sizeof inq"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"INQUIRY tgt %d devtype %x \", target,\n\t\t    gdt->sc_hdr[target].hd_devtype)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_enc32",
          "args": [
            "sd.info",
            "0"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "245-251",
          "snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&sd",
            "sizeof sd"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"REQUEST SENSE tgt %d \", target)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"SYNCHRONIZE CACHE tgt %d \", target)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"opc %d tgt %d \", xs->cmd->opcode,\n\t\t    target)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_internal_cache_cmd \")"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_copy_internal_data;\nint\tgdt_internal_cache_cmd;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_internal_cache_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tstruct scsi_inquiry_data inq;\n\tstruct scsi_sense_data sd;\n\tstruct {\n\t\tstruct scsi_mode_header hd;\n\t\tstruct scsi_blk_desc bd;\n\t\tunion scsi_disk_pages dp;\n\t} mpd;\n\tstruct scsi_read_cap_data rcd;\n\tu_int8_t target = link->target;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cache_cmd \"));\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase START_STOP:\n#if 0\n\tcase VERIFY:\n#endif\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"opc %d tgt %d \", xs->cmd->opcode,\n\t\t    target));\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"SYNCHRONIZE CACHE tgt %d \", target));\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"REQUEST SENSE tgt %d \", target));\n\t\tbzero(&sd, sizeof sd);\n\t\tsd.error_code = 0x70;\n\t\tsd.segment = 0;\n\t\tsd.flags = SKEY_NO_SENSE;\n\t\tgdt_enc32(sd.info, 0);\n\t\tsd.extra_len = 0;\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);\n\t\tbreak;\n\n\tcase INQUIRY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"INQUIRY tgt %d devtype %x \", target,\n\t\t    gdt->sc_hdr[target].hd_devtype));\n\t\tbzero(&inq, sizeof inq);\n\t\tinq.device =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;\n\t\tinq.dev_qual2 =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;\n\t\tinq.version = 2;\n\t\tinq.response_format = 2;\n\t\tinq.additional_length = 32;\n\t\tstrcpy(inq.vendor, \"ICP    \");\n\t\tsprintf(inq.product, \"Host drive  #%02d\", target);\n\t\tstrcpy(inq.revision, \"   \");\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"MODE SENSE tgt %d \", target));\n\n\t\tbzero(&mpd, sizeof mpd);\n\t\tswitch (((struct scsi_mode_sense *)xs->cmd)->page) {\n\t\tcase 4:\n\t\t\t/* scsi_disk.h says this should be 0x16 */\n\t\t\tmpd.dp.rigid_geometry.pg_length = 0x16;\n\t\t\tmpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +\n\t\t\t    mpd.dp.rigid_geometry.pg_length;\n\t\t\tmpd.hd.blk_desc_len = sizeof mpd.bd;\n\n\t\t\t/* XXX */\n\t\t\tmpd.hd.dev_spec =\n\t\t\t    (gdt->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;\n\t\t\t_lto3b(GDT_SECTOR_SIZE, mpd.bd.blklen);\n\t\t\tmpd.dp.rigid_geometry.pg_code = 4;\n\t\t\t_lto3b(gdt->sc_hdr[target].hd_size /\n\t\t\t    gdt->sc_hdr[target].hd_heads /\n\t\t\t    gdt->sc_hdr[target].hd_secs,\n\t\t\t    mpd.dp.rigid_geometry.ncyl);\n\t\t\tmpd.dp.rigid_geometry.nheads =\n\t\t\t    gdt->sc_hdr[target].hd_heads;\n\t\t\tgdt_copy_internal_data(xs, (u_int8_t *)&mpd,\n\t\t\t    sizeof mpd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: mode sense page %d not simulated\\n\",\n\t\t\t    gdt->sc_dev.dv_xname,\n       \t\t\t    ((struct scsi_mode_sense *)xs->cmd)->page);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"READ CAPACITY tgt %d \", target));\n\t\tbzero(&rcd, sizeof rcd);\n\t\t_lto4b(gdt->sc_hdr[target].hd_size - 1, rcd.addr);\n\t\t_lto4b(GDT_SECTOR_SIZE, rcd.length);\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"gdt_internal_cache_cmd got bad opcode: %d\\n\",\n\t\t    xs->cmd->opcode);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (0);\n\t}\n\n\txs->error = XS_NOERROR;\n\treturn (1);\n}"
  },
  {
    "function_name": "gdt_copy_internal_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "762-780",
    "snippet": "void\ngdt_copy_internal_data(xs, data, size)\n\tstruct scsi_xfer *xs;\n\tu_int8_t *data;\n\tsize_t size;\n{\n\tsize_t copy_cnt;\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_copy_internal_data \"));\n\n\tif (!xs->datalen)\n\t\tprintf(\"uio move not yet supported\\n\");\n\telse {\n\t\tcopy_cnt = MIN(size, xs->datalen);\n\t\tbcopy(data, xs->data, copy_cnt);\n\t}\n\n\t\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_copy_internal_data"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "data",
            "xs->data",
            "copy_cnt"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "size",
            "xs->datalen"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uio move not yet supported\\n\""
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_copy_internal_data \")"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_copy_internal_data;\n\nvoid\ngdt_copy_internal_data(xs, data, size)\n\tstruct scsi_xfer *xs;\n\tu_int8_t *data;\n\tsize_t size;\n{\n\tsize_t copy_cnt;\n\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_copy_internal_data \"));\n\n\tif (!xs->datalen)\n\t\tprintf(\"uio move not yet supported\\n\");\n\telse {\n\t\tcopy_cnt = MIN(size, xs->datalen);\n\t\tbcopy(data, xs->data, copy_cnt);\n\t}\n\n\t\n}"
  },
  {
    "function_name": "gdt_exec_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "660-760",
    "snippet": "int\ngdt_exec_ccb(ccb)\n\tstruct gdt_ccb *ccb;\n{\n\tstruct scsi_xfer *xs = ccb->gc_xs;\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tu_int32_t sg_canz;\n\tbus_dmamap_t xfer;\n\tint i;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_exec_ccb(%p, %p) \", xs, ccb));\n\n\tgdt->sc_cmd_cnt = 0;\n\t/*\n\t * XXX Yeah I know it's a always-true condition, but that may change\n\t * later.\n\t */\n\tif (gdt->sc_cmd_cnt == 0)\n\t\tgdt->sc_set_sema0(gdt);\n\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,\n\t    target);\n\n\tswitch (xs->cmd->opcode) {\n\tcase PREVENT_ALLOW:\n\t\t/* XXX PREVENT_ALLOW support goes here */\n\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    1);\n\t\tsg_canz = 0;\n\t\tbreak;\n\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\t/* XXX WRITE_THR could be supported too */\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;\n\t\tbreak;\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;\n\t\tbreak;\n\t}\n\n\tif (xs->cmd->opcode != PREVENT_ALLOW) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    ccb->gc_blockno);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,\n\t\t    ccb->gc_blockcnt);\n\t}\n\n\txfer = ccb->gc_dmamap_xfer;\n\tif (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    0xffffffff);\n\t\tfor (i = 0; i < xfer->dm_nsegs; i++) {\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,\n\t\t\t    xfer->dm_segs[i].ds_addr);\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_LEN,\n\t\t\t    xfer->dm_segs[i].ds_len);\n\t\t\tGDT_DPRINTF(GDT_D_IO, (\"#%d va %p pa %p len %x\\n\", i,\n\t\t\t    buf, xfer->dm_segs[i].ds_addr,\n\t\t\t    xfer->dm_segs[i].ds_len));\n\t\t}\n\t\tsg_canz = xfer->dm_nsegs;\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +\n\t\t    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);\n\t} else {\n\t\t/* XXX Hardly correct */\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    xfer->dm_segs[0].ds_addr);\n\t\tsg_canz = 0;\n\t}\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);\n\n\tgdt->sc_cmd_len =\n\t    roundup(GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ,\n\t    sizeof (u_int32_t));\n\n\tif (gdt->sc_cmd_cnt > 0 &&\n\t    gdt->sc_cmd_off + gdt->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >\n\t    gdt->sc_ic_all_size) {\n\t\tprintf(\"%s: DPMEM overflow\\n\", gdt->sc_dev.dv_xname);\n\t\tgdt_free_ccb(gdt, ccb);\n\t\txs->error = XS_BUSY;\n\t\treturn (0);\n\t}\n\n\tgdt->sc_copy_cmd(gdt, ccb);\n\tgdt->sc_release_event(gdt, ccb);\n\n\txs->error = XS_NOERROR;\n\txs->resid = 0;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_exec_ccb",
      "void\tgdt_free_ccb",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdt->sc_release_event",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_copy_cmd",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_free_ccb",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1213-1229",
          "snippet": "void\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_free_ccb",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: DPMEM overflow\\n\"",
            "gdt->sc_dev.dv_xname"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ",
            "sizeof (u_int32_t)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_enc32",
          "args": [
            "gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ",
            "sg_canz"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "245-251",
          "snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_IO",
            "(\"#%d va %p pa %p len %x\\n\", i,\n\t\t\t    buf, xfer->dm_segs[i].ds_addr,\n\t\t\t    xfer->dm_segs[i].ds_len)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_enc16",
          "args": [
            "gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO",
            "target"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "237-243",
          "snippet": "static __inline__ void\ngdt_enc16(addr, value)\n\tu_int8_t *addr;\n\tu_int16_t value;\n{\n\t*(u_int16_t *)addr = htole16(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc16(addr, value)\n\tu_int8_t *addr;\n\tu_int16_t value;\n{\n\t*(u_int16_t *)addr = htole16(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt->sc_set_sema0",
          "args": [
            "gdt"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_exec_ccb(%p, %p) \", xs, ccb)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_exec_ccb;\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_exec_ccb(ccb)\n\tstruct gdt_ccb *ccb;\n{\n\tstruct scsi_xfer *xs = ccb->gc_xs;\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tu_int32_t sg_canz;\n\tbus_dmamap_t xfer;\n\tint i;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_exec_ccb(%p, %p) \", xs, ccb));\n\n\tgdt->sc_cmd_cnt = 0;\n\t/*\n\t * XXX Yeah I know it's a always-true condition, but that may change\n\t * later.\n\t */\n\tif (gdt->sc_cmd_cnt == 0)\n\t\tgdt->sc_set_sema0(gdt);\n\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX, ccb->gc_cmd_index);\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DEVICENO,\n\t    target);\n\n\tswitch (xs->cmd->opcode) {\n\tcase PREVENT_ALLOW:\n\t\t/* XXX PREVENT_ALLOW support goes here */\n\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    1);\n\t\tsg_canz = 0;\n\t\tbreak;\n\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\t/* XXX WRITE_THR could be supported too */\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_WRITE;\n\t\tbreak;\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\t\tgdt->sc_cmd[GDT_CMD_OPCODE] = GDT_READ;\n\t\tbreak;\n\t}\n\n\tif (xs->cmd->opcode != PREVENT_ALLOW) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKNO,\n\t\t    ccb->gc_blockno);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_BLOCKCNT,\n\t\t    ccb->gc_blockcnt);\n\t}\n\n\txfer = ccb->gc_dmamap_xfer;\n\tif (gdt->sc_cache_feat & GDT_SCATTER_GATHER) {\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    0xffffffff);\n\t\tfor (i = 0; i < xfer->dm_nsegs; i++) {\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_PTR,\n\t\t\t    xfer->dm_segs[i].ds_addr);\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_CACHE_SG_LST + i * GDT_SG_SZ + GDT_SG_LEN,\n\t\t\t    xfer->dm_segs[i].ds_len);\n\t\t\tGDT_DPRINTF(GDT_D_IO, (\"#%d va %p pa %p len %x\\n\", i,\n\t\t\t    buf, xfer->dm_segs[i].ds_addr,\n\t\t\t    xfer->dm_segs[i].ds_len));\n\t\t}\n\t\tsg_canz = xfer->dm_nsegs;\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_LST +\n\t\t    sg_canz * GDT_SG_SZ + GDT_SG_LEN, 0);\n\t} else {\n\t\t/* XXX Hardly correct */\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_DESTADDR,\n\t\t    xfer->dm_segs[0].ds_addr);\n\t\tsg_canz = 0;\n\t}\n\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION + GDT_CACHE_SG_CANZ, sg_canz);\n\n\tgdt->sc_cmd_len =\n\t    roundup(GDT_CMD_UNION + GDT_CACHE_SG_LST + sg_canz * GDT_SG_SZ,\n\t    sizeof (u_int32_t));\n\n\tif (gdt->sc_cmd_cnt > 0 &&\n\t    gdt->sc_cmd_off + gdt->sc_cmd_len + GDT_DPMEM_COMMAND_OFFSET >\n\t    gdt->sc_ic_all_size) {\n\t\tprintf(\"%s: DPMEM overflow\\n\", gdt->sc_dev.dv_xname);\n\t\tgdt_free_ccb(gdt, ccb);\n\t\txs->error = XS_BUSY;\n\t\treturn (0);\n\t}\n\n\tgdt->sc_copy_cmd(gdt, ccb);\n\tgdt->sc_release_event(gdt, ccb);\n\n\txs->error = XS_NOERROR;\n\txs->resid = 0;\n\treturn (1);\n}"
  },
  {
    "function_name": "gdt_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "461-657",
    "snippet": "int\ngdt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tstruct gdt_ccb *ccb;\n\tint dontqueue = 0;\n\tu_int32_t blockno, blockcnt;\n\tstruct scsi_rw *rw;\n\tstruct scsi_rw_big *rwb;\n\tbus_dmamap_t xfer;\n\tint error;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_scsi_cmd \"));\n\n\tif (target >= GDT_MAX_HDRIVES || !gdt->sc_hdr[target].hd_present ||\n\t    link->lun != 0) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txs->error = XS_NOERROR;\n\tccb = NULL;\n\n\tGDT_LOCK_GDT(gdt);\n\tif (!gdt_polling && gdt->sc_test_busy(gdt)) {\n\t\t/* Don't double enqueue if we came from gdt_chain. */\n\t\tif (xs != LIST_FIRST(&gdt->sc_queue))\n\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase REQUEST_SENSE:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase START_STOP:\n\tcase READ_CAPACITY:\n\tcase SYNCHRONIZE_CACHE:\n#if 0\n\tcase VERIFY:\n#endif\n\t\treturn (gdt_internal_cache_cmd(xs) ? COMPLETE :\n\t\t    TRY_AGAIN_LATER);\n\n\tcase PREVENT_ALLOW:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"PREVENT/ALLOW \"));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_NOERROR;\n\t\treturn (COMPLETE);\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\tGDT_LOCK_GDT(gdt);\n\n\t\t/*\n\t\t * When chaining commands we may get called with the\n\t\t * first command in the queue, recognize this case\n\t\t * easily.\n\t\t */\n\t\tif (xs == LIST_FIRST(&gdt->sc_queue))\n\t\t\txs = gdt_dequeue(gdt);\n\t\telse {\n\t\t\t/* A new command chain, start from the beginning.  */\n\t\t\tgdt->sc_cmd_off = 0;\n\n\t\t\t/* Don't resort to queuing if we are polling.  */\n\t\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t\t/*\n\t\t\t * The queue, if existent, must be processed first,\n\t\t\t * before the new command can be run.\n\t\t\t */\n\t\t\tif (LIST_FIRST(&gdt->sc_queue) != NULL) {\n\t\t\t\t/* If order cannot be preserved, punt.  */\n\t\t\t\tif (dontqueue) {\n\t\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Enqueue the new command, ponder on the front\n\t\t\t\t * command of the queue instead.\n\t\t\t\t */\n\t\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\t\t\txs = gdt_dequeue(gdt);\n\t\t\t}\n\t\t}\n\n\t\tif (xs->cmdlen == 6) {\n\t\t\trw = (struct scsi_rw *)xs->cmd;\n\t\t\tblockno =\n\t\t\t    _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);\n\t\t\tblockcnt = rw->length ? rw->length : 0x100;\n\t\t} else {\n\t\t\trwb = (struct scsi_rw_big *)xs->cmd;\n\t\t\tblockno = _4btol(rwb->addr);\n\t\t\tblockcnt = _2btol(rwb->length);\n\t\t}\n\t\tif (blockno >= gdt->sc_hdr[target].hd_size ||\n\t\t    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\tprintf(\"%s: out of bounds %u-%u >= %u\\n\",\n\t\t\t    gdt->sc_dev.dv_xname, blockno, blockcnt,\n\t\t\t    gdt->sc_hdr[target].hd_size);\n\t\t\tscsi_done(xs);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t}\n\n\t\tccb = gdt_get_ccb(gdt, xs->flags);\n\n\t\t/*\n\t\t * Are we out of commands, then queue.  If we cannot queue,\n\t\t * then punt.\n\t\t */\n\t\tif (ccb == NULL) {\n\t\t\tif (dontqueue) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\t\t\tif (xs->error) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\n\t\t\t/* Put back on the queue, in the front.  */\n\t\t\tgdt_enqueue(gdt, xs, 1);\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\t\t}\n\n\t\tccb->gc_blockno = blockno;\n\t\tccb->gc_blockcnt = blockcnt;\n\t\tccb->gc_xs = xs;\n\t\tccb->gc_timeout = xs->timeout;\n\t\tccb->gc_service = GDT_CACHESERVICE;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);\n\n\t\txfer = ccb->gc_dmamap_xfer;\n\t\terror = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, \n\t\t    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? \n\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tprintf(\"%s: gdt_scsi_cmd: \", gdt->sc_dev.dv_xname); \n\t\t\tif (error == EFBIG)\n\t\t\t\tprintf(\"more than %d dma segs\\n\",\n\t\t\t\t    GDT_MAXOFFSETS);\n\t\t\telse\n\t\t\t\tprintf(\"error %d loading dma map\\n\", error);\n\t\t\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tgdt_free_ccb(gdt, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(gdt->sc_dmat, xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\tgdt_enqueue_ccb(gdt, ccb);\n\t\t/* XXX what if enqueue did not start a transfer? */\n\t\tif (gdt_polling) {\n\t\t\tif (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tprintf(\"%s: command %d timed out\\n\",\n\t\t\t\t    gdt->sc_dev.dv_xname, ccb->gc_cmd_index);\n\t\t\t\txs->error = XS_TIMEOUT;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t}\n\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\t\tif (gdt_polling) {\n \t\t\tscsi_done(xs);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\tdefault:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"unknown opc %d \", xs->cmd->opcode));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_chain",
      "struct scsi_xfer *gdt_dequeue",
      "void\tgdt_enqueue",
      "void\tgdt_enqueue_ccb",
      "void\tgdt_free_ccb",
      "struct gdt_ccb *gdt_get_ccb",
      "int\tgdt_internal_cache_cmd",
      "int\tgdt_scsi_cmd",
      "int\tgdt_wait",
      "u_int8_t gdt_polling;",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"unknown opc %d \", xs->cmd->opcode)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: command %d timed out\\n\"",
            "gdt->sc_dev.dv_xname",
            "ccb->gc_cmd_index"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_wait",
          "args": [
            "gdt",
            "ccb",
            "ccb->gc_timeout"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1081-1107",
          "snippet": "int\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgdt_wait",
            "u_int8_t gdt_from_wait;",
            "struct gdt_softc *gdt_wait_gdt;",
            "int\tgdt_wait_index;",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_wait;\nu_int8_t gdt_from_wait;\nstruct gdt_softc *gdt_wait_gdt;\nint\tgdt_wait_index;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_wait(gdt, ccb, timeout)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n\tint timeout;\n{\n\tint rv = 0;\n\n\tGDT_DPRINTF(GDT_D_MISC,\n\t    (\"gdt_wait(%p, %p, %d) \", gdt, ccb, timeout));\n\n\tgdt_from_wait = 1;\n\tdo {\n\t\tif (gdt_intr(gdt) && gdt == gdt_wait_gdt &&\n\t\t    ccb->gc_cmd_index == gdt_wait_index) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tDELAY(1);\n\t} while (--timeout);\n\tgdt_from_wait = 0;\n\n\twhile (gdt->sc_test_busy(gdt))\n\t\tDELAY(0);\t\t/* XXX correct? */\n\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_enqueue_ccb",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enqueue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1231-1240",
          "snippet": "void\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_enqueue_ccb",
            "void\tgdt_start_ccbs",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_start_ccbs;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_enqueue_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_enqueue_ccb(%p, %p) \", gdt, ccb));\n\n\tTAILQ_INSERT_TAIL(&gdt->sc_ccbq, ccb, gc_chain);\n\tgdt_start_ccbs(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "gdt->sc_dmat",
            "xfer",
            "(xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t    BUS_DMASYNC_PREWRITE"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_free_ccb",
          "args": [
            "gdt",
            "ccb"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1213-1229",
          "snippet": "void\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_free_ccb",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_free_ccb;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_free_ccb(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_QUEUE, (\"gdt_free_ccb(%p, %p) \", gdt, ccb));\n\n\tGDT_LOCK_GDT(gdt);\n\n\tTAILQ_INSERT_HEAD(&gdt->sc_free_ccb, ccb, gc_chain);\n\n\t/* If the free list was empty, wake up potential waiters. */\n\tif (TAILQ_NEXT(ccb, gc_chain) == NULL)\n\t\twakeup(&gdt->sc_free_ccb);\n\n\tGDT_UNLOCK_GDT(gdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "gdt->sc_dmat",
            "xfer",
            "xs->data",
            "xs->datalen",
            "NULL",
            "(xs->flags & SCSI_NOSLEEP) ? \n\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_ccb_set_cmd",
          "args": [
            "ccb",
            "GDT_GCF_SCSI"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_ccb_set_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "89-99",
          "snippet": "static __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}",
          "includes": [],
          "macros_used": [
            "#define GDT_GCF_CMD_MASK\t0x3"
          ],
          "globals_used": [
            "static __inline__ int gdt_ccb_set_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#define GDT_GCF_CMD_MASK\t0x3\n\nstatic __inline__ int gdt_ccb_set_cmd;\n\nstatic __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_get_ccb",
          "args": [
            "gdt",
            "xs->flags"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_2btol",
          "args": [
            "rwb->length"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_4btol",
          "args": [
            "rwb->addr"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_3btol",
          "args": [
            "rw->addr"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_dequeue",
          "args": [
            "gdt"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_dequeue",
          "args": [
            "gdt"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"PREVENT/ALLOW \")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_internal_cache_cmd",
          "args": [
            "xs"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_internal_cache_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "783-896",
          "snippet": "int\ngdt_internal_cache_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tstruct scsi_inquiry_data inq;\n\tstruct scsi_sense_data sd;\n\tstruct {\n\t\tstruct scsi_mode_header hd;\n\t\tstruct scsi_blk_desc bd;\n\t\tunion scsi_disk_pages dp;\n\t} mpd;\n\tstruct scsi_read_cap_data rcd;\n\tu_int8_t target = link->target;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cache_cmd \"));\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase START_STOP:\n#if 0\n\tcase VERIFY:\n#endif\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"opc %d tgt %d \", xs->cmd->opcode,\n\t\t    target));\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"SYNCHRONIZE CACHE tgt %d \", target));\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"REQUEST SENSE tgt %d \", target));\n\t\tbzero(&sd, sizeof sd);\n\t\tsd.error_code = 0x70;\n\t\tsd.segment = 0;\n\t\tsd.flags = SKEY_NO_SENSE;\n\t\tgdt_enc32(sd.info, 0);\n\t\tsd.extra_len = 0;\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);\n\t\tbreak;\n\n\tcase INQUIRY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"INQUIRY tgt %d devtype %x \", target,\n\t\t    gdt->sc_hdr[target].hd_devtype));\n\t\tbzero(&inq, sizeof inq);\n\t\tinq.device =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;\n\t\tinq.dev_qual2 =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;\n\t\tinq.version = 2;\n\t\tinq.response_format = 2;\n\t\tinq.additional_length = 32;\n\t\tstrcpy(inq.vendor, \"ICP    \");\n\t\tsprintf(inq.product, \"Host drive  #%02d\", target);\n\t\tstrcpy(inq.revision, \"   \");\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"MODE SENSE tgt %d \", target));\n\n\t\tbzero(&mpd, sizeof mpd);\n\t\tswitch (((struct scsi_mode_sense *)xs->cmd)->page) {\n\t\tcase 4:\n\t\t\t/* scsi_disk.h says this should be 0x16 */\n\t\t\tmpd.dp.rigid_geometry.pg_length = 0x16;\n\t\t\tmpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +\n\t\t\t    mpd.dp.rigid_geometry.pg_length;\n\t\t\tmpd.hd.blk_desc_len = sizeof mpd.bd;\n\n\t\t\t/* XXX */\n\t\t\tmpd.hd.dev_spec =\n\t\t\t    (gdt->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;\n\t\t\t_lto3b(GDT_SECTOR_SIZE, mpd.bd.blklen);\n\t\t\tmpd.dp.rigid_geometry.pg_code = 4;\n\t\t\t_lto3b(gdt->sc_hdr[target].hd_size /\n\t\t\t    gdt->sc_hdr[target].hd_heads /\n\t\t\t    gdt->sc_hdr[target].hd_secs,\n\t\t\t    mpd.dp.rigid_geometry.ncyl);\n\t\t\tmpd.dp.rigid_geometry.nheads =\n\t\t\t    gdt->sc_hdr[target].hd_heads;\n\t\t\tgdt_copy_internal_data(xs, (u_int8_t *)&mpd,\n\t\t\t    sizeof mpd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: mode sense page %d not simulated\\n\",\n\t\t\t    gdt->sc_dev.dv_xname,\n       \t\t\t    ((struct scsi_mode_sense *)xs->cmd)->page);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"READ CAPACITY tgt %d \", target));\n\t\tbzero(&rcd, sizeof rcd);\n\t\t_lto4b(gdt->sc_hdr[target].hd_size - 1, rcd.addr);\n\t\t_lto4b(GDT_SECTOR_SIZE, rcd.length);\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"gdt_internal_cache_cmd got bad opcode: %d\\n\",\n\t\t    xs->cmd->opcode);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (0);\n\t}\n\n\txs->error = XS_NOERROR;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_copy_internal_data",
            "int\tgdt_internal_cache_cmd",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_copy_internal_data;\nint\tgdt_internal_cache_cmd;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_internal_cache_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tstruct scsi_inquiry_data inq;\n\tstruct scsi_sense_data sd;\n\tstruct {\n\t\tstruct scsi_mode_header hd;\n\t\tstruct scsi_blk_desc bd;\n\t\tunion scsi_disk_pages dp;\n\t} mpd;\n\tstruct scsi_read_cap_data rcd;\n\tu_int8_t target = link->target;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cache_cmd \"));\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase START_STOP:\n#if 0\n\tcase VERIFY:\n#endif\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"opc %d tgt %d \", xs->cmd->opcode,\n\t\t    target));\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"SYNCHRONIZE CACHE tgt %d \", target));\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"REQUEST SENSE tgt %d \", target));\n\t\tbzero(&sd, sizeof sd);\n\t\tsd.error_code = 0x70;\n\t\tsd.segment = 0;\n\t\tsd.flags = SKEY_NO_SENSE;\n\t\tgdt_enc32(sd.info, 0);\n\t\tsd.extra_len = 0;\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);\n\t\tbreak;\n\n\tcase INQUIRY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"INQUIRY tgt %d devtype %x \", target,\n\t\t    gdt->sc_hdr[target].hd_devtype));\n\t\tbzero(&inq, sizeof inq);\n\t\tinq.device =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 4) ? T_CDROM : T_DIRECT;\n\t\tinq.dev_qual2 =\n\t\t    (gdt->sc_hdr[target].hd_devtype & 1) ? SID_REMOVABLE : 0;\n\t\tinq.version = 2;\n\t\tinq.response_format = 2;\n\t\tinq.additional_length = 32;\n\t\tstrcpy(inq.vendor, \"ICP    \");\n\t\tsprintf(inq.product, \"Host drive  #%02d\", target);\n\t\tstrcpy(inq.revision, \"   \");\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"MODE SENSE tgt %d \", target));\n\n\t\tbzero(&mpd, sizeof mpd);\n\t\tswitch (((struct scsi_mode_sense *)xs->cmd)->page) {\n\t\tcase 4:\n\t\t\t/* scsi_disk.h says this should be 0x16 */\n\t\t\tmpd.dp.rigid_geometry.pg_length = 0x16;\n\t\t\tmpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +\n\t\t\t    mpd.dp.rigid_geometry.pg_length;\n\t\t\tmpd.hd.blk_desc_len = sizeof mpd.bd;\n\n\t\t\t/* XXX */\n\t\t\tmpd.hd.dev_spec =\n\t\t\t    (gdt->sc_hdr[target].hd_devtype & 2) ? 0x80 : 0;\n\t\t\t_lto3b(GDT_SECTOR_SIZE, mpd.bd.blklen);\n\t\t\tmpd.dp.rigid_geometry.pg_code = 4;\n\t\t\t_lto3b(gdt->sc_hdr[target].hd_size /\n\t\t\t    gdt->sc_hdr[target].hd_heads /\n\t\t\t    gdt->sc_hdr[target].hd_secs,\n\t\t\t    mpd.dp.rigid_geometry.ncyl);\n\t\t\tmpd.dp.rigid_geometry.nheads =\n\t\t\t    gdt->sc_hdr[target].hd_heads;\n\t\t\tgdt_copy_internal_data(xs, (u_int8_t *)&mpd,\n\t\t\t    sizeof mpd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: mode sense page %d not simulated\\n\",\n\t\t\t    gdt->sc_dev.dv_xname,\n       \t\t\t    ((struct scsi_mode_sense *)xs->cmd)->page);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"READ CAPACITY tgt %d \", target));\n\t\tbzero(&rcd, sizeof rcd);\n\t\t_lto4b(gdt->sc_hdr[target].hd_size - 1, rcd.addr);\n\t\t_lto4b(GDT_SECTOR_SIZE, rcd.length);\n\t\tgdt_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"gdt_internal_cache_cmd got bad opcode: %d\\n\",\n\t\t    xs->cmd->opcode);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (0);\n\t}\n\n\txs->error = XS_NOERROR;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_UNLOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt->sc_test_busy",
          "args": [
            "gdt"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_LOCK_GDT",
          "args": [
            "gdt"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_scsi_cmd \")"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_chain;\nstruct scsi_xfer *gdt_dequeue;\nvoid\tgdt_enqueue;\nvoid\tgdt_enqueue_ccb;\nvoid\tgdt_free_ccb;\nstruct gdt_ccb *gdt_get_ccb;\nint\tgdt_internal_cache_cmd;\nint\tgdt_scsi_cmd;\nint\tgdt_wait;\nu_int8_t gdt_polling;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\nint flags;\n\nint\ngdt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *link = xs->sc_link;\n\tstruct gdt_softc *gdt = link->adapter_softc;\n\tu_int8_t target = link->target;\n\tstruct gdt_ccb *ccb;\n\tint dontqueue = 0;\n\tu_int32_t blockno, blockcnt;\n\tstruct scsi_rw *rw;\n\tstruct scsi_rw_big *rwb;\n\tbus_dmamap_t xfer;\n\tint error;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_scsi_cmd \"));\n\n\tif (target >= GDT_MAX_HDRIVES || !gdt->sc_hdr[target].hd_present ||\n\t    link->lun != 0) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n\n\txs->error = XS_NOERROR;\n\tccb = NULL;\n\n\tGDT_LOCK_GDT(gdt);\n\tif (!gdt_polling && gdt->sc_test_busy(gdt)) {\n\t\t/* Don't double enqueue if we came from gdt_chain. */\n\t\tif (xs != LIST_FIRST(&gdt->sc_queue))\n\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\tGDT_UNLOCK_GDT(gdt);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tGDT_UNLOCK_GDT(gdt);\n\n\tswitch (xs->cmd->opcode) {\n\tcase TEST_UNIT_READY:\n\tcase REQUEST_SENSE:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase START_STOP:\n\tcase READ_CAPACITY:\n\tcase SYNCHRONIZE_CACHE:\n#if 0\n\tcase VERIFY:\n#endif\n\t\treturn (gdt_internal_cache_cmd(xs) ? COMPLETE :\n\t\t    TRY_AGAIN_LATER);\n\n\tcase PREVENT_ALLOW:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"PREVENT/ALLOW \"));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_NOERROR;\n\t\treturn (COMPLETE);\n\n\tcase READ_COMMAND:\n\tcase READ_BIG:\n\tcase WRITE_COMMAND:\n\tcase WRITE_BIG:\n\t\tGDT_LOCK_GDT(gdt);\n\n\t\t/*\n\t\t * When chaining commands we may get called with the\n\t\t * first command in the queue, recognize this case\n\t\t * easily.\n\t\t */\n\t\tif (xs == LIST_FIRST(&gdt->sc_queue))\n\t\t\txs = gdt_dequeue(gdt);\n\t\telse {\n\t\t\t/* A new command chain, start from the beginning.  */\n\t\t\tgdt->sc_cmd_off = 0;\n\n\t\t\t/* Don't resort to queuing if we are polling.  */\n\t\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t\t/*\n\t\t\t * The queue, if existent, must be processed first,\n\t\t\t * before the new command can be run.\n\t\t\t */\n\t\t\tif (LIST_FIRST(&gdt->sc_queue) != NULL) {\n\t\t\t\t/* If order cannot be preserved, punt.  */\n\t\t\t\tif (dontqueue) {\n\t\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Enqueue the new command, ponder on the front\n\t\t\t\t * command of the queue instead.\n\t\t\t\t */\n\t\t\t\tgdt_enqueue(gdt, xs, 0);\n\t\t\t\txs = gdt_dequeue(gdt);\n\t\t\t}\n\t\t}\n\n\t\tif (xs->cmdlen == 6) {\n\t\t\trw = (struct scsi_rw *)xs->cmd;\n\t\t\tblockno =\n\t\t\t    _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);\n\t\t\tblockcnt = rw->length ? rw->length : 0x100;\n\t\t} else {\n\t\t\trwb = (struct scsi_rw_big *)xs->cmd;\n\t\t\tblockno = _4btol(rwb->addr);\n\t\t\tblockcnt = _2btol(rwb->length);\n\t\t}\n\t\tif (blockno >= gdt->sc_hdr[target].hd_size ||\n\t\t    blockno + blockcnt > gdt->sc_hdr[target].hd_size) {\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\tprintf(\"%s: out of bounds %u-%u >= %u\\n\",\n\t\t\t    gdt->sc_dev.dv_xname, blockno, blockcnt,\n\t\t\t    gdt->sc_hdr[target].hd_size);\n\t\t\tscsi_done(xs);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (COMPLETE);\n\t\t}\n\n\t\tccb = gdt_get_ccb(gdt, xs->flags);\n\n\t\t/*\n\t\t * Are we out of commands, then queue.  If we cannot queue,\n\t\t * then punt.\n\t\t */\n\t\tif (ccb == NULL) {\n\t\t\tif (dontqueue) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\t\t\tif (xs->error) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tscsi_done(xs);\n\t\t\t\treturn (COMPLETE);\n\t\t\t}\n\n\t\t\t/* Put back on the queue, in the front.  */\n\t\t\tgdt_enqueue(gdt, xs, 1);\n\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\treturn (SUCCESSFULLY_QUEUED);\n\t\t}\n\n\t\tccb->gc_blockno = blockno;\n\t\tccb->gc_blockcnt = blockcnt;\n\t\tccb->gc_xs = xs;\n\t\tccb->gc_timeout = xs->timeout;\n\t\tccb->gc_service = GDT_CACHESERVICE;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_SCSI);\n\n\t\txfer = ccb->gc_dmamap_xfer;\n\t\terror = bus_dmamap_load(gdt->sc_dmat, xfer, xs->data, \n\t\t    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? \n\t\t    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\tif (error) {\n\t\t\tprintf(\"%s: gdt_scsi_cmd: \", gdt->sc_dev.dv_xname); \n\t\t\tif (error == EFBIG)\n\t\t\t\tprintf(\"more than %d dma segs\\n\",\n\t\t\t\t    GDT_MAXOFFSETS);\n\t\t\telse\n\t\t\t\tprintf(\"error %d loading dma map\\n\", error);\n\t\t\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tgdt_free_ccb(gdt, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(gdt->sc_dmat, xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t    BUS_DMASYNC_PREWRITE);\n\n\t\tgdt_enqueue_ccb(gdt, ccb);\n\t\t/* XXX what if enqueue did not start a transfer? */\n\t\tif (gdt_polling) {\n\t\t\tif (!gdt_wait(gdt, ccb, ccb->gc_timeout)) {\n\t\t\t\tGDT_UNLOCK_GDT(gdt);\n\t\t\t\tprintf(\"%s: command %d timed out\\n\",\n\t\t\t\t    gdt->sc_dev.dv_xname, ccb->gc_cmd_index);\n\t\t\t\txs->error = XS_TIMEOUT;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t}\n\n\t\tGDT_UNLOCK_GDT(gdt);\n\n\t\tif (gdt_polling) {\n \t\t\tscsi_done(xs);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\tdefault:\n\t\tGDT_DPRINTF(GDT_D_CMD, (\"unknown opc %d \", xs->cmd->opcode));\n\t\t/* XXX Not yet implemented */\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn (COMPLETE);\n\t}\n}"
  },
  {
    "function_name": "gdt_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "426-440",
    "snippet": "void\ngdt_enqueue(gdt, xs, infront)\n\tstruct gdt_softc *gdt;\n\tstruct scsi_xfer *xs;\n\tint infront;\n{\n\tif (infront || LIST_FIRST(&gdt->sc_queue) == NULL) {\n\t\tif (LIST_FIRST(&gdt->sc_queue) == NULL)\n\t\t\tgdt->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&gdt->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(gdt->sc_queuelast, xs, free_list);\n\tgdt->sc_queuelast = xs;\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_enqueue",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_AFTER",
          "args": [
            "gdt->sc_queuelast",
            "xs",
            "free_list"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&gdt->sc_queue",
            "xs",
            "free_list"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_enqueue;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_enqueue(gdt, xs, infront)\n\tstruct gdt_softc *gdt;\n\tstruct scsi_xfer *xs;\n\tint infront;\n{\n\tif (infront || LIST_FIRST(&gdt->sc_queue) == NULL) {\n\t\tif (LIST_FIRST(&gdt->sc_queue) == NULL)\n\t\t\tgdt->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&gdt->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(gdt->sc_queuelast, xs, free_list);\n\tgdt->sc_queuelast = xs;\n}"
  },
  {
    "function_name": "gdt_eval_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "397-419",
    "snippet": "void\ngdt_eval_mapping(size, cyls, heads, secs)\n\tu_int32_t size;\n\tint *cyls, *heads, *secs;\n{\n\t*cyls = size / GDT_HEADS / GDT_SECS;\n\tif (*cyls < GDT_MAXCYLS) {\n\t\t*heads = GDT_HEADS;\n\t\t*secs = GDT_SECS;\n\t} else {\n\t\t/* Too high for 64 * 32 */\n\t\t*cyls = size / GDT_MEDHEADS / GDT_MEDSECS;\n\t\tif (*cyls < GDT_MAXCYLS) {\n\t\t\t*heads = GDT_MEDHEADS;\n\t\t\t*secs = GDT_MEDSECS;\n\t\t} else {\n\t\t\t/* Too high for 127 * 63 */\n\t\t\t*cyls = size / GDT_BIGHEADS / GDT_BIGSECS;\n\t\t\t*heads = GDT_BIGHEADS;\n\t\t\t*secs = GDT_BIGSECS;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_eval_mapping"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_eval_mapping;\n\nvoid\ngdt_eval_mapping(size, cyls, heads, secs)\n\tu_int32_t size;\n\tint *cyls, *heads, *secs;\n{\n\t*cyls = size / GDT_HEADS / GDT_SECS;\n\tif (*cyls < GDT_MAXCYLS) {\n\t\t*heads = GDT_HEADS;\n\t\t*secs = GDT_SECS;\n\t} else {\n\t\t/* Too high for 64 * 32 */\n\t\t*cyls = size / GDT_MEDHEADS / GDT_MEDSECS;\n\t\tif (*cyls < GDT_MAXCYLS) {\n\t\t\t*heads = GDT_MEDHEADS;\n\t\t\t*secs = GDT_MEDSECS;\n\t\t} else {\n\t\t\t/* Too high for 127 * 63 */\n\t\t\t*cyls = size / GDT_BIGHEADS / GDT_BIGSECS;\n\t\t\t*heads = GDT_BIGHEADS;\n\t\t\t*secs = GDT_BIGSECS;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "gdt_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
    "lines": "105-395",
    "snippet": "int\ngdt_attach(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tu_int16_t cdev_cnt;\n\tint i, id, drv_cyls, drv_hds, drv_secs, error;\n\n\tgdt_polling = 1;\n\tgdt_from_wait = 0;\n\tgdt_clear_events(gdt);\n\n\tTAILQ_INIT(&gdt->sc_free_ccb);\n\tTAILQ_INIT(&gdt->sc_ccbq);\n\tLIST_INIT(&gdt->sc_queue);\n\n\t/* Initialize the ccbs */\n\tfor (i = 0; i < GDT_MAXCMDS; i++) {\n\t\tgdt->sc_ccbs[i].gc_cmd_index = i + 2;\n\t\terror = bus_dmamap_create(gdt->sc_dmat,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,\n\t\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t    &gdt->sc_ccbs[i].gc_dmamap_xfer);\n\t\tif (error) {\n\t\t\tprintf(\"%s: cannot create ccb dmamap (%d)\",\n\t\t\t    gdt->sc_dev.dv_xname, error);\n\t\t\treturn (1);\n\t\t}\n\t\t(void)gdt_ccb_set_cmd(gdt->sc_ccbs + i, GDT_GCF_UNUSED);\n\t\tTAILQ_INSERT_TAIL(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],\n\t\t    gc_chain);\n\t}\n\n\t/* Fill in the prototype scsi_link. */\n\tgdt->sc_link.adapter_softc = gdt;\n\tgdt->sc_link.adapter = &gdt_switch;\n\tgdt->sc_link.adapter_target = 7;\n\tgdt->sc_link.device = &gdt_dev;\n\tgdt->sc_link.openings = GDT_MAXCMDS;\t/* XXX what is optimal? */\n\tgdt->sc_link.adapter_buswidth =\n\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"screen service initialization error %d\\n\",\n\t\t     gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_MOUNT, 0xffff, 1,\n\t    0)) {\n\t\tprintf(\"cache service mount error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service post-mount initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\tcdev_cnt = (u_int16_t)gdt->sc_info;\n\n\t/* Detect number of busses */\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);\n\tgdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;\n\tgdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;\n\tgdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t    GDT_IOCHAN_RAW_DESC, GDT_INVALID_CHANNEL,\n\t    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {\n\t\tgdt->sc_bus_cnt = gdt->sc_scratch[GDT_IOC_CHAN_COUNT];\n\t\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t\tid = gdt->sc_scratch[GDT_IOC_HDR_SZ +\n\t\t\t    i * GDT_RAWIOC_SZ + GDT_RAWIOC_PROC_ID];\n\t\t\tgdt->sc_bus_id[id] = id < GDT_MAXID ? id : 0xff;\n\t\t}\n\n\t} else {\n\t\t/* New method failed, use fallback. */\n\t\tgdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO, i);\n\t\tfor (i = 0; i < GDT_MAXBUS; i++) {\n\t\t\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t\t    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,\n\t\t\t    GDT_IO_CHANNEL | GDT_INVALID_CHANNEL,\n\t\t\t    GDT_GETCH_SZ)) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tprintf(\"cannot get channel count, \"\n\t\t\t\t\t    \"error %d\\n\", gdt->sc_status);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgdt->sc_bus_id[i] =\n\t\t\t    (gdt->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?\n\t\t\t    gdt->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;\n\t\t}\n\t\tgdt->sc_bus_cnt = i;\n\t}\n\n\t/* Read cache confgiuration */\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_CINFO_SZ)) {\n\t\tprintf(\"cannot get cache info, error %d\\n\", gdt->sc_status);\n\t\treturn (1);\n\t}\n\tgdt->sc_cpar.cp_version =\n\t    gdt_dec32(gdt->sc_scratch + GDT_CPAR_VERSION);\n\tgdt->sc_cpar.cp_state = gdt_dec16(gdt->sc_scratch + GDT_CPAR_STATE);\n\tgdt->sc_cpar.cp_strategy =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_STRATEGY);\n\tgdt->sc_cpar.cp_write_back =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_WRITE_BACK);\n\tgdt->sc_cpar.cp_block_size =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_BLOCK_SIZE);\n\n\t/* Read board information and features */\n\tgdt->sc_more_proc = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_BINFO_SZ)) {\n\t\t/* XXX A lot of these assignments can probably go later */\n\t\tgdt->sc_binfo.bi_ser_no =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_SER_NO);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_OEM_ID,\n\t\t    gdt->sc_binfo.bi_oem_id, sizeof gdt->sc_binfo.bi_oem_id);\n\t\tgdt->sc_binfo.bi_ep_flags =\n\t\t    gdt_dec16(gdt->sc_scratch + GDT_BINFO_EP_FLAGS);\n\t\tgdt->sc_binfo.bi_proc_id =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_PROC_ID);\n\t\tgdt->sc_binfo.bi_memsize =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEMSIZE);\n\t\tgdt->sc_binfo.bi_mem_banks =\n\t\t    gdt->sc_scratch[GDT_BINFO_MEM_BANKS];\n\t\tgdt->sc_binfo.bi_chan_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_TYPE];\n\t\tgdt->sc_binfo.bi_chan_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_COUNT];\n\t\tgdt->sc_binfo.bi_rdongle_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RDONGLE_PRES];\n\t\tgdt->sc_binfo.bi_epr_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_EPR_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_revision =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_REVISION);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_TYPE_STRING,\n\t\t    gdt->sc_binfo.bi_type_string,\n\t\t    sizeof gdt->sc_binfo.bi_type_string);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_RAID_STRING,\n\t\t    gdt->sc_binfo.bi_raid_string,\n\t\t    sizeof gdt->sc_binfo.bi_raid_string);\n\t\tgdt->sc_binfo.bi_update_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_UPDATE_PRES];\n\t\tgdt->sc_binfo.bi_xor_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_XOR_PRES];\n\t\tgdt->sc_binfo.bi_prom_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_TYPE];\n\t\tgdt->sc_binfo.bi_prom_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_COUNT];\n\t\tgdt->sc_binfo.bi_dup_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_DUP_PRES);\n\t\tgdt->sc_binfo.bi_chan_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_CHAN_PRES);\n\t\tgdt->sc_binfo.bi_mem_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEM_PRES);\n\t\tgdt->sc_binfo.bi_ft_bus_system =\n\t\t    gdt->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];\n\t\tgdt->sc_binfo.bi_subtype_valid =\n\t\t    gdt->sc_scratch[GDT_BINFO_SUBTYPE_VALID];\n\t\tgdt->sc_binfo.bi_board_subtype =\n\t\t    gdt->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];\n\t\tgdt->sc_binfo.bi_rampar_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RAMPAR_PRES];\n\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t    GDT_BOARD_FEATURES, GDT_INVALID_CHANNEL, GDT_BFEAT_SZ)) {\n\t\t\tgdt->sc_bfeat.bf_chaining =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_CHAINING];\n\t\t\tgdt->sc_bfeat.bf_striping =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_STRIPING];\n\t\t\tgdt->sc_bfeat.bf_mirroring =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_MIRRORING];\n\t\t\tgdt->sc_bfeat.bf_raid =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_RAID];\n\t\t\tgdt->sc_more_proc = 1;\n\t\t}\n\t} else {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\t/* Read more information */\n\tif (gdt->sc_more_proc) {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"raw service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\t/* Set/get features raw service (scatter/gather) */\n\tgdt->sc_raw_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,\n\t    GDT_SCATTER_GATHER, 0, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,\n\t\t    0, 0))\n\t\t\tgdt->sc_raw_feat = gdt->sc_info;\n\n\t/* Set/get features cache service (scatter/gather) */\n\tgdt->sc_cache_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_SET_FEAT, 0,\n\t    GDT_SCATTER_GATHER, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,\n\t\t    0))\n\t\t\tgdt->sc_cache_feat = gdt->sc_info;\n\n\t/* XXX Linux reserve drives here, potentially */\n\n\t/* Scan for cache devices */\n\tfor (i = 0; i < cdev_cnt && i < GDT_MAX_HDRIVES; i++)\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INFO, i, 0,\n\t\t    0)) {\n\t\t\tgdt->sc_hdr[i].hd_present = 1;\n\t\t\tgdt->sc_hdr[i].hd_size = gdt->sc_info;\n\n\t\t\t/*\n\t\t\t * Evaluate mapping (sectors per head, heads per cyl)\n\t\t\t */\n\t\t\tgdt->sc_hdr[i].hd_size &= ~GDT_SECS32;\n\t\t\tif (gdt->sc_info2 == 0)\n\t\t\t\tgdt_eval_mapping(gdt->sc_hdr[i].hd_size,\n\t\t\t\t    &drv_cyls, &drv_hds, &drv_secs);\n\t\t\telse {\n\t\t\t\tdrv_hds = gdt->sc_info2 & 0xff;\n\t\t\t\tdrv_secs = (gdt->sc_info2 >> 8) & 0xff;\n\t\t\t\tdrv_cyls = gdt->sc_hdr[i].hd_size / drv_hds /\n\t\t\t\t    drv_secs;\n\t\t\t}\n\t\t\tgdt->sc_hdr[i].hd_heads = drv_hds;\n\t\t\tgdt->sc_hdr[i].hd_secs = drv_secs;\n\t\t\t/* Round the size */\n\t\t\tgdt->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;\n\n\t\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE,\n\t\t\t    GDT_DEVTYPE, i, 0, 0))\n\t\t\t\tgdt->sc_hdr[i].hd_devtype = gdt->sc_info;\n\t\t}\n\n\tprintf(\"dpmem %x %d-bus %d cache device%s\\n\", gdt->sc_dpmembase,\n\t    gdt->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? \"\" : \"s\");\n\tprintf(\"%s: ver %x, cache %s, strategy %d, writeback %s, blksz %d\\n\",\n\t    gdt->sc_dev.dv_xname, gdt->sc_cpar.cp_version,\n\t    gdt->sc_cpar.cp_state ? \"on\" : \"off\", gdt->sc_cpar.cp_strategy,\n\t    gdt->sc_cpar.cp_write_back ? \"on\" : \"off\",\n\t    gdt->sc_cpar.cp_block_size);\n#if 1\n\tprintf(\"%s: raw feat %x cache feat %x\\n\", gdt->sc_dev.dv_xname,\n\t    gdt->sc_raw_feat, gdt->sc_cache_feat);\n#endif\n\n\tconfig_found(&gdt->sc_dev, &gdt->sc_link, scsiprint);\n\n\tMALLOC(gdt->sc_raw_link, struct scsi_link *,\n\t    gdt->sc_bus_cnt * sizeof (struct scsi_link), M_DEVBUF, M_NOWAIT);\n\tbzero(gdt->sc_raw_link, gdt->sc_bus_cnt * sizeof (struct scsi_link));\n\n\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t/* Fill in the prototype scsi_link. */\n\t\tgdt->sc_raw_link[i].adapter_softc = gdt;\n\t\tgdt->sc_raw_link[i].adapter = &gdt_raw_switch;\n\t\tgdt->sc_raw_link[i].adapter_target = 7;\n\t\tgdt->sc_raw_link[i].device = &gdt_dev;\n\t\tgdt->sc_raw_link[i].openings = 4;\t/* XXX a guess */\n\t\tgdt->sc_raw_link[i].adapter_buswidth =\n\t\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : 16;\t/* XXX */\n\n\t\tconfig_found(&gdt->sc_dev, &gdt->sc_raw_link[i], scsiprint);\n\t}\n\n\tgdt_polling = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_disk.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_clear_events",
      "void\tgdt_eval_mapping",
      "int\tgdt_internal_cmd",
      "struct scsi_adapter gdt_switch = {\n\tgdt_scsi_cmd, gdtminphys, 0, 0,\n};",
      "struct scsi_adapter gdt_raw_switch = {\n\tgdt_raw_scsi_cmd, gdtminphys, 0, 0,\n};",
      "struct scsi_device gdt_dev = {\n\tNULL, NULL, NULL, NULL\n};",
      "u_int8_t gdt_polling;",
      "u_int8_t gdt_from_wait;",
      "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
      "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&gdt->sc_dev",
            "&gdt->sc_raw_link[i]",
            "scsiprint"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "gdt->sc_raw_link",
            "gdt->sc_bus_cnt * sizeof (struct scsi_link)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MALLOC",
          "args": [
            "gdt->sc_raw_link",
            "structscsi_link *,\n\t    gdt->sc_bus_cnt * sizeof (struct scsi_link)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&gdt->sc_dev",
            "&gdt->sc_link",
            "scsiprint"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: raw feat %x cache feat %x\\n\"",
            "gdt->sc_dev.dv_xname",
            "gdt->sc_raw_feat",
            "gdt->sc_cache_feat"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_internal_cmd",
          "args": [
            "gdt",
            "GDT_CACHESERVICE",
            "GDT_DEVTYPE",
            "i",
            "0",
            "0"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_internal_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "1109-1184",
          "snippet": "int\ngdt_internal_cmd(gdt, service, opcode, arg1, arg2, arg3)\n\tstruct gdt_softc *gdt;\n\tu_int8_t service;\n\tu_int16_t opcode;\n\tu_int32_t arg1, arg2, arg3;\n{\n\tint retries;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cmd(%p, %d, %d, %d, %d, %d) \",\n\t    gdt, service, opcode, arg1, arg2, arg3));\n\n\tbzero(gdt->sc_cmd, GDT_CMD_SZ);\n\n\tfor (retries = GDT_RETRIES; ; ) {\n\t\tccb = gdt_get_ccb(gdt, SCSI_NOSLEEP);\n\t\tif (ccb == NULL) {\n\t\t\tprintf(\"%s: no free command index found\\n\",\n\t\t\t    gdt->sc_dev.dv_xname);\n\t\t\treturn (0);\n\t\t}\n\t\tccb->gc_service = service;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_INTERNAL);\n\n\t\tgdt->sc_set_sema0(gdt);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX,\n\t\t    ccb->gc_cmd_index);\n\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_OPCODE, opcode);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\n\t\tswitch (service) {\n\t\tcase GDT_CACHESERVICE:\n\t\t\tif (opcode == GDT_IOCTL) {\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_SUBFUNC, arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_CHANNEL, arg2);\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_PARAM_SIZE, (u_int16_t)arg3);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_P_PARAM,\n\t\t\t\t    vtophys(gdt->sc_scratch));\n\t\t\t} else {\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_DEVICENO, (u_int16_t)arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_BLOCKNO, arg2);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GDT_SCSIRAWSERVICE:\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_RAW_DIRECTION, arg1);\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =\n\t\t\t    (u_int8_t)arg2;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =\n\t\t\t    (u_int8_t)arg3;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =\n\t\t\t    (u_int8_t)(arg3 >> 8);\n\t\t}\n\n\t\tgdt->sc_cmd_len = GDT_CMD_SZ;\n\t\tgdt->sc_cmd_off = 0;\n\t\tgdt->sc_cmd_cnt = 0;\n\t\tgdt->sc_copy_cmd(gdt, ccb);\n\t\tgdt->sc_release_event(gdt, ccb);\n\t\tDELAY(20);\n\t\tif (!gdt_wait(gdt, ccb, GDT_POLL_TIMEOUT))\n\t\t\treturn (0);\n\t\tif (gdt->sc_status != GDT_S_BSY || --retries == 0)\n\t\t\tbreak;\n\t\tDELAY(1);\n\t}\n\treturn (gdt->sc_status == GDT_S_OK);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct gdt_ccb *gdt_get_ccb",
            "int\tgdt_internal_cmd",
            "int\tgdt_wait",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct gdt_ccb *gdt_get_ccb;\nint\tgdt_internal_cmd;\nint\tgdt_wait;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_internal_cmd(gdt, service, opcode, arg1, arg2, arg3)\n\tstruct gdt_softc *gdt;\n\tu_int8_t service;\n\tu_int16_t opcode;\n\tu_int32_t arg1, arg2, arg3;\n{\n\tint retries;\n\tstruct gdt_ccb *ccb;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_internal_cmd(%p, %d, %d, %d, %d, %d) \",\n\t    gdt, service, opcode, arg1, arg2, arg3));\n\n\tbzero(gdt->sc_cmd, GDT_CMD_SZ);\n\n\tfor (retries = GDT_RETRIES; ; ) {\n\t\tccb = gdt_get_ccb(gdt, SCSI_NOSLEEP);\n\t\tif (ccb == NULL) {\n\t\t\tprintf(\"%s: no free command index found\\n\",\n\t\t\t    gdt->sc_dev.dv_xname);\n\t\t\treturn (0);\n\t\t}\n\t\tccb->gc_service = service;\n\t\tgdt_ccb_set_cmd(ccb, GDT_GCF_INTERNAL);\n\n\t\tgdt->sc_set_sema0(gdt);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_COMMANDINDEX,\n\t\t    ccb->gc_cmd_index);\n\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_OPCODE, opcode);\n\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_BOARDNODE, GDT_LOCALBOARD);\n\n\t\tswitch (service) {\n\t\tcase GDT_CACHESERVICE:\n\t\t\tif (opcode == GDT_IOCTL) {\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_SUBFUNC, arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_CHANNEL, arg2);\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_PARAM_SIZE, (u_int16_t)arg3);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_IOCTL_P_PARAM,\n\t\t\t\t    vtophys(gdt->sc_scratch));\n\t\t\t} else {\n\t\t\t\tgdt_enc16(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_DEVICENO, (u_int16_t)arg1);\n\t\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t\t    GDT_CACHE_BLOCKNO, arg2);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GDT_SCSIRAWSERVICE:\n\t\t\tgdt_enc32(gdt->sc_cmd + GDT_CMD_UNION +\n\t\t\t    GDT_RAW_DIRECTION, arg1);\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_BUS] =\n\t\t\t    (u_int8_t)arg2;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_TARGET] =\n\t\t\t    (u_int8_t)arg3;\n\t\t\tgdt->sc_cmd[GDT_CMD_UNION + GDT_RAW_LUN] =\n\t\t\t    (u_int8_t)(arg3 >> 8);\n\t\t}\n\n\t\tgdt->sc_cmd_len = GDT_CMD_SZ;\n\t\tgdt->sc_cmd_off = 0;\n\t\tgdt->sc_cmd_cnt = 0;\n\t\tgdt->sc_copy_cmd(gdt, ccb);\n\t\tgdt->sc_release_event(gdt, ccb);\n\t\tDELAY(20);\n\t\tif (!gdt_wait(gdt, ccb, GDT_POLL_TIMEOUT))\n\t\t\treturn (0);\n\t\tif (gdt->sc_status != GDT_S_BSY || --retries == 0)\n\t\t\tbreak;\n\t\tDELAY(1);\n\t}\n\treturn (gdt->sc_status == GDT_S_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_eval_mapping",
          "args": [
            "gdt->sc_hdr[i].hd_size",
            "&drv_cyls",
            "&drv_hds",
            "&drv_secs"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_eval_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "397-419",
          "snippet": "void\ngdt_eval_mapping(size, cyls, heads, secs)\n\tu_int32_t size;\n\tint *cyls, *heads, *secs;\n{\n\t*cyls = size / GDT_HEADS / GDT_SECS;\n\tif (*cyls < GDT_MAXCYLS) {\n\t\t*heads = GDT_HEADS;\n\t\t*secs = GDT_SECS;\n\t} else {\n\t\t/* Too high for 64 * 32 */\n\t\t*cyls = size / GDT_MEDHEADS / GDT_MEDSECS;\n\t\tif (*cyls < GDT_MAXCYLS) {\n\t\t\t*heads = GDT_MEDHEADS;\n\t\t\t*secs = GDT_MEDSECS;\n\t\t} else {\n\t\t\t/* Too high for 127 * 63 */\n\t\t\t*cyls = size / GDT_BIGHEADS / GDT_BIGSECS;\n\t\t\t*heads = GDT_BIGHEADS;\n\t\t\t*secs = GDT_BIGSECS;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_eval_mapping"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_eval_mapping;\n\nvoid\ngdt_eval_mapping(size, cyls, heads, secs)\n\tu_int32_t size;\n\tint *cyls, *heads, *secs;\n{\n\t*cyls = size / GDT_HEADS / GDT_SECS;\n\tif (*cyls < GDT_MAXCYLS) {\n\t\t*heads = GDT_HEADS;\n\t\t*secs = GDT_SECS;\n\t} else {\n\t\t/* Too high for 64 * 32 */\n\t\t*cyls = size / GDT_MEDHEADS / GDT_MEDSECS;\n\t\tif (*cyls < GDT_MAXCYLS) {\n\t\t\t*heads = GDT_MEDHEADS;\n\t\t\t*secs = GDT_MEDSECS;\n\t\t} else {\n\t\t\t/* Too high for 127 * 63 */\n\t\t\t*cyls = size / GDT_BIGHEADS / GDT_BIGSECS;\n\t\t\t*heads = GDT_BIGHEADS;\n\t\t\t*secs = GDT_BIGSECS;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_dec32",
          "args": [
            "gdt->sc_scratch + GDT_BINFO_MEM_PRES"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_dec32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "260-265",
          "snippet": "static __inline__ u_int32_t\ngdt_dec32(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh32(*(u_int32_t *)addr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ u_int32_t\ngdt_dec32(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh32(*(u_int32_t *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "gdt->sc_scratch + GDT_BINFO_RAID_STRING",
            "gdt->sc_binfo.bi_raid_string",
            "sizeof gdt->sc_binfo.bi_raid_string"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_dec16",
          "args": [
            "gdt->sc_scratch + GDT_BINFO_EP_FLAGS"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_dec16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "253-258",
          "snippet": "static __inline__ u_int16_t\ngdt_dec16(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh16(*(u_int16_t *)addr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ u_int16_t\ngdt_dec16(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh16(*(u_int16_t *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_enc32",
          "args": [
            "gdt->sc_scratch + GDT_GETCH_CHANNEL_NO",
            "i"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_enc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "245-251",
          "snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ void\ngdt_enc32(addr, value)\n\tu_int8_t *addr;\n\tu_int32_t value;\n{\n\t*(u_int32_t *)addr = htole32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&gdt->sc_free_ccb",
            "&gdt->sc_ccbs[i]",
            "gc_chain"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_ccb_set_cmd",
          "args": [
            "gdt->sc_ccbs + i",
            "GDT_GCF_UNUSED"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_ccb_set_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "89-99",
          "snippet": "static __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}",
          "includes": [],
          "macros_used": [
            "#define GDT_GCF_CMD_MASK\t0x3"
          ],
          "globals_used": [
            "static __inline__ int gdt_ccb_set_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#define GDT_GCF_CMD_MASK\t0x3\n\nstatic __inline__ int gdt_ccb_set_cmd;\n\nstatic __inline__ int\ngdt_ccb_set_cmd(ccb, flag)\n\tstruct gdt_ccb *ccb;\n\tint flag;\n{\n\tint rv = ccb->gc_flags & GDT_GCF_CMD_MASK;\n\n\tccb->gc_flags &= ~GDT_GCF_CMD_MASK;\n\tccb->gc_flags |= flag;\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "gdt->sc_dmat",
            "(GDT_MAXOFFSETS - 1) << PGSHIFT",
            "GDT_MAXOFFSETS",
            "(GDT_MAXOFFSETS - 1) << PGSHIFT",
            "0",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&gdt->sc_ccbs[i].gc_dmamap_xfer"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&gdt->sc_queue"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&gdt->sc_ccbq"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&gdt->sc_free_ccb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_clear_events",
          "args": [
            "gdt"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_clear_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "910-917",
          "snippet": "void\ngdt_clear_events(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_clear_events(%p) \", gdt));\n\n\t/* XXX To be implemented */\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_clear_events",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_clear_events;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nvoid\ngdt_clear_events(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_clear_events(%p) \", gdt));\n\n\t/* XXX To be implemented */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_clear_events;\nvoid\tgdt_eval_mapping;\nint\tgdt_internal_cmd;\nstruct scsi_adapter gdt_switch = {\n\tgdt_scsi_cmd, gdtminphys, 0, 0,\n};\nstruct scsi_adapter gdt_raw_switch = {\n\tgdt_raw_scsi_cmd, gdtminphys, 0, 0,\n};\nstruct scsi_device gdt_dev = {\n\tNULL, NULL, NULL, NULL\n};\nu_int8_t gdt_polling;\nu_int8_t gdt_from_wait;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_attach(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tu_int16_t cdev_cnt;\n\tint i, id, drv_cyls, drv_hds, drv_secs, error;\n\n\tgdt_polling = 1;\n\tgdt_from_wait = 0;\n\tgdt_clear_events(gdt);\n\n\tTAILQ_INIT(&gdt->sc_free_ccb);\n\tTAILQ_INIT(&gdt->sc_ccbq);\n\tLIST_INIT(&gdt->sc_queue);\n\n\t/* Initialize the ccbs */\n\tfor (i = 0; i < GDT_MAXCMDS; i++) {\n\t\tgdt->sc_ccbs[i].gc_cmd_index = i + 2;\n\t\terror = bus_dmamap_create(gdt->sc_dmat,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,\n\t\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t    &gdt->sc_ccbs[i].gc_dmamap_xfer);\n\t\tif (error) {\n\t\t\tprintf(\"%s: cannot create ccb dmamap (%d)\",\n\t\t\t    gdt->sc_dev.dv_xname, error);\n\t\t\treturn (1);\n\t\t}\n\t\t(void)gdt_ccb_set_cmd(gdt->sc_ccbs + i, GDT_GCF_UNUSED);\n\t\tTAILQ_INSERT_TAIL(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],\n\t\t    gc_chain);\n\t}\n\n\t/* Fill in the prototype scsi_link. */\n\tgdt->sc_link.adapter_softc = gdt;\n\tgdt->sc_link.adapter = &gdt_switch;\n\tgdt->sc_link.adapter_target = 7;\n\tgdt->sc_link.device = &gdt_dev;\n\tgdt->sc_link.openings = GDT_MAXCMDS;\t/* XXX what is optimal? */\n\tgdt->sc_link.adapter_buswidth =\n\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"screen service initialization error %d\\n\",\n\t\t     gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_MOUNT, 0xffff, 1,\n\t    0)) {\n\t\tprintf(\"cache service mount error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service post-mount initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\tcdev_cnt = (u_int16_t)gdt->sc_info;\n\n\t/* Detect number of busses */\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);\n\tgdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;\n\tgdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;\n\tgdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t    GDT_IOCHAN_RAW_DESC, GDT_INVALID_CHANNEL,\n\t    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {\n\t\tgdt->sc_bus_cnt = gdt->sc_scratch[GDT_IOC_CHAN_COUNT];\n\t\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t\tid = gdt->sc_scratch[GDT_IOC_HDR_SZ +\n\t\t\t    i * GDT_RAWIOC_SZ + GDT_RAWIOC_PROC_ID];\n\t\t\tgdt->sc_bus_id[id] = id < GDT_MAXID ? id : 0xff;\n\t\t}\n\n\t} else {\n\t\t/* New method failed, use fallback. */\n\t\tgdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO, i);\n\t\tfor (i = 0; i < GDT_MAXBUS; i++) {\n\t\t\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t\t    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,\n\t\t\t    GDT_IO_CHANNEL | GDT_INVALID_CHANNEL,\n\t\t\t    GDT_GETCH_SZ)) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tprintf(\"cannot get channel count, \"\n\t\t\t\t\t    \"error %d\\n\", gdt->sc_status);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgdt->sc_bus_id[i] =\n\t\t\t    (gdt->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?\n\t\t\t    gdt->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;\n\t\t}\n\t\tgdt->sc_bus_cnt = i;\n\t}\n\n\t/* Read cache confgiuration */\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_CINFO_SZ)) {\n\t\tprintf(\"cannot get cache info, error %d\\n\", gdt->sc_status);\n\t\treturn (1);\n\t}\n\tgdt->sc_cpar.cp_version =\n\t    gdt_dec32(gdt->sc_scratch + GDT_CPAR_VERSION);\n\tgdt->sc_cpar.cp_state = gdt_dec16(gdt->sc_scratch + GDT_CPAR_STATE);\n\tgdt->sc_cpar.cp_strategy =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_STRATEGY);\n\tgdt->sc_cpar.cp_write_back =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_WRITE_BACK);\n\tgdt->sc_cpar.cp_block_size =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_BLOCK_SIZE);\n\n\t/* Read board information and features */\n\tgdt->sc_more_proc = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_BINFO_SZ)) {\n\t\t/* XXX A lot of these assignments can probably go later */\n\t\tgdt->sc_binfo.bi_ser_no =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_SER_NO);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_OEM_ID,\n\t\t    gdt->sc_binfo.bi_oem_id, sizeof gdt->sc_binfo.bi_oem_id);\n\t\tgdt->sc_binfo.bi_ep_flags =\n\t\t    gdt_dec16(gdt->sc_scratch + GDT_BINFO_EP_FLAGS);\n\t\tgdt->sc_binfo.bi_proc_id =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_PROC_ID);\n\t\tgdt->sc_binfo.bi_memsize =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEMSIZE);\n\t\tgdt->sc_binfo.bi_mem_banks =\n\t\t    gdt->sc_scratch[GDT_BINFO_MEM_BANKS];\n\t\tgdt->sc_binfo.bi_chan_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_TYPE];\n\t\tgdt->sc_binfo.bi_chan_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_COUNT];\n\t\tgdt->sc_binfo.bi_rdongle_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RDONGLE_PRES];\n\t\tgdt->sc_binfo.bi_epr_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_EPR_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_revision =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_REVISION);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_TYPE_STRING,\n\t\t    gdt->sc_binfo.bi_type_string,\n\t\t    sizeof gdt->sc_binfo.bi_type_string);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_RAID_STRING,\n\t\t    gdt->sc_binfo.bi_raid_string,\n\t\t    sizeof gdt->sc_binfo.bi_raid_string);\n\t\tgdt->sc_binfo.bi_update_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_UPDATE_PRES];\n\t\tgdt->sc_binfo.bi_xor_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_XOR_PRES];\n\t\tgdt->sc_binfo.bi_prom_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_TYPE];\n\t\tgdt->sc_binfo.bi_prom_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_COUNT];\n\t\tgdt->sc_binfo.bi_dup_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_DUP_PRES);\n\t\tgdt->sc_binfo.bi_chan_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_CHAN_PRES);\n\t\tgdt->sc_binfo.bi_mem_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEM_PRES);\n\t\tgdt->sc_binfo.bi_ft_bus_system =\n\t\t    gdt->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];\n\t\tgdt->sc_binfo.bi_subtype_valid =\n\t\t    gdt->sc_scratch[GDT_BINFO_SUBTYPE_VALID];\n\t\tgdt->sc_binfo.bi_board_subtype =\n\t\t    gdt->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];\n\t\tgdt->sc_binfo.bi_rampar_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RAMPAR_PRES];\n\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t    GDT_BOARD_FEATURES, GDT_INVALID_CHANNEL, GDT_BFEAT_SZ)) {\n\t\t\tgdt->sc_bfeat.bf_chaining =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_CHAINING];\n\t\t\tgdt->sc_bfeat.bf_striping =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_STRIPING];\n\t\t\tgdt->sc_bfeat.bf_mirroring =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_MIRRORING];\n\t\t\tgdt->sc_bfeat.bf_raid =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_RAID];\n\t\t\tgdt->sc_more_proc = 1;\n\t\t}\n\t} else {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\t/* Read more information */\n\tif (gdt->sc_more_proc) {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"raw service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\t/* Set/get features raw service (scatter/gather) */\n\tgdt->sc_raw_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,\n\t    GDT_SCATTER_GATHER, 0, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,\n\t\t    0, 0))\n\t\t\tgdt->sc_raw_feat = gdt->sc_info;\n\n\t/* Set/get features cache service (scatter/gather) */\n\tgdt->sc_cache_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_SET_FEAT, 0,\n\t    GDT_SCATTER_GATHER, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,\n\t\t    0))\n\t\t\tgdt->sc_cache_feat = gdt->sc_info;\n\n\t/* XXX Linux reserve drives here, potentially */\n\n\t/* Scan for cache devices */\n\tfor (i = 0; i < cdev_cnt && i < GDT_MAX_HDRIVES; i++)\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INFO, i, 0,\n\t\t    0)) {\n\t\t\tgdt->sc_hdr[i].hd_present = 1;\n\t\t\tgdt->sc_hdr[i].hd_size = gdt->sc_info;\n\n\t\t\t/*\n\t\t\t * Evaluate mapping (sectors per head, heads per cyl)\n\t\t\t */\n\t\t\tgdt->sc_hdr[i].hd_size &= ~GDT_SECS32;\n\t\t\tif (gdt->sc_info2 == 0)\n\t\t\t\tgdt_eval_mapping(gdt->sc_hdr[i].hd_size,\n\t\t\t\t    &drv_cyls, &drv_hds, &drv_secs);\n\t\t\telse {\n\t\t\t\tdrv_hds = gdt->sc_info2 & 0xff;\n\t\t\t\tdrv_secs = (gdt->sc_info2 >> 8) & 0xff;\n\t\t\t\tdrv_cyls = gdt->sc_hdr[i].hd_size / drv_hds /\n\t\t\t\t    drv_secs;\n\t\t\t}\n\t\t\tgdt->sc_hdr[i].hd_heads = drv_hds;\n\t\t\tgdt->sc_hdr[i].hd_secs = drv_secs;\n\t\t\t/* Round the size */\n\t\t\tgdt->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;\n\n\t\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE,\n\t\t\t    GDT_DEVTYPE, i, 0, 0))\n\t\t\t\tgdt->sc_hdr[i].hd_devtype = gdt->sc_info;\n\t\t}\n\n\tprintf(\"dpmem %x %d-bus %d cache device%s\\n\", gdt->sc_dpmembase,\n\t    gdt->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? \"\" : \"s\");\n\tprintf(\"%s: ver %x, cache %s, strategy %d, writeback %s, blksz %d\\n\",\n\t    gdt->sc_dev.dv_xname, gdt->sc_cpar.cp_version,\n\t    gdt->sc_cpar.cp_state ? \"on\" : \"off\", gdt->sc_cpar.cp_strategy,\n\t    gdt->sc_cpar.cp_write_back ? \"on\" : \"off\",\n\t    gdt->sc_cpar.cp_block_size);\n#if 1\n\tprintf(\"%s: raw feat %x cache feat %x\\n\", gdt->sc_dev.dv_xname,\n\t    gdt->sc_raw_feat, gdt->sc_cache_feat);\n#endif\n\n\tconfig_found(&gdt->sc_dev, &gdt->sc_link, scsiprint);\n\n\tMALLOC(gdt->sc_raw_link, struct scsi_link *,\n\t    gdt->sc_bus_cnt * sizeof (struct scsi_link), M_DEVBUF, M_NOWAIT);\n\tbzero(gdt->sc_raw_link, gdt->sc_bus_cnt * sizeof (struct scsi_link));\n\n\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t/* Fill in the prototype scsi_link. */\n\t\tgdt->sc_raw_link[i].adapter_softc = gdt;\n\t\tgdt->sc_raw_link[i].adapter = &gdt_raw_switch;\n\t\tgdt->sc_raw_link[i].adapter_target = 7;\n\t\tgdt->sc_raw_link[i].device = &gdt_dev;\n\t\tgdt->sc_raw_link[i].openings = 4;\t/* XXX a guess */\n\t\tgdt->sc_raw_link[i].adapter_buswidth =\n\t\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : 16;\t/* XXX */\n\n\t\tconfig_found(&gdt->sc_dev, &gdt->sc_raw_link[i], scsiprint);\n\t}\n\n\tgdt_polling = 0;\n\treturn (0);\n}"
  }
]