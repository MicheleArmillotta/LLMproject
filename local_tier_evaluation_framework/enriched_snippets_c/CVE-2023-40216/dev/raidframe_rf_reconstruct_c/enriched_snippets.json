[
  {
    "function_name": "rf_UnblockRecon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1590-1646",
    "snippet": "int \nrf_UnblockRecon(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t row = asmap->origRow;\n\tRF_StripeNum_t stripeID = asmap->stripeID;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n\tint     created = 0;\n\tRF_CallbackDesc_t *cb;\n\n\tpsid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_NONE, &created);\n\n\t/* When recon is forced, the pss desc can get deleted before we get\n\t * back to unblock recon. But, this can _only_ happen when recon is\n\t * forced. It would be good to put some kind of sanity check here, but\n\t * how to decide if recon was just forced or not? */\n\tif (!pssPtr) {\n\t\t/* printf(\"Warning: no pss descriptor upon unblock on psid %ld\n\t\t * RU %d\\n\",psid,which_ru); */\n\t\tif (rf_reconDebug || rf_pssDebug)\n\t\t\tprintf(\"Warning: no pss descriptor upon unblock on psid %ld RU %d\\n\", (long) psid, which_ru);\n\t\tgoto out;\n\t}\n\tpssPtr->blockCount--;\n\tDprintf3(\"raid%d: unblocking recon on psid %ld: blockcount is %d\\n\",\n\t\t raidPtr->raidid, psid, pssPtr->blockCount);\n\tif (pssPtr->blockCount == 0) {\t/* if recon blockage has been released */\n\n\t\t/* unblock recon before calling CauseReconEvent in case\n\t\t * CauseReconEvent causes us to try to issue a new read before\n\t\t * returning here. */\n\t\tpssPtr->flags &= ~RF_PSS_RECON_BLOCKED;\n\n\n\t\twhile (pssPtr->blockWaitList) {\t\n\t\t\t/* spin through the block-wait list and\n\t\t\t   release all the waiters */\n\t\t\tcb = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb->next;\n\t\t\tcb->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL, RF_REVENT_BLOCKCLEAR);\n\t\t\trf_FreeCallbackDesc(cb);\n\t\t}\n\t\tif (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {\n\t\t\t/* if no recon was requested while recon was blocked */\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\t}\n\t}\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PSStatusDelete",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[row]->pssTable",
            "pssPtr"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PSStatusDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "224-247",
          "snippet": "void \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "cb"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "cb->row",
            "cb->col",
            "NULL",
            "RF_REVENT_BLOCKCLEAR"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"raid%d: unblocking recon on psid %ld: blockcount is %d\\n\"",
            "raidPtr->raidid",
            "psid",
            "pssPtr->blockCount"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: no pss descriptor upon unblock on psid %ld RU %d\\n\"",
            "(long) psid",
            "which_ru"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_LookupRUStatus",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[row]->pssTable",
            "psid",
            "which_ru",
            "RF_PSS_NONE",
            "&created"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "rf_LookupRUStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "170-218",
          "snippet": "RF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nRF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapStripeIDToParityStripeID",
          "args": [
            "&raidPtr->Layout",
            "stripeID",
            "&which_ru"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MapStripeIDToParityStripeID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_layout.c",
          "lines": "501-517",
          "snippet": "RF_StripeNum_t \nrf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)\n\tRF_RaidLayout_t *layoutPtr;\n\tRF_StripeNum_t stripeID;\n\tRF_ReconUnitNum_t *which_ru;\n{\n\tRF_StripeNum_t parityStripeID;\n\n\t/* quick exit in the common case of SUsPerPU==1 */\n\tif ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {\n\t\t*which_ru = 0;\n\t\treturn (stripeID);\n\t} else {\n\t\t(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID, &parityStripeID, which_ru);\n\t}\n\treturn (parityStripeID);\n}",
          "includes": [
            "#include \"rf_reconutil.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_raid5.h\"",
            "#include \"rf_raid4.h\"",
            "#include \"rf_raid1.h\"",
            "#include \"rf_raid0.h\"",
            "#include \"rf_declusterPQ.h\"",
            "#include \"rf_pq.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_reconutil.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_general.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_states.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid4.h\"\n#include \"rf_raid1.h\"\n#include \"rf_raid0.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_pq.h\"\n#include \"rf_decluster.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include \"rf_types.h\"\n\nRF_StripeNum_t \nrf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)\n\tRF_RaidLayout_t *layoutPtr;\n\tRF_StripeNum_t stripeID;\n\tRF_ReconUnitNum_t *which_ru;\n{\n\tRF_StripeNum_t parityStripeID;\n\n\t/* quick exit in the common case of SUsPerPU==1 */\n\tif ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {\n\t\t*which_ru = 0;\n\t\treturn (stripeID);\n\t} else {\n\t\t(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID, &parityStripeID, which_ru);\n\t}\n\treturn (parityStripeID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_UnblockRecon(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t row = asmap->origRow;\n\tRF_StripeNum_t stripeID = asmap->stripeID;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n\tint     created = 0;\n\tRF_CallbackDesc_t *cb;\n\n\tpsid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_NONE, &created);\n\n\t/* When recon is forced, the pss desc can get deleted before we get\n\t * back to unblock recon. But, this can _only_ happen when recon is\n\t * forced. It would be good to put some kind of sanity check here, but\n\t * how to decide if recon was just forced or not? */\n\tif (!pssPtr) {\n\t\t/* printf(\"Warning: no pss descriptor upon unblock on psid %ld\n\t\t * RU %d\\n\",psid,which_ru); */\n\t\tif (rf_reconDebug || rf_pssDebug)\n\t\t\tprintf(\"Warning: no pss descriptor upon unblock on psid %ld RU %d\\n\", (long) psid, which_ru);\n\t\tgoto out;\n\t}\n\tpssPtr->blockCount--;\n\tDprintf3(\"raid%d: unblocking recon on psid %ld: blockcount is %d\\n\",\n\t\t raidPtr->raidid, psid, pssPtr->blockCount);\n\tif (pssPtr->blockCount == 0) {\t/* if recon blockage has been released */\n\n\t\t/* unblock recon before calling CauseReconEvent in case\n\t\t * CauseReconEvent causes us to try to issue a new read before\n\t\t * returning here. */\n\t\tpssPtr->flags &= ~RF_PSS_RECON_BLOCKED;\n\n\n\t\twhile (pssPtr->blockWaitList) {\t\n\t\t\t/* spin through the block-wait list and\n\t\t\t   release all the waiters */\n\t\t\tcb = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb->next;\n\t\t\tcb->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL, RF_REVENT_BLOCKCLEAR);\n\t\t\trf_FreeCallbackDesc(cb);\n\t\t}\n\t\tif (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {\n\t\t\t/* if no recon was requested while recon was blocked */\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\t}\n\t}\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ForceReconReadDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1574-1588",
    "snippet": "void \nrf_ForceReconReadDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_ReconBuffer_t *rbuf = arg;\n\n\tif (status) {\n\t\tprintf(\"Forced recon read failed!\\n\");\t/* fprintf(stderr,\"Forced\n\t\t\t\t\t\t\t *  recon read\n\t\t\t\t\t\t\t * failed!\\n\"); */\n\t\tRF_PANIC();\n\t}\n\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, (void *) rbuf, RF_REVENT_FORCEDREADDONE);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_ForceReconReadDoneProc",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "(RF_Raid_t *) rbuf->raidPtr",
            "rbuf->row",
            "rbuf->col",
            "(void *) rbuf",
            "RF_REVENT_FORCEDREADDONE"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Forced recon read failed!\\n\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_ForceReconReadDoneProc;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nvoid \nrf_ForceReconReadDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_ReconBuffer_t *rbuf = arg;\n\n\tif (status) {\n\t\tprintf(\"Forced recon read failed!\\n\");\t/* fprintf(stderr,\"Forced\n\t\t\t\t\t\t\t *  recon read\n\t\t\t\t\t\t\t * failed!\\n\"); */\n\t\tRF_PANIC();\n\t}\n\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, (void *) rbuf, RF_REVENT_FORCEDREADDONE);\n}"
  },
  {
    "function_name": "rf_ForceOrBlockRecon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1459-1569",
    "snippet": "int \nrf_ForceOrBlockRecon(raidPtr, asmap, cbFunc, cbArg)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n\tvoid    (*cbFunc) (RF_Raid_t *, void *);\n\tvoid   *cbArg;\n{\n\tRF_RowCol_t row = asmap->physInfo->row;\t/* which row of the array\n\t\t\t\t\t\t * we're working on */\n\tRF_StripeNum_t stripeID = asmap->stripeID;\t/* the stripe ID we're\n\t\t\t\t\t\t\t * forcing recon on */\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\t/* num sects in one RU */\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* a pointer to the parity\n\t\t\t\t\t\t * stripe status structure */\n\tRF_StripeNum_t psid;\t/* parity stripe id */\n\tRF_SectorNum_t offset, fd_offset;\t/* disk offset, failed-disk\n\t\t\t\t\t\t * offset */\n\tRF_RowCol_t *diskids;\n\tRF_RowCol_t stripe;\n\tRF_ReconUnitNum_t which_ru;\t/* RU within parity stripe */\n\tRF_RowCol_t fcol, diskno, i;\n\tRF_ReconBuffer_t *new_rbuf;\t/* ptr to newly allocated rbufs */\n\tRF_DiskQueueData_t *req;/* disk I/O req to be enqueued */\n\tRF_CallbackDesc_t *cb;\n\tint     created = 0, nPromoted;\n\n\tpsid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);\n\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);\n\n\t/* if recon is not ongoing on this PS, just return */\n\tif (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {\n\t\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\t\treturn (0);\n\t}\n\t/* otherwise, we have to wait for reconstruction to complete on this\n\t * RU. */\n\t/* In order to avoid waiting for a potentially large number of\n\t * low-priority accesses to complete, we force a normal-priority (i.e.\n\t * not low-priority) reconstruction on this RU. */\n\tif (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) && !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {\n\t\tDDprintf1(\"Forcing recon on psid %ld\\n\", psid);\n\t\tpssPtr->flags |= RF_PSS_FORCED_ON_WRITE;\t/* mark this RU as under\n\t\t\t\t\t\t\t\t * forced recon */\n\t\tpssPtr->flags &= ~RF_PSS_RECON_BLOCKED;\t/* clear the blockage\n\t\t\t\t\t\t\t * that we just set */\n\t\tfcol = raidPtr->reconControl[row]->fcol;\n\n\t\t/* get a listing of the disks comprising the indicated stripe */\n\t\t(raidPtr->Layout.map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &stripe);\n\t\tRF_ASSERT(row == stripe);\n\n\t\t/* For previously issued reads, elevate them to normal\n\t\t * priority.  If the I/O has already completed, it won't be\n\t\t * found in the queue, and hence this will be a no-op. For\n\t\t * unissued reads, allocate buffers and issue new reads.  The\n\t\t * fact that we've set the FORCED bit means that the regular\n\t\t * recon procs will not re-issue these reqs */\n\t\tfor (i = 0; i < raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol; i++)\n\t\t\tif ((diskno = diskids[i]) != fcol) {\n\t\t\t\tif (pssPtr->issued[diskno]) {\n\t\t\t\t\tnPromoted = rf_DiskIOPromote(&raidPtr->Queues[row][diskno], psid, which_ru);\n\t\t\t\t\tif (rf_reconDebug && nPromoted)\n\t\t\t\t\t\tprintf(\"raid%d: promoted read from row %d col %d\\n\", raidPtr->raidid, row, diskno);\n\t\t\t\t} else {\n\t\t\t\t\tnew_rbuf = rf_MakeReconBuffer(raidPtr, row, diskno, RF_RBUF_TYPE_FORCED);\t/* create new buf */\n\t\t\t\t\trf_ComputePSDiskOffsets(raidPtr, psid, row, diskno, &offset, &fd_offset,\n\t\t\t\t\t    &new_rbuf->spRow, &new_rbuf->spCol, &new_rbuf->spOffset);\t/* find offsets & spare\n\t\t\t\t\t\t\t\t\t\t\t\t\t * location */\n\t\t\t\t\tnew_rbuf->parityStripeID = psid;\t/* fill in the buffer */\n\t\t\t\t\tnew_rbuf->which_ru = which_ru;\n\t\t\t\t\tnew_rbuf->failedDiskSectorOffset = fd_offset;\n\t\t\t\t\tnew_rbuf->priority = RF_IO_NORMAL_PRIORITY;\n\n\t\t\t\t\t/* use NULL b_proc b/c all addrs\n\t\t\t\t\t * should be in kernel space */\n\t\t\t\t\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, offset + which_ru * sectorsPerRU, sectorsPerRU, new_rbuf->buffer,\n\t\t\t\t\t    psid, which_ru, (int (*) (void *, int)) rf_ForceReconReadDoneProc, (void *) new_rbuf, NULL,\n\t\t\t\t\t    NULL, (void *) raidPtr, 0, NULL);\n\n\t\t\t\t\tRF_ASSERT(req);\t/* XXX -- fix this --\n\t\t\t\t\t\t\t * XXX */\n\n\t\t\t\t\tnew_rbuf->arg = req;\n\t\t\t\t\trf_DiskIOEnqueue(&raidPtr->Queues[row][diskno], req, RF_IO_NORMAL_PRIORITY);\t/* enqueue the I/O */\n\t\t\t\t\tDprintf3(\"raid%d: Issued new read req on row %d col %d\\n\", raidPtr->raidid, row, diskno);\n\t\t\t\t}\n\t\t\t}\n\t\t/* if the write is sitting in the disk queue, elevate its\n\t\t * priority */\n\t\tif (rf_DiskIOPromote(&raidPtr->Queues[row][fcol], psid, which_ru))\n\t\t\tprintf(\"raid%d: promoted write to row %d col %d\\n\", \n\t\t\t       raidPtr->raidid, row, fcol);\n\t}\n\t/* install a callback descriptor to be invoked when recon completes on\n\t * this parity stripe. */\n\tcb = rf_AllocCallbackDesc();\n\t/* XXX the following is bogus.. These functions don't really match!!\n\t * GO */\n\tcb->callbackFunc = (void (*) (RF_CBParam_t)) cbFunc;\n\tcb->callbackArg.p = (void *) cbArg;\n\tcb->next = pssPtr->procWaitList;\n\tpssPtr->procWaitList = cb;\n\tDDprintf2(\"raid%d: Waiting for forced recon on psid %ld\\n\", \n\t\t  raidPtr->raidid, psid);\n\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (1);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ComputePSDiskOffsets",
      "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
      "void rf_ForceReconReadDoneProc",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DDprintf2",
          "args": [
            "\"raid%d: Waiting for forced recon on psid %ld\\n\"",
            "raidPtr->raidid",
            "psid"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocCallbackDesc",
          "args": [],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "80-87",
          "snippet": "RF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nRF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: promoted write to row %d col %d\\n\"",
            "raidPtr->raidid",
            "row",
            "fcol"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_DiskIOPromote",
          "args": [
            "&raidPtr->Queues[row][fcol]",
            "psid",
            "which_ru"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOPromote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "499-513",
          "snippet": "int \nrf_DiskIOPromote(queue, parityStripeID, which_ru)\n\tRF_DiskQueue_t *queue;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tint     retval;\n\n\tif (!queue->qPtr->Promote)\n\t\treturn (-1);\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\tretval = (queue->qPtr->Promote) (queue->qHdr, parityStripeID, which_ru);\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\treturn (retval);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_DiskIOPromote(queue, parityStripeID, which_ru)\n\tRF_DiskQueue_t *queue;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tint     retval;\n\n\tif (!queue->qPtr->Promote)\n\t\treturn (-1);\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\tretval = (queue->qPtr->Promote) (queue->qHdr, parityStripeID, which_ru);\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOPromote\");\n\treturn (retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"raid%d: Issued new read req on row %d col %d\\n\"",
            "raidPtr->raidid",
            "row",
            "diskno"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&raidPtr->Queues[row][diskno]",
            "req",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_READ",
            "offset + which_ru * sectorsPerRU",
            "sectorsPerRU",
            "new_rbuf->buffer",
            "psid",
            "which_ru",
            "(int (*) (void *, int)) rf_ForceReconReadDoneProc",
            "(void *) new_rbuf",
            "NULL",
            "NULL",
            "(void *) raidPtr",
            "0",
            "NULL"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ComputePSDiskOffsets",
          "args": [
            "raidPtr",
            "psid",
            "row",
            "diskno",
            "&offset",
            "&fd_offset",
            "&new_rbuf->spRow",
            "&new_rbuf->spCol",
            "&new_rbuf->spOffset"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ComputePSDiskOffsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1085-1196",
          "snippet": "int \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ComputePSDiskOffsets",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_MakeReconBuffer",
          "args": [
            "raidPtr",
            "row",
            "diskno",
            "RF_RBUF_TYPE_FORCED"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MakeReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "230-252",
          "snippet": "RF_ReconBuffer_t *\nrf_MakeReconBuffer(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_RbufType_t type)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *t;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, layoutPtr->SUsPerRU * layoutPtr->sectorsPerStripeUnit);\n\n\tRF_Malloc(t, sizeof(RF_ReconBuffer_t), (RF_ReconBuffer_t *));\n\tRF_Malloc(t->buffer, recon_buffer_size, (caddr_t));\n\tRF_Malloc(t->arrived, raidPtr->numCol * sizeof(char), (char *));\n\tt->raidPtr = raidPtr;\n\tt->row = row;\n\tt->col = col;\n\tt->priority = RF_IO_RECON_PRIORITY;\n\tt->type = type;\n\tt->pssPtr = NULL;\n\tt->next = NULL;\n\treturn (t);\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_ReconBuffer_t *\nrf_MakeReconBuffer(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_RbufType_t type)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *t;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, layoutPtr->SUsPerRU * layoutPtr->sectorsPerStripeUnit);\n\n\tRF_Malloc(t, sizeof(RF_ReconBuffer_t), (RF_ReconBuffer_t *));\n\tRF_Malloc(t->buffer, recon_buffer_size, (caddr_t));\n\tRF_Malloc(t->arrived, raidPtr->numCol * sizeof(char), (char *));\n\tt->raidPtr = raidPtr;\n\tt->row = row;\n\tt->col = col;\n\tt->priority = RF_IO_RECON_PRIORITY;\n\tt->type = type;\n\tt->pssPtr = NULL;\n\tt->next = NULL;\n\treturn (t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "row == stripe"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "asmap->raidAddress",
            "&diskids",
            "&stripe"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DDprintf1",
          "args": [
            "\"Forcing recon on psid %ld\\n\"",
            "psid"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_LookupRUStatus",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[row]->pssTable",
            "psid",
            "which_ru",
            "RF_PSS_CREATE | RF_PSS_RECON_BLOCKED",
            "&created"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "rf_LookupRUStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "170-218",
          "snippet": "RF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nRF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapStripeIDToParityStripeID",
          "args": [
            "&raidPtr->Layout",
            "stripeID",
            "&which_ru"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MapStripeIDToParityStripeID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_layout.c",
          "lines": "501-517",
          "snippet": "RF_StripeNum_t \nrf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)\n\tRF_RaidLayout_t *layoutPtr;\n\tRF_StripeNum_t stripeID;\n\tRF_ReconUnitNum_t *which_ru;\n{\n\tRF_StripeNum_t parityStripeID;\n\n\t/* quick exit in the common case of SUsPerPU==1 */\n\tif ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {\n\t\t*which_ru = 0;\n\t\treturn (stripeID);\n\t} else {\n\t\t(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID, &parityStripeID, which_ru);\n\t}\n\treturn (parityStripeID);\n}",
          "includes": [
            "#include \"rf_reconutil.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_raid5.h\"",
            "#include \"rf_raid4.h\"",
            "#include \"rf_raid1.h\"",
            "#include \"rf_raid0.h\"",
            "#include \"rf_declusterPQ.h\"",
            "#include \"rf_pq.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_reconutil.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_general.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_chaindecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_states.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid4.h\"\n#include \"rf_raid1.h\"\n#include \"rf_raid0.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_pq.h\"\n#include \"rf_decluster.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include \"rf_types.h\"\n\nRF_StripeNum_t \nrf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)\n\tRF_RaidLayout_t *layoutPtr;\n\tRF_StripeNum_t stripeID;\n\tRF_ReconUnitNum_t *which_ru;\n{\n\tRF_StripeNum_t parityStripeID;\n\n\t/* quick exit in the common case of SUsPerPU==1 */\n\tif ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {\n\t\t*which_ru = 0;\n\t\treturn (stripeID);\n\t} else {\n\t\t(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID, &parityStripeID, which_ru);\n\t}\n\treturn (parityStripeID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ComputePSDiskOffsets;\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nvoid rf_ForceReconReadDoneProc;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ForceOrBlockRecon(raidPtr, asmap, cbFunc, cbArg)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n\tvoid    (*cbFunc) (RF_Raid_t *, void *);\n\tvoid   *cbArg;\n{\n\tRF_RowCol_t row = asmap->physInfo->row;\t/* which row of the array\n\t\t\t\t\t\t * we're working on */\n\tRF_StripeNum_t stripeID = asmap->stripeID;\t/* the stripe ID we're\n\t\t\t\t\t\t\t * forcing recon on */\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\t/* num sects in one RU */\n\tRF_ReconParityStripeStatus_t *pssPtr;\t/* a pointer to the parity\n\t\t\t\t\t\t * stripe status structure */\n\tRF_StripeNum_t psid;\t/* parity stripe id */\n\tRF_SectorNum_t offset, fd_offset;\t/* disk offset, failed-disk\n\t\t\t\t\t\t * offset */\n\tRF_RowCol_t *diskids;\n\tRF_RowCol_t stripe;\n\tRF_ReconUnitNum_t which_ru;\t/* RU within parity stripe */\n\tRF_RowCol_t fcol, diskno, i;\n\tRF_ReconBuffer_t *new_rbuf;\t/* ptr to newly allocated rbufs */\n\tRF_DiskQueueData_t *req;/* disk I/O req to be enqueued */\n\tRF_CallbackDesc_t *cb;\n\tint     created = 0, nPromoted;\n\n\tpsid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);\n\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);\n\n\t/* if recon is not ongoing on this PS, just return */\n\tif (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {\n\t\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\t\treturn (0);\n\t}\n\t/* otherwise, we have to wait for reconstruction to complete on this\n\t * RU. */\n\t/* In order to avoid waiting for a potentially large number of\n\t * low-priority accesses to complete, we force a normal-priority (i.e.\n\t * not low-priority) reconstruction on this RU. */\n\tif (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) && !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {\n\t\tDDprintf1(\"Forcing recon on psid %ld\\n\", psid);\n\t\tpssPtr->flags |= RF_PSS_FORCED_ON_WRITE;\t/* mark this RU as under\n\t\t\t\t\t\t\t\t * forced recon */\n\t\tpssPtr->flags &= ~RF_PSS_RECON_BLOCKED;\t/* clear the blockage\n\t\t\t\t\t\t\t * that we just set */\n\t\tfcol = raidPtr->reconControl[row]->fcol;\n\n\t\t/* get a listing of the disks comprising the indicated stripe */\n\t\t(raidPtr->Layout.map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &stripe);\n\t\tRF_ASSERT(row == stripe);\n\n\t\t/* For previously issued reads, elevate them to normal\n\t\t * priority.  If the I/O has already completed, it won't be\n\t\t * found in the queue, and hence this will be a no-op. For\n\t\t * unissued reads, allocate buffers and issue new reads.  The\n\t\t * fact that we've set the FORCED bit means that the regular\n\t\t * recon procs will not re-issue these reqs */\n\t\tfor (i = 0; i < raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol; i++)\n\t\t\tif ((diskno = diskids[i]) != fcol) {\n\t\t\t\tif (pssPtr->issued[diskno]) {\n\t\t\t\t\tnPromoted = rf_DiskIOPromote(&raidPtr->Queues[row][diskno], psid, which_ru);\n\t\t\t\t\tif (rf_reconDebug && nPromoted)\n\t\t\t\t\t\tprintf(\"raid%d: promoted read from row %d col %d\\n\", raidPtr->raidid, row, diskno);\n\t\t\t\t} else {\n\t\t\t\t\tnew_rbuf = rf_MakeReconBuffer(raidPtr, row, diskno, RF_RBUF_TYPE_FORCED);\t/* create new buf */\n\t\t\t\t\trf_ComputePSDiskOffsets(raidPtr, psid, row, diskno, &offset, &fd_offset,\n\t\t\t\t\t    &new_rbuf->spRow, &new_rbuf->spCol, &new_rbuf->spOffset);\t/* find offsets & spare\n\t\t\t\t\t\t\t\t\t\t\t\t\t * location */\n\t\t\t\t\tnew_rbuf->parityStripeID = psid;\t/* fill in the buffer */\n\t\t\t\t\tnew_rbuf->which_ru = which_ru;\n\t\t\t\t\tnew_rbuf->failedDiskSectorOffset = fd_offset;\n\t\t\t\t\tnew_rbuf->priority = RF_IO_NORMAL_PRIORITY;\n\n\t\t\t\t\t/* use NULL b_proc b/c all addrs\n\t\t\t\t\t * should be in kernel space */\n\t\t\t\t\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, offset + which_ru * sectorsPerRU, sectorsPerRU, new_rbuf->buffer,\n\t\t\t\t\t    psid, which_ru, (int (*) (void *, int)) rf_ForceReconReadDoneProc, (void *) new_rbuf, NULL,\n\t\t\t\t\t    NULL, (void *) raidPtr, 0, NULL);\n\n\t\t\t\t\tRF_ASSERT(req);\t/* XXX -- fix this --\n\t\t\t\t\t\t\t * XXX */\n\n\t\t\t\t\tnew_rbuf->arg = req;\n\t\t\t\t\trf_DiskIOEnqueue(&raidPtr->Queues[row][diskno], req, RF_IO_NORMAL_PRIORITY);\t/* enqueue the I/O */\n\t\t\t\t\tDprintf3(\"raid%d: Issued new read req on row %d col %d\\n\", raidPtr->raidid, row, diskno);\n\t\t\t\t}\n\t\t\t}\n\t\t/* if the write is sitting in the disk queue, elevate its\n\t\t * priority */\n\t\tif (rf_DiskIOPromote(&raidPtr->Queues[row][fcol], psid, which_ru))\n\t\t\tprintf(\"raid%d: promoted write to row %d col %d\\n\", \n\t\t\t       raidPtr->raidid, row, fcol);\n\t}\n\t/* install a callback descriptor to be invoked when recon completes on\n\t * this parity stripe. */\n\tcb = rf_AllocCallbackDesc();\n\t/* XXX the following is bogus.. These functions don't really match!!\n\t * GO */\n\tcb->callbackFunc = (void (*) (RF_CBParam_t)) cbFunc;\n\tcb->callbackArg.p = (void *) cbArg;\n\tcb->next = pssPtr->procWaitList;\n\tpssPtr->procWaitList = cb;\n\tDDprintf2(\"raid%d: Waiting for forced recon on psid %ld\\n\", \n\t\t  raidPtr->raidid, psid);\n\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (1);\n}"
  },
  {
    "function_name": "rf_CheckForcedOrBlockedReconstruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1418-1450",
    "snippet": "int \nrf_CheckForcedOrBlockedReconstruction(\n    RF_Raid_t * raidPtr,\n    RF_ReconParityStripeStatus_t * pssPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_StripeNum_t psid,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_CallbackDesc_t *cb;\n\tint     retcode = 0;\n\n\tif ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))\n\t\tretcode = RF_PSS_FORCED_ON_WRITE;\n\telse\n\t\tif (pssPtr->flags & RF_PSS_RECON_BLOCKED) {\n\t\t\tDprintf4(\"RECON: row %d col %d blocked at psid %ld ru %d\\n\", row, col, psid, which_ru);\n\t\t\tcb = rf_AllocCallbackDesc();\t/* append ourselves to\n\t\t\t\t\t\t\t * the blockage-wait\n\t\t\t\t\t\t\t * list */\n\t\t\tcb->row = row;\n\t\t\tcb->col = col;\n\t\t\tcb->next = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb;\n\t\t\tretcode = RF_PSS_RECON_BLOCKED;\n\t\t}\n\tif (!retcode)\n\t\tpssPtr->flags |= RF_PSS_UNDER_RECON;\t/* mark this RU as under\n\t\t\t\t\t\t\t * reconstruction */\n\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
      "int rf_CheckForcedOrBlockedReconstruction",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_AllocCallbackDesc",
          "args": [],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "80-87",
          "snippet": "RF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nRF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf4",
          "args": [
            "\"RECON: row %d col %d blocked at psid %ld ru %d\\n\"",
            "row",
            "col",
            "psid",
            "which_ru"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nint rf_CheckForcedOrBlockedReconstruction;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_CheckForcedOrBlockedReconstruction(\n    RF_Raid_t * raidPtr,\n    RF_ReconParityStripeStatus_t * pssPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_StripeNum_t psid,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_CallbackDesc_t *cb;\n\tint     retcode = 0;\n\n\tif ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))\n\t\tretcode = RF_PSS_FORCED_ON_WRITE;\n\telse\n\t\tif (pssPtr->flags & RF_PSS_RECON_BLOCKED) {\n\t\t\tDprintf4(\"RECON: row %d col %d blocked at psid %ld ru %d\\n\", row, col, psid, which_ru);\n\t\t\tcb = rf_AllocCallbackDesc();\t/* append ourselves to\n\t\t\t\t\t\t\t * the blockage-wait\n\t\t\t\t\t\t\t * list */\n\t\t\tcb->row = row;\n\t\t\tcb->col = col;\n\t\t\tcb->next = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb;\n\t\t\tretcode = RF_PSS_RECON_BLOCKED;\n\t\t}\n\tif (!retcode)\n\t\tpssPtr->flags |= RF_PSS_UNDER_RECON;\t/* mark this RU as under\n\t\t\t\t\t\t\t * reconstruction */\n\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_CheckHeadSeparation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1352-1410",
    "snippet": "int \nrf_CheckHeadSeparation(\n    RF_Raid_t * raidPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_HeadSepLimit_t hsCtr,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb, *p, *pt;\n\tint     retval = 0;\n\n\t/* if we're too far ahead of the slowest disk, stop working on this\n\t * disk until the slower ones catch up.  We do this by scheduling a\n\t * wakeup callback for the time when the slowest disk has caught up.\n\t * We define \"caught up\" with 20% hysteresis, i.e. the head separation\n\t * must have fallen to at most 80% of the max allowable head\n\t * separation before we'll wake up.\n\t * \n\t */\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif ((raidPtr->headSepLimit >= 0) &&\n\t    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit)) {\n\t\tDprintf6(\"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\\n\",\n\t\t\t raidPtr->raidid, row, col, ctrl->headSepCounter, \n\t\t\t reconCtrlPtr->minHeadSepCounter, \n\t\t\t raidPtr->headSepLimit);\n\t\tcb = rf_AllocCallbackDesc();\n\t\t/* the minHeadSepCounter value we have to get to before we'll\n\t\t * wake up.  build in 20% hysteresis. */\n\t\tcb->callbackArg.v = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit / 5);\n\t\tcb->row = row;\n\t\tcb->col = col;\n\t\tcb->next = NULL;\n\n\t\t/* insert this callback descriptor into the sorted list of\n\t\t * pending head-sep callbacks */\n\t\tp = reconCtrlPtr->headSepCBList;\n\t\tif (!p)\n\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\telse\n\t\t\tif (cb->callbackArg.v < p->callbackArg.v) {\n\t\t\t\tcb->next = reconCtrlPtr->headSepCBList;\n\t\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\t\t} else {\n\t\t\t\tfor (pt = p, p = p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt = p, p = p->next);\n\t\t\t\tcb->next = p;\n\t\t\t\tpt->next = cb;\n\t\t\t}\n\t\tretval = 1;\n#if RF_RECON_STATS > 0\n\t\tctrl->reconCtrl->reconDesc->hsStallCount++;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\treturn (retval);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);",
      "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocCallbackDesc",
          "args": [],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "80-87",
          "snippet": "RF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nRF_CallbackDesc_t *\nrf_AllocCallbackDesc()\n{\n\tRF_CallbackDesc_t *p;\n\n\tRF_FREELIST_GET(rf_callback_freelist, p, next, (RF_CallbackDesc_t *));\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf6",
          "args": [
            "\"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\\n\"",
            "raidPtr->raidid",
            "row",
            "col",
            "ctrl->headSepCounter",
            "reconCtrlPtr->minHeadSepCounter",
            "raidPtr->headSepLimit"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_CheckHeadSeparation(\n    RF_Raid_t * raidPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_HeadSepLimit_t hsCtr,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb, *p, *pt;\n\tint     retval = 0;\n\n\t/* if we're too far ahead of the slowest disk, stop working on this\n\t * disk until the slower ones catch up.  We do this by scheduling a\n\t * wakeup callback for the time when the slowest disk has caught up.\n\t * We define \"caught up\" with 20% hysteresis, i.e. the head separation\n\t * must have fallen to at most 80% of the max allowable head\n\t * separation before we'll wake up.\n\t * \n\t */\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif ((raidPtr->headSepLimit >= 0) &&\n\t    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit)) {\n\t\tDprintf6(\"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\\n\",\n\t\t\t raidPtr->raidid, row, col, ctrl->headSepCounter, \n\t\t\t reconCtrlPtr->minHeadSepCounter, \n\t\t\t raidPtr->headSepLimit);\n\t\tcb = rf_AllocCallbackDesc();\n\t\t/* the minHeadSepCounter value we have to get to before we'll\n\t\t * wake up.  build in 20% hysteresis. */\n\t\tcb->callbackArg.v = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit / 5);\n\t\tcb->row = row;\n\t\tcb->col = col;\n\t\tcb->next = NULL;\n\n\t\t/* insert this callback descriptor into the sorted list of\n\t\t * pending head-sep callbacks */\n\t\tp = reconCtrlPtr->headSepCBList;\n\t\tif (!p)\n\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\telse\n\t\t\tif (cb->callbackArg.v < p->callbackArg.v) {\n\t\t\t\tcb->next = reconCtrlPtr->headSepCBList;\n\t\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\t\t} else {\n\t\t\t\tfor (pt = p, p = p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt = p, p = p->next);\n\t\t\t\tcb->next = p;\n\t\t\t\tpt->next = cb;\n\t\t\t}\n\t\tretval = 1;\n#if RF_RECON_STATS > 0\n\t\tctrl->reconCtrl->reconDesc->hsStallCount++;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\treturn (retval);\n}"
  },
  {
    "function_name": "rf_CheckForNewMinHeadSep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1300-1338",
    "snippet": "void \nrf_CheckForNewMinHeadSep(raidPtr, row, hsCtr)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_HeadSepLimit_t hsCtr;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_HeadSepLimit_t new_min;\n\tRF_RowCol_t i;\n\tRF_CallbackDesc_t *p;\n\tRF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);\t/* from the definition\n\t\t\t\t\t\t\t\t * of a minimum */\n\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tnew_min = ~(1L << (8 * sizeof(long) - 1));\t/* 0x7FFF....FFF */\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (i != reconCtrlPtr->fcol) {\n\t\t\tif (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min)\n\t\t\t\tnew_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;\n\t\t}\n\t/* set the new minimum and wake up anyone who can now run again */\n\tif (new_min != reconCtrlPtr->minHeadSepCounter) {\n\t\treconCtrlPtr->minHeadSepCounter = new_min;\n\t\tDprintf1(\"RECON:  new min head pos counter val is %ld\\n\", new_min);\n\t\twhile (reconCtrlPtr->headSepCBList) {\n\t\t\tif (reconCtrlPtr->headSepCBList->callbackArg.v > new_min)\n\t\t\t\tbreak;\n\t\t\tp = reconCtrlPtr->headSepCBList;\n\t\t\treconCtrlPtr->headSepCBList = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);\n\t\t\trf_FreeCallbackDesc(p);\n\t\t}\n\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "p"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "p->row",
            "p->col",
            "NULL",
            "RF_REVENT_HEADSEPCLEAR"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"RECON:  new min head pos counter val is %ld\\n\"",
            "new_min"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "reconCtrlPtr->rb_mutex"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "hsCtr >= reconCtrlPtr->minHeadSepCounter"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nvoid \nrf_CheckForNewMinHeadSep(raidPtr, row, hsCtr)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_HeadSepLimit_t hsCtr;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_HeadSepLimit_t new_min;\n\tRF_RowCol_t i;\n\tRF_CallbackDesc_t *p;\n\tRF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);\t/* from the definition\n\t\t\t\t\t\t\t\t * of a minimum */\n\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tnew_min = ~(1L << (8 * sizeof(long) - 1));\t/* 0x7FFF....FFF */\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (i != reconCtrlPtr->fcol) {\n\t\t\tif (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min)\n\t\t\t\tnew_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;\n\t\t}\n\t/* set the new minimum and wake up anyone who can now run again */\n\tif (new_min != reconCtrlPtr->minHeadSepCounter) {\n\t\treconCtrlPtr->minHeadSepCounter = new_min;\n\t\tDprintf1(\"RECON:  new min head pos counter val is %ld\\n\", new_min);\n\t\twhile (reconCtrlPtr->headSepCBList) {\n\t\t\tif (reconCtrlPtr->headSepCBList->callbackArg.v > new_min)\n\t\t\t\tbreak;\n\t\t\tp = reconCtrlPtr->headSepCBList;\n\t\t\treconCtrlPtr->headSepCBList = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);\n\t\t\trf_FreeCallbackDesc(p);\n\t\t}\n\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n}"
  },
  {
    "function_name": "rf_ReconWriteDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1278-1293",
    "snippet": "int \nrf_ReconWriteDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_ReconBuffer_t *rbuf = (RF_ReconBuffer_t *) arg;\n\n\tDprintf2(\"Reconstruction completed on psid %ld ru %d\\n\", rbuf->parityStripeID, rbuf->which_ru);\n\tif (status) {\n\t\tprintf(\"Recon write failed!\\n\");\t/* fprintf(stderr,\"Recon\n\t\t\t\t\t\t\t * write failed!\\n\"); */\n\t\tRF_PANIC();\n\t}\n\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, arg, RF_REVENT_WRITEDONE);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ReconWriteDoneProc(void *, int);",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "(RF_Raid_t *) rbuf->raidPtr",
            "rbuf->row",
            "rbuf->col",
            "arg",
            "RF_REVENT_WRITEDONE"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Recon write failed!\\n\""
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"Reconstruction completed on psid %ld ru %d\\n\"",
            "rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ReconWriteDoneProc(void *, int);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ReconWriteDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_ReconBuffer_t *rbuf = (RF_ReconBuffer_t *) arg;\n\n\tDprintf2(\"Reconstruction completed on psid %ld ru %d\\n\", rbuf->parityStripeID, rbuf->which_ru);\n\tif (status) {\n\t\tprintf(\"Recon write failed!\\n\");\t/* fprintf(stderr,\"Recon\n\t\t\t\t\t\t\t * write failed!\\n\"); */\n\t\tRF_PANIC();\n\t}\n\trf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, arg, RF_REVENT_WRITEDONE);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ReconReadDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1249-1272",
    "snippet": "int \nrf_ReconReadDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = (RF_PerDiskReconCtrl_t *) arg;\n\tRF_Raid_t *raidPtr = ctrl->reconCtrl->reconDesc->raidPtr;\n\n\tif (status) {\n\t\t/*\n\t         * XXX\n\t         */\n\t\tprintf(\"Recon read failed!\\n\");\n\t\tRF_PANIC();\n\t}\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\traidPtr->recon_tracerecs[ctrl->col].specific.recon.recon_fetch_to_return_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\n\trf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL, RF_REVENT_READDONE);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ReconReadDoneProc(void *, int);",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "ctrl->row",
            "ctrl->col",
            "NULL",
            "RF_REVENT_READDONE"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "raidPtr->recon_tracerecs[ctrl->col].recon_timer"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "raidPtr->recon_tracerecs[ctrl->col].recon_timer"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "raidPtr->recon_tracerecs[ctrl->col].recon_timer"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "raidPtr->recon_tracerecs[ctrl->col].recon_timer"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Recon read failed!\\n\""
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ReconReadDoneProc(void *, int);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ReconReadDoneProc(arg, status)\n\tvoid   *arg;\n\tint     status;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = (RF_PerDiskReconCtrl_t *) arg;\n\tRF_Raid_t *raidPtr = ctrl->reconCtrl->reconDesc->raidPtr;\n\n\tif (status) {\n\t\t/*\n\t         * XXX\n\t         */\n\t\tprintf(\"Recon read failed!\\n\");\n\t\tRF_PANIC();\n\t}\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\traidPtr->recon_tracerecs[ctrl->col].specific.recon.recon_fetch_to_return_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[ctrl->col].recon_timer);\n\n\trf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL, RF_REVENT_READDONE);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_IssueNextWriteRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1198-1239",
    "snippet": "int \nrf_IssueNextWriteRequest(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_DiskQueueData_t *req;\n\n\trbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);\n\tRF_ASSERT(rbuf);\t/* there must be one available, or we wouldn't\n\t\t\t\t * have gotten the event that sent us here */\n\tRF_ASSERT(rbuf->pssPtr);\n\n\trbuf->pssPtr->writeRbuf = rbuf;\n\trbuf->pssPtr = NULL;\n\n\tDprintf7(\"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\\n\",\n\t    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,\n\t    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);\n\tDprintf6(\"RECON: new write psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t    rbuf->parityStripeID, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\n\t/* should be ok to use a NULL b_proc here b/c all addrs should be in\n\t * kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset,\n\t    sectorsPerRU, rbuf->buffer,\n\t    rbuf->parityStripeID, rbuf->which_ru,\n\t    rf_ReconWriteDoneProc, (void *) rbuf, NULL,\n\t    &raidPtr->recon_tracerecs[fcol],\n\t    (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\trbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ReconWriteDoneProc(void *, int);",
      "int rf_IssueNextWriteRequest",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&raidPtr->Queues[rbuf->spRow][rbuf->spCol]",
            "req",
            "RF_IO_RECON_PRIORITY"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_WRITE",
            "rbuf->spOffset",
            "sectorsPerRU",
            "rbuf->buffer",
            "rbuf->parityStripeID",
            "rbuf->which_ru",
            "rf_ReconWriteDoneProc",
            "(void *) rbuf",
            "NULL",
            "&raidPtr->recon_tracerecs[fcol]",
            "(void *) raidPtr",
            "0",
            "NULL"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf6",
          "args": [
            "\"RECON: new write psid %ld   %02x %02x %02x %02x %02x\\n\"",
            "rbuf->parityStripeID",
            "rbuf->buffer[0] & 0xff",
            "rbuf->buffer[1] & 0xff",
            "rbuf->buffer[2] & 0xff",
            "rbuf->buffer[3] & 0xff",
            "rbuf->buffer[4] & 0xff"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf7",
          "args": [
            "\"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\\n\"",
            "rbuf->spRow",
            "rbuf->spCol",
            "rbuf->spOffset",
            "rbuf->parityStripeID",
            "rbuf->which_ru",
            "rbuf->failedDiskSectorOffset",
            "rbuf->buffer"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rbuf->pssPtr"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "rbuf"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_GetFullReconBuffer",
          "args": [
            "raidPtr->reconControl[row]"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ReconWriteDoneProc(void *, int);\nint rf_IssueNextWriteRequest;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\n\nint \nrf_IssueNextWriteRequest(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_DiskQueueData_t *req;\n\n\trbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);\n\tRF_ASSERT(rbuf);\t/* there must be one available, or we wouldn't\n\t\t\t\t * have gotten the event that sent us here */\n\tRF_ASSERT(rbuf->pssPtr);\n\n\trbuf->pssPtr->writeRbuf = rbuf;\n\trbuf->pssPtr = NULL;\n\n\tDprintf7(\"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\\n\",\n\t    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,\n\t    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);\n\tDprintf6(\"RECON: new write psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t    rbuf->parityStripeID, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\n\t/* should be ok to use a NULL b_proc here b/c all addrs should be in\n\t * kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset,\n\t    sectorsPerRU, rbuf->buffer,\n\t    rbuf->parityStripeID, rbuf->which_ru,\n\t    rf_ReconWriteDoneProc, (void *) rbuf, NULL,\n\t    &raidPtr->recon_tracerecs[fcol],\n\t    (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\trbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ComputePSDiskOffsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "1085-1196",
    "snippet": "int \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ComputePSDiskOffsets",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\"",
            "psid",
            "row",
            "col"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapSector",
          "args": [
            "raidPtr",
            "sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit",
            "spRow",
            "spCol",
            "spOffset",
            "RF_REMAP"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapParity",
          "args": [
            "raidPtr",
            "sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit",
            "spRow",
            "spCol",
            "spOffset",
            "RF_REMAP"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "row == testrow && fcol == testcol"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapSector",
          "args": [
            "raidPtr",
            "sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit",
            "&testrow",
            "&testcol",
            "outFailedDiskSectorOffset",
            "RF_DONT_REMAP"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapParity",
          "args": [
            "raidPtr",
            "sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit",
            "&testrow",
            "&testcol",
            "outFailedDiskSectorOffset",
            "RF_DONT_REMAP"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "row == testrow && col == testcol"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapSector",
          "args": [
            "raidPtr",
            "sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit",
            "&testrow",
            "&testcol",
            "outDiskOffset",
            "RF_DONT_REMAP"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutPtr->map->MapParity",
          "args": [
            "raidPtr",
            "sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit",
            "&testrow",
            "&testcol",
            "outDiskOffset",
            "RF_DONT_REMAP"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "k < stripeWidth"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "sosRaidAddress",
            "&prow",
            "&pcol",
            "&poffset",
            "RF_DONT_REMAP"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "diskids"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "sosRaidAddress",
            "&diskids",
            "&stripe"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ParityStripeIDToRaidAddress",
          "args": [
            "layoutPtr",
            "psid"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}"
  },
  {
    "function_name": "rf_TryToRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "988-1058",
    "snippet": "int \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_TryToRead",
      "int rf_ReconReadDoneProc(void *, int);",
      "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
      "int rf_CheckForcedOrBlockedReconstruction",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&raidPtr->Queues[row][col]",
            "req",
            "RF_IO_RECON_PRIORITY"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_READ",
            "ctrl->diskOffset",
            "sectorsPerRU",
            "ctrl->rbuf->buffer",
            "psid",
            "which_ru",
            "rf_ReconReadDoneProc",
            "(void *) ctrl",
            "NULL",
            "&raidPtr->recon_tracerecs[col]",
            "(void *) raidPtr",
            "0",
            "NULL"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "raidPtr->recon_tracerecs[col].recon_timer"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "raidPtr->recon_tracerecs[col].recon_timer"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "raidPtr->recon_tracerecs[col].recon_timer"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "raidPtr->recon_tracerecs[col].recon_timer"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf5",
          "args": [
            "\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\"",
            "psid",
            "row",
            "col",
            "ctrl->diskOffset",
            "ctrl->rbuf->buffer"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CauseReconEvent",
          "args": [
            "raidPtr",
            "row",
            "col",
            "NULL",
            "RF_REVENT_SKIP"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CauseReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "169-194",
          "snippet": "void \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);",
            "RF_RowCol_t row;",
            "static RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;",
            "RF_RowCol_t col;",
            "void   *arg;",
            "RF_Revent_t type;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_ReconEvent_t *\nGetReconEventDesc(RF_RowCol_t row, RF_RowCol_t col,\n    void *arg, RF_Revent_t type);\nRF_RowCol_t row;\nstatic RF_ReconEvent_t *\nGetReconEventDesc(row, col, arg, type)\n\tRF_RowCol_t row;\nRF_RowCol_t col;\nvoid   *arg;\nRF_Revent_t type;\n\nvoid \nrf_CauseReconEvent(raidPtr, row, col, arg, type)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n\tvoid   *arg;\n\tRF_Revent_t type;\n{\n\tRF_ReconCtrl_t *rctrl = raidPtr->reconControl[row];\n\tRF_ReconEvent_t *event = GetReconEventDesc(row, col, arg, type);\n\n\tif (type == RF_REVENT_BUFCLEAR) {\n\t\tRF_ASSERT(col != rctrl->fcol);\n\t}\n\tRF_ASSERT(row >= 0 && row <= raidPtr->numRow && col >= 0 && col <= raidPtr->numCol);\n\tRF_LOCK_MUTEX(rctrl->eq_mutex);\n\tRF_ASSERT((rctrl->eventQueue == NULL) == (rctrl->eq_count == 0));\t/* q null and count==0\n\t\t\t\t\t\t\t\t\t\t * must be equivalent\n\t\t\t\t\t\t\t\t\t\t * conditions */\n\tevent->next = rctrl->eventQueue;\n\trctrl->eventQueue = event;\n\trctrl->eq_count++;\n\tRF_UNLOCK_MUTEX(rctrl->eq_mutex);\n\n\tDO_SIGNAL(rctrl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_PSStatusDelete",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[row]->pssTable",
            "pssPtr"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PSStatusDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "224-247",
          "snippet": "void \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_PSStatusDelete(raidPtr, pssTable, pssPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n{\n\tRF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);\n\tRF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;\n\n\twhile (p) {\n\t\tif (p == pssPtr) {\n\t\t\tif (pt)\n\t\t\t\tpt->next = p->next;\n\t\t\telse\n\t\t\t\thdr->chain = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_FreePSStatus(raidPtr, p);\n\t\t\treturn;\n\t\t}\n\t\tpt = p;\n\t\tp = p->next;\n\t}\n\tRF_ASSERT(0);\t\t/* we must find it here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\"",
            "psid",
            "which_ru"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[row]->reconMap",
            "ctrl->rbuf->failedDiskSectorOffset"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: Stalling psid %ld ru %d: recon blocked\\n\"",
            "psid",
            "which_ru"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckForcedOrBlockedReconstruction",
          "args": [
            "raidPtr",
            "pssPtr",
            "ctrl",
            "row",
            "col",
            "psid",
            "which_ru"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckForcedOrBlockedReconstruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1418-1450",
          "snippet": "int \nrf_CheckForcedOrBlockedReconstruction(\n    RF_Raid_t * raidPtr,\n    RF_ReconParityStripeStatus_t * pssPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_StripeNum_t psid,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_CallbackDesc_t *cb;\n\tint     retcode = 0;\n\n\tif ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))\n\t\tretcode = RF_PSS_FORCED_ON_WRITE;\n\telse\n\t\tif (pssPtr->flags & RF_PSS_RECON_BLOCKED) {\n\t\t\tDprintf4(\"RECON: row %d col %d blocked at psid %ld ru %d\\n\", row, col, psid, which_ru);\n\t\t\tcb = rf_AllocCallbackDesc();\t/* append ourselves to\n\t\t\t\t\t\t\t * the blockage-wait\n\t\t\t\t\t\t\t * list */\n\t\t\tcb->row = row;\n\t\t\tcb->col = col;\n\t\t\tcb->next = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb;\n\t\t\tretcode = RF_PSS_RECON_BLOCKED;\n\t\t}\n\tif (!retcode)\n\t\tpssPtr->flags |= RF_PSS_UNDER_RECON;\t/* mark this RU as under\n\t\t\t\t\t\t\t * reconstruction */\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
            "int rf_CheckForcedOrBlockedReconstruction",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nint rf_CheckForcedOrBlockedReconstruction;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_CheckForcedOrBlockedReconstruction(\n    RF_Raid_t * raidPtr,\n    RF_ReconParityStripeStatus_t * pssPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_StripeNum_t psid,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_CallbackDesc_t *cb;\n\tint     retcode = 0;\n\n\tif ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))\n\t\tretcode = RF_PSS_FORCED_ON_WRITE;\n\telse\n\t\tif (pssPtr->flags & RF_PSS_RECON_BLOCKED) {\n\t\t\tDprintf4(\"RECON: row %d col %d blocked at psid %ld ru %d\\n\", row, col, psid, which_ru);\n\t\t\tcb = rf_AllocCallbackDesc();\t/* append ourselves to\n\t\t\t\t\t\t\t * the blockage-wait\n\t\t\t\t\t\t\t * list */\n\t\t\tcb->row = row;\n\t\t\tcb->col = col;\n\t\t\tcb->next = pssPtr->blockWaitList;\n\t\t\tpssPtr->blockWaitList = cb;\n\t\t\tretcode = RF_PSS_RECON_BLOCKED;\n\t\t}\n\tif (!retcode)\n\t\tpssPtr->flags |= RF_PSS_UNDER_RECON;\t/* mark this RU as under\n\t\t\t\t\t\t\t * reconstruction */\n\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_LookupRUStatus",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[row]->pssTable",
            "psid",
            "which_ru",
            "RF_PSS_CREATE",
            "&created"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "rf_LookupRUStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "170-218",
          "snippet": "RF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nRF_ReconParityStripeStatus_t *\nrf_LookupRUStatus(\n    RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable,\n    RF_StripeNum_t psID,\n    RF_ReconUnitNum_t which_ru,\n    RF_PSSFlags_t flags,\t/* whether or not to create it if it doesn't\n\t\t\t\t * exist + what flags to set initially */\n    int *created)\n{\n\tRF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];\n\tRF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;\n\n\t*created = 0;\n\tfor (p = pssPtr; p; p = p->next) {\n\t\tif (p->parityStripeID == psID && p->which_ru == which_ru)\n\t\t\tbreak;\n\t}\n\n\tif (!p && (flags & RF_PSS_CREATE)) {\n\t\tDprintf2(\"PSS: creating pss for psid %ld ru %d\\n\", psID, which_ru);\n\t\tp = rf_AllocPSStatus(raidPtr);\n\t\tp->next = hdr->chain;\n\t\thdr->chain = p;\n\n\t\tp->parityStripeID = psID;\n\t\tp->which_ru = which_ru;\n\t\tp->flags = flags;\n\t\tp->rbuf = NULL;\n\t\tp->writeRbuf = NULL;\n\t\tp->blockCount = 0;\n\t\tp->procWaitList = NULL;\n\t\tp->blockWaitList = NULL;\n\t\tp->bufWaitList = NULL;\n\t\t*created = 1;\n\t} else\n\t\tif (p) {\t/* we didn't create, but we want to specify\n\t\t\t\t * some new status */\n\t\t\tp->flags |= flags;\t/* add in whatever flags we're\n\t\t\t\t\t\t * specifying */\n\t\t}\n\tif (p && (flags & RF_PSS_RECON_BLOCKED)) {\n\t\tp->blockCount++;/* if we're asking to block recon, bump the\n\t\t\t\t * count */\n\t\tDprintf3(\"raid%d: Blocked recon on psid %ld.  count now %d\\n\",\n\t\t\t raidPtr->raidid, psID, p->blockCount);\n\t}\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_PSS_MUTEX",
          "args": [
            "raidPtr",
            "row",
            "psid"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckHeadSeparation",
          "args": [
            "raidPtr",
            "ctrl",
            "row",
            "col",
            "ctrl->headSepCounter",
            "which_ru"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckHeadSeparation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1352-1410",
          "snippet": "int \nrf_CheckHeadSeparation(\n    RF_Raid_t * raidPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_HeadSepLimit_t hsCtr,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb, *p, *pt;\n\tint     retval = 0;\n\n\t/* if we're too far ahead of the slowest disk, stop working on this\n\t * disk until the slower ones catch up.  We do this by scheduling a\n\t * wakeup callback for the time when the slowest disk has caught up.\n\t * We define \"caught up\" with 20% hysteresis, i.e. the head separation\n\t * must have fallen to at most 80% of the max allowable head\n\t * separation before we'll wake up.\n\t * \n\t */\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif ((raidPtr->headSepLimit >= 0) &&\n\t    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit)) {\n\t\tDprintf6(\"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\\n\",\n\t\t\t raidPtr->raidid, row, col, ctrl->headSepCounter, \n\t\t\t reconCtrlPtr->minHeadSepCounter, \n\t\t\t raidPtr->headSepLimit);\n\t\tcb = rf_AllocCallbackDesc();\n\t\t/* the minHeadSepCounter value we have to get to before we'll\n\t\t * wake up.  build in 20% hysteresis. */\n\t\tcb->callbackArg.v = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit / 5);\n\t\tcb->row = row;\n\t\tcb->col = col;\n\t\tcb->next = NULL;\n\n\t\t/* insert this callback descriptor into the sorted list of\n\t\t * pending head-sep callbacks */\n\t\tp = reconCtrlPtr->headSepCBList;\n\t\tif (!p)\n\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\telse\n\t\t\tif (cb->callbackArg.v < p->callbackArg.v) {\n\t\t\t\tcb->next = reconCtrlPtr->headSepCBList;\n\t\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\t\t} else {\n\t\t\t\tfor (pt = p, p = p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt = p, p = p->next);\n\t\t\t\tcb->next = p;\n\t\t\t\tpt->next = cb;\n\t\t\t}\n\t\tretval = 1;\n#if RF_RECON_STATS > 0\n\t\tctrl->reconCtrl->reconDesc->hsStallCount++;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\treturn (retval);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);",
            "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_CheckHeadSeparation(\n    RF_Raid_t * raidPtr,\n    RF_PerDiskReconCtrl_t * ctrl,\n    RF_RowCol_t row,\n    RF_RowCol_t col,\n    RF_HeadSepLimit_t hsCtr,\n    RF_ReconUnitNum_t which_ru)\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb, *p, *pt;\n\tint     retval = 0;\n\n\t/* if we're too far ahead of the slowest disk, stop working on this\n\t * disk until the slower ones catch up.  We do this by scheduling a\n\t * wakeup callback for the time when the slowest disk has caught up.\n\t * We define \"caught up\" with 20% hysteresis, i.e. the head separation\n\t * must have fallen to at most 80% of the max allowable head\n\t * separation before we'll wake up.\n\t * \n\t */\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif ((raidPtr->headSepLimit >= 0) &&\n\t    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit)) {\n\t\tDprintf6(\"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\\n\",\n\t\t\t raidPtr->raidid, row, col, ctrl->headSepCounter, \n\t\t\t reconCtrlPtr->minHeadSepCounter, \n\t\t\t raidPtr->headSepLimit);\n\t\tcb = rf_AllocCallbackDesc();\n\t\t/* the minHeadSepCounter value we have to get to before we'll\n\t\t * wake up.  build in 20% hysteresis. */\n\t\tcb->callbackArg.v = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit / 5);\n\t\tcb->row = row;\n\t\tcb->col = col;\n\t\tcb->next = NULL;\n\n\t\t/* insert this callback descriptor into the sorted list of\n\t\t * pending head-sep callbacks */\n\t\tp = reconCtrlPtr->headSepCBList;\n\t\tif (!p)\n\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\telse\n\t\t\tif (cb->callbackArg.v < p->callbackArg.v) {\n\t\t\t\tcb->next = reconCtrlPtr->headSepCBList;\n\t\t\t\treconCtrlPtr->headSepCBList = cb;\n\t\t\t} else {\n\t\t\t\tfor (pt = p, p = p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt = p, p = p->next);\n\t\t\t\tcb->next = p;\n\t\t\t\tpt->next = cb;\n\t\t\t}\n\t\tretval = 1;\n#if RF_RECON_STATS > 0\n\t\tctrl->reconCtrl->reconDesc->hsStallCount++;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\treturn (retval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_TryToRead;\nint rf_ReconReadDoneProc(void *, int);\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nint rf_CheckForcedOrBlockedReconstruction;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_IssueNextReadRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "910-977",
    "snippet": "int \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_IssueNextReadRequest",
      "int rf_TryToRead",
      "int rf_ComputePSDiskOffsets",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_TryToRead",
          "args": [
            "raidPtr",
            "row",
            "col"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "rf_TryToRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "988-1058",
          "snippet": "int \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_TryToRead",
            "int rf_ReconReadDoneProc(void *, int);",
            "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
            "int rf_CheckForcedOrBlockedReconstruction",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_TryToRead;\nint rf_ReconReadDoneProc(void *, int);\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nint rf_CheckForcedOrBlockedReconstruction;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "raidPtr->recon_tracerecs[col].recon_timer"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &raidPtr->recon_tracerecs[col]",
            "sizeof(raidPtr->recon_tracerecs[col])"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckForNewMinHeadSep",
          "args": [
            "raidPtr",
            "row",
            "ctrl->headSepCounter"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckForNewMinHeadSep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1300-1338",
          "snippet": "void \nrf_CheckForNewMinHeadSep(raidPtr, row, hsCtr)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_HeadSepLimit_t hsCtr;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_HeadSepLimit_t new_min;\n\tRF_RowCol_t i;\n\tRF_CallbackDesc_t *p;\n\tRF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);\t/* from the definition\n\t\t\t\t\t\t\t\t * of a minimum */\n\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tnew_min = ~(1L << (8 * sizeof(long) - 1));\t/* 0x7FFF....FFF */\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (i != reconCtrlPtr->fcol) {\n\t\t\tif (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min)\n\t\t\t\tnew_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;\n\t\t}\n\t/* set the new minimum and wake up anyone who can now run again */\n\tif (new_min != reconCtrlPtr->minHeadSepCounter) {\n\t\treconCtrlPtr->minHeadSepCounter = new_min;\n\t\tDprintf1(\"RECON:  new min head pos counter val is %ld\\n\", new_min);\n\t\twhile (reconCtrlPtr->headSepCBList) {\n\t\t\tif (reconCtrlPtr->headSepCBList->callbackArg.v > new_min)\n\t\t\t\tbreak;\n\t\t\tp = reconCtrlPtr->headSepCBList;\n\t\t\treconCtrlPtr->headSepCBList = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);\n\t\t\trf_FreeCallbackDesc(p);\n\t\t}\n\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nvoid \nrf_CheckForNewMinHeadSep(raidPtr, row, hsCtr)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_HeadSepLimit_t hsCtr;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_HeadSepLimit_t new_min;\n\tRF_RowCol_t i;\n\tRF_CallbackDesc_t *p;\n\tRF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);\t/* from the definition\n\t\t\t\t\t\t\t\t * of a minimum */\n\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tnew_min = ~(1L << (8 * sizeof(long) - 1));\t/* 0x7FFF....FFF */\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (i != reconCtrlPtr->fcol) {\n\t\t\tif (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min)\n\t\t\t\tnew_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;\n\t\t}\n\t/* set the new minimum and wake up anyone who can now run again */\n\tif (new_min != reconCtrlPtr->minHeadSepCounter) {\n\t\treconCtrlPtr->minHeadSepCounter = new_min;\n\t\tDprintf1(\"RECON:  new min head pos counter val is %ld\\n\", new_min);\n\t\twhile (reconCtrlPtr->headSepCBList) {\n\t\t\tif (reconCtrlPtr->headSepCBList->callbackArg.v > new_min)\n\t\t\t\tbreak;\n\t\t\tp = reconCtrlPtr->headSepCBList;\n\t\t\treconCtrlPtr->headSepCBList = p->next;\n\t\t\tp->next = NULL;\n\t\t\trf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);\n\t\t\trf_FreeCallbackDesc(p);\n\t\t}\n\n\t}\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"Skipping psid %ld ru %d: already reconstructed\\n\"",
            "ctrl->curPSID",
            "ctrl->ru_count"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[row]->reconMap",
            "rbuf->failedDiskSectorOffset"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ComputePSDiskOffsets",
          "args": [
            "raidPtr",
            "ctrl->curPSID",
            "row",
            "col",
            "&ctrl->diskOffset",
            "&rbuf->failedDiskSectorOffset",
            "&rbuf->spRow",
            "&rbuf->spCol",
            "&rbuf->spOffset"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ComputePSDiskOffsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1085-1196",
          "snippet": "int \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ComputePSDiskOffsets",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ComputePSDiskOffsets(\n    RF_Raid_t * raidPtr,\t/* raid descriptor */\n    RF_StripeNum_t psid,\t/* parity stripe identifier */\n    RF_RowCol_t row,\t\t/* row and column of disk to find the offsets\n\t\t\t\t * for */\n    RF_RowCol_t col,\n    RF_SectorNum_t * outDiskOffset,\n    RF_SectorNum_t * outFailedDiskSectorOffset,\n    RF_RowCol_t * spRow,\t/* OUT: row,col of spare unit for failed unit */\n    RF_RowCol_t * spCol,\n    RF_SectorNum_t * spOffset)\n{\t\t\t\t/* OUT: offset into disk containing spare unit */\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_RaidAddr_t sosRaidAddress;\t/* start-of-stripe */\n\tRF_RowCol_t *diskids;\n\tu_int   i, j, k, i_offset, j_offset;\n\tRF_RowCol_t prow, pcol;\n\tint     testcol, testrow;\n\tRF_RowCol_t stripe;\n\tRF_SectorNum_t poffset;\n\tchar    i_is_parity = 0, j_is_parity = 0;\n\tRF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\n\t/* get a listing of the disks comprising that stripe */\n\tsosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);\n\tRF_ASSERT(diskids);\n\n\t/* reject this entire parity stripe if it does not contain the\n\t * indicated disk or it does not contain the failed disk */\n\tif (row != stripe)\n\t\tgoto skipit;\n\tfor (i = 0; i < stripeWidth; i++) {\n\t\tif (col == diskids[i])\n\t\t\tbreak;\n\t}\n\tif (i == stripeWidth)\n\t\tgoto skipit;\n\tfor (j = 0; j < stripeWidth; j++) {\n\t\tif (fcol == diskids[j])\n\t\t\tbreak;\n\t}\n\tif (j == stripeWidth) {\n\t\tgoto skipit;\n\t}\n\t/* find out which disk the parity is on */\n\t(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);\n\n\t/* find out if either the current RU or the failed RU is parity */\n\t/* also, if the parity occurs in this stripe prior to the data and/or\n\t * failed col, we need to decrement i and/or j */\n\tfor (k = 0; k < stripeWidth; k++)\n\t\tif (diskids[k] == pcol)\n\t\t\tbreak;\n\tRF_ASSERT(k < stripeWidth);\n\ti_offset = i;\n\tj_offset = j;\n\tif (k < i)\n\t\ti_offset--;\n\telse\n\t\tif (k == i) {\n\t\t\ti_is_parity = 1;\n\t\t\ti_offset = 0;\n\t\t}\t\t/* set offsets to zero to disable multiply\n\t\t\t\t * below */\n\tif (k < j)\n\t\tj_offset--;\n\telse\n\t\tif (k == j) {\n\t\t\tj_is_parity = 1;\n\t\t\tj_offset = 0;\n\t\t}\n\t/* at this point, [ij]_is_parity tells us whether the [current,failed]\n\t * disk is parity at the start of this RU, and, if data, \"[ij]_offset\"\n\t * tells us how far into the stripe the [current,failed] disk is. */\n\n\t/* call the mapping routine to get the offset into the current disk,\n\t * repeat for failed disk. */\n\tif (i_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);\n\n\tRF_ASSERT(row == testrow && col == testcol);\n\n\tif (j_is_parity)\n\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\telse\n\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);\n\tRF_ASSERT(row == testrow && fcol == testcol);\n\n\t/* now locate the spare unit for the failed unit */\n\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (j_is_parity)\n\t\t\tlayoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t\telse\n\t\t\tlayoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);\n\t} else {\n\t\t*spRow = raidPtr->reconControl[row]->spareRow;\n\t\t*spCol = raidPtr->reconControl[row]->spareCol;\n\t\t*spOffset = *outFailedDiskSectorOffset;\n\t}\n\n\treturn (0);\n\nskipit:\n\tDprintf3(\"RECON: Skipping psid %ld: nothing needed from r%d c%d\\n\",\n\t    psid, row, col);\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_IssueNextReadRequest;\nint rf_TryToRead;\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_ProcessReconEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "779-887",
    "snippet": "int \nrf_ProcessReconEvent(raidPtr, frow, event)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t frow;\n\tRF_ReconEvent_t *event;\n{\n\tint     retcode = 0, submitblocked;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_SectorCount_t sectorsPerRU;\n\n\tDprintf1(\"RECON: rf_ProcessReconEvent type %d\\n\", event->type);\n\tswitch (event->type) {\n\n\t\t/* a read I/O has completed */\n\tcase RF_REVENT_READDONE:\n\t\trbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;\n\t\tDprintf3(\"RECON: READDONE EVENT: row %d col %d psid %ld\\n\",\n\t\t    frow, event->col, rbuf->parityStripeID);\n\t\tDprintf7(\"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\\n\",\n\t\t    rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 0, 0);\n\t\tDprintf1(\"RECON: submitblocked=%d\\n\", submitblocked);\n\t\tif (!submitblocked)\n\t\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a write I/O has completed */\n\tcase RF_REVENT_WRITEDONE:\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tsectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDprintf3(\"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\\n\",\n\t\t    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);\n\t\trf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,\n\t\t    rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU - 1);\n\t\trf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);\n\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING) {\n\t\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t\traidPtr->numFullReconBuffers--;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t} else\n\t\t\tif (rbuf->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t\tbreak;\n\n\tcase RF_REVENT_BUFCLEAR:\t/* A buffer-stall condition has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: BUFCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long) event->arg);\n\t\tRF_ASSERT(!submitblocked);\t/* we wouldn't have gotten the\n\t\t\t\t\t\t * BUFCLEAR event if we\n\t\t\t\t\t\t * couldn't submit */\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_BLOCKCLEAR:\t/* A user-write reconstruction\n\t\t\t\t\t * blockage has been cleared */\n\t\tDDprintf2(\"RECON: BLOCKCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_HEADSEPCLEAR:\t/* A max-head-separation\n\t\t\t\t\t * reconstruction blockage has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: HEADSEPCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a buffer has become ready to write */\n\tcase RF_REVENT_BUFREADY:\n\t\tDprintf2(\"RECON: BUFREADY EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextWriteRequest(raidPtr, frow);\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tbreak;\n\n\t\t/* we need to skip the current RU entirely because it got\n\t\t * recon'd while we were waiting for something else to happen */\n\tcase RF_REVENT_SKIP:\n\t\tDDprintf2(\"RECON: SKIP EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a forced-reconstruction read access has completed.  Just\n\t\t * submit the buffer */\n\tcase RF_REVENT_FORCEDREADDONE:\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDDprintf2(\"RECON: FORCEDREADDONE EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);\n\t\tRF_ASSERT(!submitblocked);\n\t\tbreak;\n\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\trf_FreeReconEventDesc(event);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ProcessReconEvent",
      "int rf_IssueNextReadRequest",
      "int rf_TryToRead",
      "int rf_IssueNextWriteRequest",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeReconEventDesc",
          "args": [
            "event"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconEventDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_revent.c",
          "lines": "214-219",
          "snippet": "void \nrf_FreeReconEventDesc(event)\n\tRF_ReconEvent_t *event;\n{\n\tRF_FREELIST_FREE(rf_revent_freelist, event, next);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_revent_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_desc.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_revent.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n\nstatic RF_FreeList_t *rf_revent_freelist;\n\nvoid \nrf_FreeReconEventDesc(event)\n\tRF_ReconEvent_t *event;\n{\n\tRF_FREELIST_FREE(rf_revent_freelist, event, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!submitblocked"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_SubmitReconBuffer",
          "args": [
            "rbuf",
            "1",
            "0"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SubmitReconBufferRAID1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid1.c",
          "lines": "541-688",
          "snippet": "int \nrf_SubmitReconBufferRAID1(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconCtrl_t *reconCtrlPtr;\n\tRF_RaidLayout_t *layoutPtr;\n\tint     retcode, created;\n\tRF_CallbackDesc_t *cb, *p;\n\tRF_ReconBuffer_t *t;\n\tRF_Raid_t *raidPtr;\n\tcaddr_t ta;\n\n\tretcode = 0;\n\tcreated = 0;\n\n\traidPtr = rbuf->raidPtr;\n\tlayoutPtr = &raidPtr->Layout;\n\treconCtrlPtr = raidPtr->reconControl[rbuf->row];\n\n\tRF_ASSERT(rbuf);\n\tRF_ASSERT(rbuf->col != reconCtrlPtr->fcol);\n\n\tif (rf_reconbufferDebug) {\n\t\tprintf(\"raid%d: RAID1 reconbuffer submission r%d c%d psid %ld ru%d (failed offset %ld)\\n\",\n\t\t       raidPtr->raidid, rbuf->row, rbuf->col, \n\t\t       (long) rbuf->parityStripeID, rbuf->which_ru,\n\t\t    (long) rbuf->failedDiskSectorOffset);\n\t}\n\tif (rf_reconDebug) {\n\t\tprintf(\"RAID1 reconbuffer submit psid %ld buf %lx\\n\",\n\t\t    (long) rbuf->parityStripeID, (long) rbuf->buffer);\n\t\tprintf(\"RAID1 psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t\t    (long) rbuf->parityStripeID,\n\t\t    rbuf->buffer[0], rbuf->buffer[1], rbuf->buffer[2], rbuf->buffer[3],\n\t\t    rbuf->buffer[4]);\n\t}\n\tRF_LOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable,\n\t    rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);\n\tRF_ASSERT(pssPtr);\t/* if it didn't exist, we wouldn't have gotten\n\t\t\t\t * an rbuf for it */\n\n\t/*\n         * Since this is simple mirroring, the first submission for a stripe is also\n         * treated as the last.\n         */\n\n\tt = NULL;\n\tif (keep_it) {\n\t\tif (rf_reconbufferDebug) {\n\t\t\tprintf(\"raid%d: RAID1 rbuf submission: keeping rbuf\\n\", \n\t\t\t       raidPtr->raidid);\n\t\t}\n\t\tt = rbuf;\n\t} else {\n\t\tif (use_committed) {\n\t\t\tif (rf_reconbufferDebug) {\n\t\t\t\tprintf(\"raid%d: RAID1 rbuf submission: using committed rbuf\\n\", raidPtr->raidid);\n\t\t\t}\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\tt->next = NULL;\n\t\t} else\n\t\t\tif (reconCtrlPtr->floatingRbufs) {\n\t\t\t\tif (rf_reconbufferDebug) {\n\t\t\t\t\tprintf(\"raid%d: RAID1 rbuf submission: using floating rbuf\\n\", raidPtr->raidid);\n\t\t\t\t}\n\t\t\t\tt = reconCtrlPtr->floatingRbufs;\n\t\t\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\t\t\tt->next = NULL;\n\t\t\t}\n\t}\n\tif (t == NULL) {\n\t\tif (rf_reconbufferDebug) {\n\t\t\tprintf(\"raid%d: RAID1 rbuf submission: waiting for rbuf\\n\", raidPtr->raidid);\n\t\t}\n\t\tRF_ASSERT((keep_it == 0) && (use_committed == 0));\n\t\traidPtr->procsInBufWait++;\n\t\tif ((raidPtr->procsInBufWait == (raidPtr->numCol - 1))\n\t\t    && (raidPtr->numFullReconBuffers == 0)) {\n\t\t\t/* ruh-ro */\n\t\t\tRF_ERRORMSG(\"Buffer wait deadlock\\n\");\n\t\t\trf_PrintPSStatusTable(raidPtr, rbuf->row);\n\t\t\tRF_PANIC();\n\t\t}\n\t\tpssPtr->flags |= RF_PSS_BUFFERWAIT;\n\t\tcb = rf_AllocCallbackDesc();\n\t\tcb->row = rbuf->row;\n\t\tcb->col = rbuf->col;\n\t\tcb->callbackArg.v = rbuf->parityStripeID;\n\t\tcb->callbackArg2.v = rbuf->which_ru;\n\t\tcb->next = NULL;\n\t\tif (reconCtrlPtr->bufferWaitList == NULL) {\n\t\t\t/* we are the wait list- lucky us */\n\t\t\treconCtrlPtr->bufferWaitList = cb;\n\t\t} else {\n\t\t\t/* append to wait list */\n\t\t\tfor (p = reconCtrlPtr->bufferWaitList; p->next; p = p->next);\n\t\t\tp->next = cb;\n\t\t}\n\t\tretcode = 1;\n\t\tgoto out;\n\t}\n\tif (t != rbuf) {\n\t\tt->row = rbuf->row;\n\t\tt->col = reconCtrlPtr->fcol;\n\t\tt->parityStripeID = rbuf->parityStripeID;\n\t\tt->which_ru = rbuf->which_ru;\n\t\tt->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;\n\t\tt->spRow = rbuf->spRow;\n\t\tt->spCol = rbuf->spCol;\n\t\tt->spOffset = rbuf->spOffset;\n\t\t/* Swap buffers. DANCE! */\n\t\tta = t->buffer;\n\t\tt->buffer = rbuf->buffer;\n\t\trbuf->buffer = ta;\n\t}\n\t/*\n         * Use the rbuf we've been given as the target.\n         */\n\tRF_ASSERT(pssPtr->rbuf == NULL);\n\tpssPtr->rbuf = t;\n\n\tt->count = 1;\n\t/*\n         * Below, we use 1 for numDataCol (which is equal to the count in the\n         * previous line), so we'll always be done.\n         */\n\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, 1);\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif (rf_reconbufferDebug) {\n\t\tprintf(\"raid%d: RAID1 rbuf submission: returning %d\\n\", \n\t\t       raidPtr->raidid, retcode);\n\t}\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid1.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_reconbuffer.h\"\n#include \"rf_engine.h\"\n#include \"rf_map.h\"\n#include \"rf_layout.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid1.h\"\n#include \"rf_raid.h\"\n\nint \nrf_SubmitReconBufferRAID1(rbuf, keep_it, use_committed)\n\tRF_ReconBuffer_t *rbuf;\t/* the recon buffer to submit */\n\tint     keep_it;\t/* whether we can keep this buffer or we have\n\t\t\t\t * to return it */\n\tint     use_committed;\t/* whether to use a committed or an available\n\t\t\t\t * recon buffer */\n{\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\tRF_ReconCtrl_t *reconCtrlPtr;\n\tRF_RaidLayout_t *layoutPtr;\n\tint     retcode, created;\n\tRF_CallbackDesc_t *cb, *p;\n\tRF_ReconBuffer_t *t;\n\tRF_Raid_t *raidPtr;\n\tcaddr_t ta;\n\n\tretcode = 0;\n\tcreated = 0;\n\n\traidPtr = rbuf->raidPtr;\n\tlayoutPtr = &raidPtr->Layout;\n\treconCtrlPtr = raidPtr->reconControl[rbuf->row];\n\n\tRF_ASSERT(rbuf);\n\tRF_ASSERT(rbuf->col != reconCtrlPtr->fcol);\n\n\tif (rf_reconbufferDebug) {\n\t\tprintf(\"raid%d: RAID1 reconbuffer submission r%d c%d psid %ld ru%d (failed offset %ld)\\n\",\n\t\t       raidPtr->raidid, rbuf->row, rbuf->col, \n\t\t       (long) rbuf->parityStripeID, rbuf->which_ru,\n\t\t    (long) rbuf->failedDiskSectorOffset);\n\t}\n\tif (rf_reconDebug) {\n\t\tprintf(\"RAID1 reconbuffer submit psid %ld buf %lx\\n\",\n\t\t    (long) rbuf->parityStripeID, (long) rbuf->buffer);\n\t\tprintf(\"RAID1 psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t\t    (long) rbuf->parityStripeID,\n\t\t    rbuf->buffer[0], rbuf->buffer[1], rbuf->buffer[2], rbuf->buffer[3],\n\t\t    rbuf->buffer[4]);\n\t}\n\tRF_LOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\n\tRF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\n\tpssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable,\n\t    rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);\n\tRF_ASSERT(pssPtr);\t/* if it didn't exist, we wouldn't have gotten\n\t\t\t\t * an rbuf for it */\n\n\t/*\n         * Since this is simple mirroring, the first submission for a stripe is also\n         * treated as the last.\n         */\n\n\tt = NULL;\n\tif (keep_it) {\n\t\tif (rf_reconbufferDebug) {\n\t\t\tprintf(\"raid%d: RAID1 rbuf submission: keeping rbuf\\n\", \n\t\t\t       raidPtr->raidid);\n\t\t}\n\t\tt = rbuf;\n\t} else {\n\t\tif (use_committed) {\n\t\t\tif (rf_reconbufferDebug) {\n\t\t\t\tprintf(\"raid%d: RAID1 rbuf submission: using committed rbuf\\n\", raidPtr->raidid);\n\t\t\t}\n\t\t\tt = reconCtrlPtr->committedRbufs;\n\t\t\tRF_ASSERT(t);\n\t\t\treconCtrlPtr->committedRbufs = t->next;\n\t\t\tt->next = NULL;\n\t\t} else\n\t\t\tif (reconCtrlPtr->floatingRbufs) {\n\t\t\t\tif (rf_reconbufferDebug) {\n\t\t\t\t\tprintf(\"raid%d: RAID1 rbuf submission: using floating rbuf\\n\", raidPtr->raidid);\n\t\t\t\t}\n\t\t\t\tt = reconCtrlPtr->floatingRbufs;\n\t\t\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\t\t\tt->next = NULL;\n\t\t\t}\n\t}\n\tif (t == NULL) {\n\t\tif (rf_reconbufferDebug) {\n\t\t\tprintf(\"raid%d: RAID1 rbuf submission: waiting for rbuf\\n\", raidPtr->raidid);\n\t\t}\n\t\tRF_ASSERT((keep_it == 0) && (use_committed == 0));\n\t\traidPtr->procsInBufWait++;\n\t\tif ((raidPtr->procsInBufWait == (raidPtr->numCol - 1))\n\t\t    && (raidPtr->numFullReconBuffers == 0)) {\n\t\t\t/* ruh-ro */\n\t\t\tRF_ERRORMSG(\"Buffer wait deadlock\\n\");\n\t\t\trf_PrintPSStatusTable(raidPtr, rbuf->row);\n\t\t\tRF_PANIC();\n\t\t}\n\t\tpssPtr->flags |= RF_PSS_BUFFERWAIT;\n\t\tcb = rf_AllocCallbackDesc();\n\t\tcb->row = rbuf->row;\n\t\tcb->col = rbuf->col;\n\t\tcb->callbackArg.v = rbuf->parityStripeID;\n\t\tcb->callbackArg2.v = rbuf->which_ru;\n\t\tcb->next = NULL;\n\t\tif (reconCtrlPtr->bufferWaitList == NULL) {\n\t\t\t/* we are the wait list- lucky us */\n\t\t\treconCtrlPtr->bufferWaitList = cb;\n\t\t} else {\n\t\t\t/* append to wait list */\n\t\t\tfor (p = reconCtrlPtr->bufferWaitList; p->next; p = p->next);\n\t\t\tp->next = cb;\n\t\t}\n\t\tretcode = 1;\n\t\tgoto out;\n\t}\n\tif (t != rbuf) {\n\t\tt->row = rbuf->row;\n\t\tt->col = reconCtrlPtr->fcol;\n\t\tt->parityStripeID = rbuf->parityStripeID;\n\t\tt->which_ru = rbuf->which_ru;\n\t\tt->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;\n\t\tt->spRow = rbuf->spRow;\n\t\tt->spCol = rbuf->spCol;\n\t\tt->spOffset = rbuf->spOffset;\n\t\t/* Swap buffers. DANCE! */\n\t\tta = t->buffer;\n\t\tt->buffer = rbuf->buffer;\n\t\trbuf->buffer = ta;\n\t}\n\t/*\n         * Use the rbuf we've been given as the target.\n         */\n\tRF_ASSERT(pssPtr->rbuf == NULL);\n\tpssPtr->rbuf = t;\n\n\tt->count = 1;\n\t/*\n         * Below, we use 1 for numDataCol (which is equal to the count in the\n         * previous line), so we'll always be done.\n         */\n\trf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, 1);\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);\n\tRF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);\n\tif (rf_reconbufferDebug) {\n\t\tprintf(\"raid%d: RAID1 rbuf submission: returning %d\\n\", \n\t\t       raidPtr->raidid, retcode);\n\t}\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DDprintf2",
          "args": [
            "\"RECON: FORCEDREADDONE EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeDiskQueueData",
          "args": [
            "(RF_DiskQueueData_t *) rbuf->arg"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "596-601",
          "snippet": "void \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nvoid \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_IssueNextReadRequest",
          "args": [
            "raidPtr",
            "frow",
            "event->col"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IssueNextReadRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "910-977",
          "snippet": "int \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_IssueNextReadRequest",
            "int rf_TryToRead",
            "int rf_ComputePSDiskOffsets",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_IssueNextReadRequest;\nint rf_TryToRead;\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DDprintf2",
          "args": [
            "\"RECON: SKIP EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckFloatingRbufCount",
          "args": [
            "raidPtr",
            "1"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckFloatingRbufCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "272-336",
          "snippet": "void \nrf_CheckFloatingRbufCount(raidPtr, dolock)\n\tRF_Raid_t *raidPtr;\n\tint     dolock;\n{\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconBuffer_t *rbuf;\n\tint     i, j, sum = 0;\n\tRF_RowCol_t frow = 0;\n\n\tfor (i = 0; i < raidPtr->numRow; i++)\n\t\tif (raidPtr->reconControl[i]) {\n\t\t\tfrow = i;\n\t\t\tbreak;\n\t\t}\n\tRF_ASSERT(frow >= 0);\n\n\tif (dolock)\n\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\tpssTable = raidPtr->reconControl[frow]->pssTable;\n\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tRF_LOCK_MUTEX(pssTable[i].mutex);\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\trbuf = (RF_ReconBuffer_t *) p->rbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\trbuf = (RF_ReconBuffer_t *) p->writeRbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\tfor (j = 0; j < p->xorBufCount; j++) {\n\t\t\t\trbuf = (RF_ReconBuffer_t *) p->rbufsForXor[j];\n\t\t\t\tRF_ASSERT(rbuf);\n\t\t\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tRF_UNLOCK_MUTEX(pssTable[i].mutex);\n\t}\n\n\tfor (rbuf = raidPtr->reconControl[frow]->floatingRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->committedRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->fullBufferList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->priorityList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\n\tRF_ASSERT(sum == raidPtr->numFloatingReconBufs);\n\n\tif (dolock)\n\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_RowCol_t frow;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_RowCol_t frow;\n\nvoid \nrf_CheckFloatingRbufCount(raidPtr, dolock)\n\tRF_Raid_t *raidPtr;\n\tint     dolock;\n{\n\tRF_ReconParityStripeStatus_t *p;\n\tRF_PSStatusHeader_t *pssTable;\n\tRF_ReconBuffer_t *rbuf;\n\tint     i, j, sum = 0;\n\tRF_RowCol_t frow = 0;\n\n\tfor (i = 0; i < raidPtr->numRow; i++)\n\t\tif (raidPtr->reconControl[i]) {\n\t\t\tfrow = i;\n\t\t\tbreak;\n\t\t}\n\tRF_ASSERT(frow >= 0);\n\n\tif (dolock)\n\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\tpssTable = raidPtr->reconControl[frow]->pssTable;\n\n\tfor (i = 0; i < raidPtr->pssTableSize; i++) {\n\t\tRF_LOCK_MUTEX(pssTable[i].mutex);\n\t\tfor (p = pssTable[i].chain; p; p = p->next) {\n\t\t\trbuf = (RF_ReconBuffer_t *) p->rbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\trbuf = (RF_ReconBuffer_t *) p->writeRbuf;\n\t\t\tif (rbuf && rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\tsum++;\n\n\t\t\tfor (j = 0; j < p->xorBufCount; j++) {\n\t\t\t\trbuf = (RF_ReconBuffer_t *) p->rbufsForXor[j];\n\t\t\t\tRF_ASSERT(rbuf);\n\t\t\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tRF_UNLOCK_MUTEX(pssTable[i].mutex);\n\t}\n\n\tfor (rbuf = raidPtr->reconControl[frow]->floatingRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->committedRbufs; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->fullBufferList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\tfor (rbuf = raidPtr->reconControl[frow]->priorityList; rbuf; rbuf = rbuf->next) {\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING)\n\t\t\tsum++;\n\t}\n\n\tRF_ASSERT(sum == raidPtr->numFloatingReconBufs);\n\n\tif (dolock)\n\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_IssueNextWriteRequest",
          "args": [
            "raidPtr",
            "frow"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IssueNextWriteRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "1198-1239",
          "snippet": "int \nrf_IssueNextWriteRequest(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_DiskQueueData_t *req;\n\n\trbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);\n\tRF_ASSERT(rbuf);\t/* there must be one available, or we wouldn't\n\t\t\t\t * have gotten the event that sent us here */\n\tRF_ASSERT(rbuf->pssPtr);\n\n\trbuf->pssPtr->writeRbuf = rbuf;\n\trbuf->pssPtr = NULL;\n\n\tDprintf7(\"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\\n\",\n\t    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,\n\t    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);\n\tDprintf6(\"RECON: new write psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t    rbuf->parityStripeID, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\n\t/* should be ok to use a NULL b_proc here b/c all addrs should be in\n\t * kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset,\n\t    sectorsPerRU, rbuf->buffer,\n\t    rbuf->parityStripeID, rbuf->which_ru,\n\t    rf_ReconWriteDoneProc, (void *) rbuf, NULL,\n\t    &raidPtr->recon_tracerecs[fcol],\n\t    (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\trbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ReconWriteDoneProc(void *, int);",
            "int rf_IssueNextWriteRequest",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ReconWriteDoneProc(void *, int);\nint rf_IssueNextWriteRequest;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\n\nint \nrf_IssueNextWriteRequest(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tRF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_DiskQueueData_t *req;\n\n\trbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);\n\tRF_ASSERT(rbuf);\t/* there must be one available, or we wouldn't\n\t\t\t\t * have gotten the event that sent us here */\n\tRF_ASSERT(rbuf->pssPtr);\n\n\trbuf->pssPtr->writeRbuf = rbuf;\n\trbuf->pssPtr = NULL;\n\n\tDprintf7(\"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\\n\",\n\t    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,\n\t    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);\n\tDprintf6(\"RECON: new write psid %ld   %02x %02x %02x %02x %02x\\n\",\n\t    rbuf->parityStripeID, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\n\t/* should be ok to use a NULL b_proc here b/c all addrs should be in\n\t * kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset,\n\t    sectorsPerRU, rbuf->buffer,\n\t    rbuf->parityStripeID, rbuf->which_ru,\n\t    rf_ReconWriteDoneProc, (void *) rbuf, NULL,\n\t    &raidPtr->recon_tracerecs[fcol],\n\t    (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\trbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: BUFREADY EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_TryToRead",
          "args": [
            "raidPtr",
            "frow",
            "event->col"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rf_TryToRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "988-1058",
          "snippet": "int \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_TryToRead",
            "int rf_ReconReadDoneProc(void *, int);",
            "int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);",
            "int rf_CheckForcedOrBlockedReconstruction",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_TryToRead;\nint rf_ReconReadDoneProc(void *, int);\nint rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);\nint rf_CheckForcedOrBlockedReconstruction;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_TryToRead(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\tRF_StripeNum_t psid = ctrl->curPSID;\n\tRF_ReconUnitNum_t which_ru = ctrl->ru_count;\n\tRF_DiskQueueData_t *req;\n\tint     status, created = 0;\n\tRF_ReconParityStripeStatus_t *pssPtr;\n\n\t/* if the current disk is too far ahead of the others, issue a\n\t * head-separation wait and return */\n\tif (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))\n\t\treturn (0);\n\tRF_LOCK_PSS_MUTEX(raidPtr, row, psid);\n\tpssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);\n\n\t/* if recon is blocked on the indicated parity stripe, issue a\n\t * block-wait request and return. this also must mark the indicated RU\n\t * in the stripe as under reconstruction if not blocked. */\n\tstatus = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);\n\tif (status == RF_PSS_RECON_BLOCKED) {\n\t\tDprintf2(\"RECON: Stalling psid %ld ru %d: recon blocked\\n\", psid, which_ru);\n\t\tgoto out;\n\t} else\n\t\tif (status == RF_PSS_FORCED_ON_WRITE) {\n\t\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\t\tgoto out;\n\t\t}\n\t/* make one last check to be sure that the indicated RU didn't get\n\t * reconstructed while we were waiting for something else to happen.\n\t * This is unfortunate in that it causes us to make this check twice\n\t * in the normal case.  Might want to make some attempt to re-work\n\t * this so that we only do this check if we've definitely blocked on\n\t * one of the above checks.  When this condition is detected, we may\n\t * have just created a bogus status entry, which we need to delete. */\n\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {\n\t\tDprintf2(\"RECON: Skipping psid %ld ru %d: prior recon after stall\\n\", psid, which_ru);\n\t\tif (created)\n\t\t\trf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);\n\t\trf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);\n\t\tgoto out;\n\t}\n\t/* found something to read.  issue the I/O */\n\tDprintf5(\"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\\n\",\n\t    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);\n\tRF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);\n\traidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =\n\t    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\n\t/* should be ok to use a NULL proc pointer here, all the bufs we use\n\t * should be in kernel space */\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,\n\t    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);\n\n\tRF_ASSERT(req);\t\t/* XXX -- fix this -- XXX */\n\n\tctrl->rbuf->arg = (void *) req;\n\trf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);\n\tpssPtr->issued[col] = 1;\n\nout:\n\tRF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: HEADSEPCLEAR EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DDprintf2",
          "args": [
            "\"RECON: BLOCKCLEAR EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!submitblocked"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: BUFCLEAR EVENT: row %d col %d\\n\"",
            "frow",
            "event->col"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeReconBuffer",
          "args": [
            "rbuf"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "256-266",
          "snippet": "void \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconBuffer(rbuf)\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_Raid_t *raidPtr = rbuf->raidPtr;\n\tu_int   recon_buffer_size = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.SUsPerRU * raidPtr->Layout.sectorsPerStripeUnit);\n\n\tRF_Free(rbuf->arrived, raidPtr->numCol * sizeof(char));\n\tRF_Free(rbuf->buffer, recon_buffer_size);\n\tRF_Free(rbuf, sizeof(*rbuf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->reconControl[frow]->rb_mutex"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReleaseFloatingReconBuffer",
          "args": [
            "raidPtr",
            "frow",
            "rbuf"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReleaseFloatingReconBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconbuffer.c",
          "lines": "392-419",
          "snippet": "void \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}",
          "includes": [
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_nwayxor.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_revent.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_raid.h\"\n\nvoid \nrf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconBuffer_t *rbuf;\n{\n\tRF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];\n\tRF_CallbackDesc_t *cb;\n\n\tDprintf2(\"RECON: releasing rbuf for psid %ld ru %d\\n\",\n\t    (long) rbuf->parityStripeID, rbuf->which_ru);\n\n\t/* if anyone is waiting on buffers, wake one of them up.  They will\n\t * subsequently wake up anyone else waiting on their RU */\n\tif (rcPtr->bufferWaitList) {\n\t\trbuf->next = rcPtr->committedRbufs;\n\t\trcPtr->committedRbufs = rbuf;\n\t\tcb = rcPtr->bufferWaitList;\n\t\trcPtr->bufferWaitList = cb->next;\n\t\trf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);\t/* arg==1 => we've\n\t\t\t\t\t\t\t\t\t\t\t\t * committed a buffer */\n\t\trf_FreeCallbackDesc(cb);\n\t\traidPtr->procsInBufWait--;\n\t} else {\n\t\trbuf->next = rcPtr->floatingRbufs;\n\t\trcPtr->floatingRbufs = rbuf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->reconControl[frow]->rb_mutex"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RemoveFromActiveReconTable",
          "args": [
            "raidPtr",
            "frow",
            "rbuf->parityStripeID",
            "rbuf->which_ru"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RemoveFromActiveReconTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_psstatus.c",
          "lines": "249-297",
          "snippet": "void \nrf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n{\n\tRF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[RF_HASH_PSID(raidPtr, psid)]);\n\tRF_ReconParityStripeStatus_t *p, *pt;\n\tRF_CallbackDesc_t *cb, *cb1;\n\n\tRF_LOCK_MUTEX(hdr->mutex);\n\tfor (pt = NULL, p = hdr->chain; p; pt = p, p = p->next) {\n\t\tif ((p->parityStripeID == psid) && (p->which_ru == which_ru))\n\t\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\trf_PrintPSStatusTable(raidPtr, row);\n\t}\n\tRF_ASSERT(p);\t\t/* it must be there */\n\n\tDprintf2(\"PSS: deleting pss for psid %ld ru %d\\n\", psid, which_ru);\n\n\t/* delete this entry from the hash chain */\n\tif (pt)\n\t\tpt->next = p->next;\n\telse\n\t\thdr->chain = p->next;\n\tp->next = NULL;\n\n\tRF_UNLOCK_MUTEX(hdr->mutex);\n\n\t/* wakup anyone waiting on the parity stripe ID */\n\tcb = p->procWaitList;\n\tp->procWaitList = NULL;\n\twhile (cb) {\n\t\tDprintf1(\"Waking up access waiting on parity stripe ID %ld\\n\", p->parityStripeID);\n\t\tcb1 = cb->next;\n\t\t(cb->callbackFunc) (cb->callbackArg);\n\n\t\t/* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,\n\t\t * IMHO */\n\t\t/* (cb->callbackFunc)(cb->callbackArg, 0); */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\n\trf_FreePSStatus(raidPtr, p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_psstatus.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);",
            "static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);",
            "RF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;",
            "RF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_psstatus.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nRealPrintPSStatusTable(RF_Raid_t * raidPtr,\n    RF_PSStatusHeader_t * pssTable);\nstatic int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nstatic void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);\nRF_PSStatusHeader_t *\nrf_MakeParityStripeStatusTable(raidPtr)\n\tRF_Raid_t *raidPtr;\nRF_ReconParityStripeStatus_t *\nrf_AllocPSStatus(raidPtr)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psid;\n{\n\tRF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[RF_HASH_PSID(raidPtr, psid)]);\n\tRF_ReconParityStripeStatus_t *p, *pt;\n\tRF_CallbackDesc_t *cb, *cb1;\n\n\tRF_LOCK_MUTEX(hdr->mutex);\n\tfor (pt = NULL, p = hdr->chain; p; pt = p, p = p->next) {\n\t\tif ((p->parityStripeID == psid) && (p->which_ru == which_ru))\n\t\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\trf_PrintPSStatusTable(raidPtr, row);\n\t}\n\tRF_ASSERT(p);\t\t/* it must be there */\n\n\tDprintf2(\"PSS: deleting pss for psid %ld ru %d\\n\", psid, which_ru);\n\n\t/* delete this entry from the hash chain */\n\tif (pt)\n\t\tpt->next = p->next;\n\telse\n\t\thdr->chain = p->next;\n\tp->next = NULL;\n\n\tRF_UNLOCK_MUTEX(hdr->mutex);\n\n\t/* wakup anyone waiting on the parity stripe ID */\n\tcb = p->procWaitList;\n\tp->procWaitList = NULL;\n\twhile (cb) {\n\t\tDprintf1(\"Waking up access waiting on parity stripe ID %ld\\n\", p->parityStripeID);\n\t\tcb1 = cb->next;\n\t\t(cb->callbackFunc) (cb->callbackArg);\n\n\t\t/* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,\n\t\t * IMHO */\n\t\t/* (cb->callbackFunc)(cb->callbackArg, 0); */\n\t\trf_FreeCallbackDesc(cb);\n\t\tcb = cb1;\n\t}\n\n\trf_FreePSStatus(raidPtr, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ReconMapUpdate",
          "args": [
            "raidPtr",
            "raidPtr->reconControl[frow]->reconMap",
            "rbuf->failedDiskSectorOffset",
            "rbuf->failedDiskSectorOffset + sectorsPerRU - 1"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReconMapUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "131-170",
          "snippet": "void \nrf_ReconMapUpdate(raidPtr, mapPtr, startSector, stopSector)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n\tRF_SectorNum_t stopSector;\n{\n\tRF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;\n\tRF_SectorNum_t i, first_in_RU, last_in_RU;\n\tRF_ReconMapListElem_t *p, *pt;\n\n\tRF_LOCK_MUTEX(mapPtr->mutex);\n\tRF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk && stopSector >= startSector);\n\n\twhile (startSector <= stopSector) {\n\t\ti = startSector / mapPtr->sectorsPerReconUnit;\n\t\tfirst_in_RU = i * sectorsPerReconUnit;\n\t\tlast_in_RU = first_in_RU + sectorsPerReconUnit - 1;\n\t\tp = mapPtr->status[i];\n\t\tif (p != RU_ALL) {\n\t\t\tif (p == RU_NOTHING || p->startSector > startSector) {\t/* insert at front of\n\t\t\t\t\t\t\t\t\t\t * list */\n\n\t\t\t\tmapPtr->status[i] = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), (p == RU_NOTHING) ? NULL : p);\n\t\t\t\tupdate_size(mapPtr, sizeof(RF_ReconMapListElem_t));\n\n\t\t\t} else {/* general case */\n\t\t\t\tdo {\t/* search for place to insert */\n\t\t\t\t\tpt = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t} while (p && (p->startSector < startSector));\n\t\t\t\tpt->next = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), p);\n\t\t\t\tupdate_size(mapPtr, sizeof(RF_ReconMapListElem_t));\n\t\t\t}\n\t\t\tcompact_stat_entry(raidPtr, mapPtr, i);\n\t\t}\n\t\tstartSector = RF_MIN(stopSector, last_in_RU) + 1;\n\t}\n\tRF_UNLOCK_MUTEX(mapPtr->mutex);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_NOTHING  ((RF_ReconMapListElem_t *) 0)",
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);",
            "static RF_ReconMapListElem_t *\nMakeReconMapListElem(RF_SectorNum_t startSector,\n    RF_SectorNum_t stopSector, RF_ReconMapListElem_t * next);",
            "static void \nFreeReconMapListElem(RF_ReconMap_t * mapPtr,\n    RF_ReconMapListElem_t * p);",
            "RF_ReconMap_t *\nrf_MakeReconMap(raidPtr, ru_sectors, disk_sectors, spareUnitsPerDisk)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_NOTHING  ((RF_ReconMapListElem_t *) 0)\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\nstatic RF_ReconMapListElem_t *\nMakeReconMapListElem(RF_SectorNum_t startSector,\n    RF_SectorNum_t stopSector, RF_ReconMapListElem_t * next);\nstatic void \nFreeReconMapListElem(RF_ReconMap_t * mapPtr,\n    RF_ReconMapListElem_t * p);\nRF_ReconMap_t *\nrf_MakeReconMap(raidPtr, ru_sectors, disk_sectors, spareUnitsPerDisk)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_ReconMapUpdate(raidPtr, mapPtr, startSector, stopSector)\n\tRF_Raid_t *raidPtr;\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n\tRF_SectorNum_t stopSector;\n{\n\tRF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;\n\tRF_SectorNum_t i, first_in_RU, last_in_RU;\n\tRF_ReconMapListElem_t *p, *pt;\n\n\tRF_LOCK_MUTEX(mapPtr->mutex);\n\tRF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk && stopSector >= startSector);\n\n\twhile (startSector <= stopSector) {\n\t\ti = startSector / mapPtr->sectorsPerReconUnit;\n\t\tfirst_in_RU = i * sectorsPerReconUnit;\n\t\tlast_in_RU = first_in_RU + sectorsPerReconUnit - 1;\n\t\tp = mapPtr->status[i];\n\t\tif (p != RU_ALL) {\n\t\t\tif (p == RU_NOTHING || p->startSector > startSector) {\t/* insert at front of\n\t\t\t\t\t\t\t\t\t\t * list */\n\n\t\t\t\tmapPtr->status[i] = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), (p == RU_NOTHING) ? NULL : p);\n\t\t\t\tupdate_size(mapPtr, sizeof(RF_ReconMapListElem_t));\n\n\t\t\t} else {/* general case */\n\t\t\t\tdo {\t/* search for place to insert */\n\t\t\t\t\tpt = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t} while (p && (p->startSector < startSector));\n\t\t\t\tpt->next = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), p);\n\t\t\t\tupdate_size(mapPtr, sizeof(RF_ReconMapListElem_t));\n\t\t\t}\n\t\t\tcompact_stat_entry(raidPtr, mapPtr, i);\n\t\t}\n\t\tstartSector = RF_MIN(stopSector, last_in_RU) + 1;\n\t}\n\tRF_UNLOCK_MUTEX(mapPtr->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\\n\"",
            "rbuf->parityStripeID",
            "rbuf->which_ru",
            "raidPtr->reconControl[frow]->percentComplete"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"RECON: submitblocked=%d\\n\"",
            "submitblocked"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf7",
          "args": [
            "\"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\\n\"",
            "rbuf->parityStripeID",
            "rbuf->buffer",
            "rbuf->buffer[0] & 0xff",
            "rbuf->buffer[1] & 0xff",
            "rbuf->buffer[2] & 0xff",
            "rbuf->buffer[3] & 0xff",
            "rbuf->buffer[4] & 0xff"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"RECON: READDONE EVENT: row %d col %d psid %ld\\n\"",
            "frow",
            "event->col",
            "rbuf->parityStripeID"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"RECON: rf_ProcessReconEvent type %d\\n\"",
            "event->type"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ProcessReconEvent;\nint rf_IssueNextReadRequest;\nint rf_TryToRead;\nint rf_IssueNextWriteRequest;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ProcessReconEvent(raidPtr, frow, event)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t frow;\n\tRF_ReconEvent_t *event;\n{\n\tint     retcode = 0, submitblocked;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_SectorCount_t sectorsPerRU;\n\n\tDprintf1(\"RECON: rf_ProcessReconEvent type %d\\n\", event->type);\n\tswitch (event->type) {\n\n\t\t/* a read I/O has completed */\n\tcase RF_REVENT_READDONE:\n\t\trbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;\n\t\tDprintf3(\"RECON: READDONE EVENT: row %d col %d psid %ld\\n\",\n\t\t    frow, event->col, rbuf->parityStripeID);\n\t\tDprintf7(\"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\\n\",\n\t\t    rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 0, 0);\n\t\tDprintf1(\"RECON: submitblocked=%d\\n\", submitblocked);\n\t\tif (!submitblocked)\n\t\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a write I/O has completed */\n\tcase RF_REVENT_WRITEDONE:\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tsectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDprintf3(\"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\\n\",\n\t\t    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);\n\t\trf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,\n\t\t    rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU - 1);\n\t\trf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);\n\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING) {\n\t\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t\traidPtr->numFullReconBuffers--;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t} else\n\t\t\tif (rbuf->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t\tbreak;\n\n\tcase RF_REVENT_BUFCLEAR:\t/* A buffer-stall condition has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: BUFCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long) event->arg);\n\t\tRF_ASSERT(!submitblocked);\t/* we wouldn't have gotten the\n\t\t\t\t\t\t * BUFCLEAR event if we\n\t\t\t\t\t\t * couldn't submit */\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_BLOCKCLEAR:\t/* A user-write reconstruction\n\t\t\t\t\t * blockage has been cleared */\n\t\tDDprintf2(\"RECON: BLOCKCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_HEADSEPCLEAR:\t/* A max-head-separation\n\t\t\t\t\t * reconstruction blockage has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: HEADSEPCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a buffer has become ready to write */\n\tcase RF_REVENT_BUFREADY:\n\t\tDprintf2(\"RECON: BUFREADY EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextWriteRequest(raidPtr, frow);\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tbreak;\n\n\t\t/* we need to skip the current RU entirely because it got\n\t\t * recon'd while we were waiting for something else to happen */\n\tcase RF_REVENT_SKIP:\n\t\tDDprintf2(\"RECON: SKIP EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a forced-reconstruction read access has completed.  Just\n\t\t * submit the buffer */\n\tcase RF_REVENT_FORCEDREADDONE:\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDDprintf2(\"RECON: FORCEDREADDONE EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);\n\t\tRF_ASSERT(!submitblocked);\n\t\tbreak;\n\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\trf_FreeReconEventDesc(event);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_ContinueReconstructFailedDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "601-773",
    "snippet": "int \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int rf_ProcessReconEvent",
      "int rf_IssueNextReadRequest",
      "void rf_FreeReconDesc",
      "void rf_SignalReconDone",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;",
      "int     numDisksDone;",
      "RF_RowCol_t srow;",
      "RF_RowCol_t scol;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_SignalReconDone",
          "args": [
            "raidPtr"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SignalReconDone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "117-127",
          "snippet": "void \nrf_SignalReconDone(RF_Raid_t * raidPtr)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tfor (p = raidPtr->recon_done_procs; p; p = p->next) {\n\t\tp->proc(raidPtr, p->arg);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_SignalReconDone",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_SignalReconDone;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_SignalReconDone(RF_Raid_t * raidPtr)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tfor (p = raidPtr->recon_done_procs; p; p = p->next) {\n\t\tp->proc(raidPtr, p->arg);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeReconDesc",
          "args": [
            "reconDesc"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "222-237",
          "snippet": "void \nrf_FreeReconDesc(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n#if RF_RECON_STATS > 0\n\tprintf(\"RAIDframe: %qu recon event waits, %qu recon delays\\n\",\n\t    reconDesc->numReconEventWaits, reconDesc->numReconExecDelays);\n#endif /* RF_RECON_STATS > 0 */\n\n\tprintf(\"RAIDframe: %qu max exec ticks\\n\", reconDesc->maxReconExecTicks);\n\n#if (RF_RECON_STATS > 0) || defined(_KERNEL)\n\tprintf(\"\\n\");\n#endif /* (RF_RECON_STATS > 0) || _KERNEL */\n\tRF_FREELIST_FREE(rf_recond_freelist, reconDesc, next);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_recond_freelist;",
            "void rf_FreeReconDesc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_recond_freelist;\nvoid rf_FreeReconDesc;\n\nvoid \nrf_FreeReconDesc(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n#if RF_RECON_STATS > 0\n\tprintf(\"RAIDframe: %qu recon event waits, %qu recon delays\\n\",\n\t    reconDesc->numReconEventWaits, reconDesc->numReconExecDelays);\n#endif /* RF_RECON_STATS > 0 */\n\n\tprintf(\"RAIDframe: %qu max exec ticks\\n\", reconDesc->maxReconExecTicks);\n\n#if (RF_RECON_STATS > 0) || defined(_KERNEL)\n\tprintf(\"\\n\");\n#endif /* (RF_RECON_STATS > 0) || _KERNEL */\n\tRF_FREELIST_FREE(rf_recond_freelist, reconDesc, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->recon_tracerecs",
            "raidPtr->numCol * sizeof(RF_AccTraceEntry_t)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeReconControl",
          "args": [
            "raidPtr",
            "row"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeReconControl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconutil.c",
          "lines": "162-188",
          "snippet": "void \nrf_FreeReconControl(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_ReconBuffer_t *t;\n\tRF_ReconUnitNum_t i;\n\n\tRF_ASSERT(reconCtrlPtr);\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (reconCtrlPtr->perDiskInfo[i].rbuf)\n\t\t\trf_FreeReconBuffer(reconCtrlPtr->perDiskInfo[i].rbuf);\n\tfor (i = 0; i < raidPtr->numFloatingReconBufs; i++) {\n\t\tt = reconCtrlPtr->floatingRbufs;\n\t\tRF_ASSERT(t);\n\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\trf_FreeReconBuffer(t);\n\t}\n\trf_mutex_destroy(&reconCtrlPtr->rb_mutex);\n\trf_mutex_destroy(&reconCtrlPtr->eq_mutex);\n\trf_cond_destroy(&reconCtrlPtr->eq_cond);\n\trf_FreeReconMap(reconCtrlPtr->reconMap);\n\trf_FreeParityStripeStatusTable(raidPtr, reconCtrlPtr->pssTable);\n\tRF_Free(reconCtrlPtr->perDiskInfo, raidPtr->numCol * sizeof(RF_PerDiskReconCtrl_t));\n\tRF_Free(reconCtrlPtr, sizeof(*reconCtrlPtr));\n}",
          "includes": [
            "#include \"rf_chaindecluster.h\"",
            "#include \"rf_interdecluster.h\"",
            "#include \"rf_raid5_rotatedspare.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_chaindecluster.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid5_rotatedspare.h\"\n#include \"rf_decluster.h\"\n#include \"rf_general.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_desc.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_FreeReconControl(raidPtr, row)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n{\n\tRF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];\n\tRF_ReconBuffer_t *t;\n\tRF_ReconUnitNum_t i;\n\n\tRF_ASSERT(reconCtrlPtr);\n\tfor (i = 0; i < raidPtr->numCol; i++)\n\t\tif (reconCtrlPtr->perDiskInfo[i].rbuf)\n\t\t\trf_FreeReconBuffer(reconCtrlPtr->perDiskInfo[i].rbuf);\n\tfor (i = 0; i < raidPtr->numFloatingReconBufs; i++) {\n\t\tt = reconCtrlPtr->floatingRbufs;\n\t\tRF_ASSERT(t);\n\t\treconCtrlPtr->floatingRbufs = t->next;\n\t\trf_FreeReconBuffer(t);\n\t}\n\trf_mutex_destroy(&reconCtrlPtr->rb_mutex);\n\trf_mutex_destroy(&reconCtrlPtr->eq_mutex);\n\trf_cond_destroy(&reconCtrlPtr->eq_cond);\n\trf_FreeReconMap(reconCtrlPtr->reconMap);\n\trf_FreeParityStripeStatusTable(raidPtr, reconCtrlPtr->pssTable);\n\tRF_Free(reconCtrlPtr->perDiskInfo, raidPtr->numCol * sizeof(RF_PerDiskReconCtrl_t));\n\tRF_Free(reconCtrlPtr, sizeof(*reconCtrlPtr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Total head-sep stall count was %d\\n\"",
            "(int) reconDesc->hsStallCount"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ResumeNewRequests",
          "args": [
            "raidPtr"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ResumeNewRequests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "810-834",
          "snippet": "void \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_DIFF",
          "args": [
            "&(raidPtr->reconControl[row]->starttime)",
            "&etime",
            "&elpsd"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "etime"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PrintUserStats",
          "args": [
            "raidPtr"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintUserStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "975-1005",
          "snippet": "void \nrf_PrintUserStats(RF_Raid_t * raidPtr)\n{\n\tlong    elapsed_us, mbs, mbs_frac;\n\tstruct timeval diff;\n\n\tRF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);\n\telapsed_us = RF_TIMEVAL_TO_US(diff);\n\n\t/* 2000 sectors per megabyte, 10000000 microseconds per second */\n\tif (elapsed_us)\n\t\tmbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);\n\telse\n\t\tmbs = 0;\n\n\t/* this computes only the first digit of the fractional mb/s moved */\n\tif (elapsed_us) {\n\t\tmbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))\n\t\t    - (mbs * 10);\n\t} else {\n\t\tmbs_frac = 0;\n\t}\n\n\tprintf(\"Number of I/Os:             %ld\\n\", raidPtr->userstats.num_ios);\n\tprintf(\"Elapsed time (us):          %ld\\n\", elapsed_us);\n\tprintf(\"User I/Os per second:       %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));\n\tprintf(\"Average user response time: %ld us\\n\", RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));\n\tprintf(\"Total sectors moved:        %ld\\n\", raidPtr->userstats.num_sect_moved);\n\tprintf(\"Average access size (sect): %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));\n\tprintf(\"Achieved data rate:         %ld.%ld MB/sec\\n\", mbs, mbs_frac);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_PrintUserStats(RF_Raid_t * raidPtr)\n{\n\tlong    elapsed_us, mbs, mbs_frac;\n\tstruct timeval diff;\n\n\tRF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);\n\telapsed_us = RF_TIMEVAL_TO_US(diff);\n\n\t/* 2000 sectors per megabyte, 10000000 microseconds per second */\n\tif (elapsed_us)\n\t\tmbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);\n\telse\n\t\tmbs = 0;\n\n\t/* this computes only the first digit of the fractional mb/s moved */\n\tif (elapsed_us) {\n\t\tmbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))\n\t\t    - (mbs * 10);\n\t} else {\n\t\tmbs_frac = 0;\n\t}\n\n\tprintf(\"Number of I/Os:             %ld\\n\", raidPtr->userstats.num_ios);\n\tprintf(\"Elapsed time (us):          %ld\\n\", elapsed_us);\n\tprintf(\"User I/Os per second:       %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));\n\tprintf(\"Average user response time: %ld us\\n\", RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));\n\tprintf(\"Total sectors moved:        %ld\\n\", raidPtr->userstats.num_sect_moved);\n\tprintf(\"Average access size (sect): %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));\n\tprintf(\"Achieved data rate:         %ld.%ld MB/sec\\n\", mbs, mbs_frac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_StopUserStats",
          "args": [
            "raidPtr"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "rf_StopUserStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "958-962",
          "snippet": "void \nrf_StopUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.stop);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StopUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.stop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_SuspendNewRequestsAndWait",
          "args": [
            "raidPtr"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SuspendNewRequestsAndWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "785-808",
          "snippet": "int \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_PrintReconSchedule",
          "args": [
            "raidPtr->reconControl[row]->reconMap",
            "&(raidPtr->reconControl[row]->starttime)"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintReconSchedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "378-394",
          "snippet": "void \nrf_PrintReconSchedule(mapPtr, starttime)\n\tRF_ReconMap_t *mapPtr;\n\tstruct timeval *starttime;\n{\n\tstatic int old_pctg = -1;\n\tstruct timeval tv, diff;\n\tint     new_pctg;\n\n\tnew_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\tif (new_pctg != old_pctg) {\n\t\tRF_GETTIME(tv);\n\t\tRF_TIMEVAL_DIFF(starttime, &tv, &diff);\n\t\tprintf(\"%d %d.%06d\\n\", (int) new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\told_pctg = new_pctg;\n\t}\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\nvoid \nrf_PrintReconSchedule(mapPtr, starttime)\n\tRF_ReconMap_t *mapPtr;\n\tstruct timeval *starttime;\n{\n\tstatic int old_pctg = -1;\n\tstruct timeval tv, diff;\n\tint     new_pctg;\n\n\tnew_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\tif (new_pctg != old_pctg) {\n\t\tRF_GETTIME(tv);\n\t\tRF_TIMEVAL_DIFF(starttime, &tv, &diff);\n\t\tprintf(\"%d %d.%06d\\n\", (int) new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);\n\t\told_pctg = new_pctg;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_UnitsLeftToReconstruct",
          "args": [
            "mapPtr"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnitsLeftToReconstruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "321-327",
          "snippet": "RF_ReconUnitCount_t \nrf_UnitsLeftToReconstruct(mapPtr)\n\tRF_ReconMap_t *mapPtr;\n{\n\tRF_ASSERT(mapPtr != NULL);\n\treturn (mapPtr->unitsLeft);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\nRF_ReconUnitCount_t \nrf_UnitsLeftToReconstruct(mapPtr)\n\tRF_ReconMap_t *mapPtr;\n{\n\tRF_ASSERT(mapPtr != NULL);\n\treturn (mapPtr->unitsLeft);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ProcessReconEvent",
          "args": [
            "raidPtr",
            "row",
            "event"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ProcessReconEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "779-887",
          "snippet": "int \nrf_ProcessReconEvent(raidPtr, frow, event)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t frow;\n\tRF_ReconEvent_t *event;\n{\n\tint     retcode = 0, submitblocked;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_SectorCount_t sectorsPerRU;\n\n\tDprintf1(\"RECON: rf_ProcessReconEvent type %d\\n\", event->type);\n\tswitch (event->type) {\n\n\t\t/* a read I/O has completed */\n\tcase RF_REVENT_READDONE:\n\t\trbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;\n\t\tDprintf3(\"RECON: READDONE EVENT: row %d col %d psid %ld\\n\",\n\t\t    frow, event->col, rbuf->parityStripeID);\n\t\tDprintf7(\"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\\n\",\n\t\t    rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 0, 0);\n\t\tDprintf1(\"RECON: submitblocked=%d\\n\", submitblocked);\n\t\tif (!submitblocked)\n\t\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a write I/O has completed */\n\tcase RF_REVENT_WRITEDONE:\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tsectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDprintf3(\"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\\n\",\n\t\t    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);\n\t\trf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,\n\t\t    rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU - 1);\n\t\trf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);\n\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING) {\n\t\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t\traidPtr->numFullReconBuffers--;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t} else\n\t\t\tif (rbuf->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t\tbreak;\n\n\tcase RF_REVENT_BUFCLEAR:\t/* A buffer-stall condition has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: BUFCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long) event->arg);\n\t\tRF_ASSERT(!submitblocked);\t/* we wouldn't have gotten the\n\t\t\t\t\t\t * BUFCLEAR event if we\n\t\t\t\t\t\t * couldn't submit */\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_BLOCKCLEAR:\t/* A user-write reconstruction\n\t\t\t\t\t * blockage has been cleared */\n\t\tDDprintf2(\"RECON: BLOCKCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_HEADSEPCLEAR:\t/* A max-head-separation\n\t\t\t\t\t * reconstruction blockage has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: HEADSEPCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a buffer has become ready to write */\n\tcase RF_REVENT_BUFREADY:\n\t\tDprintf2(\"RECON: BUFREADY EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextWriteRequest(raidPtr, frow);\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tbreak;\n\n\t\t/* we need to skip the current RU entirely because it got\n\t\t * recon'd while we were waiting for something else to happen */\n\tcase RF_REVENT_SKIP:\n\t\tDDprintf2(\"RECON: SKIP EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a forced-reconstruction read access has completed.  Just\n\t\t * submit the buffer */\n\tcase RF_REVENT_FORCEDREADDONE:\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDDprintf2(\"RECON: FORCEDREADDONE EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);\n\t\tRF_ASSERT(!submitblocked);\n\t\tbreak;\n\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\trf_FreeReconEventDesc(event);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ProcessReconEvent",
            "int rf_IssueNextReadRequest",
            "int rf_TryToRead",
            "int rf_IssueNextWriteRequest",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ProcessReconEvent;\nint rf_IssueNextReadRequest;\nint rf_TryToRead;\nint rf_IssueNextWriteRequest;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ProcessReconEvent(raidPtr, frow, event)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t frow;\n\tRF_ReconEvent_t *event;\n{\n\tint     retcode = 0, submitblocked;\n\tRF_ReconBuffer_t *rbuf;\n\tRF_SectorCount_t sectorsPerRU;\n\n\tDprintf1(\"RECON: rf_ProcessReconEvent type %d\\n\", event->type);\n\tswitch (event->type) {\n\n\t\t/* a read I/O has completed */\n\tcase RF_REVENT_READDONE:\n\t\trbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;\n\t\tDprintf3(\"RECON: READDONE EVENT: row %d col %d psid %ld\\n\",\n\t\t    frow, event->col, rbuf->parityStripeID);\n\t\tDprintf7(\"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\\n\",\n\t\t    rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,\n\t\t    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 0, 0);\n\t\tDprintf1(\"RECON: submitblocked=%d\\n\", submitblocked);\n\t\tif (!submitblocked)\n\t\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a write I/O has completed */\n\tcase RF_REVENT_WRITEDONE:\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tsectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDprintf3(\"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\\n\",\n\t\t    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);\n\t\trf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,\n\t\t    rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU - 1);\n\t\trf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);\n\n\t\tif (rbuf->type == RF_RBUF_TYPE_FLOATING) {\n\t\t\tRF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t\traidPtr->numFullReconBuffers--;\n\t\t\trf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);\n\t\t} else\n\t\t\tif (rbuf->type == RF_RBUF_TYPE_FORCED)\n\t\t\t\trf_FreeReconBuffer(rbuf);\n\t\t\telse\n\t\t\t\tRF_ASSERT(0);\n\t\tbreak;\n\n\tcase RF_REVENT_BUFCLEAR:\t/* A buffer-stall condition has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: BUFCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long) event->arg);\n\t\tRF_ASSERT(!submitblocked);\t/* we wouldn't have gotten the\n\t\t\t\t\t\t * BUFCLEAR event if we\n\t\t\t\t\t\t * couldn't submit */\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_BLOCKCLEAR:\t/* A user-write reconstruction\n\t\t\t\t\t * blockage has been cleared */\n\t\tDDprintf2(\"RECON: BLOCKCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\tcase RF_REVENT_HEADSEPCLEAR:\t/* A max-head-separation\n\t\t\t\t\t * reconstruction blockage has been\n\t\t\t\t\t * cleared */\n\t\tDprintf2(\"RECON: HEADSEPCLEAR EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_TryToRead(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a buffer has become ready to write */\n\tcase RF_REVENT_BUFREADY:\n\t\tDprintf2(\"RECON: BUFREADY EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextWriteRequest(raidPtr, frow);\n\t\tif (rf_floatingRbufDebug) {\n\t\t\trf_CheckFloatingRbufCount(raidPtr, 1);\n\t\t}\n\t\tbreak;\n\n\t\t/* we need to skip the current RU entirely because it got\n\t\t * recon'd while we were waiting for something else to happen */\n\tcase RF_REVENT_SKIP:\n\t\tDDprintf2(\"RECON: SKIP EVENT: row %d col %d\\n\", frow, event->col);\n\t\tretcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);\n\t\tbreak;\n\n\t\t/* a forced-reconstruction read access has completed.  Just\n\t\t * submit the buffer */\n\tcase RF_REVENT_FORCEDREADDONE:\n\t\trbuf = (RF_ReconBuffer_t *) event->arg;\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);\n\t\tDDprintf2(\"RECON: FORCEDREADDONE EVENT: row %d col %d\\n\", frow, event->col);\n\t\tsubmitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);\n\t\tRF_ASSERT(!submitblocked);\n\t\tbreak;\n\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\trf_FreeReconEventDesc(event);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "event"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_GetNextReconEvent",
          "args": [
            "reconDesc",
            "row",
            "(void (*) (void *)) rf_ContinueReconstructFailedDisk",
            "reconDesc"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "event"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_GetNextReconEvent",
          "args": [
            "reconDesc",
            "row",
            "(void (*) (void *)) rf_ContinueReconstructFailedDisk",
            "reconDesc"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf",
          "args": [
            "\"RECON: resume requests\\n\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf2",
          "args": [
            "\"RECON: done issuing for r%d c%d\\n\"",
            "row",
            "i"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IssueNextReadRequest",
          "args": [
            "raidPtr",
            "row",
            "i"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IssueNextReadRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "910-977",
          "snippet": "int \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_IssueNextReadRequest",
            "int rf_TryToRead",
            "int rf_ComputePSDiskOffsets",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_IssueNextReadRequest;\nint rf_TryToRead;\nint rf_ComputePSDiskOffsets;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_IssueNextReadRequest(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ReconBuffer_t *rbuf = ctrl->rbuf;\n\tRF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;\n\tRF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;\n\tint     do_new_check = 0, retcode = 0, status;\n\n\t/* if we are currently the slowest disk, mark that we have to do a new\n\t * check */\n\tif (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)\n\t\tdo_new_check = 1;\n\n\twhile (1) {\n\n\t\tctrl->ru_count++;\n\t\tif (ctrl->ru_count < RUsPerPU) {\n\t\t\tctrl->diskOffset += sectorsPerRU;\n\t\t\trbuf->failedDiskSectorOffset += sectorsPerRU;\n\t\t} else {\n\t\t\tctrl->curPSID++;\n\t\t\tctrl->ru_count = 0;\n\t\t\t/* code left over from when head-sep was based on\n\t\t\t * parity stripe id */\n\t\t\tif (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {\n\t\t\t\trf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));\n\t\t\t\treturn (1);\t/* finito! */\n\t\t\t}\n\t\t\t/* find the disk offsets of the start of the parity\n\t\t\t * stripe on both the current disk and the failed\n\t\t\t * disk. skip this entire parity stripe if either disk\n\t\t\t * does not appear in the indicated PS */\n\t\t\tstatus = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,\n\t\t\t    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);\n\t\t\tif (status) {\n\t\t\t\tctrl->ru_count = RUsPerPU - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trbuf->which_ru = ctrl->ru_count;\n\n\t\t/* skip this RU if it's already been reconstructed */\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {\n\t\t\tDprintf2(\"Skipping psid %ld ru %d: already reconstructed\\n\", ctrl->curPSID, ctrl->ru_count);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tctrl->headSepCounter++;\n\tif (do_new_check)\n\t\trf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);\t/* update min if needed */\n\n\n\t/* at this point, we have definitely decided what to do, and we have\n\t * only to see if we can actually do it now */\n\trbuf->parityStripeID = ctrl->curPSID;\n\trbuf->which_ru = ctrl->ru_count;\n\tbzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));\n\traidPtr->recon_tracerecs[col].reconacc = 1;\n\tRF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);\n\tretcode = rf_TryToRead(raidPtr, row, col);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "raidPtr->reconControl[row]->starttime"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeReconControl",
          "args": [
            "reconDesc",
            "row",
            "col",
            "srow",
            "scol"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StartUserStats",
          "args": [
            "raidPtr"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "rf_StartUserStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "949-956",
          "snippet": "void \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf",
          "args": [
            "\"RECON: end request suspend\\n\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf",
          "args": [
            "\"RECON: begin request suspend\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->recon_tracerecs",
            "raidPtr->numCol * sizeof(RF_AccTraceEntry_t)",
            "(RF_AccTraceEntry_t *)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ProcessReconEvent;\nint rf_IssueNextReadRequest;\nvoid rf_FreeReconDesc;\nvoid rf_SignalReconDone;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ReconstructInPlace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "377-598",
    "snippet": "int\nrf_ReconstructInPlace(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_LayoutSW_t *lp;\n\tRF_RaidDisk_t *badDisk;\n\tRF_ComponentLabel_t c_label;\n\tint     numDisksDone = 0, rc;\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint retcode;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->SubmitReconBuffer) {\n\t\t/*\n\t         * The current infrastructure only supports reconstructing one\n\t         * disk at a time for each array.\n\t         */\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif ((raidPtr->Disks[row][col].status == rf_ds_optimal) &&\n\t\t    (raidPtr->numFailures > 0)) { \n\t\t\t/* XXX 0 above shouldn't be constant!!! */\n\t\t\t/* some component other than this has failed.\n\t\t\t   Let's not make things worse than they already\n\t\t\t   are... */\n\t\t\tprintf(\"RAIDFRAME: Unable to reconstruct to disk at:\\n\");\n\t\t\tprintf(\"      Row: %d Col: %d   Too many failures.\\n\",\n\t\t\t       row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tif (raidPtr->Disks[row][col].status == rf_ds_reconstructing) {\n\t\t\tprintf(\"RAIDFRAME: Unable to reconstruct to disk at:\\n\");\n\t\t\tprintf(\"      Row: %d Col: %d   Reconstruction already occuring!\\n\", row, col);\n\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\n\t\tif (raidPtr->Disks[row][col].status != rf_ds_failed) {\n\t\t\t/* \"It's gone...\" */\n\t\t\traidPtr->numFailures++;\n\t\t\traidPtr->Disks[row][col].status = rf_ds_failed;\n\t\t\traidPtr->status[row] = rf_rs_degraded;\n\t\t}\n\n\t\twhile (raidPtr->reconInProgress) {\n\t\t\tRF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);\n\t\t}\n\n\t\traidPtr->reconInProgress++;\n\n\n\t\t/* first look for a spare drive onto which to reconstruct \n\t\t   the data.  spare disk descriptors are stored in row 0. \n\t\t   This may have to change eventually */\n\n\t\t/* Actually, we don't care if it's failed or not... \n\t\t   On a RAID set with correct parity, this function\n\t\t   should be callable on any component without ill affects. */\n\t\t/* RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\t\t */\n\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct to disk at row %d col %d: operation not supported for RF_DISTRIBUTE_SPARE\\n\", row, col);\n\n\t\t\traidPtr->reconInProgress--;\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\t\t\t\n\n\t\t/* XXX need goop here to see if the disk is alive,\n\t\t   and, if not, make it so...  */\n\t\t\n\n\n\t\tbadDisk = &raidPtr->Disks[row][col];\n\n\t\tproc = raidPtr->engine_thread;\n\n\t\t/* This device may have been opened successfully the \n\t\t   first time. Close it before trying to open it again.. */\n\n\t\tif (raidPtr->raid_cinfo[row][col].ci_vp != NULL) {\n\t\t\tprintf(\"Closing the open device: %s\\n\",\n\t\t\t       raidPtr->Disks[row][col].devname);\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[row][col].ci_vp, 0, proc);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\tFREAD | FWRITE, proc->p_ucred, proc);\n\t\t\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\t\t}\n\t\tprintf(\"About to (re-)open the device for rebuilding: %s\\n\",\n\t\t       raidPtr->Disks[row][col].devname);\n\t\t\n\t\tretcode = raidlookup(raidPtr->Disks[row][col].devname, \n\t\t\t\t     proc, &vp);\n\t\n\t\tif (retcode) {\n\t\t\tprintf(\"raid%d: rebuilding: raidlookup on device: %s failed: %d!\\n\",\n\t\t\t       raidPtr->raidid,\n\t\t\t       raidPtr->Disks[row][col].devname, retcode);\n\n\t\t\t/* XXX the component isn't responding properly... \n\t\t\t   must be still dead :-( */\n\t\t\traidPtr->reconInProgress--;\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn(retcode);\n\n\t\t} else {\n\n\t\t\t/* Ok, so we can at least do a lookup... \n\t\t\t   How about actually getting a vp for it? */\n\n\t\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, \n\t\t\t\t\t\t   proc)) != 0) {\n\t\t\t\traidPtr->reconInProgress--;\n\t\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\t\treturn(retcode);\n\t\t\t}\n\t\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t\t\t\t    FREAD, proc->p_ucred, proc);\n\t\t\tif (retcode) {\n\t\t\t\traidPtr->reconInProgress--;\n\t\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\t\treturn(retcode);\n\t\t\t}\n\t\t\traidPtr->Disks[row][col].blockSize =\n\t\t\t\tdpart.disklab->d_secsize;\n\n\t\t\traidPtr->Disks[row][col].numBlocks = \n\t\t\t\tdpart.part->p_size - rf_protectedSectors;\n\t\t\t\n\t\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\t\t\t\n\t\t\traidPtr->Disks[row][col].dev = va.va_rdev;\n\t\t\t\n\t\t\t/* we allow the user to specify that only a \n\t\t\t   fraction of the disks should be used this is \n\t\t\t   just for debug:  it speeds up\n\t\t\t * the parity scan */\n\t\t\traidPtr->Disks[row][col].numBlocks =\n\t\t\t\traidPtr->Disks[row][col].numBlocks *\n\t\t\t\trf_sizePercentage / 100;\n\t\t}\n\n\n\n\t\tspareDiskPtr = &raidPtr->Disks[row][col];\n\t\tspareDiskPtr->status = rf_ds_used_spare;\n\n\t\tprintf(\"RECON: initiating in-place reconstruction on\\n\");\n\t\tprintf(\"       row %d col %d -> spare at row %d col %d\\n\", \n\t\t       row, col, row, col);\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\n\t\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, \n\t\t\t\t\t       spareDiskPtr, numDisksDone, \n\t\t\t\t\t       row, col);\n\t\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\t\treconDesc->hsStallCount = 0;\n\t\treconDesc->numReconExecDelays = 0;\n\t\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\treconDesc->reconExecTimerRunning = 0;\n\t\treconDesc->reconExecTicks = 0;\n\t\treconDesc->maxReconExecTicks = 0;\n\t\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->reconInProgress--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t} else {\n\t\tRF_ERRORMSG1(\"RECON: no way to reconstruct failed disk for arch %c\\n\",\n\t\t\t     lp->parityConfig);\n\t\trc = EIO;\n\t}\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\n\tif (!rc) {\n\t\t/* Need to set these here, as at this point it'll be claiming\n\t\t   that the disk is in rf_ds_spared!  But we know better :-) */\n\t\t\n\t\traidPtr->Disks[row][col].status = rf_ds_optimal;\n\t\traidPtr->status[row] = rf_rs_optimal;\n\t\t\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(raidPtr->raid_cinfo[row][col].ci_dev,\n\t\t\t\t\t raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\t &c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(raidPtr->raid_cinfo[row][col].ci_dev,\n\t\t\t\t\t  raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\t  &c_label);\n\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tRF_SIGNAL_COND(raidPtr->waitForReconCond);\n\twakeup(&raidPtr->waitForReconCond);\t\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;",
      "RF_RaidDisk_t *spareDiskPtr;",
      "int     numDisksDone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&raidPtr->waitForReconCond"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_SIGNAL_COND",
          "args": [
            "raidPtr->waitForReconCond"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->raid_cinfo[row][col].ci_dev",
            "raidPtr->raid_cinfo[row][col].ci_vp",
            "&c_label"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1985-2017",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->raid_cinfo[row][col].ci_dev",
            "raidPtr->raid_cinfo[row][col].ci_vp",
            "&c_label"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1935-1983",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"RECON: no way to reconstruct failed disk for arch %c\\n\"",
            "lp->parityConfig"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ContinueReconstructFailedDisk",
          "args": [
            "reconDesc"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ContinueReconstructFailedDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "601-773",
          "snippet": "int \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ProcessReconEvent",
            "int rf_IssueNextReadRequest",
            "void rf_FreeReconDesc",
            "void rf_SignalReconDone",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;",
            "int     numDisksDone;",
            "RF_RowCol_t srow;",
            "RF_RowCol_t scol;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ProcessReconEvent;\nint rf_IssueNextReadRequest;\nvoid rf_FreeReconDesc;\nvoid rf_SignalReconDone;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_AllocRaidReconDesc",
          "args": [
            "(void *) raidPtr",
            "row",
            "col",
            "spareDiskPtr",
            "numDisksDone",
            "row",
            "col"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"       row %d col %d -> spare at row %d col %d\\n\"",
            "row",
            "col",
            "row",
            "col"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_IOCTL",
          "args": [
            "vp",
            "DIOCGPART",
            "(caddr_t) & dpart",
            "FREAD",
            "proc->p_ucred",
            "proc"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "vp",
            "&va",
            "proc->p_ucred",
            "proc"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raidlookup",
          "args": [
            "raidPtr->Disks[row][col].devname",
            "proc",
            "&vp"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "raidlookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1831-1869",
          "snippet": "int\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nint\nraidlookup(path, p, vpp)\n\tchar   *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint     error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tprintf(\"RAIDframe: vn_open returned %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0);\n\t\t(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\tVOP_UNLOCK(vp, 0);\n\t*vpp = vp;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "raidPtr->raid_cinfo[row][col].ci_vp",
            "FREAD | FWRITE",
            "proc->p_ucred",
            "proc"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "raidPtr->raid_cinfo[row][col].ci_vp",
            "0",
            "proc"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Unable to reconstruct to disk at row %d col %d: operation not supported for RF_DISTRIBUTE_SPARE\\n\"",
            "row",
            "col"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "raidPtr->waitForReconCond",
            "raidPtr->mutex"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nRF_RaidDisk_t *spareDiskPtr;\nint     numDisksDone;\n\nint\nrf_ReconstructInPlace(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_LayoutSW_t *lp;\n\tRF_RaidDisk_t *badDisk;\n\tRF_ComponentLabel_t c_label;\n\tint     numDisksDone = 0, rc;\n\tstruct partinfo dpart;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tstruct proc *proc;\n\tint retcode;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->SubmitReconBuffer) {\n\t\t/*\n\t         * The current infrastructure only supports reconstructing one\n\t         * disk at a time for each array.\n\t         */\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\tif ((raidPtr->Disks[row][col].status == rf_ds_optimal) &&\n\t\t    (raidPtr->numFailures > 0)) { \n\t\t\t/* XXX 0 above shouldn't be constant!!! */\n\t\t\t/* some component other than this has failed.\n\t\t\t   Let's not make things worse than they already\n\t\t\t   are... */\n\t\t\tprintf(\"RAIDFRAME: Unable to reconstruct to disk at:\\n\");\n\t\t\tprintf(\"      Row: %d Col: %d   Too many failures.\\n\",\n\t\t\t       row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tif (raidPtr->Disks[row][col].status == rf_ds_reconstructing) {\n\t\t\tprintf(\"RAIDFRAME: Unable to reconstruct to disk at:\\n\");\n\t\t\tprintf(\"      Row: %d Col: %d   Reconstruction already occuring!\\n\", row, col);\n\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\n\t\tif (raidPtr->Disks[row][col].status != rf_ds_failed) {\n\t\t\t/* \"It's gone...\" */\n\t\t\traidPtr->numFailures++;\n\t\t\traidPtr->Disks[row][col].status = rf_ds_failed;\n\t\t\traidPtr->status[row] = rf_rs_degraded;\n\t\t}\n\n\t\twhile (raidPtr->reconInProgress) {\n\t\t\tRF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);\n\t\t}\n\n\t\traidPtr->reconInProgress++;\n\n\n\t\t/* first look for a spare drive onto which to reconstruct \n\t\t   the data.  spare disk descriptors are stored in row 0. \n\t\t   This may have to change eventually */\n\n\t\t/* Actually, we don't care if it's failed or not... \n\t\t   On a RAID set with correct parity, this function\n\t\t   should be callable on any component without ill affects. */\n\t\t/* RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\t\t */\n\n\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct to disk at row %d col %d: operation not supported for RF_DISTRIBUTE_SPARE\\n\", row, col);\n\n\t\t\traidPtr->reconInProgress--;\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\t\t\t\n\n\t\t/* XXX need goop here to see if the disk is alive,\n\t\t   and, if not, make it so...  */\n\t\t\n\n\n\t\tbadDisk = &raidPtr->Disks[row][col];\n\n\t\tproc = raidPtr->engine_thread;\n\n\t\t/* This device may have been opened successfully the \n\t\t   first time. Close it before trying to open it again.. */\n\n\t\tif (raidPtr->raid_cinfo[row][col].ci_vp != NULL) {\n\t\t\tprintf(\"Closing the open device: %s\\n\",\n\t\t\t       raidPtr->Disks[row][col].devname);\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[row][col].ci_vp, 0, proc);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\tFREAD | FWRITE, proc->p_ucred, proc);\n\t\t\traidPtr->raid_cinfo[row][col].ci_vp = NULL;\n\t\t}\n\t\tprintf(\"About to (re-)open the device for rebuilding: %s\\n\",\n\t\t       raidPtr->Disks[row][col].devname);\n\t\t\n\t\tretcode = raidlookup(raidPtr->Disks[row][col].devname, \n\t\t\t\t     proc, &vp);\n\t\n\t\tif (retcode) {\n\t\t\tprintf(\"raid%d: rebuilding: raidlookup on device: %s failed: %d!\\n\",\n\t\t\t       raidPtr->raidid,\n\t\t\t       raidPtr->Disks[row][col].devname, retcode);\n\n\t\t\t/* XXX the component isn't responding properly... \n\t\t\t   must be still dead :-( */\n\t\t\traidPtr->reconInProgress--;\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn(retcode);\n\n\t\t} else {\n\n\t\t\t/* Ok, so we can at least do a lookup... \n\t\t\t   How about actually getting a vp for it? */\n\n\t\t\tif ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, \n\t\t\t\t\t\t   proc)) != 0) {\n\t\t\t\traidPtr->reconInProgress--;\n\t\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\t\treturn(retcode);\n\t\t\t}\n\t\t\tretcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,\n\t\t\t\t\t    FREAD, proc->p_ucred, proc);\n\t\t\tif (retcode) {\n\t\t\t\traidPtr->reconInProgress--;\n\t\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\t\treturn(retcode);\n\t\t\t}\n\t\t\traidPtr->Disks[row][col].blockSize =\n\t\t\t\tdpart.disklab->d_secsize;\n\n\t\t\traidPtr->Disks[row][col].numBlocks = \n\t\t\t\tdpart.part->p_size - rf_protectedSectors;\n\t\t\t\n\t\t\traidPtr->raid_cinfo[row][col].ci_vp = vp;\n\t\t\traidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;\n\t\t\t\n\t\t\traidPtr->Disks[row][col].dev = va.va_rdev;\n\t\t\t\n\t\t\t/* we allow the user to specify that only a \n\t\t\t   fraction of the disks should be used this is \n\t\t\t   just for debug:  it speeds up\n\t\t\t * the parity scan */\n\t\t\traidPtr->Disks[row][col].numBlocks =\n\t\t\t\traidPtr->Disks[row][col].numBlocks *\n\t\t\t\trf_sizePercentage / 100;\n\t\t}\n\n\n\n\t\tspareDiskPtr = &raidPtr->Disks[row][col];\n\t\tspareDiskPtr->status = rf_ds_used_spare;\n\n\t\tprintf(\"RECON: initiating in-place reconstruction on\\n\");\n\t\tprintf(\"       row %d col %d -> spare at row %d col %d\\n\", \n\t\t       row, col, row, col);\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\n\t\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, \n\t\t\t\t\t       spareDiskPtr, numDisksDone, \n\t\t\t\t\t       row, col);\n\t\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\t\treconDesc->hsStallCount = 0;\n\t\treconDesc->numReconExecDelays = 0;\n\t\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\treconDesc->reconExecTimerRunning = 0;\n\t\treconDesc->reconExecTicks = 0;\n\t\treconDesc->maxReconExecTicks = 0;\n\t\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->reconInProgress--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t} else {\n\t\tRF_ERRORMSG1(\"RECON: no way to reconstruct failed disk for arch %c\\n\",\n\t\t\t     lp->parityConfig);\n\t\trc = EIO;\n\t}\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\n\tif (!rc) {\n\t\t/* Need to set these here, as at this point it'll be claiming\n\t\t   that the disk is in rf_ds_spared!  But we know better :-) */\n\t\t\n\t\traidPtr->Disks[row][col].status = rf_ds_optimal;\n\t\traidPtr->status[row] = rf_rs_optimal;\n\t\t\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(raidPtr->raid_cinfo[row][col].ci_dev,\n\t\t\t\t\t raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\t &c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(raidPtr->raid_cinfo[row][col].ci_dev,\n\t\t\t\t\t  raidPtr->raid_cinfo[row][col].ci_vp,\n\t\t\t\t\t  &c_label);\n\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tRF_SIGNAL_COND(raidPtr->waitForReconCond);\n\twakeup(&raidPtr->waitForReconCond);\t\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_ReconstructFailedDiskBasic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "283-365",
    "snippet": "int \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;",
      "RF_RaidDisk_t *spareDiskPtr;",
      "int     numDisksDone;",
      "RF_RowCol_t srow;",
      "RF_RowCol_t scol;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raidwrite_component_label",
          "args": [
            "raidPtr->raid_cinfo[srow][scol].ci_dev",
            "raidPtr->raid_cinfo[srow][scol].ci_vp",
            "&c_label"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "raidwrite_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1985-2017",
          "snippet": "int \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint \nraidwrite_component_label(dev, b_vp, component_label)\n\tdev_t dev; \n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the write */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_WRITE;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\tmemset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );\n\n\tmemcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\terror = biowait(bp); \n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp);\n\tif (error) {\n\t\tprintf(\"Failed to write RAID component info!\\n\");\n\t}\n\n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raidread_component_label",
          "args": [
            "raidPtr->raid_cinfo[srow][scol].ci_dev",
            "raidPtr->raid_cinfo[srow][scol].ci_vp",
            "&c_label"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "raidread_component_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "1935-1983",
          "snippet": "int\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [
            "#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */",
            "#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */"
          ],
          "globals_used": [
            "static void KernelWakeupFunc(struct buf * bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\n#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */\n#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */\n\nstatic void KernelWakeupFunc(struct buf * bp);\n\nint\nraidread_component_label(dev, b_vp, component_label)\n\tdev_t dev;\n\tstruct vnode *b_vp;\n\tRF_ComponentLabel_t *component_label;\n{\n\tstruct buf *bp;\n\tint error;\n\t\n\t/* XXX should probably ensure that we don't try to do this if\n\t   someone has changed rf_protected_sectors. */ \n\n\t/* get a block of the appropriate size... */\n\tbp = geteblk((int)RF_COMPONENT_INFO_SIZE);\n\tbp->b_dev = dev;\n\n\t/* get our ducks in a row for the read */\n\tbp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;\n\tbp->b_bcount = RF_COMPONENT_INFO_SIZE;\n\tbp->b_flags = B_BUSY | B_READ;\n \tbp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;\n\n\t(*bdevsw[major(bp->b_dev)].d_strategy)(bp);\n\n\terror = biowait(bp); \n\n\tif (!error) {\n\t\tmemcpy(component_label, bp->b_un.b_addr,\n\t\t       sizeof(RF_ComponentLabel_t));\n#if 0\n\t\tprintf(\"raidread_component_label: got component label:\\n\");\n\t\tprintf(\"Version: %d\\n\",component_label->version);\n\t\tprintf(\"Serial Number: %d\\n\",component_label->serial_number);\n\t\tprintf(\"Mod counter: %d\\n\",component_label->mod_counter);\n\t\tprintf(\"Row: %d\\n\", component_label->row);\n\t\tprintf(\"Column: %d\\n\", component_label->column);\n\t\tprintf(\"Num Rows: %d\\n\", component_label->num_rows);\n\t\tprintf(\"Num Columns: %d\\n\", component_label->num_columns);\n\t\tprintf(\"Clean: %d\\n\", component_label->clean);\n\t\tprintf(\"Status: %d\\n\", component_label->status);\n#endif\n        } else {\n\t\tprintf(\"Failed to read RAID component label!\\n\");\n\t}\n\n        bp->b_flags = B_INVAL | B_AGE;\n\tbrelse(bp); \n\treturn(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ContinueReconstructFailedDisk",
          "args": [
            "reconDesc"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ContinueReconstructFailedDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "601-773",
          "snippet": "int \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int rf_ProcessReconEvent",
            "int rf_IssueNextReadRequest",
            "void rf_FreeReconDesc",
            "void rf_SignalReconDone",
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;",
            "int     numDisksDone;",
            "RF_RowCol_t srow;",
            "RF_RowCol_t scol;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nint rf_ProcessReconEvent;\nint rf_IssueNextReadRequest;\nvoid rf_FreeReconDesc;\nvoid rf_SignalReconDone;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ContinueReconstructFailedDisk(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tRF_Raid_t *raidPtr = reconDesc->raidPtr;\n\tRF_RowCol_t row = reconDesc->row;\n\tRF_RowCol_t col = reconDesc->col;\n\tRF_RowCol_t srow = reconDesc->srow;\n\tRF_RowCol_t scol = reconDesc->scol;\n\tRF_ReconMap_t *mapPtr;\n\n\tRF_ReconEvent_t *event;\n\tstruct timeval etime, elpsd;\n\tunsigned long xor_s, xor_resid_us;\n\tint     retcode, i, ds;\n\n\tswitch (reconDesc->state) {\n\tcase 0:\n\t\traidPtr->accumXorTimeUs = 0;\n\n\t\t/* create one trace record per physical disk */\n\t\tRF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));\n\n\t\t/* quiesce the array prior to starting recon.  this is needed\n\t\t * to assure no nasty interactions with pending user writes.\n\t\t * We need to do this before we change the disk or row status. */\n\t\treconDesc->state = 1;\n\n\t\tDprintf(\"RECON: begin request suspend\\n\");\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\tDprintf(\"RECON: end request suspend\\n\");\n\t\trf_StartUserStats(raidPtr);\t/* zero out the stats kept on\n\t\t\t\t\t\t * user accs */\n\t\t/* fall through to state 1 */\n\tcase 1:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\n\t\t/* create the reconstruction control pointer and install it in\n\t\t * the right slot */\n\t\traidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\traidPtr->status[row] = rf_rs_reconstructing;\n\t\traidPtr->Disks[row][col].status = rf_ds_reconstructing;\n\t\traidPtr->Disks[row][col].spareRow = srow;\n\t\traidPtr->Disks[row][col].spareCol = scol;\n\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\t\tRF_GETTIME(raidPtr->reconControl[row]->starttime);\n\n\t\t/* now start up the actual reconstruction: issue a read for\n\t\t * each surviving disk */\n\n\t\treconDesc->numDisksDone = 0;\n\t\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\t\tif (i != col) {\n\t\t\t\t/* find and issue the next I/O on the\n\t\t\t\t * indicated disk */\n\t\t\t\tif (rf_IssueNextReadRequest(raidPtr, row, i)) {\n\t\t\t\t\tDprintf2(\"RECON: done issuing for r%d c%d\\n\", row, i);\n\t\t\t\t\treconDesc->numDisksDone++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 2;\n\n\tcase 2:\n\t\tDprintf(\"RECON: resume requests\\n\");\n\t\trf_ResumeNewRequests(raidPtr);\n\n\n\t\treconDesc->state = 3;\n\n\tcase 3:\n\n\t\t/* process reconstruction events until all disks report that\n\t\t * they've completed all work */\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\n\t\twhile (reconDesc->numDisksDone < raidPtr->numCol - 1) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\tif (rf_ProcessReconEvent(raidPtr, row, event))\n\t\t\t\treconDesc->numDisksDone++;\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\n\t\treconDesc->state = 4;\n\n\tcase 4:\n\t\tmapPtr = raidPtr->reconControl[row]->reconMap;\n\t\tif (rf_reconDebug) {\n\t\t\tprintf(\"RECON: all reads completed\\n\");\n\t\t}\n\t\t/* at this point all the reads have completed.  We now wait\n\t\t * for any pending writes to complete, and then we're done */\n\n\t\twhile (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {\n\n\t\t\tevent = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);\n\t\t\tRF_ASSERT(event);\n\n\t\t\t(void) rf_ProcessReconEvent(raidPtr, row, event);\t/* ignore return code */\n\t\t\traidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);\n\t\t\tif (rf_prReconSched) {\n\t\t\t\trf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));\n\t\t\t}\n\t\t}\n\t\treconDesc->state = 5;\n\n\tcase 5:\n\t\t/* Success:  mark the dead disk as reconstructed.  We quiesce\n\t\t * the array here to assure no nasty interactions with pending\n\t\t * user accesses when we free up the psstatus structure as\n\t\t * part of FreeReconControl() */\n\n\t\treconDesc->state = 6;\n\n\t\tretcode = rf_SuspendNewRequestsAndWait(raidPtr);\n\t\trf_StopUserStats(raidPtr);\n\t\trf_PrintUserStats(raidPtr);\t/* print out the stats on user\n\t\t\t\t\t\t * accs accumulated during\n\t\t\t\t\t\t * recon */\n\n\t\t/* fall through to state 6 */\n\tcase 6:\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->numFailures--;\n\t\tds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);\n\t\traidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;\n\t\traidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\tRF_GETTIME(etime);\n\t\tRF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);\n\n\t\t/* XXX -- why is state 7 different from state 6 if there is no\n\t\t * return() here? -- XXX Note that I set elpsd above & use it\n\t\t * below, so if you put a return here you'll have to fix this.\n\t\t * (also, FreeReconControl is called below) */\n\n\tcase 7:\n\n\t\trf_ResumeNewRequests(raidPtr);\n\n\t\tprintf(\"Reconstruction of disk at row %d col %d completed and spare disk reassigned\\n\", row, col);\n\t\txor_s = raidPtr->accumXorTimeUs / 1000000;\n\t\txor_resid_us = raidPtr->accumXorTimeUs % 1000000;\n\t\tprintf(\"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\\n\",\n\t\t    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);\n\t\tprintf(\"  (start time %d sec %d usec, end time %d sec %d usec)\\n\",\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_sec,\n\t\t    (int) raidPtr->reconControl[row]->starttime.tv_usec,\n\t\t    (int) etime.tv_sec, (int) etime.tv_usec);\n\n#if RF_RECON_STATS > 0\n\t\tprintf(\"Total head-sep stall count was %d\\n\",\n\t\t    (int) reconDesc->hsStallCount);\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\t\trf_FreeReconControl(raidPtr, row);\n\t\tRF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));\n\t\trf_FreeReconDesc(reconDesc);\n\n\t}\n\n\trf_SignalReconDone(raidPtr);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_AllocRaidReconDesc",
          "args": [
            "(void *) raidPtr",
            "row",
            "col",
            "spareDiskPtr",
            "numDisksDone",
            "srow",
            "scol"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\"",
            "row",
            "col",
            "srow",
            "scol"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\"",
            "row",
            "col"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\"",
            "row",
            "col"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->Disks[row][col].status == rf_ds_failed"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nRF_RaidDisk_t *spareDiskPtr;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_ReconstructFailedDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "247-281",
    "snippet": "int \nrf_ReconstructFailedDisk(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_LayoutSW_t *lp;\n\tint     rc;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->SubmitReconBuffer) {\n\t\t/*\n\t         * The current infrastructure only supports reconstructing one\n\t         * disk at a time for each array.\n\t         */\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\twhile (raidPtr->reconInProgress) {\n\t\t\tRF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);\n\t\t}\n\t\traidPtr->reconInProgress++;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\trc = rf_ReconstructFailedDiskBasic(raidPtr, row, col);\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->reconInProgress--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t} else {\n\t\tRF_ERRORMSG1(\"RECON: no way to reconstruct failed disk for arch %c\\n\",\n\t\t    lp->parityConfig);\n\t\trc = EIO;\n\t}\n\tRF_SIGNAL_COND(raidPtr->waitForReconCond);\n\twakeup(&raidPtr->waitForReconCond);\t/* XXX Methinks this will be\n\t\t\t\t\t\t * needed at some point... GO */\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
      "RF_RowCol_t row;",
      "RF_RowCol_t col;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&raidPtr->waitForReconCond"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_SIGNAL_COND",
          "args": [
            "raidPtr->waitForReconCond"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"RECON: no way to reconstruct failed disk for arch %c\\n\"",
            "lp->parityConfig"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReconstructFailedDiskBasic",
          "args": [
            "raidPtr",
            "row",
            "col"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReconstructFailedDiskBasic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "283-365",
          "snippet": "int \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;",
            "RF_RaidDisk_t *spareDiskPtr;",
            "int     numDisksDone;",
            "RF_RowCol_t srow;",
            "RF_RowCol_t scol;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nRF_RaidDisk_t *spareDiskPtr;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "raidPtr->waitForReconCond",
            "raidPtr->mutex"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\n\nint \nrf_ReconstructFailedDisk(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_LayoutSW_t *lp;\n\tint     rc;\n\n\tlp = raidPtr->Layout.map;\n\tif (lp->SubmitReconBuffer) {\n\t\t/*\n\t         * The current infrastructure only supports reconstructing one\n\t         * disk at a time for each array.\n\t         */\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\twhile (raidPtr->reconInProgress) {\n\t\t\tRF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);\n\t\t}\n\t\traidPtr->reconInProgress++;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\trc = rf_ReconstructFailedDiskBasic(raidPtr, row, col);\n\t\tRF_LOCK_MUTEX(raidPtr->mutex);\n\t\traidPtr->reconInProgress--;\n\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t} else {\n\t\tRF_ERRORMSG1(\"RECON: no way to reconstruct failed disk for arch %c\\n\",\n\t\t    lp->parityConfig);\n\t\trc = EIO;\n\t}\n\tRF_SIGNAL_COND(raidPtr->waitForReconCond);\n\twakeup(&raidPtr->waitForReconCond);\t/* XXX Methinks this will be\n\t\t\t\t\t\t * needed at some point... GO */\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_FreeReconDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "222-237",
    "snippet": "void \nrf_FreeReconDesc(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n#if RF_RECON_STATS > 0\n\tprintf(\"RAIDframe: %qu recon event waits, %qu recon delays\\n\",\n\t    reconDesc->numReconEventWaits, reconDesc->numReconExecDelays);\n#endif /* RF_RECON_STATS > 0 */\n\n\tprintf(\"RAIDframe: %qu max exec ticks\\n\", reconDesc->maxReconExecTicks);\n\n#if (RF_RECON_STATS > 0) || defined(_KERNEL)\n\tprintf(\"\\n\");\n#endif /* (RF_RECON_STATS > 0) || _KERNEL */\n\tRF_FREELIST_FREE(rf_recond_freelist, reconDesc, next);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_recond_freelist;",
      "void rf_FreeReconDesc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_recond_freelist",
            "reconDesc",
            "next"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_recond_freelist;\nvoid rf_FreeReconDesc;\n\nvoid \nrf_FreeReconDesc(reconDesc)\n\tRF_RaidReconDesc_t *reconDesc;\n{\n#if RF_RECON_STATS > 0\n\tprintf(\"RAIDframe: %qu recon event waits, %qu recon delays\\n\",\n\t    reconDesc->numReconEventWaits, reconDesc->numReconExecDelays);\n#endif /* RF_RECON_STATS > 0 */\n\n\tprintf(\"RAIDframe: %qu max exec ticks\\n\", reconDesc->maxReconExecTicks);\n\n#if (RF_RECON_STATS > 0) || defined(_KERNEL)\n\tprintf(\"\\n\");\n#endif /* (RF_RECON_STATS > 0) || _KERNEL */\n\tRF_FREELIST_FREE(rf_recond_freelist, reconDesc, next);\n}"
  },
  {
    "function_name": "rf_ConfigureReconstruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "168-192",
    "snippet": "int \nrf_ConfigureReconstruction(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_recond_freelist, RF_MAX_FREE_RECOND,\n\t    RF_RECOND_INC, sizeof(RF_RaidReconDesc_t));\n\tif (rf_recond_freelist == NULL)\n\t\treturn (ENOMEM);\n\tRF_FREELIST_CREATE(rf_rdp_freelist, RF_MAX_FREE_RDP,\n\t    RF_RDP_INC, sizeof(RF_ReconDoneProc_t));\n\tif (rf_rdp_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownReconstruction, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownReconstruction(NULL);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_RDP_INC      1",
      "#define RF_MAX_FREE_RDP 4",
      "#define RF_RECOND_INC       1",
      "#define RF_MAX_FREE_RECOND  4"
    ],
    "globals_used": [
      "static RF_FreeList_t *rf_recond_freelist;",
      "void rf_ShutdownReconstruction",
      "static RF_FreeList_t *rf_rdp_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ShutdownReconstruction",
          "args": [
            "NULL"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownReconstruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "160-166",
          "snippet": "void \nrf_ShutdownReconstruction(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\tRF_FREELIST_DESTROY(rf_rdp_freelist, next, (RF_ReconDoneProc_t *));\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_recond_freelist;",
            "void rf_ShutdownReconstruction",
            "static RF_FreeList_t *rf_rdp_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_recond_freelist;\nvoid rf_ShutdownReconstruction;\nstatic RF_FreeList_t *rf_rdp_freelist;\n\nvoid \nrf_ShutdownReconstruction(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\tRF_FREELIST_DESTROY(rf_rdp_freelist, next, (RF_ReconDoneProc_t *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownReconstruction",
            "NULL"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_recond_freelist",
            "next",
            "(RF_RaidReconDesc_t *)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_rdp_freelist",
            "RF_MAX_FREE_RDP",
            "RF_RDP_INC",
            "sizeof(RF_ReconDoneProc_t)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_recond_freelist",
            "RF_MAX_FREE_RECOND",
            "RF_RECOND_INC",
            "sizeof(RF_RaidReconDesc_t)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\n#define RF_RDP_INC      1\n#define RF_MAX_FREE_RDP 4\n#define RF_RECOND_INC       1\n#define RF_MAX_FREE_RECOND  4\n\nstatic RF_FreeList_t *rf_recond_freelist;\nvoid rf_ShutdownReconstruction;\nstatic RF_FreeList_t *rf_rdp_freelist;\n\nint \nrf_ConfigureReconstruction(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_recond_freelist, RF_MAX_FREE_RECOND,\n\t    RF_RECOND_INC, sizeof(RF_RaidReconDesc_t));\n\tif (rf_recond_freelist == NULL)\n\t\treturn (ENOMEM);\n\tRF_FREELIST_CREATE(rf_rdp_freelist, RF_MAX_FREE_RDP,\n\t    RF_RDP_INC, sizeof(RF_ReconDoneProc_t));\n\tif (rf_rdp_freelist == NULL) {\n\t\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownReconstruction, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownReconstruction(NULL);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownReconstruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "160-166",
    "snippet": "void \nrf_ShutdownReconstruction(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\tRF_FREELIST_DESTROY(rf_rdp_freelist, next, (RF_ReconDoneProc_t *));\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_recond_freelist;",
      "void rf_ShutdownReconstruction",
      "static RF_FreeList_t *rf_rdp_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_rdp_freelist",
            "next",
            "(RF_ReconDoneProc_t *)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_recond_freelist",
            "next",
            "(RF_RaidReconDesc_t *)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_recond_freelist;\nvoid rf_ShutdownReconstruction;\nstatic RF_FreeList_t *rf_rdp_freelist;\n\nvoid \nrf_ShutdownReconstruction(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));\n\tRF_FREELIST_DESTROY(rf_rdp_freelist, next, (RF_ReconDoneProc_t *));\n}"
  },
  {
    "function_name": "rf_RegisterReconDoneProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "129-150",
    "snippet": "int \nrf_RegisterReconDoneProc(\n    RF_Raid_t * raidPtr,\n    void (*proc) (RF_Raid_t *, void *),\n    void *arg,\n    RF_ReconDoneProc_t ** handlep)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_FREELIST_GET(rf_rdp_freelist, p, next, (RF_ReconDoneProc_t *));\n\tif (p == NULL)\n\t\treturn (ENOMEM);\n\tp->proc = proc;\n\tp->arg = arg;\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tp->next = raidPtr->recon_done_procs;\n\traidPtr->recon_done_procs = p;\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tif (handlep)\n\t\t*handlep = p;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_rdp_freelist;",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->recon_done_proc_mutex"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->recon_done_proc_mutex"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_rdp_freelist",
            "p",
            "next",
            "(RF_ReconDoneProc_t *)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_rdp_freelist;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\n\nint \nrf_RegisterReconDoneProc(\n    RF_Raid_t * raidPtr,\n    void (*proc) (RF_Raid_t *, void *),\n    void *arg,\n    RF_ReconDoneProc_t ** handlep)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_FREELIST_GET(rf_rdp_freelist, p, next, (RF_ReconDoneProc_t *));\n\tif (p == NULL)\n\t\treturn (ENOMEM);\n\tp->proc = proc;\n\tp->arg = arg;\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tp->next = raidPtr->recon_done_procs;\n\traidPtr->recon_done_procs = p;\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tif (handlep)\n\t\t*handlep = p;\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_SignalReconDone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
    "lines": "117-127",
    "snippet": "void \nrf_SignalReconDone(RF_Raid_t * raidPtr)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tfor (p = raidPtr->recon_done_procs; p; p = p->next) {\n\t\tp->proc(raidPtr, p->arg);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n}",
    "includes": [
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_reconbuffer.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_reconutil.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include <sys/errno.h>",
      "#include <sys/buf.h>",
      "#include <sys/time.h>",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_SignalReconDone",
      "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->recon_done_proc_mutex"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->proc",
          "args": [
            "raidPtr",
            "p->arg"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->recon_done_proc_mutex"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nvoid rf_SignalReconDone;\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\n\nvoid \nrf_SignalReconDone(RF_Raid_t * raidPtr)\n{\n\tRF_ReconDoneProc_t *p;\n\n\tRF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n\tfor (p = raidPtr->recon_done_procs; p; p = p->next) {\n\t\tp->proc(raidPtr, p->arg);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);\n}"
  }
]