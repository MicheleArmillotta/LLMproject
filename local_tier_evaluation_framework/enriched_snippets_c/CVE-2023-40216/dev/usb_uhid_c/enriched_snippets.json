[
  {
    "function_name": "uhidpoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "717-744",
    "snippet": "int\nuhidpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tint revents = 0;\n\tint s;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\ts = splusb();\n\tif (events & (POLLOUT | POLLWRNORM))\n\t\trevents |= events & (POLLOUT | POLLWRNORM);\n\tif (events & (POLLIN | POLLRDNORM)) {\n\t\tif (sc->sc_q.c_cc > 0)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &sc->sc_rsel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sc->sc_rsel"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhidpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tint revents = 0;\n\tint s;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\ts = splusb();\n\tif (events & (POLLOUT | POLLWRNORM))\n\t\trevents |= events & (POLLOUT | POLLWRNORM);\n\tif (events & (POLLIN | POLLRDNORM)) {\n\t\tif (sc->sc_q.c_cc > 0)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &sc->sc_rsel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}"
  },
  {
    "function_name": "uhidioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "697-715",
    "snippet": "int\nuhidioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_ioctl(sc, cmd, addr, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhid_do_ioctl",
          "args": [
            "sc",
            "cmd",
            "addr",
            "flag",
            "p"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "uhid_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
          "lines": "582-695",
          "snippet": "int\nuhid_do_ioctl(sc, cmd, addr, flag, p)\n\tstruct uhid_softc *sc;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_ctl_report_desc *rd;\n\tstruct usb_ctl_report *re;\n\tint size, id;\n\tusbd_status err;\n\n\tDPRINTFN(2, (\"uhidioctl: cmd=%lx\\n\", cmd));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async != NULL)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async = p;\n\t\t\tDPRINTF((\"uhid_do_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async = NULL;\n\t\tbreak;\n\n\t/* XXX this is not the most general solution. */\n\tcase TIOCSPGRP:\n\t\tif (sc->sc_async == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (*(int *)addr != sc->sc_async->p_pgid)\n\t\t\treturn (EPERM);\n\t\tbreak;\n\n\tcase USB_GET_REPORT_DESC:\n\t\trd = (struct usb_ctl_report_desc *)addr;\n\t\tsize = min(sc->sc_repdesc_size, sizeof rd->data);\n\t\trd->size = size;\n\t\tmemcpy(rd->data, sc->sc_repdesc, size);\n\t\tbreak;\n\n\tcase USB_SET_IMMED:\n\t\tif (*(int *)addr) {\n\t\t\t/* XXX should read into ibuf, but does it matter? */\n\t\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);\n\t\t\tif (err)\n\t\t\t\treturn (EOPNOTSUPP);\n\n\t\t\tsc->sc_state |=  UHID_IMMED;\n\t\t} else\n\t\t\tsc->sc_state &= ~UHID_IMMED;\n\t\tbreak;\n\n\tcase USB_GET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_get_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tcase USB_SET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_set_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/filio.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UHID_IMMED\t0x08\t/* return read data immediately */"
          ],
          "globals_used": [
            "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
            "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UHID_IMMED\t0x08\t/* return read data immediately */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhid_do_ioctl(sc, cmd, addr, flag, p)\n\tstruct uhid_softc *sc;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_ctl_report_desc *rd;\n\tstruct usb_ctl_report *re;\n\tint size, id;\n\tusbd_status err;\n\n\tDPRINTFN(2, (\"uhidioctl: cmd=%lx\\n\", cmd));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async != NULL)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async = p;\n\t\t\tDPRINTF((\"uhid_do_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async = NULL;\n\t\tbreak;\n\n\t/* XXX this is not the most general solution. */\n\tcase TIOCSPGRP:\n\t\tif (sc->sc_async == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (*(int *)addr != sc->sc_async->p_pgid)\n\t\t\treturn (EPERM);\n\t\tbreak;\n\n\tcase USB_GET_REPORT_DESC:\n\t\trd = (struct usb_ctl_report_desc *)addr;\n\t\tsize = min(sc->sc_repdesc_size, sizeof rd->data);\n\t\trd->size = size;\n\t\tmemcpy(rd->data, sc->sc_repdesc, size);\n\t\tbreak;\n\n\tcase USB_SET_IMMED:\n\t\tif (*(int *)addr) {\n\t\t\t/* XXX should read into ibuf, but does it matter? */\n\t\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);\n\t\t\tif (err)\n\t\t\t\treturn (EOPNOTSUPP);\n\n\t\t\tsc->sc_state |=  UHID_IMMED;\n\t\t} else\n\t\t\tsc->sc_state &= ~UHID_IMMED;\n\t\tbreak;\n\n\tcase USB_GET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_get_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tcase USB_SET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_set_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhidioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_ioctl(sc, cmd, addr, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "uhid_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "582-695",
    "snippet": "int\nuhid_do_ioctl(sc, cmd, addr, flag, p)\n\tstruct uhid_softc *sc;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_ctl_report_desc *rd;\n\tstruct usb_ctl_report *re;\n\tint size, id;\n\tusbd_status err;\n\n\tDPRINTFN(2, (\"uhidioctl: cmd=%lx\\n\", cmd));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async != NULL)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async = p;\n\t\t\tDPRINTF((\"uhid_do_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async = NULL;\n\t\tbreak;\n\n\t/* XXX this is not the most general solution. */\n\tcase TIOCSPGRP:\n\t\tif (sc->sc_async == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (*(int *)addr != sc->sc_async->p_pgid)\n\t\t\treturn (EPERM);\n\t\tbreak;\n\n\tcase USB_GET_REPORT_DESC:\n\t\trd = (struct usb_ctl_report_desc *)addr;\n\t\tsize = min(sc->sc_repdesc_size, sizeof rd->data);\n\t\trd->size = size;\n\t\tmemcpy(rd->data, sc->sc_repdesc, size);\n\t\tbreak;\n\n\tcase USB_SET_IMMED:\n\t\tif (*(int *)addr) {\n\t\t\t/* XXX should read into ibuf, but does it matter? */\n\t\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);\n\t\t\tif (err)\n\t\t\t\treturn (EOPNOTSUPP);\n\n\t\t\tsc->sc_state |=  UHID_IMMED;\n\t\t} else\n\t\t\tsc->sc_state &= ~UHID_IMMED;\n\t\tbreak;\n\n\tcase USB_GET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_get_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tcase USB_SET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_set_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UHID_IMMED\t0x08\t/* return read data immediately */"
    ],
    "globals_used": [
      "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
      "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_set_report",
          "args": [
            "sc->sc_iface",
            "re->report",
            "id",
            "re->data",
            "size"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_report_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "305-330",
          "snippet": "usbd_status\nusbd_set_report_async(iface, type, id, data, len)\n\tusbd_interface_handle iface;\n\tint type;\n\tint id;\n\tvoid *data;\n\tint len;\n{\n\tusb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(4, (\"usbd_set_report_async: len=%d\\n\", len));\n\tif (ifd == NULL)\n\t\treturn (USBD_IOERROR);\n\terr = usbd_interface2device_handle(iface, &dev);\n\tif (err)\n\t\treturn (err);\n\treq.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\treq.bRequest = UR_SET_REPORT;\n\tUSETW2(req.wValue, type, id);\n\tUSETW(req.wIndex, ifd->bInterfaceNumber);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request_async(dev, &req, data));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_set_report_async(iface, type, id, data, len)\n\tusbd_interface_handle iface;\n\tint type;\n\tint id;\n\tvoid *data;\n\tint len;\n{\n\tusb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(4, (\"usbd_set_report_async: len=%d\\n\", len));\n\tif (ifd == NULL)\n\t\treturn (USBD_IOERROR);\n\terr = usbd_interface2device_handle(iface, &dev);\n\tif (err)\n\t\treturn (err);\n\treq.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\treq.bRequest = UR_SET_REPORT;\n\tUSETW2(req.wValue, type, id);\n\tUSETW(req.wIndex, ifd->bInterfaceNumber);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request_async(dev, &req, data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_report",
          "args": [
            "sc->sc_iface",
            "re->report",
            "id",
            "re->data",
            "size"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_report_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "384-400",
          "snippet": "usbd_status\nusbd_get_report_descriptor(dev, ifcno, repid, size, d)\n\tusbd_device_handle dev;\n\tint ifcno;\n\tint repid;\n\tint size;\n\tvoid *d;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_REPORT, repid);\n\tUSETW(req.wIndex, ifcno);\n\tUSETW(req.wLength, size);\n\treturn (usbd_do_request(dev, &req, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_report_descriptor(dev, ifcno, repid, size, d)\n\tusbd_device_handle dev;\n\tint ifcno;\n\tint repid;\n\tint size;\n\tvoid *d;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_REPORT, repid);\n\tUSETW(req.wIndex, ifcno);\n\tUSETW(req.wLength, size);\n\treturn (usbd_do_request(dev, &req, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rd->data",
            "sc->sc_repdesc",
            "size"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_repdesc_size",
            "sizeof rd->data"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhid_do_ioctl: FIOASYNC %p\\n\", p)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhidioctl: cmd=%lx\\n\", cmd)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UHID_IMMED\t0x08\t/* return read data immediately */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhid_do_ioctl(sc, cmd, addr, flag, p)\n\tstruct uhid_softc *sc;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct usb_ctl_report_desc *rd;\n\tstruct usb_ctl_report *re;\n\tint size, id;\n\tusbd_status err;\n\n\tDPRINTFN(2, (\"uhidioctl: cmd=%lx\\n\", cmd));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tif (*(int *)addr) {\n\t\t\tif (sc->sc_async != NULL)\n\t\t\t\treturn (EBUSY);\n\t\t\tsc->sc_async = p;\n\t\t\tDPRINTF((\"uhid_do_ioctl: FIOASYNC %p\\n\", p));\n\t\t} else\n\t\t\tsc->sc_async = NULL;\n\t\tbreak;\n\n\t/* XXX this is not the most general solution. */\n\tcase TIOCSPGRP:\n\t\tif (sc->sc_async == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (*(int *)addr != sc->sc_async->p_pgid)\n\t\t\treturn (EPERM);\n\t\tbreak;\n\n\tcase USB_GET_REPORT_DESC:\n\t\trd = (struct usb_ctl_report_desc *)addr;\n\t\tsize = min(sc->sc_repdesc_size, sizeof rd->data);\n\t\trd->size = size;\n\t\tmemcpy(rd->data, sc->sc_repdesc, size);\n\t\tbreak;\n\n\tcase USB_SET_IMMED:\n\t\tif (*(int *)addr) {\n\t\t\t/* XXX should read into ibuf, but does it matter? */\n\t\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);\n\t\t\tif (err)\n\t\t\t\treturn (EOPNOTSUPP);\n\n\t\t\tsc->sc_state |=  UHID_IMMED;\n\t\t} else\n\t\t\tsc->sc_state &= ~UHID_IMMED;\n\t\tbreak;\n\n\tcase USB_GET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_get_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tcase USB_SET_REPORT:\n\t\tre = (struct usb_ctl_report *)addr;\n\t\tswitch (re->report) {\n\t\tcase UHID_INPUT_REPORT:\n\t\t\tsize = sc->sc_isize;\n\t\t\tid = sc->sc_iid;\n\t\t\tbreak;\n\t\tcase UHID_OUTPUT_REPORT:\n\t\t\tsize = sc->sc_osize;\n\t\t\tid = sc->sc_oid;\n\t\t\tbreak;\n\t\tcase UHID_FEATURE_REPORT:\n\t\t\tsize = sc->sc_fsize;\n\t\t\tid = sc->sc_fid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\terr = usbd_set_report(sc->sc_iface, re->report, id, re->data,\n\t\t\t  size);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "uhidwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "564-580",
    "snippet": "int\nuhidwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_write(sc, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
      "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhid_do_write",
          "args": [
            "sc",
            "uio",
            "flag"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "uhid_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
          "lines": "530-562",
          "snippet": "int\nuhid_do_write(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint error;\n\tint size;\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidwrite\\n\"));\n\t\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsize = sc->sc_osize;\n\terror = 0;\n\tif (uio->uio_resid != size)\n\t\treturn (EINVAL);\n\terror = uiomove(sc->sc_obuf, size, uio);\n\tif (!error) {\n\t\tif (sc->sc_oid)\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  sc->sc_obuf[0], sc->sc_obuf+1, size-1);\n\t\telse\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  0, sc->sc_obuf, size);\n\t\tif (err)\n\t\t\terror = EIO;\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/filio.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
            "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
            "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhid_do_write(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint error;\n\tint size;\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidwrite\\n\"));\n\t\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsize = sc->sc_osize;\n\terror = 0;\n\tif (uio->uio_resid != size)\n\t\treturn (EINVAL);\n\terror = uiomove(sc->sc_obuf, size, uio);\n\tif (!error) {\n\t\tif (sc->sc_oid)\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  sc->sc_obuf[0], sc->sc_obuf+1, size-1);\n\t\telse\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  0, sc->sc_obuf, size);\n\t\tif (err)\n\t\t\terror = EIO;\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhidwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_write(sc, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "uhid_do_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "530-562",
    "snippet": "int\nuhid_do_write(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint error;\n\tint size;\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidwrite\\n\"));\n\t\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsize = sc->sc_osize;\n\terror = 0;\n\tif (uio->uio_resid != size)\n\t\treturn (EINVAL);\n\terror = uiomove(sc->sc_obuf, size, uio);\n\tif (!error) {\n\t\tif (sc->sc_oid)\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  sc->sc_obuf[0], sc->sc_obuf+1, size-1);\n\t\telse\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  0, sc->sc_obuf, size);\n\t\tif (err)\n\t\t\terror = EIO;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
      "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
      "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_set_report",
          "args": [
            "sc->sc_iface",
            "UHID_OUTPUT_REPORT",
            "0",
            "sc->sc_obuf",
            "size"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_report_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "305-330",
          "snippet": "usbd_status\nusbd_set_report_async(iface, type, id, data, len)\n\tusbd_interface_handle iface;\n\tint type;\n\tint id;\n\tvoid *data;\n\tint len;\n{\n\tusb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(4, (\"usbd_set_report_async: len=%d\\n\", len));\n\tif (ifd == NULL)\n\t\treturn (USBD_IOERROR);\n\terr = usbd_interface2device_handle(iface, &dev);\n\tif (err)\n\t\treturn (err);\n\treq.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\treq.bRequest = UR_SET_REPORT;\n\tUSETW2(req.wValue, type, id);\n\tUSETW(req.wIndex, ifd->bInterfaceNumber);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request_async(dev, &req, data));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_set_report_async(iface, type, id, data, len)\n\tusbd_interface_handle iface;\n\tint type;\n\tint id;\n\tvoid *data;\n\tint len;\n{\n\tusb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);\n\tusbd_device_handle dev;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tDPRINTFN(4, (\"usbd_set_report_async: len=%d\\n\", len));\n\tif (ifd == NULL)\n\t\treturn (USBD_IOERROR);\n\terr = usbd_interface2device_handle(iface, &dev);\n\tif (err)\n\t\treturn (err);\n\treq.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n\treq.bRequest = UR_SET_REPORT;\n\tUSETW2(req.wValue, type, id);\n\tUSETW(req.wIndex, ifd->bInterfaceNumber);\n\tUSETW(req.wLength, len);\n\treturn (usbd_do_request_async(dev, &req, data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "sc->sc_obuf",
            "size",
            "uio"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhidwrite\\n\")"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhid_do_write(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint error;\n\tint size;\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidwrite\\n\"));\n\t\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsize = sc->sc_osize;\n\terror = 0;\n\tif (uio->uio_resid != size)\n\t\treturn (EINVAL);\n\terror = uiomove(sc->sc_obuf, size, uio);\n\tif (!error) {\n\t\tif (sc->sc_oid)\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  sc->sc_obuf[0], sc->sc_obuf+1, size-1);\n\t\telse\n\t\t\terr = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,\n\t\t\t\t  0, sc->sc_obuf, size);\n\t\tif (err)\n\t\t\terror = EIO;\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "uhidread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "512-528",
    "snippet": "int\nuhidread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_read(sc, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
      "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhid_do_read",
          "args": [
            "sc",
            "uio",
            "flag"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "uhid_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
          "lines": "447-510",
          "snippet": "int\nuhid_do_read(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint s;\n\tint error = 0;\n\tsize_t length;\n\tu_char buffer[UHID_CHUNK];\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidread\\n\"));\n\tif (sc->sc_state & UHID_IMMED) {\n\t\tDPRINTFN(1, (\"uhidread immed\\n\"));\n\t\t\n\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t    sc->sc_iid, buffer, sc->sc_isize);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\treturn (uiomove(buffer, sc->sc_isize, uio));\n\t}\n\n\ts = splusb();\n\twhile (sc->sc_q.c_cc == 0) {\n\t\tif (flag & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tsc->sc_state |= UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhidread: sleep on %p\\n\", sc));\n\t\terror = tsleep(&sc->sc_q, PZERO | PCATCH, \"uhidrea\", 0);\n\t\tDPRINTFN(5, (\"uhidread: woke, error=%d\\n\", error));\n\t\tif (sc->sc_dying)\n\t\t\terror = EIO;\n\t\tif (error) {\n\t\t\tsc->sc_state &= ~UHID_ASLP;\n\t\t\tbreak;\n\t\t}\n\t\tif (sc->sc_state & UHID_NEEDCLEAR) {\n\t\t\tDPRINTFN(-1,(\"uhidread: clearing stall\\n\"));\n\t\t\tsc->sc_state &= ~UHID_NEEDCLEAR;\n\t\t\tusbd_clear_endpoint_stall(sc->sc_intrpipe);\n\t\t}\n\t}\n\tsplx(s);\n\n\t/* Transfer as many chunks as possible. */\n\twhile (sc->sc_q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\tlength = min(sc->sc_q.c_cc, uio->uio_resid);\n\t\tif (length > sizeof(buffer))\n\t\t\tlength = sizeof(buffer);\n\n\t\t/* Remove a small chunk from the input queue. */\n\t\t(void) q_to_b(&sc->sc_q, buffer, length);\n\t\tDPRINTFN(5, (\"uhidread: got %lu chars\\n\", (u_long)length));\n\n\t\t/* Copy the data to the user process. */\n\t\tif ((error = uiomove(buffer, length, uio)) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/filio.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tUHID_CHUNK\t128\t/* chunk size for read */",
            "#define UHID_IMMED\t0x08\t/* return read data immediately */",
            "#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */",
            "#define\tUHID_ASLP\t0x02\t/* waiting for device data */"
          ],
          "globals_used": [
            "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
            "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
            "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUHID_CHUNK\t128\t/* chunk size for read */\n#define UHID_IMMED\t0x08\t/* return read data immediately */\n#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */\n#define\tUHID_ASLP\t0x02\t/* waiting for device data */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhid_do_read(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint s;\n\tint error = 0;\n\tsize_t length;\n\tu_char buffer[UHID_CHUNK];\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidread\\n\"));\n\tif (sc->sc_state & UHID_IMMED) {\n\t\tDPRINTFN(1, (\"uhidread immed\\n\"));\n\t\t\n\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t    sc->sc_iid, buffer, sc->sc_isize);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\treturn (uiomove(buffer, sc->sc_isize, uio));\n\t}\n\n\ts = splusb();\n\twhile (sc->sc_q.c_cc == 0) {\n\t\tif (flag & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tsc->sc_state |= UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhidread: sleep on %p\\n\", sc));\n\t\terror = tsleep(&sc->sc_q, PZERO | PCATCH, \"uhidrea\", 0);\n\t\tDPRINTFN(5, (\"uhidread: woke, error=%d\\n\", error));\n\t\tif (sc->sc_dying)\n\t\t\terror = EIO;\n\t\tif (error) {\n\t\t\tsc->sc_state &= ~UHID_ASLP;\n\t\t\tbreak;\n\t\t}\n\t\tif (sc->sc_state & UHID_NEEDCLEAR) {\n\t\t\tDPRINTFN(-1,(\"uhidread: clearing stall\\n\"));\n\t\t\tsc->sc_state &= ~UHID_NEEDCLEAR;\n\t\t\tusbd_clear_endpoint_stall(sc->sc_intrpipe);\n\t\t}\n\t}\n\tsplx(s);\n\n\t/* Transfer as many chunks as possible. */\n\twhile (sc->sc_q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\tlength = min(sc->sc_q.c_cc, uio->uio_resid);\n\t\tif (length > sizeof(buffer))\n\t\t\tlength = sizeof(buffer);\n\n\t\t/* Remove a small chunk from the input queue. */\n\t\t(void) q_to_b(&sc->sc_q, buffer, length);\n\t\tDPRINTFN(5, (\"uhidread: got %lu chars\\n\", (u_long)length));\n\n\t\t/* Copy the data to the user process. */\n\t\tif ((error = uiomove(buffer, length, uio)) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhidread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct uhid_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = uhid_do_read(sc, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "uhid_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "447-510",
    "snippet": "int\nuhid_do_read(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint s;\n\tint error = 0;\n\tsize_t length;\n\tu_char buffer[UHID_CHUNK];\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidread\\n\"));\n\tif (sc->sc_state & UHID_IMMED) {\n\t\tDPRINTFN(1, (\"uhidread immed\\n\"));\n\t\t\n\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t    sc->sc_iid, buffer, sc->sc_isize);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\treturn (uiomove(buffer, sc->sc_isize, uio));\n\t}\n\n\ts = splusb();\n\twhile (sc->sc_q.c_cc == 0) {\n\t\tif (flag & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tsc->sc_state |= UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhidread: sleep on %p\\n\", sc));\n\t\terror = tsleep(&sc->sc_q, PZERO | PCATCH, \"uhidrea\", 0);\n\t\tDPRINTFN(5, (\"uhidread: woke, error=%d\\n\", error));\n\t\tif (sc->sc_dying)\n\t\t\terror = EIO;\n\t\tif (error) {\n\t\t\tsc->sc_state &= ~UHID_ASLP;\n\t\t\tbreak;\n\t\t}\n\t\tif (sc->sc_state & UHID_NEEDCLEAR) {\n\t\t\tDPRINTFN(-1,(\"uhidread: clearing stall\\n\"));\n\t\t\tsc->sc_state &= ~UHID_NEEDCLEAR;\n\t\t\tusbd_clear_endpoint_stall(sc->sc_intrpipe);\n\t\t}\n\t}\n\tsplx(s);\n\n\t/* Transfer as many chunks as possible. */\n\twhile (sc->sc_q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\tlength = min(sc->sc_q.c_cc, uio->uio_resid);\n\t\tif (length > sizeof(buffer))\n\t\t\tlength = sizeof(buffer);\n\n\t\t/* Remove a small chunk from the input queue. */\n\t\t(void) q_to_b(&sc->sc_q, buffer, length);\n\t\tDPRINTFN(5, (\"uhidread: got %lu chars\\n\", (u_long)length));\n\n\t\t/* Copy the data to the user process. */\n\t\tif ((error = uiomove(buffer, length, uio)) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tUHID_CHUNK\t128\t/* chunk size for read */",
      "#define UHID_IMMED\t0x08\t/* return read data immediately */",
      "#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */",
      "#define\tUHID_ASLP\t0x02\t/* waiting for device data */"
    ],
    "globals_used": [
      "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
      "uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));",
      "uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "buffer",
            "length",
            "uio"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhidread: got %lu chars\\n\", (u_long)length)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q_to_b",
          "args": [
            "&sc->sc_q",
            "buffer",
            "length"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_q.c_cc",
            "uio->uio_resid"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->sc_intrpipe"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"uhidread: clearing stall\\n\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhidread: woke, error=%d\\n\", error)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&sc->sc_q",
            "PZERO | PCATCH",
            "\"uhidrea\"",
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhidread: sleep on %p\\n\", sc)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "buffer",
            "sc->sc_isize",
            "uio"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_report",
          "args": [
            "sc->sc_iface",
            "UHID_INPUT_REPORT",
            "sc->sc_iid",
            "buffer",
            "sc->sc_isize"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_report_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "384-400",
          "snippet": "usbd_status\nusbd_get_report_descriptor(dev, ifcno, repid, size, d)\n\tusbd_device_handle dev;\n\tint ifcno;\n\tint repid;\n\tint size;\n\tvoid *d;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_REPORT, repid);\n\tUSETW(req.wIndex, ifcno);\n\tUSETW(req.wLength, size);\n\treturn (usbd_do_request(dev, &req, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_report_descriptor(dev, ifcno, repid, size, d)\n\tusbd_device_handle dev;\n\tint ifcno;\n\tint repid;\n\tint size;\n\tvoid *d;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_INTERFACE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_REPORT, repid);\n\tUSETW(req.wIndex, ifcno);\n\tUSETW(req.wLength, size);\n\treturn (usbd_do_request(dev, &req, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhidread immed\\n\")"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhidread\\n\")"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUHID_CHUNK\t128\t/* chunk size for read */\n#define UHID_IMMED\t0x08\t/* return read data immediately */\n#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */\n#define\tUHID_ASLP\t0x02\t/* waiting for device data */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_read __P((struct uhid_softc *, struct uio *uio, int));\nuhid_do_write __P((struct uhid_softc *, struct uio *uio, int));\n\nint\nuhid_do_read(sc, uio, flag)\n\tstruct uhid_softc *sc;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint s;\n\tint error = 0;\n\tsize_t length;\n\tu_char buffer[UHID_CHUNK];\n\tusbd_status err;\n\n\tDPRINTFN(1, (\"uhidread\\n\"));\n\tif (sc->sc_state & UHID_IMMED) {\n\t\tDPRINTFN(1, (\"uhidread immed\\n\"));\n\t\t\n\t\terr = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,\n\t\t\t\t    sc->sc_iid, buffer, sc->sc_isize);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\treturn (uiomove(buffer, sc->sc_isize, uio));\n\t}\n\n\ts = splusb();\n\twhile (sc->sc_q.c_cc == 0) {\n\t\tif (flag & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tsc->sc_state |= UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhidread: sleep on %p\\n\", sc));\n\t\terror = tsleep(&sc->sc_q, PZERO | PCATCH, \"uhidrea\", 0);\n\t\tDPRINTFN(5, (\"uhidread: woke, error=%d\\n\", error));\n\t\tif (sc->sc_dying)\n\t\t\terror = EIO;\n\t\tif (error) {\n\t\t\tsc->sc_state &= ~UHID_ASLP;\n\t\t\tbreak;\n\t\t}\n\t\tif (sc->sc_state & UHID_NEEDCLEAR) {\n\t\t\tDPRINTFN(-1,(\"uhidread: clearing stall\\n\"));\n\t\t\tsc->sc_state &= ~UHID_NEEDCLEAR;\n\t\t\tusbd_clear_endpoint_stall(sc->sc_intrpipe);\n\t\t}\n\t}\n\tsplx(s);\n\n\t/* Transfer as many chunks as possible. */\n\twhile (sc->sc_q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\tlength = min(sc->sc_q.c_cc, uio->uio_resid);\n\t\tif (length > sizeof(buffer))\n\t\t\tlength = sizeof(buffer);\n\n\t\t/* Remove a small chunk from the input queue. */\n\t\t(void) q_to_b(&sc->sc_q, buffer, length);\n\t\tDPRINTFN(5, (\"uhidread: got %lu chars\\n\", (u_long)length));\n\n\t\t/* Copy the data to the user process. */\n\t\tif ((error = uiomove(buffer, length, uio)) != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "uhidclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "417-445",
    "snippet": "int\nuhidclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tDPRINTF((\"uhidclose: sc=%p\\n\", sc));\n\n\t/* Disable interrupts. */\n\tusbd_abort_pipe(sc->sc_intrpipe);\n\tusbd_close_pipe(sc->sc_intrpipe);\n\tsc->sc_intrpipe = 0;\n\n\tclfree(&sc->sc_q);\n\n\tfree(sc->sc_ibuf, M_USBDEV);\n\tfree(sc->sc_obuf, M_USBDEV);\n\n\tsc->sc_state &= ~UHID_OPEN;\n\n\tsc->sc_async = 0;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tUHID_OPEN\t0x01\t/* device is open */"
    ],
    "globals_used": [
      "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->sc_obuf",
            "M_USBDEV"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clfree",
          "args": [
            "&sc->sc_q"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->sc_intrpipe"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->sc_intrpipe"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhidclose: sc=%p\\n\", sc)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUHID_OPEN\t0x01\t/* device is open */\n\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhidclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\n\tUSB_GET_SC(uhid, UHIDUNIT(dev), sc);\n\n\tDPRINTF((\"uhidclose: sc=%p\\n\", sc));\n\n\t/* Disable interrupts. */\n\tusbd_abort_pipe(sc->sc_intrpipe);\n\tusbd_close_pipe(sc->sc_intrpipe);\n\tsc->sc_intrpipe = 0;\n\n\tclfree(&sc->sc_q);\n\n\tfree(sc->sc_ibuf, M_USBDEV);\n\tfree(sc->sc_obuf, M_USBDEV);\n\n\tsc->sc_state &= ~UHID_OPEN;\n\n\tsc->sc_async = 0;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "uhidopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "368-415",
    "snippet": "int\nuhidopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(uhid, UHIDUNIT(dev), sc);\n\n\tDPRINTF((\"uhidopen: sc=%p\\n\", sc));\n\n\tif (sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_state & UHID_OPEN)\n\t\treturn (EBUSY);\n\tsc->sc_state |= UHID_OPEN;\n\n\tif (clalloc(&sc->sc_q, UHID_BSIZE, 0) == -1) {\n\t\tsc->sc_state &= ~UHID_OPEN;\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);\n\tsc->sc_obuf = malloc(sc->sc_osize, M_USBDEV, M_WAITOK);\n\n\t/* Set up interrupt pipe. */\n\terr = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, \n\t\t  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, \n\t\t  sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);\n\tif (err) {\n\t\tDPRINTF((\"uhidopen: usbd_open_pipe_intr failed, \"\n\t\t\t \"error=%d\\n\",err));\n\t\tfree(sc->sc_ibuf, M_USBDEV);\n\t\tfree(sc->sc_obuf, M_USBDEV);\n\t\tsc->sc_state &= ~UHID_OPEN;\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_state &= ~UHID_IMMED;\n\n\tsc->sc_async = 0;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tUHID_BSIZE\t1020\t/* buffer size */",
      "#define UHID_IMMED\t0x08\t/* return read data immediately */",
      "#define\tUHID_OPEN\t0x01\t/* device is open */"
    ],
    "globals_used": [
      "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));",
      "uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->sc_obuf",
            "M_USBDEV"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhidopen: usbd_open_pipe_intr failed, \"\n\t\t\t \"error=%d\\n\",err)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe_intr",
          "args": [
            "sc->sc_iface",
            "sc->sc_ep_addr",
            "USBD_SHORT_XFER_OK",
            "&sc->sc_intrpipe",
            "sc",
            "sc->sc_ibuf",
            "sc->sc_isize",
            "uhid_intr",
            "USBD_DEFAULT_INTERVAL"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sc->sc_osize",
            "M_USBDEV",
            "M_WAITOK"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clalloc",
          "args": [
            "&sc->sc_q",
            "UHID_BSIZE",
            "0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhidopen: sc=%p\\n\", sc)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC_OPEN",
          "args": [
            "uhid",
            "UHIDUNIT(dev)",
            "sc"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHIDUNIT",
          "args": [
            "dev"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUHID_BSIZE\t1020\t/* buffer size */\n#define UHID_IMMED\t0x08\t/* return read data immediately */\n#define\tUHID_OPEN\t0x01\t/* device is open */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\nuhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,\n\t\t\t      struct proc *));\n\nint\nuhidopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct uhid_softc *sc;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(uhid, UHIDUNIT(dev), sc);\n\n\tDPRINTF((\"uhidopen: sc=%p\\n\", sc));\n\n\tif (sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_state & UHID_OPEN)\n\t\treturn (EBUSY);\n\tsc->sc_state |= UHID_OPEN;\n\n\tif (clalloc(&sc->sc_q, UHID_BSIZE, 0) == -1) {\n\t\tsc->sc_state &= ~UHID_OPEN;\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);\n\tsc->sc_obuf = malloc(sc->sc_osize, M_USBDEV, M_WAITOK);\n\n\t/* Set up interrupt pipe. */\n\terr = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, \n\t\t  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, \n\t\t  sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);\n\tif (err) {\n\t\tDPRINTF((\"uhidopen: usbd_open_pipe_intr failed, \"\n\t\t\t \"error=%d\\n\",err));\n\t\tfree(sc->sc_ibuf, M_USBDEV);\n\t\tfree(sc->sc_obuf, M_USBDEV);\n\t\tsc->sc_state &= ~UHID_OPEN;\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_state &= ~UHID_IMMED;\n\n\tsc->sc_async = 0;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "uhid_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "324-366",
    "snippet": "void\nuhid_intr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct uhid_softc *sc = addr;\n\n#ifdef UHID_DEBUG\n\tif (uhiddebug > 5) {\n\t\tu_int32_t cc, i;\n\t\t\n\t\tusbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);\n\t\tDPRINTF((\"uhid_intr: status=%d cc=%d\\n\", status, cc));\n\t\tDPRINTF((\"uhid_intr: data =\"));\n\t\tfor (i = 0; i < cc; i++)\n\t\t\tDPRINTF((\" %02x\", sc->sc_ibuf[i]));\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tDPRINTF((\"uhid_intr: status=%d\\n\", status));\n\t\tsc->sc_state |= UHID_NEEDCLEAR;\n\t\treturn;\n\t}\n\n\t(void) b_to_q(sc->sc_ibuf, sc->sc_isize, &sc->sc_q);\n\t\t\n\tif (sc->sc_state & UHID_ASLP) {\n\t\tsc->sc_state &= ~UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhid_intr: waking %p\\n\", sc));\n\t\twakeup(&sc->sc_q);\n\t}\n\tselwakeup(&sc->sc_rsel);\n\tif (sc->sc_async != NULL) {\n\t\tDPRINTFN(3, (\"uhid_intr: sending SIGIO %p\\n\", sc->sc_async));\n\t\tpsignal(sc->sc_async, SIGIO);\n\t}\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */",
      "#define\tUHID_ASLP\t0x02\t/* waiting for device data */"
    ],
    "globals_used": [
      "uhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "sc->sc_async",
            "SIGIO"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhid_intr: sending SIGIO %p\\n\", sc->sc_async)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sc->sc_rsel"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_q"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhid_intr: waking %p\\n\", sc)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_to_q",
          "args": [
            "sc->sc_ibuf",
            "sc->sc_isize",
            "&sc->sc_q"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhid_intr: status=%d\\n\", status)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"\\n\")"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" %02x\", sc->sc_ibuf[i])"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhid_intr: data =\")"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhid_intr: status=%d cc=%d\\n\", status, cc)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&cc",
            "NULL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UHID_NEEDCLEAR\t0x04\t/* needs clearing endpoint stall */\n#define\tUHID_ASLP\t0x02\t/* waiting for device data */\n\nuhid_intr __P((usbd_xfer_handle, usbd_private_handle,\n\t\t\t   usbd_status));\n\nvoid\nuhid_intr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct uhid_softc *sc = addr;\n\n#ifdef UHID_DEBUG\n\tif (uhiddebug > 5) {\n\t\tu_int32_t cc, i;\n\t\t\n\t\tusbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);\n\t\tDPRINTF((\"uhid_intr: status=%d cc=%d\\n\", status, cc));\n\t\tDPRINTF((\"uhid_intr: data =\"));\n\t\tfor (i = 0; i < cc; i++)\n\t\t\tDPRINTF((\" %02x\", sc->sc_ibuf[i]));\n\t\tDPRINTF((\"\\n\"));\n\t}\n#endif\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tDPRINTF((\"uhid_intr: status=%d\\n\", status));\n\t\tsc->sc_state |= UHID_NEEDCLEAR;\n\t\treturn;\n\t}\n\n\t(void) b_to_q(sc->sc_ibuf, sc->sc_isize, &sc->sc_q);\n\t\t\n\tif (sc->sc_state & UHID_ASLP) {\n\t\tsc->sc_state &= ~UHID_ASLP;\n\t\tDPRINTFN(5, (\"uhid_intr: waking %p\\n\", sc));\n\t\twakeup(&sc->sc_q);\n\t}\n\tselwakeup(&sc->sc_rsel);\n\tif (sc->sc_async != NULL) {\n\t\tDPRINTFN(3, (\"uhid_intr: sending SIGIO %p\\n\", sc->sc_async));\n\t\tpsignal(sc->sc_async, SIGIO);\n\t}\n}"
  },
  {
    "function_name": "uhid_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhid.c",
    "lines": "256-273",
    "snippet": "int\nuhid_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhid_softc *sc = (struct uhid_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/filio.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/hid.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/filio.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nuhid_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhid_softc *sc = (struct uhid_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  }
]