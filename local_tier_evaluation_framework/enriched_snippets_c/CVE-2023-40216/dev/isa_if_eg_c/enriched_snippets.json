[
  {
    "function_name": "egstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "821-827",
    "snippet": "void\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void egstop",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "0"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}"
  },
  {
    "function_name": "egwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "809-819",
    "snippet": "void\negwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct eg_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\tsc->sc_arpcom.ac_if.if_oerrors++;\n\n\tegreset(sc);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void egwatchdog",
      "void egreset",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egreset",
          "args": [
            "sc"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "egreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "796-807",
          "snippet": "void\negreset(sc)\n\tstruct eg_softc *sc;\n{\n\tint s;\n\n\tdprintf((\"egreset()\\n\"));\n\ts = splnet();\n\tegstop(sc);\n\teginit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void eginit",
            "void egreset",
            "void egstop",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid eginit;\nvoid egreset;\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negreset(sc)\n\tstruct eg_softc *sc;\n{\n\tint s;\n\n\tdprintf((\"egreset()\\n\"));\n\ts = splnet();\n\tegstop(sc);\n\teginit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid egwatchdog;\nvoid egreset;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct eg_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\tsc->sc_arpcom.ac_if.if_oerrors++;\n\n\tegreset(sc);\n}"
  },
  {
    "function_name": "egreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "796-807",
    "snippet": "void\negreset(sc)\n\tstruct eg_softc *sc;\n{\n\tint s;\n\n\tdprintf((\"egreset()\\n\"));\n\ts = splnet();\n\tegstop(sc);\n\teginit(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void eginit",
      "void egreset",
      "void egstop",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginit",
          "args": [
            "sc"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "eginit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "427-473",
          "snippet": "void\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define EG_BUFLEN\t0x0670"
          ],
          "globals_used": [
            "void eginit",
            "void egrecv",
            "void egstart",
            "static inline void egprintpcb",
            "static int egwritePCB",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n\nvoid eginit;\nvoid egrecv;\nvoid egstart;\nstatic inline void egprintpcb;\nstatic int egwritePCB;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "egstop",
          "args": [
            "sc"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "egstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "821-827",
          "snippet": "void\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void egstop",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"egreset()\\n\")"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid eginit;\nvoid egreset;\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negreset(sc)\n\tstruct eg_softc *sc;\n{\n\tint s;\n\n\tdprintf((\"egreset()\\n\"));\n\ts = splnet();\n\tegstop(sc);\n\teginit(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "egioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "723-794",
    "snippet": "int\negioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct eg_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\teginit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\teginit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tegstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\teginit(sc);\n\t\t} else {\n\t\t\tsc->eg_pcb[0] = EG_CMD_GETSTATS;\n\t\t\tsc->eg_pcb[1] = 0;\n\t\t\tif (egwritePCB(sc) != 0)\n\t\t\t\tdprintf((\"write error\\n\"));\n\t\t\t/*\n\t\t\t * XXX deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1,\n\t\t\t */\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn error;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void eginit",
      "int egioctl",
      "void egstop",
      "static int egwritePCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"write error\\n\")"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eginit",
          "args": [
            "sc"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "eginit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "427-473",
          "snippet": "void\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define EG_BUFLEN\t0x0670"
          ],
          "globals_used": [
            "void eginit",
            "void egrecv",
            "void egstart",
            "static inline void egprintpcb",
            "static int egwritePCB",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n\nvoid eginit;\nvoid egrecv;\nvoid egstart;\nstatic inline void egprintpcb;\nstatic int egwritePCB;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "egstop",
          "args": [
            "sc"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "egstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "821-827",
          "snippet": "void\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void egstop",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid eginit;\nint egioctl;\nvoid egstop;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nint\negioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct eg_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\teginit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\teginit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tegstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\teginit(sc);\n\t\t} else {\n\t\t\tsc->eg_pcb[0] = EG_CMD_GETSTATS;\n\t\t\tsc->eg_pcb[1] = 0;\n\t\t\tif (egwritePCB(sc) != 0)\n\t\t\t\tdprintf((\"write error\\n\"));\n\t\t\t/*\n\t\t\t * XXX deal with flags changes:\n\t\t\t * IFF_MULTICAST, IFF_PROMISC,\n\t\t\t * IFF_LINK0, IFF_LINK1,\n\t\t\t */\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn error;\n}"
  },
  {
    "function_name": "egread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "632-674",
    "snippet": "void\negread(sc, buf, len)\n\tstruct eg_softc *sc;\n\tcaddr_t buf;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\t\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHER_MAX_LEN) {\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = egget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN\t1518"
    ],
    "globals_used": [
      "void egread",
      "struct mbuf *egget",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;",
      "caddr_t buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egget",
          "args": [
            "sc",
            "buf",
            "len"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid packet size %d; dropping\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN\t1518\n\nvoid egread;\nstruct mbuf *egget;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\ncaddr_t buf;\n\nvoid\negread(sc, buf, len)\n\tstruct eg_softc *sc;\n\tcaddr_t buf;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\t\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHER_MAX_LEN) {\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = egget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
  },
  {
    "function_name": "egintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "563-627",
    "snippet": "int\negintr(arg)\n\tvoid *arg;\n{\n\tregister struct eg_softc *sc = arg;\n\tint ret = 0;\n\tint i, len;\n\tu_short *ptr;\n\n\twhile (inb(sc->eg_stat) & EG_STAT_ACRF) {\n\t\tret = 1;\n\t\tegreadPCB(sc);\n\t\tswitch (sc->eg_pcb[0]) {\n\t\tcase EG_RSP_RECVPACKET:\n\t\t\tlen = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);\n\t\n\t\t\t/* Set direction bit : Adapter -> host */\n\t\t\toutb(sc->eg_ctl, inb(sc->eg_ctl) | EG_CTL_DIR); \n\n\t\t\tfor (ptr = (u_short *) sc->eg_inbuf; len > 0; len -= 2) {\n\t\t\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t\t\t;\n\t\t\t\t*ptr++ = inw(sc->eg_data);\n\t\t\t}\n\n\t\t\tlen = sc->eg_pcb[8] | (sc->eg_pcb[9] << 8);\n\t\t\tegread(sc, sc->eg_inbuf, len);\n\n\t\t\tsc->eg_incount--;\n\t\t\tegrecv(sc);\n\t\t\tbreak;\n\n\t\tcase EG_RSP_SENDPACKET:\n\t\t\tif (sc->eg_pcb[6] || sc->eg_pcb[7]) {\n\t\t\t\tdprintf((\"packet dropped\\n\"));\n\t\t\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\t\t} else\n\t\t\t\tsc->sc_arpcom.ac_if.if_opackets++;\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += sc->eg_pcb[8] & 0xf;\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tegstart(&sc->sc_arpcom.ac_if);\n\t\t\tbreak;\n\n\t\tcase EG_RSP_GETSTATS:\n\t\t\tdprintf((\"Card Statistics\\n\"));\n\t\t\tbcopy(&sc->eg_pcb[2], &i, sizeof(i));\n\t\t\tdprintf((\"Receive Packets %d\\n\", i));\n\t\t\tbcopy(&sc->eg_pcb[6], &i, sizeof(i));\n\t\t\tdprintf((\"Transmit Packets %d\\n\", i));\n\t\t\tdprintf((\"CRC errors %d\\n\", *(short*) &sc->eg_pcb[10]));\n\t\t\tdprintf((\"alignment errors %d\\n\", *(short*) &sc->eg_pcb[12]));\n\t\t\tdprintf((\"no resources errors %d\\n\", *(short*) &sc->eg_pcb[14]));\n\t\t\tdprintf((\"overrun errors %d\\n\", *(short*) &sc->eg_pcb[16]));\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tdprintf((\"egintr: Unknown response %x??\\n\",\n\t\t\t    sc->eg_pcb[0]));\n\t\t\tegprintpcb(sc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int egintr",
      "void egrecv",
      "void egstart",
      "void egread",
      "static inline void egprintpcb",
      "static int egreadPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egprintpcb",
          "args": [
            "sc"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "egprintpcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "148-156",
          "snippet": "static inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void egprintpcb",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintpcb;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"egintr: Unknown response %x??\\n\",\n\t\t\t    sc->eg_pcb[0])"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"overrun errors %d\\n\", *(short*) &sc->eg_pcb[16])"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"no resources errors %d\\n\", *(short*) &sc->eg_pcb[14])"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"alignment errors %d\\n\", *(short*) &sc->eg_pcb[12])"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"CRC errors %d\\n\", *(short*) &sc->eg_pcb[10])"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"Transmit Packets %d\\n\", i)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&sc->eg_pcb[6]",
            "&i",
            "sizeof(i)"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"Receive Packets %d\\n\", i)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"Card Statistics\\n\")"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egstart",
          "args": [
            "&sc->sc_arpcom.ac_if"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "egstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "497-561",
          "snippet": "void\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "void egstart",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MIN_LEN\t64\n\nvoid egstart;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"packet dropped\\n\")"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egrecv",
          "args": [
            "sc"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "egrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "475-495",
          "snippet": "void\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define EG_BUFLEN\t0x0670",
            "#define EG_INLEN  \t10"
          ],
          "globals_used": [
            "void egrecv",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n#define EG_INLEN  \t10\n\nvoid egrecv;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "egread",
          "args": [
            "sc",
            "sc->eg_inbuf",
            "len"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "egread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "632-674",
          "snippet": "void\negread(sc, buf, len)\n\tstruct eg_softc *sc;\n\tcaddr_t buf;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\t\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHER_MAX_LEN) {\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = egget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN\t1518"
          ],
          "globals_used": [
            "void egread",
            "struct mbuf *egget",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;",
            "caddr_t buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN\t1518\n\nvoid egread;\nstruct mbuf *egget;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\ncaddr_t buf;\n\nvoid\negread(sc, buf, len)\n\tstruct eg_softc *sc;\n\tcaddr_t buf;\n\tint len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\t\n\tif (len <= sizeof(struct ether_header) ||\n\t    len > ETHER_MAX_LEN) {\n\t\tprintf(\"%s: invalid packet size %d; dropping\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Pull packet off interface. */\n\tm = egget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->eg_data"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "inb(sc->eg_ctl) | EG_CTL_DIR"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "egreadPCB",
          "args": [
            "sc"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "251-294",
          "snippet": "static int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "static int egreadPCBready",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstatic int egreadPCBready;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nint egintr;\nvoid egrecv;\nvoid egstart;\nvoid egread;\nstatic inline void egprintpcb;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nint\negintr(arg)\n\tvoid *arg;\n{\n\tregister struct eg_softc *sc = arg;\n\tint ret = 0;\n\tint i, len;\n\tu_short *ptr;\n\n\twhile (inb(sc->eg_stat) & EG_STAT_ACRF) {\n\t\tret = 1;\n\t\tegreadPCB(sc);\n\t\tswitch (sc->eg_pcb[0]) {\n\t\tcase EG_RSP_RECVPACKET:\n\t\t\tlen = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);\n\t\n\t\t\t/* Set direction bit : Adapter -> host */\n\t\t\toutb(sc->eg_ctl, inb(sc->eg_ctl) | EG_CTL_DIR); \n\n\t\t\tfor (ptr = (u_short *) sc->eg_inbuf; len > 0; len -= 2) {\n\t\t\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t\t\t;\n\t\t\t\t*ptr++ = inw(sc->eg_data);\n\t\t\t}\n\n\t\t\tlen = sc->eg_pcb[8] | (sc->eg_pcb[9] << 8);\n\t\t\tegread(sc, sc->eg_inbuf, len);\n\n\t\t\tsc->eg_incount--;\n\t\t\tegrecv(sc);\n\t\t\tbreak;\n\n\t\tcase EG_RSP_SENDPACKET:\n\t\t\tif (sc->eg_pcb[6] || sc->eg_pcb[7]) {\n\t\t\t\tdprintf((\"packet dropped\\n\"));\n\t\t\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\t\t} else\n\t\t\t\tsc->sc_arpcom.ac_if.if_opackets++;\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += sc->eg_pcb[8] & 0xf;\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t\tegstart(&sc->sc_arpcom.ac_if);\n\t\t\tbreak;\n\n\t\tcase EG_RSP_GETSTATS:\n\t\t\tdprintf((\"Card Statistics\\n\"));\n\t\t\tbcopy(&sc->eg_pcb[2], &i, sizeof(i));\n\t\t\tdprintf((\"Receive Packets %d\\n\", i));\n\t\t\tbcopy(&sc->eg_pcb[6], &i, sizeof(i));\n\t\t\tdprintf((\"Transmit Packets %d\\n\", i));\n\t\t\tdprintf((\"CRC errors %d\\n\", *(short*) &sc->eg_pcb[10]));\n\t\t\tdprintf((\"alignment errors %d\\n\", *(short*) &sc->eg_pcb[12]));\n\t\t\tdprintf((\"no resources errors %d\\n\", *(short*) &sc->eg_pcb[14]));\n\t\t\tdprintf((\"overrun errors %d\\n\", *(short*) &sc->eg_pcb[16]));\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tdprintf((\"egintr: Unknown response %x??\\n\",\n\t\t\t    sc->eg_pcb[0]));\n\t\t\tegprintpcb(sc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "egstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "497-561",
    "snippet": "void\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_MIN_LEN\t64"
    ],
    "globals_used": [
      "void egstart",
      "static int egwritePCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "sc->eg_data",
            "*ptr++"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "inb(sc->eg_ctl) & ~EG_CTL_DIR"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "mtod(m, caddr_t)",
            "buffer",
            "m->m_len"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"egwritePCB in egstart failed\\n\")"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m0->m_pkthdr.len",
            "ETHER_MIN_LEN"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "gusmax_mixer_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2892-3092",
          "snippet": "int\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"egstart: no header mbuf\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MIN_LEN\t64\n\nvoid egstart;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}"
  },
  {
    "function_name": "egrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "475-495",
    "snippet": "void\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define EG_BUFLEN\t0x0670",
      "#define EG_INLEN  \t10"
    ],
    "globals_used": [
      "void egrecv",
      "static int egwritePCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n#define EG_INLEN  \t10\n\nvoid egrecv;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}"
  },
  {
    "function_name": "eginit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "427-473",
    "snippet": "void\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define EG_BUFLEN\t0x0670"
    ],
    "globals_used": [
      "void eginit",
      "void egrecv",
      "void egstart",
      "static inline void egprintpcb",
      "static int egwritePCB",
      "static int egreadPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egstart",
          "args": [
            "ifp"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "egstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "497-561",
          "snippet": "void\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "void egstart",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MIN_LEN\t64\n\nvoid egstart;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct eg_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tcaddr_t buffer;\n\tint len;\n\tu_short *ptr;\n\n\t/* Don't transmit if interface is busy or not running */\n\tif ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\nloop:\n\t/* Dequeue the next datagram. */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\t\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"egstart: no header mbuf\");\n\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\tsc->eg_pcb[0] = EG_CMD_SENDPACKET;\n\tsc->eg_pcb[1] = 0x06;\n\tsc->eg_pcb[2] = 0; /* address not used, we send zero */\n\tsc->eg_pcb[3] = 0;\n\tsc->eg_pcb[4] = 0;\n\tsc->eg_pcb[5] = 0;\n\tsc->eg_pcb[6] = len; /* length of packet */\n\tsc->eg_pcb[7] = len >> 8;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"egwritePCB in egstart failed\\n\"));\n\t\tifp->if_oerrors++;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tm_freem(m0);\n\t\tgoto loop;\n\t}\n\n\tbuffer = sc->eg_outbuf;\n\tfor (m = m0; m != 0; m = m->m_next) {\n\t\tbcopy(mtod(m, caddr_t), buffer, m->m_len);\n\t\tbuffer += m->m_len;\n\t}\n\n\t/* set direction bit: host -> adapter */\n\toutb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); \n\t\n\tfor (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {\n\t\toutw(sc->eg_data, *ptr++);\n\t\twhile (!(inb(sc->eg_stat) & EG_STAT_HRDY))\n\t\t\t; /* XXX need timeout here */\n\t}\n\t\n\tm_freem(m0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "egrecv",
          "args": [
            "sc"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "egrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "475-495",
          "snippet": "void\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define EG_BUFLEN\t0x0670",
            "#define EG_INLEN  \t10"
          ],
          "globals_used": [
            "void egrecv",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n#define EG_INLEN  \t10\n\nvoid egrecv;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negrecv(sc)\n\tstruct eg_softc *sc;\n{\n\n\twhile (sc->eg_incount < EG_INLEN) {\n\t\tsc->eg_pcb[0] = EG_CMD_RECVPACKET;\n\t\tsc->eg_pcb[1] = 0x08;\n\t\tsc->eg_pcb[2] = 0; /* address not used.. we send zero */\n\t\tsc->eg_pcb[3] = 0;\n\t\tsc->eg_pcb[4] = 0;\n\t\tsc->eg_pcb[5] = 0;\n\t\tsc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */\n\t\tsc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;\n\t\tsc->eg_pcb[8] = 0; /* timeout, 0 == none */\n\t\tsc->eg_pcb[9] = 0;\n\t\tif (egwritePCB(sc) != 0)\n\t\t\tbreak;\n\t\tsc->eg_incount++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "EG_CTL_CMDE"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "EG_BUFLEN",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: configure card command failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "egprintpcb",
          "args": [
            "sc"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "egprintpcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "148-156",
          "snippet": "static inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void egprintpcb",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintpcb;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"read error\\n\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egreadPCB",
          "args": [
            "sc"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "251-294",
          "snippet": "static int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "static int egreadPCBready",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstatic int egreadPCBready;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"write error3\\n\")"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define EG_BUFLEN\t0x0670\n\nvoid eginit;\nvoid egrecv;\nvoid egstart;\nstatic inline void egprintpcb;\nstatic int egwritePCB;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\neginit(sc)\n\tregister struct eg_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* soft reset the board */\n\toutb(sc->eg_ctl, EG_CTL_FLSH);\n\tdelay(100);\n\toutb(sc->eg_ctl, EG_CTL_ATTN);\n\tdelay(100);\n\toutb(sc->eg_ctl, 0);\n\tdelay(200);\n\n\tsc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */\n\tsc->eg_pcb[1] = 2;\n\tsc->eg_pcb[2] = 3; /* receive broadcast & multicast */\n\tsc->eg_pcb[3] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\tdprintf((\"write error3\\n\"));\n\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)\n\t\tprintf(\"%s: configure card command failed\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tif (sc->eg_inbuf == 0)\n\t\tsc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\tsc->eg_incount = 0;\n\n\tif (sc->eg_outbuf == 0)\n\t\tsc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);\n\n\toutb(sc->eg_ctl, EG_CTL_CMDE);\n\n\tsc->eg_incount = 0;\n\tegrecv(sc);\n\n\t/* Interface is now `running', with no output active. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* Attempt to start output, if any. */\n\tegstart(ifp);\n}"
  },
  {
    "function_name": "egattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "355-425",
    "snippet": "void\negattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eg_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\t\n\tegstop(sc);\n\n\tsc->eg_pcb[0] = EG_CMD_GETEADDR; /* Get Station address */\n\tsc->eg_pcb[1] = 0;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"write error\\n\"));\n\t\treturn;\n\t}\t\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\n\t/* check Get station address response */\n\tif (sc->eg_pcb[0] != EG_RSP_GETEADDR || sc->eg_pcb[1] != 0x06) { \n\t\tdprintf((\"parse error\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\tbcopy(&sc->eg_pcb[2], sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\": ROM v%d.%02d %dk address %s\\n\",\n\t    sc->eg_rom_major, sc->eg_rom_minor, sc->eg_ram,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tsc->eg_pcb[0] = EG_CMD_SETEADDR; /* Set station address */\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"write error2\\n\"));\n\t\treturn;\n\t}\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error2\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\tif (sc->eg_pcb[0] != EG_RSP_SETEADDR || sc->eg_pcb[1] != 0x02 ||\n\t    sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0) {\n\t\tdprintf((\"parse error2\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = egstart;\n\tifp->if_ioctl = egioctl;\n\tifp->if_watchdog = egwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\t\n\t/* Now we can attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\t\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, egintr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "void egattach",
      "int egintr",
      "int egioctl",
      "void egstart",
      "void egwatchdog",
      "void egstop",
      "static inline void egprintpcb",
      "static int egwritePCB",
      "static int egreadPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "egintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "egprintpcb",
          "args": [
            "sc"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "egprintpcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "148-156",
          "snippet": "static inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void egprintpcb",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintpcb;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"parse error2\\n\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"read error2\\n\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egreadPCB",
          "args": [
            "sc"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "251-294",
          "snippet": "static int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "static int egreadPCBready",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstatic int egreadPCBready;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"write error2\\n\")"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": ROM v%d.%02d %dk address %s\\n\"",
            "sc->eg_rom_major",
            "sc->eg_rom_minor",
            "sc->eg_ram",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"parse error\\n\")"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"read error\\n\")"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"write error\\n\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egstop",
          "args": [
            "sc"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "egstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "821-827",
          "snippet": "void\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void egstop",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nvoid egstop;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negstop(sc)\n\tregister struct eg_softc *sc;\n{\n\t\n\toutb(sc->eg_ctl, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\n\nvoid egattach;\nint egintr;\nint egioctl;\nvoid egstart;\nvoid egwatchdog;\nvoid egstop;\nstatic inline void egprintpcb;\nstatic int egwritePCB;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nvoid\negattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eg_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\t\n\tegstop(sc);\n\n\tsc->eg_pcb[0] = EG_CMD_GETEADDR; /* Get Station address */\n\tsc->eg_pcb[1] = 0;\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"write error\\n\"));\n\t\treturn;\n\t}\t\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\n\t/* check Get station address response */\n\tif (sc->eg_pcb[0] != EG_RSP_GETEADDR || sc->eg_pcb[1] != 0x06) { \n\t\tdprintf((\"parse error\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\tbcopy(&sc->eg_pcb[2], sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\": ROM v%d.%02d %dk address %s\\n\",\n\t    sc->eg_rom_major, sc->eg_rom_minor, sc->eg_ram,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tsc->eg_pcb[0] = EG_CMD_SETEADDR; /* Set station address */\n\tif (egwritePCB(sc) != 0) {\n\t\tdprintf((\"write error2\\n\"));\n\t\treturn;\n\t}\n\tif (egreadPCB(sc) != 0) {\n\t\tdprintf((\"read error2\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\tif (sc->eg_pcb[0] != EG_RSP_SETEADDR || sc->eg_pcb[1] != 0x02 ||\n\t    sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0) {\n\t\tdprintf((\"parse error2\\n\"));\n\t\tegprintpcb(sc);\n\t\treturn;\n\t}\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = egstart;\n\tifp->if_ioctl = egioctl;\n\tifp->if_watchdog = egwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\t\n\t/* Now we can attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\t\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, egintr, sc, sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "egprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "300-353",
    "snippet": "int\negprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eg_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint i;\n\n\tif ((ia->ia_iobase & ~0x07f0) != 0) {\n\t\tdprintf((\"Weird iobase %x\\n\", ia->ia_iobase));\n\t\treturn 0;\n\t}\n\t\n\tsc->eg_cmd = ia->ia_iobase + EG_COMMAND;\n\tsc->eg_ctl = ia->ia_iobase + EG_CONTROL;\n\tsc->eg_stat = ia->ia_iobase + EG_STATUS;\n\tsc->eg_data = ia->ia_iobase + EG_DATA;\n\n\t/* hard reset card */\n\toutb(sc->eg_ctl, EG_CTL_RESET); \n\toutb(sc->eg_ctl, 0);\n\tfor (i = 0; i < 5000; i++) {\n\t\tdelay(1000);\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == EG_PCB_NULL) \n\t\t\tbreak;\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) {\n\t\tdprintf((\"eg: Reset failed\\n\"));\n\t\treturn 0;\n\t}\n\tsc->eg_pcb[0] = EG_CMD_GETINFO; /* Get Adapter Info */\n\tsc->eg_pcb[1] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\treturn 0;\n\t\n\tif (egreadPCB(sc) != 0) {\n\t\tegprintpcb(sc);\n\t\treturn 0;\n\t}\n\n\tif (sc->eg_pcb[0] != EG_RSP_GETINFO || /* Get Adapter Info Response */\n\t    sc->eg_pcb[1] != 0x0a) {\n\t\tegprintpcb(sc);\n\t\treturn 0;\n\t}\n\tsc->eg_rom_major = sc->eg_pcb[3];\n\tsc->eg_rom_minor = sc->eg_pcb[2];\n\tsc->eg_ram = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);\n\t\n\tia->ia_iosize = 0x08;\n\tia->ia_msize = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int egprobe",
      "static inline void egprintpcb",
      "static int egwritePCB",
      "static int egreadPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egprintpcb",
          "args": [
            "sc"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "egprintpcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "148-156",
          "snippet": "static inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void egprintpcb",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintpcb;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "egreadPCB",
          "args": [
            "sc"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "251-294",
          "snippet": "static int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "static int egreadPCBready",
            "static int egreadPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstatic int egreadPCBready;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "egwritePCB",
          "args": [
            "sc"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "egwritePCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "223-249",
          "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "static int egreadPCBstat",
            "static int egwritePCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"eg: Reset failed\\n\")"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "0"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"Weird iobase %x\\n\", ia->ia_iobase)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nint egprobe;\nstatic inline void egprintpcb;\nstatic int egwritePCB;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nint\negprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eg_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tint i;\n\n\tif ((ia->ia_iobase & ~0x07f0) != 0) {\n\t\tdprintf((\"Weird iobase %x\\n\", ia->ia_iobase));\n\t\treturn 0;\n\t}\n\t\n\tsc->eg_cmd = ia->ia_iobase + EG_COMMAND;\n\tsc->eg_ctl = ia->ia_iobase + EG_CONTROL;\n\tsc->eg_stat = ia->ia_iobase + EG_STATUS;\n\tsc->eg_data = ia->ia_iobase + EG_DATA;\n\n\t/* hard reset card */\n\toutb(sc->eg_ctl, EG_CTL_RESET); \n\toutb(sc->eg_ctl, 0);\n\tfor (i = 0; i < 5000; i++) {\n\t\tdelay(1000);\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == EG_PCB_NULL) \n\t\t\tbreak;\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) {\n\t\tdprintf((\"eg: Reset failed\\n\"));\n\t\treturn 0;\n\t}\n\tsc->eg_pcb[0] = EG_CMD_GETINFO; /* Get Adapter Info */\n\tsc->eg_pcb[1] = 0;\n\tif (egwritePCB(sc) != 0)\n\t\treturn 0;\n\t\n\tif (egreadPCB(sc) != 0) {\n\t\tegprintpcb(sc);\n\t\treturn 0;\n\t}\n\n\tif (sc->eg_pcb[0] != EG_RSP_GETINFO || /* Get Adapter Info Response */\n\t    sc->eg_pcb[1] != 0x0a) {\n\t\tegprintpcb(sc);\n\t\treturn 0;\n\t}\n\tsc->eg_rom_major = sc->eg_pcb[3];\n\tsc->eg_rom_minor = sc->eg_pcb[2];\n\tsc->eg_ram = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);\n\t\n\tia->ia_iosize = 0x08;\n\tia->ia_msize = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "egreadPCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "251-294",
    "snippet": "static int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int egreadPCBstat",
      "static int egreadPCBready",
      "static int egreadPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "(inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_ctl"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"%d != %d\\n\", b, sc->eg_pcb[1] + 2)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egreadPCBstat",
          "args": [
            "sc",
            "EG_PCB_DONE"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCBstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "191-206",
          "snippet": "static int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "egreadPCBready",
          "args": [
            "sc"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCBready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "208-221",
          "snippet": "static int\negreadPCBready(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\n\tfor (i=0; i < 10000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_ACRF)\n\t\t\treturn 0;\n\t\tdelay(5);\n\t}\n\tdprintf((\"PCB read not ready\\n\"));\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBready",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBready;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCBready(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\n\tfor (i=0; i < 10000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_ACRF)\n\t\t\treturn 0;\n\t\tdelay(5);\n\t}\n\tdprintf((\"PCB read not ready\\n\"));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"len %d too large\\n\", sc->eg_pcb[1])"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->eg_pcb",
            "sizeof(sc->eg_pcb)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstatic int egreadPCBready;\nstatic int egreadPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char b;\n\t\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tbzero(sc->eg_pcb, sizeof(sc->eg_pcb));\n\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[0] = inb(sc->eg_cmd);\n\t\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\n\tsc->eg_pcb[1] = inb(sc->eg_cmd);\n\n\tif (sc->eg_pcb[1] > 62) {\n\t\tdprintf((\"len %d too large\\n\", sc->eg_pcb[1]));\n\t\treturn 1;\n\t}\n\t\n\tfor (i = 0; i < sc->eg_pcb[1]; i++) {\n\t\tif (egreadPCBready(sc))\n\t\t\treturn 1;\n\t\tsc->eg_pcb[2+i] = inb(sc->eg_cmd);\n\t}\n\tif (egreadPCBready(sc))\n\t\treturn 1;\n\tif (egreadPCBstat(sc, EG_PCB_DONE))\n\t\treturn 1;\n\tif ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {\n\t\tdprintf((\"%d != %d\\n\", b, sc->eg_pcb[1] + 2));\n\t\treturn 1;\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "egwritePCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "223-249",
    "snippet": "static int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int egoutPCB",
      "static int egreadPCBstat",
      "static int egwritePCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egreadPCBstat",
          "args": [
            "sc",
            "EG_PCB_ACCEPT"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "egreadPCBstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "191-206",
          "snippet": "static int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egreadPCBstat",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "egoutPCB",
          "args": [
            "sc",
            "len"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "egoutPCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
          "lines": "173-189",
          "snippet": "static int\negoutPCB(sc, b)\n\tstruct eg_softc *sc;\n\tu_char b;\n{\n\tint i;\n\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE) {\n\t\t\toutb(sc->eg_cmd, b);\n\t\t\treturn 0;\n\t\t}\n\t\tdelay(10);\n\t}\n\tdprintf((\"egoutPCB failed\\n\"));\n\treturn 1;\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_egreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int egoutPCB",
            "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negoutPCB(sc, b)\n\tstruct eg_softc *sc;\n\tu_char b;\n{\n\tint i;\n\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE) {\n\t\t\toutb(sc->eg_cmd, b);\n\t\t\treturn 0;\n\t\t}\n\t\tdelay(10);\n\t}\n\tdprintf((\"egoutPCB failed\\n\"));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_ctl",
            "(inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_ctl"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstatic int egreadPCBstat;\nstatic int egwritePCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negwritePCB(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\tu_char len;\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);\n\n\tlen = sc->eg_pcb[1] + 2;\n\tfor (i = 0; i < len; i++)\n\t\tegoutPCB(sc, sc->eg_pcb[i]);\n\t\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\toutb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);\n\n\tegoutPCB(sc, len);\n\n\tif (egreadPCBstat(sc, EG_PCB_ACCEPT))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "egreadPCBready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "208-221",
    "snippet": "static int\negreadPCBready(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\n\tfor (i=0; i < 10000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_ACRF)\n\t\t\treturn 0;\n\t\tdelay(5);\n\t}\n\tdprintf((\"PCB read not ready\\n\"));\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int egreadPCBready",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"PCB read not ready\\n\")"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBready;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCBready(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\n\tfor (i=0; i < 10000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_ACRF)\n\t\t\treturn 0;\n\t\tdelay(5);\n\t}\n\tdprintf((\"PCB read not ready\\n\"));\n\treturn 1;\n}"
  },
  {
    "function_name": "egreadPCBstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "191-206",
    "snippet": "static int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int egreadPCBstat",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egreadPCBstat;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negreadPCBstat(sc, statb)\n\tstruct eg_softc *sc;\n\tu_char statb;\n{\n\tint i;\n\n\tfor (i=0; i < 5000; i++) {\n\t\tif ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) \n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) \n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "egoutPCB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "173-189",
    "snippet": "static int\negoutPCB(sc, b)\n\tstruct eg_softc *sc;\n\tu_char b;\n{\n\tint i;\n\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE) {\n\t\t\toutb(sc->eg_cmd, b);\n\t\t\treturn 0;\n\t\t}\n\t\tdelay(10);\n\t}\n\tdprintf((\"egoutPCB failed\\n\"));\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int egoutPCB",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"egoutPCB failed\\n\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->eg_cmd",
            "b"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->eg_stat"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic int egoutPCB;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic int\negoutPCB(sc, b)\n\tstruct eg_softc *sc;\n\tu_char b;\n{\n\tint i;\n\n\tfor (i=0; i < 4000; i++) {\n\t\tif (inb(sc->eg_stat) & EG_STAT_HCRE) {\n\t\t\toutb(sc->eg_cmd, b);\n\t\t\treturn 0;\n\t\t}\n\t\tdelay(10);\n\t}\n\tdprintf((\"egoutPCB failed\\n\"));\n\treturn 1;\n}"
  },
  {
    "function_name": "egprintstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "159-171",
    "snippet": "static inline void\negprintstat(b)\n\tu_char b;\n{\n\tdprintf((\"%s %s %s %s %s %s %s\\n\", \n\t\t (b & EG_STAT_HCRE)?\"HCRE\":\"\",\n\t\t (b & EG_STAT_ACRF)?\"ACRF\":\"\",\n\t\t (b & EG_STAT_DIR )?\"DIR \":\"\",\n\t\t (b & EG_STAT_DONE)?\"DONE\":\"\",\n\t\t (b & EG_STAT_ASF3)?\"ASF3\":\"\",\n\t\t (b & EG_STAT_ASF2)?\"ASF2\":\"\",\n\t\t (b & EG_STAT_ASF1)?\"ASF1\":\"\"));\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void egprintstat"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"%s %s %s %s %s %s %s\\n\", \n\t\t (b & EG_STAT_HCRE)?\"HCRE\":\"\",\n\t\t (b & EG_STAT_ACRF)?\"ACRF\":\"\",\n\t\t (b & EG_STAT_DIR )?\"DIR \":\"\",\n\t\t (b & EG_STAT_DONE)?\"DONE\":\"\",\n\t\t (b & EG_STAT_ASF3)?\"ASF3\":\"\",\n\t\t (b & EG_STAT_ASF2)?\"ASF2\":\"\",\n\t\t (b & EG_STAT_ASF1)?\"ASF1\":\"\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintstat;\n\nstatic inline void\negprintstat(b)\n\tu_char b;\n{\n\tdprintf((\"%s %s %s %s %s %s %s\\n\", \n\t\t (b & EG_STAT_HCRE)?\"HCRE\":\"\",\n\t\t (b & EG_STAT_ACRF)?\"ACRF\":\"\",\n\t\t (b & EG_STAT_DIR )?\"DIR \":\"\",\n\t\t (b & EG_STAT_DONE)?\"DONE\":\"\",\n\t\t (b & EG_STAT_ASF3)?\"ASF3\":\"\",\n\t\t (b & EG_STAT_ASF2)?\"ASF2\":\"\",\n\t\t (b & EG_STAT_ASF1)?\"ASF1\":\"\"));\n}"
  },
  {
    "function_name": "egprintpcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_eg.c",
    "lines": "148-156",
    "snippet": "static inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}",
    "includes": [
      "#include <dev/isa/elink.h>",
      "#include <dev/isa/if_egreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void egprintpcb",
      "struct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "(\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i])"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_egreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"bpfilter.h\"\n\nstatic inline void egprintpcb;\nstruct mbuf *\negget(sc, buf, totlen)\n\tstruct eg_softc *sc;\n\nstatic inline void\negprintpcb(sc)\n\tstruct eg_softc *sc;\n{\n\tint i;\n\t\n\tfor (i = 0; i < sc->eg_pcb[1] + 2; i++)\n\t\tdprintf((\"pcb[%2d] = %x\\n\", i, sc->eg_pcb[i]));\n}"
  }
]