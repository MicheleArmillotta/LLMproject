[
  {
    "function_name": "xl_cardbus_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "412-425",
    "snippet": "void\nxl_cardbus_disable(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;\n\tcardbus_function_tag_t cf = csc->sc_ct->ct_cf;\n\tcardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;\n\n\tcardbus_save_bar(csc->sc_ct);\n  \n \tCardbus_function_disable(csc->sc_ct);\n\n\tcardbus_intr_disestablish(cc, cf, sc->xl_intrhand);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cardbus_intr_disestablish",
          "args": [
            "cc",
            "cf",
            "sc->xl_intrhand"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "672-682",
          "snippet": "void\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
            "cardbus_function_tag_t cf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\n\nvoid\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Cardbus_function_disable",
          "args": [
            "csc->sc_ct"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_save_bar",
          "args": [
            "csc->sc_ct"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_save_bar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
          "lines": "396-415",
          "snippet": "int cardbus_save_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tct->ct_bar[0] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE0_REG);\n\tct->ct_bar[1] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE1_REG);\n\tct->ct_bar[2] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE2_REG);\n\tct->ct_bar[3] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE3_REG);\n\tct->ct_bar[4] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE4_REG);\n\tct->ct_bar[5] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE5_REG);\n\n\tDPRINTF((\"cardbus_save_bar: %x %x\\n\", ct->ct_bar[0], ct->ct_bar[1]));\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cardbus_save_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tct->ct_bar[0] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE0_REG);\n\tct->ct_bar[1] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE1_REG);\n\tct->ct_bar[2] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE2_REG);\n\tct->ct_bar[3] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE3_REG);\n\tct->ct_bar[4] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE4_REG);\n\tct->ct_bar[5] = cardbus_conf_read(cc, cf, tag, CARDBUS_BASE5_REG);\n\n\tDPRINTF((\"cardbus_save_bar: %x %x\\n\", ct->ct_bar[0], ct->ct_bar[1]));\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nxl_cardbus_disable(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;\n\tcardbus_function_tag_t cf = csc->sc_ct->ct_cf;\n\tcardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;\n\n\tcardbus_save_bar(csc->sc_ct);\n  \n \tCardbus_function_disable(csc->sc_ct);\n\n\tcardbus_intr_disestablish(cc, cf, sc->xl_intrhand);\n}"
  },
  {
    "function_name": "xl_cardbus_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "390-410",
    "snippet": "int\nxl_cardbus_enable(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;\n\tcardbus_function_tag_t cf = csc->sc_ct->ct_cf;\n\tcardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;\n\n\tCardbus_function_enable(csc->sc_ct);\n\tcardbus_restore_bar(csc->sc_ct);\n\n\tsc->xl_intrhand = cardbus_intr_establish(cc, cf, csc->sc_intrline,\n\t    IPL_NET, xl_intr, sc);\n\tif (NULL == sc->xl_intrhand) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't establish interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_intr_establish",
          "args": [
            "cc",
            "cf",
            "csc->sc_intrline",
            "IPL_NET",
            "xl_intr",
            "sc"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_restore_bar",
          "args": [
            "csc->sc_ct"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_restore_bar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_map.c",
          "lines": "425-442",
          "snippet": "int cardbus_restore_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, ct->ct_bar[0]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, ct->ct_bar[1]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, ct->ct_bar[2]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, ct->ct_bar[3]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, ct->ct_bar[4]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, ct->ct_bar[5]);\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cardbus_restore_bar(ct)\n\tcardbus_devfunc_t ct;\n{\n\tcardbustag_t tag = Cardbus_make_tag(ct);\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE0_REG, ct->ct_bar[0]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE1_REG, ct->ct_bar[1]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE2_REG, ct->ct_bar[2]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE3_REG, ct->ct_bar[3]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE4_REG, ct->ct_bar[4]);\n\tcardbus_conf_write(cc, cf, tag, CARDBUS_BASE5_REG, ct->ct_bar[5]);\n\n\tCardbus_free_tag(ct, tag);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Cardbus_function_enable",
          "args": [
            "csc->sc_ct"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\nxl_cardbus_enable(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *csc = (struct xl_cardbus_softc *)sc;\n\tcardbus_function_tag_t cf = csc->sc_ct->ct_cf;\n\tcardbus_chipset_tag_t cc = csc->sc_ct->ct_cc;\n\n\tCardbus_function_enable(csc->sc_ct);\n\tcardbus_restore_bar(csc->sc_ct);\n\n\tsc->xl_intrhand = cardbus_intr_establish(cc, cf, csc->sc_intrline,\n\t    IPL_NET, xl_intr, sc);\n\tif (NULL == sc->xl_intrhand) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "xl_cardbus_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "352-387",
    "snippet": "int\nxl_cardbus_detach(self, arg)\n\tstruct device *self;\n\tint arg;\n{\n\tstruct xl_cardbus_softc *psc = (void *)self;\n\tstruct xl_softc *sc = &psc->sc_softc;\n\tstruct cardbus_devfunc *ct = psc->sc_ct;\n\tint rv = 0;\n\n#if defined(DIAGNOSTIC)\n\tif (ct == NULL) {\n\t\tpanic(\"%s: data structure lacks\\n\", sc->sc_dev.dv_xname);\n\t}\n#endif\n\n#if 0\n\trv = xl_detach(sc);\n#endif\n\tif (rv == 0) {\n\t\t/*\n\t\t * Unhook the interrupt handler.\n\t\t */\n\t\tcardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->xl_intrhand);\n\n\t\tif (psc->sc_cardtype == XL_3C575B) {\n\t\t\tCardbus_mapreg_unmap(ct,\n\t\t\t    CARDBUS_3C575BTX_FUNCSTAT_PCIREG,\n\t\t\t    psc->sc_funct, psc->sc_funch, psc->sc_funcsize);\n\t\t}\n\n\t\tCardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->xl_btag,\n\t\t    sc->xl_bhandle, psc->sc_mapsize);\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XL_3C575B\t\t2",
      "#define CARDBUS_3C575BTX_FUNCSTAT_PCIREG  CARDBUS_BASE2_REG  /* means 0x18 */"
    ],
    "globals_used": [
      "int xl_cardbus_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Cardbus_mapreg_unmap",
          "args": [
            "ct",
            "CARDBUS_BASE0_REG",
            "sc->xl_btag",
            "sc->xl_bhandle",
            "psc->sc_mapsize"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cardbus_mapreg_unmap",
          "args": [
            "ct",
            "CARDBUS_3C575BTX_FUNCSTAT_PCIREG",
            "psc->sc_funct",
            "psc->sc_funch",
            "psc->sc_funcsize"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_intr_disestablish",
          "args": [
            "ct->ct_cc",
            "ct->ct_cf",
            "sc->xl_intrhand"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "672-682",
          "snippet": "void\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;",
            "cardbus_function_tag_t cf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\ncardbus_intr_establish(cc, cf, irq, level, func, arg)\n     cardbus_chipset_tag_t cc;\ncardbus_function_tag_t cf;\n\nvoid\ncardbus_intr_disestablish(cc, cf, handler)\n     cardbus_chipset_tag_t cc;\n     cardbus_function_tag_t cf;\n     void *handler;\n{\n  DPRINTF((\"- pccard_intr_disestablish\\n\"));\n\n (*cf->cardbus_intr_disestablish)(cc, handler);\n  return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_detach",
          "args": [
            "sc"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: data structure lacks\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XL_3C575B\t\t2\n#define CARDBUS_3C575BTX_FUNCSTAT_PCIREG  CARDBUS_BASE2_REG  /* means 0x18 */\n\nint xl_cardbus_detach;\n\nint\nxl_cardbus_detach(self, arg)\n\tstruct device *self;\n\tint arg;\n{\n\tstruct xl_cardbus_softc *psc = (void *)self;\n\tstruct xl_softc *sc = &psc->sc_softc;\n\tstruct cardbus_devfunc *ct = psc->sc_ct;\n\tint rv = 0;\n\n#if defined(DIAGNOSTIC)\n\tif (ct == NULL) {\n\t\tpanic(\"%s: data structure lacks\\n\", sc->sc_dev.dv_xname);\n\t}\n#endif\n\n#if 0\n\trv = xl_detach(sc);\n#endif\n\tif (rv == 0) {\n\t\t/*\n\t\t * Unhook the interrupt handler.\n\t\t */\n\t\tcardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, sc->xl_intrhand);\n\n\t\tif (psc->sc_cardtype == XL_3C575B) {\n\t\t\tCardbus_mapreg_unmap(ct,\n\t\t\t    CARDBUS_3C575BTX_FUNCSTAT_PCIREG,\n\t\t\t    psc->sc_funct, psc->sc_funch, psc->sc_funcsize);\n\t\t}\n\n\t\tCardbus_mapreg_unmap(ct, CARDBUS_BASE0_REG, sc->xl_btag,\n\t\t    sc->xl_bhandle, psc->sc_mapsize);\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "xl_cardbus_intr_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "342-350",
    "snippet": "void\nxl_cardbus_intr_ack(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *psc = (struct xl_cardbus_softc *)sc;\n\n\tbus_space_write_4(psc->sc_funct, psc->sc_funch, XL_CB_INTR,\n\t    XL_CB_INTR_ACK);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XL_CB_INTR_ACK 0x8000 /* intr acknowledge bit */",
      "#define XL_CB_INTR 4\t\t/* intr acknowledge reg. CardBus only */"
    ],
    "globals_used": [
      "void xl_cardbus_intr_ack"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "psc->sc_funct",
            "psc->sc_funch",
            "XL_CB_INTR",
            "XL_CB_INTR_ACK"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XL_CB_INTR_ACK 0x8000 /* intr acknowledge bit */\n#define XL_CB_INTR 4\t\t/* intr acknowledge reg. CardBus only */\n\nvoid xl_cardbus_intr_ack;\n\nvoid\nxl_cardbus_intr_ack(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_cardbus_softc *psc = (struct xl_cardbus_softc *)sc;\n\n\tbus_space_write_4(psc->sc_funct, psc->sc_funch, XL_CB_INTR,\n\t    XL_CB_INTR_ACK);\n}"
  },
  {
    "function_name": "xl_cardbus_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "197-340",
    "snippet": "void\nxl_cardbus_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct xl_cardbus_softc *psc = (void *)self;\n\tstruct xl_softc *sc = &psc->sc_softc;\n\tstruct cardbus_attach_args *ca = aux;\n\tcardbus_devfunc_t ct = ca->ca_ct;\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\tcardbusreg_t iob, command, bhlc;\n\tconst struct xl_cardbus_product *ecp;\n\tbus_space_handle_t ioh;\n\tbus_addr_t adr;\n\n\tif (Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, 0,\n\t    &sc->xl_btag, &ioh, &adr, &psc->sc_mapsize)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tecp = xl_cardbus_lookup(ca);\n\tif (ecp == NULL) {\n\t\tprintf(\"\\n\");\n\t\tpanic(\"xl_cardbus_attach: impossible\");\n\t}\n\n\tprintf(\": 3Com %s\", ecp->ecp_name);\n\n#if 0\n#if !defined XL_POWER_STATIC\n\tsc->enable = xl_cardbus_enable;\n\tsc->disable = xl_cardbus_disable;\n#else\n\tsc->enable = NULL;\n\tsc->disable = NULL;\n#endif\n\tsc->enabled = 1;\n\tsc->sc_dmat = ca->ca_dmat;\n\tsc->xl_conf = ecp->ecp_flags;\n#endif\n\tsc->xl_bustype = XL_BUS_CARDBUS;\n\n\tiob = adr;\n\tsc->xl_bhandle = ioh;\n\n#if rbus\n#else\n\t(ct->ct_cf->cardbus_io_open)(cc, 0, iob, iob + 0x40);\n#endif\n\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_IO_ENABLE);\n\n\tcommand = cardbus_conf_read(cc, cf, ca->ca_tag,\n\t    CARDBUS_COMMAND_STATUS_REG);\n\tcommand |= ecp->ecp_csr;\n\tpsc->sc_cardtype = ecp->ecp_cardtype;\n\n\tif (psc->sc_cardtype == XL_3C575B) {\n\t\t/* Map CardBus function status window. */\n\t\tif (Cardbus_mapreg_map(ct, CARDBUS_3C575BTX_FUNCSTAT_PCIREG,\n\t\t    CARDBUS_MAPREG_TYPE_MEM, 0, &psc->sc_funct,\n\t\t    &psc->sc_funch, 0, &psc->sc_funcsize)) {\n\t\t\tprintf(\"%s: unable to map function status window\\n\",\n\t\t\t    self->dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Make sure CardBus brigde can access memory space.  Usually\n\t\t * memory access is enabled by BIOS, but some BIOSes do not\n\t\t * enable it.\n\t\t */\n\t\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);\n\n\t\t/* Setup interrupt acknowledge hook */\n\t\tsc->intr_ack = xl_cardbus_intr_ack;\n\t}\n\n\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);\n\tcardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_COMMAND_STATUS_REG,\n\t    command);\n  \n \t/*\n\t * set latency timmer\n\t */\n\tbhlc = cardbus_conf_read(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG);\n\tif (CARDBUS_LATTIMER(bhlc) < 0x20) {\n\t\t/* at least the value of latency timer should 0x20. */\n\t\tDPRINTF((\"if_xl_cardbus: lattimer 0x%x -> 0x20\\n\",\n\t\t    CARDBUS_LATTIMER(bhlc)));\n\t\tbhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n\t\tbhlc |= (0x20 << CARDBUS_LATTIMER_SHIFT);\n\t\tcardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG, bhlc);\n\t}\n\n\tpsc->sc_ct = ca->ca_ct;\n\tpsc->sc_intrline = ca->ca_intrline;\n\n#if defined XL_POWER_STATIC\n\t/* Map and establish the interrupt. */\n\n\tsc->xl_intrhand = cardbus_intr_establish(cc, cf, ca->ca_intrline,\n\t    IPL_NET, xl_intr, psc);\n\n\tif (sc->xl_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tprintf(\" at %d\", ca->ca_intrline);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": irq %d\", ca->ca_intrline);\n#endif\n\n\tbus_space_write_2(sc->xl_btag, sc->xl_bhandle, XL_COMMAND, XL_CMD_RESET);\n\tdelay(400);\n\t{\n\t\tint i = 0;\n\t\twhile (bus_space_read_2(sc->xl_btag, sc->xl_bhandle, XL_STATUS) &\n\t\t    XL_STAT_CMDBUSY) {\n\t\t\tif (++i > 10000) {\n\t\t\t\tprintf(\"ex: timeout %x\\n\",\n\t\t\t\t    bus_space_read_2(sc->xl_btag, sc->xl_bhandle,\n\t\t\t\t        XL_STATUS));\n\t\t\t\tprintf(\"ex: addr %x\\n\",\n\t\t\t\t    cardbus_conf_read(cc, cf, ca->ca_tag,\n\t\t\t\t    CARDBUS_BASE0_REG));\n\t\t\t\treturn;\t\t/* emergency exit */\n\t\t\t}\n\t\t}\n\t}\n\n\txl_attach(sc);\n\n\tif (psc->sc_cardtype == XL_3C575B)\n\t\tbus_space_write_4(psc->sc_funct, psc->sc_funch,\n\t\t    XL_CB_INTR, XL_CB_INTR_ACK);\n\n#if !defined XL_POWER_STATIC\n\tcardbus_function_disable(psc->sc_ct);  \n\tsc->enabled = 0;\n#endif\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define XL_3C575B\t\t2",
      "#define XL_CB_INTR_ACK 0x8000 /* intr acknowledge bit */",
      "#define XL_CB_INTR 4\t\t/* intr acknowledge reg. CardBus only */",
      "#define CARDBUS_3C575BTX_FUNCSTAT_PCIREG  CARDBUS_BASE2_REG  /* means 0x18 */",
      "#define XL_POWER_STATIC\t\t/* do not use enable/disable functions */"
    ],
    "globals_used": [
      "void xl_cardbus_attach",
      "void xl_cardbus_intr_ack",
      "const struct xl_cardbus_product *xl_cardbus_lookup",
      "const struct xl_cardbus_product *\nxl_cardbus_lookup(ca)\n\tconst struct cardbus_attach_args *ca;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cardbus_function_disable",
          "args": [
            "psc->sc_ct"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "cardbus_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus.c",
          "lines": "767-778",
          "snippet": "int\ncardbus_function_disable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n\n  DPRINTF((\"entering cardbus_function_disable...  \"));\n\n  disable_function(sc, func);\n\n  return 0;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pci/pcireg.h>\t/* XXX */",
            "#include <dev/pci/pcivar.h>\t/* XXX */",
            "#include <dev/cardbus/cardbus_exrom.h>",
            "#include <dev/cardbus/cardbusdevs.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void disable_function",
            "int (*func)",
            "tuple_decode_func func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pci/pcireg.h>\t/* XXX */\n#include <dev/pci/pcivar.h>\t/* XXX */\n#include <dev/cardbus/cardbus_exrom.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void disable_function;\nint (*func);\ntuple_decode_func func;\n\nint\ncardbus_function_disable(sc, func)\n     struct cardbus_softc *sc;\n     int func;\n{\n\n  DPRINTF((\"entering cardbus_function_disable...  \"));\n\n  disable_function(sc, func);\n\n  return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "psc->sc_funct",
            "psc->sc_funch",
            "XL_CB_INTR",
            "XL_CB_INTR_ACK"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_attach",
          "args": [
            "sc"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xl_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "2353-2591",
          "snippet": "void\nxl_attach(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tcaddr_t roundptr;\n\tu_int round;\n\tint i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifmedia *ifm;\n\n\tsc->xl_unit = sc->sc_dev.dv_unit;\n\txl_reset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (xl_read_eeprom(sc, (caddr_t)&enaddr, XL_EE_OEM_ADR0, 3, 1)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tu_int16_t devid;\n\t\tu_int16_t n;\n\n\t\tXL_SEL_WIN(2);\n\t\tn = CSR_READ_2(sc, 12);\n\t\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\t\tif (devid != 0x5257)\n\t\t\tn |= 0x0010;\n\t\tif (devid == 0x5257 || devid == 0x6560 || devid == 0x6562)\n\t\t\tn |= 0x4000;\n\n\t\tCSR_WRITE_2(sc, 12, n);\n\t}\n\n\tsc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->xl_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\",sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;\n#ifdef __alpha__\n\tround = (u_int64_t)sc->xl_ldata_ptr & 0xf;\n#else\n\tround = (u_int32_t)sc->xl_ldata_ptr & 0xf;\n#endif\n\troundptr = sc->xl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->xl_ldata = (struct xl_list_data *)roundptr;\n\tbzero(sc->xl_ldata, sizeof(struct xl_list_data));\n\n\t/*\n\t * Figure out the card type. 3c905B adapters have the\n\t * 'supportsNoTxLength' bit set in the capabilities\n\t * word in the EEPROM.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);\n\tif (sc->xl_caps & XL_CAPS_NO_TXLENGTH)\n\t\tsc->xl_type = XL_TYPE_905B;\n\telse\n\t\tsc->xl_type = XL_TYPE_90X;\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xl_ioctl;\n\tifp->if_output = ether_output;\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\tifp->if_start = xl_start_90xB;\n\telse\n\t\tifp->if_start = xl_start;\n\tifp->if_watchdog = xl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tXL_SEL_WIN(3);\n\tsc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);\n\n\txl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);\n\tsc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;\n\tsc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\txl_mediacheck(sc);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t    || sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\tifmedia_init(&sc->sc_mii.mii_media, 0,\n\t\t    xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 1;\n\t\tsc->sc_mii.mii_ifp = ifp;\n\t\tsc->sc_mii.mii_readreg = xl_miibus_readreg;\n\t\tsc->sc_mii.mii_writereg = xl_miibus_writereg;\n\t\tsc->sc_mii.mii_statchg = xl_miibus_statchg;\n\t\txl_setcfg(sc);\n\t\tmii_phy_probe((struct device *)sc, &sc->sc_mii, 0xffffffff);\n\n\t\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,\n\t\t\t    0, NULL);\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t\t}\n\t\telse {\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\t\t}\n\t\tifm = &sc->sc_mii.mii_media;\n\t}\n\telse {\n\t\tifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 0;\n\t\tifm = &sc->ifmedia;\n\t}\n\n\t/*\n\t * Sanity check. If the user has selected \"auto\" and this isn't\n\t * a 10/100 card of some kind, we need to force the transceiver\n\t * type to something sane.\n\t */\n\tif (sc->xl_xcvr == XL_XCVR_AUTO) {\n\t\txl_choose_xcvr(sc, 0);\n\t\txl_reset(sc, 0);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\tifmedia_add(&sc->ifmedia,\n\t\t\t    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\t/*\n\t\t * Check for a 10baseFL board in disguise.\n\t\t */\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL, 0, NULL);\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL|IFM_HDX,\n\t\t\t    0, NULL);\n\t\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\t\tifmedia_add(ifm,\n\t\t\t\t    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\t\t} else {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_2, 0, NULL);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_100_FX, 0, NULL);\n\t}\n\n\t/* Choose a default media. */\n\tswitch(sc->xl_xcvr) {\n\tcase XL_XCVR_10BT:\n\t\tmedia = IFM_ETHER|IFM_10_T;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tmedia = IFM_ETHER|IFM_10_FL;\n\t\t\txl_setmode(sc, media);\n\t\t} else {\n\t\t\tmedia = IFM_ETHER|IFM_10_5;\n\t\t\txl_setmode(sc, media);\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tmedia = IFM_ETHER|IFM_10_2;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_MII:\n\t\t/* Chosen by miibus */\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tmedia = IFM_ETHER|IFM_100_FX;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit,\n\t\t\t\t\t\t\tsc->xl_xcvr);\n\t\t/*\n\t\t * This will probably be wrong, but it prevents\n\t\t * the ifmedia code from panicking.\n\t\t */\n\t\tmedia = IFM_ETHER | IFM_10_T;\n\t\tbreak;\n\t}\n\n\tif (sc->xl_hasmii == 0)\n\t\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(xl_shutdown, sc);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_start",
            "void xl_start_90xB",
            "int xl_ioctl",
            "void xl_watchdog",
            "void xl_shutdown",
            "int xl_ifmedia_upd",
            "void xl_ifmedia_sts",
            "int xl_read_eeprom",
            "void xl_setcfg",
            "void xl_setmode",
            "void xl_reset",
            "void xl_mediacheck",
            "void xl_choose_xcvr",
            "int xl_miibus_readreg",
            "void xl_miibus_writereg",
            "void xl_miibus_statchg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_start;\nvoid xl_start_90xB;\nint xl_ioctl;\nvoid xl_watchdog;\nvoid xl_shutdown;\nint xl_ifmedia_upd;\nvoid xl_ifmedia_sts;\nint xl_read_eeprom;\nvoid xl_setcfg;\nvoid xl_setmode;\nvoid xl_reset;\nvoid xl_mediacheck;\nvoid xl_choose_xcvr;\nint xl_miibus_readreg;\nvoid xl_miibus_writereg;\nvoid xl_miibus_statchg;\n\nvoid\nxl_attach(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tcaddr_t roundptr;\n\tu_int round;\n\tint i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifmedia *ifm;\n\n\tsc->xl_unit = sc->sc_dev.dv_unit;\n\txl_reset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (xl_read_eeprom(sc, (caddr_t)&enaddr, XL_EE_OEM_ADR0, 3, 1)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tu_int16_t devid;\n\t\tu_int16_t n;\n\n\t\tXL_SEL_WIN(2);\n\t\tn = CSR_READ_2(sc, 12);\n\t\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\t\tif (devid != 0x5257)\n\t\t\tn |= 0x0010;\n\t\tif (devid == 0x5257 || devid == 0x6560 || devid == 0x6562)\n\t\t\tn |= 0x4000;\n\n\t\tCSR_WRITE_2(sc, 12, n);\n\t}\n\n\tsc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->xl_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\",sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;\n#ifdef __alpha__\n\tround = (u_int64_t)sc->xl_ldata_ptr & 0xf;\n#else\n\tround = (u_int32_t)sc->xl_ldata_ptr & 0xf;\n#endif\n\troundptr = sc->xl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->xl_ldata = (struct xl_list_data *)roundptr;\n\tbzero(sc->xl_ldata, sizeof(struct xl_list_data));\n\n\t/*\n\t * Figure out the card type. 3c905B adapters have the\n\t * 'supportsNoTxLength' bit set in the capabilities\n\t * word in the EEPROM.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);\n\tif (sc->xl_caps & XL_CAPS_NO_TXLENGTH)\n\t\tsc->xl_type = XL_TYPE_905B;\n\telse\n\t\tsc->xl_type = XL_TYPE_90X;\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xl_ioctl;\n\tifp->if_output = ether_output;\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\tifp->if_start = xl_start_90xB;\n\telse\n\t\tifp->if_start = xl_start;\n\tifp->if_watchdog = xl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tXL_SEL_WIN(3);\n\tsc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);\n\n\txl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);\n\tsc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;\n\tsc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\txl_mediacheck(sc);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t    || sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\tifmedia_init(&sc->sc_mii.mii_media, 0,\n\t\t    xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 1;\n\t\tsc->sc_mii.mii_ifp = ifp;\n\t\tsc->sc_mii.mii_readreg = xl_miibus_readreg;\n\t\tsc->sc_mii.mii_writereg = xl_miibus_writereg;\n\t\tsc->sc_mii.mii_statchg = xl_miibus_statchg;\n\t\txl_setcfg(sc);\n\t\tmii_phy_probe((struct device *)sc, &sc->sc_mii, 0xffffffff);\n\n\t\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,\n\t\t\t    0, NULL);\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t\t}\n\t\telse {\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\t\t}\n\t\tifm = &sc->sc_mii.mii_media;\n\t}\n\telse {\n\t\tifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 0;\n\t\tifm = &sc->ifmedia;\n\t}\n\n\t/*\n\t * Sanity check. If the user has selected \"auto\" and this isn't\n\t * a 10/100 card of some kind, we need to force the transceiver\n\t * type to something sane.\n\t */\n\tif (sc->xl_xcvr == XL_XCVR_AUTO) {\n\t\txl_choose_xcvr(sc, 0);\n\t\txl_reset(sc, 0);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\tifmedia_add(&sc->ifmedia,\n\t\t\t    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\t/*\n\t\t * Check for a 10baseFL board in disguise.\n\t\t */\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL, 0, NULL);\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL|IFM_HDX,\n\t\t\t    0, NULL);\n\t\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\t\tifmedia_add(ifm,\n\t\t\t\t    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\t\t} else {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_2, 0, NULL);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_100_FX, 0, NULL);\n\t}\n\n\t/* Choose a default media. */\n\tswitch(sc->xl_xcvr) {\n\tcase XL_XCVR_10BT:\n\t\tmedia = IFM_ETHER|IFM_10_T;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tmedia = IFM_ETHER|IFM_10_FL;\n\t\t\txl_setmode(sc, media);\n\t\t} else {\n\t\t\tmedia = IFM_ETHER|IFM_10_5;\n\t\t\txl_setmode(sc, media);\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tmedia = IFM_ETHER|IFM_10_2;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_MII:\n\t\t/* Chosen by miibus */\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tmedia = IFM_ETHER|IFM_100_FX;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit,\n\t\t\t\t\t\t\tsc->xl_xcvr);\n\t\t/*\n\t\t * This will probably be wrong, but it prevents\n\t\t * the ifmedia code from panicking.\n\t\t */\n\t\tmedia = IFM_ETHER | IFM_10_T;\n\t\tbreak;\n\t}\n\n\tif (sc->xl_hasmii == 0)\n\t\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(xl_shutdown, sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex: addr %x\\n\"",
            "cardbus_conf_read(cc, cf, ca->ca_tag,\n\t\t\t\t    CARDBUS_BASE0_REG)"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "ca->ca_tag",
            "CARDBUS_BASE0_REG"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "sc->xl_btag",
            "sc->xl_bhandle",
            "XL_STATUS"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "sc->xl_btag",
            "sc->xl_bhandle",
            "XL_STATUS"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "400"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "sc->xl_btag",
            "sc->xl_bhandle",
            "XL_COMMAND",
            "XL_CMD_RESET"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_intr_establish",
          "args": [
            "cc",
            "cf",
            "ca->ca_intrline",
            "IPL_NET",
            "xl_intr",
            "psc"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "ca->ca_tag",
            "CARDBUS_BHLC_REG",
            "bhlc"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"if_xl_cardbus: lattimer 0x%x -> 0x20\\n\",\n\t\t    CARDBUS_LATTIMER(bhlc))"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_LATTIMER",
          "args": [
            "bhlc"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CARDBUS_LATTIMER",
          "args": [
            "bhlc"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "ca->ca_tag",
            "CARDBUS_BHLC_REG"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_write",
          "args": [
            "cc",
            "cf",
            "ca->ca_tag",
            "CARDBUS_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "CARDBUS_BM_ENABLE"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "CARDBUS_MEM_ENABLE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cardbus_mapreg_map",
          "args": [
            "ct",
            "CARDBUS_3C575BTX_FUNCSTAT_PCIREG",
            "CARDBUS_MAPREG_TYPE_MEM",
            "0",
            "&psc->sc_funct",
            "&psc->sc_funch",
            "0",
            "&psc->sc_funcsize"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cardbus_conf_read",
          "args": [
            "cc",
            "cf",
            "ca->ca_tag",
            "CARDBUS_COMMAND_STATUS_REG"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "CARDBUS_IO_ENABLE"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cc",
            "0",
            "iob",
            "iob + 0x40"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"xl_cardbus_attach: impossible\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_cardbus_lookup",
          "args": [
            "ca"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Cardbus_mapreg_map",
          "args": [
            "ct",
            "CARDBUS_BASE0_REG",
            "CARDBUS_MAPREG_TYPE_IO",
            "0",
            "&sc->xl_btag",
            "&ioh",
            "&adr",
            "&psc->sc_mapsize"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define XL_3C575B\t\t2\n#define XL_CB_INTR_ACK 0x8000 /* intr acknowledge bit */\n#define XL_CB_INTR 4\t\t/* intr acknowledge reg. CardBus only */\n#define CARDBUS_3C575BTX_FUNCSTAT_PCIREG  CARDBUS_BASE2_REG  /* means 0x18 */\n#define XL_POWER_STATIC\t\t/* do not use enable/disable functions */\n\nvoid xl_cardbus_attach;\nvoid xl_cardbus_intr_ack;\nconst struct xl_cardbus_product *xl_cardbus_lookup;\nconst struct xl_cardbus_product *\nxl_cardbus_lookup(ca)\n\tconst struct cardbus_attach_args *ca;\n\nvoid\nxl_cardbus_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct xl_cardbus_softc *psc = (void *)self;\n\tstruct xl_softc *sc = &psc->sc_softc;\n\tstruct cardbus_attach_args *ca = aux;\n\tcardbus_devfunc_t ct = ca->ca_ct;\n\tcardbus_chipset_tag_t cc = ct->ct_cc;\n\tcardbus_function_tag_t cf = ct->ct_cf;\n\tcardbusreg_t iob, command, bhlc;\n\tconst struct xl_cardbus_product *ecp;\n\tbus_space_handle_t ioh;\n\tbus_addr_t adr;\n\n\tif (Cardbus_mapreg_map(ct, CARDBUS_BASE0_REG, CARDBUS_MAPREG_TYPE_IO, 0,\n\t    &sc->xl_btag, &ioh, &adr, &psc->sc_mapsize)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tecp = xl_cardbus_lookup(ca);\n\tif (ecp == NULL) {\n\t\tprintf(\"\\n\");\n\t\tpanic(\"xl_cardbus_attach: impossible\");\n\t}\n\n\tprintf(\": 3Com %s\", ecp->ecp_name);\n\n#if 0\n#if !defined XL_POWER_STATIC\n\tsc->enable = xl_cardbus_enable;\n\tsc->disable = xl_cardbus_disable;\n#else\n\tsc->enable = NULL;\n\tsc->disable = NULL;\n#endif\n\tsc->enabled = 1;\n\tsc->sc_dmat = ca->ca_dmat;\n\tsc->xl_conf = ecp->ecp_flags;\n#endif\n\tsc->xl_bustype = XL_BUS_CARDBUS;\n\n\tiob = adr;\n\tsc->xl_bhandle = ioh;\n\n#if rbus\n#else\n\t(ct->ct_cf->cardbus_io_open)(cc, 0, iob, iob + 0x40);\n#endif\n\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_IO_ENABLE);\n\n\tcommand = cardbus_conf_read(cc, cf, ca->ca_tag,\n\t    CARDBUS_COMMAND_STATUS_REG);\n\tcommand |= ecp->ecp_csr;\n\tpsc->sc_cardtype = ecp->ecp_cardtype;\n\n\tif (psc->sc_cardtype == XL_3C575B) {\n\t\t/* Map CardBus function status window. */\n\t\tif (Cardbus_mapreg_map(ct, CARDBUS_3C575BTX_FUNCSTAT_PCIREG,\n\t\t    CARDBUS_MAPREG_TYPE_MEM, 0, &psc->sc_funct,\n\t\t    &psc->sc_funch, 0, &psc->sc_funcsize)) {\n\t\t\tprintf(\"%s: unable to map function status window\\n\",\n\t\t\t    self->dv_xname);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Make sure CardBus brigde can access memory space.  Usually\n\t\t * memory access is enabled by BIOS, but some BIOSes do not\n\t\t * enable it.\n\t\t */\n\t\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_MEM_ENABLE);\n\n\t\t/* Setup interrupt acknowledge hook */\n\t\tsc->intr_ack = xl_cardbus_intr_ack;\n\t}\n\n\t(ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);\n\tcardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_COMMAND_STATUS_REG,\n\t    command);\n  \n \t/*\n\t * set latency timmer\n\t */\n\tbhlc = cardbus_conf_read(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG);\n\tif (CARDBUS_LATTIMER(bhlc) < 0x20) {\n\t\t/* at least the value of latency timer should 0x20. */\n\t\tDPRINTF((\"if_xl_cardbus: lattimer 0x%x -> 0x20\\n\",\n\t\t    CARDBUS_LATTIMER(bhlc)));\n\t\tbhlc &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);\n\t\tbhlc |= (0x20 << CARDBUS_LATTIMER_SHIFT);\n\t\tcardbus_conf_write(cc, cf, ca->ca_tag, CARDBUS_BHLC_REG, bhlc);\n\t}\n\n\tpsc->sc_ct = ca->ca_ct;\n\tpsc->sc_intrline = ca->ca_intrline;\n\n#if defined XL_POWER_STATIC\n\t/* Map and establish the interrupt. */\n\n\tsc->xl_intrhand = cardbus_intr_establish(cc, cf, ca->ca_intrline,\n\t    IPL_NET, xl_intr, psc);\n\n\tif (sc->xl_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tprintf(\" at %d\", ca->ca_intrline);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": irq %d\", ca->ca_intrline);\n#endif\n\n\tbus_space_write_2(sc->xl_btag, sc->xl_bhandle, XL_COMMAND, XL_CMD_RESET);\n\tdelay(400);\n\t{\n\t\tint i = 0;\n\t\twhile (bus_space_read_2(sc->xl_btag, sc->xl_bhandle, XL_STATUS) &\n\t\t    XL_STAT_CMDBUSY) {\n\t\t\tif (++i > 10000) {\n\t\t\t\tprintf(\"ex: timeout %x\\n\",\n\t\t\t\t    bus_space_read_2(sc->xl_btag, sc->xl_bhandle,\n\t\t\t\t        XL_STATUS));\n\t\t\t\tprintf(\"ex: addr %x\\n\",\n\t\t\t\t    cardbus_conf_read(cc, cf, ca->ca_tag,\n\t\t\t\t    CARDBUS_BASE0_REG));\n\t\t\t\treturn;\t\t/* emergency exit */\n\t\t\t}\n\t\t}\n\t}\n\n\txl_attach(sc);\n\n\tif (psc->sc_cardtype == XL_3C575B)\n\t\tbus_space_write_4(psc->sc_funct, psc->sc_funch,\n\t\t    XL_CB_INTR, XL_CB_INTR_ACK);\n\n#if !defined XL_POWER_STATIC\n\tcardbus_function_disable(psc->sc_ct);  \n\tsc->enabled = 0;\n#endif\n}"
  },
  {
    "function_name": "xl_cardbus_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/if_xl_cardbus.c",
    "lines": "183-195",
    "snippet": "int\nxl_cardbus_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cardbus_attach_args *ca = aux;\n\n\tif (xl_cardbus_lookup(ca) != NULL)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/cardbus/cardbusdevs.h>",
      "#include <dev/cardbus/cardbusvar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_cardbus_match",
      "const struct xl_cardbus_product *xl_cardbus_lookup",
      "const struct xl_cardbus_product *\nxl_cardbus_lookup(ca)\n\tconst struct cardbus_attach_args *ca;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_cardbus_lookup",
          "args": [
            "ca"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <dev/mii/miivar.h>\n#include <dev/cardbus/cardbusdevs.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_cardbus_match;\nconst struct xl_cardbus_product *xl_cardbus_lookup;\nconst struct xl_cardbus_product *\nxl_cardbus_lookup(ca)\n\tconst struct cardbus_attach_args *ca;\n\nint\nxl_cardbus_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct cardbus_attach_args *ca = aux;\n\n\tif (xl_cardbus_lookup(ca) != NULL)\n\t\treturn (1);\n\n\treturn (0);\n}"
  }
]