[
  {
    "function_name": "cy_probe_isa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/cy_isa.c",
    "lines": "60-87",
    "snippet": "int\ncy_probe_isa(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n  int card = ((struct device *)match)->dv_unit;\n  struct isa_attach_args *ia = aux;\n  bus_space_tag_t memt;\n  bus_space_handle_t memh;\n\n  if(ia->ia_irq == IRQUNK) {\n    printf(\"cy%d error: interrupt not defined\\n\", card);\n    return 0;\n  }\n\n  memt = ia->ia_memt;\n  if(bus_space_map(memt, ia->ia_maddr, 0x2000, 0, &memh) != 0)\n    return 0;\n\n  if(cy_probe_common(card, memt, memh, CY_BUSTYPE_ISA) == 0) {\n    bus_space_unmap(memt, memh, 0x2000);\n    return 0;\n  }\n\n  ia->ia_iosize = 0;\n  ia->ia_msize = 0x2000;\n  return 1;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int cy_probe_isa",
      "int cy_probe_common"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "0x2000"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_probe_common",
          "args": [
            "card",
            "memt",
            "memh",
            "CY_BUSTYPE_ISA"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "cy_probe_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "94-194",
          "snippet": "int\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "0x2000",
            "0",
            "&memh"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d error: interrupt not defined\\n\"",
            "card"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint cy_probe_isa;\nint cy_probe_common;\n\nint\ncy_probe_isa(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n  int card = ((struct device *)match)->dv_unit;\n  struct isa_attach_args *ia = aux;\n  bus_space_tag_t memt;\n  bus_space_handle_t memh;\n\n  if(ia->ia_irq == IRQUNK) {\n    printf(\"cy%d error: interrupt not defined\\n\", card);\n    return 0;\n  }\n\n  memt = ia->ia_memt;\n  if(bus_space_map(memt, ia->ia_maddr, 0x2000, 0, &memh) != 0)\n    return 0;\n\n  if(cy_probe_common(card, memt, memh, CY_BUSTYPE_ISA) == 0) {\n    bus_space_unmap(memt, memh, 0x2000);\n    return 0;\n  }\n\n  ia->ia_iosize = 0;\n  ia->ia_msize = 0x2000;\n  return 1;\n}"
  }
]