[
  {
    "function_name": "an_cache_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1297-1414",
    "snippet": "void\nan_cache_store (sc, eh, m, rx_quality)\n\tstruct an_softc *sc;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tunsigned short rx_quality;\n{\n\tstruct ip *ip = 0;\n\tint i;\n\tstatic int cache_slot = 0;\t/* use this cache entry */\n\tstatic int wrapindex = 0;       /* next \"free\" cache entry */\n\tint saanp=0;\n\n\t/* filters:\n\t * 1. ip only\n\t * 2. configurable filter to throw out unicast packets,\n\t * keep multicast only.\n\t */\n\n\tif ((ntohs(eh->ether_type) == 0x800)) {\n\t\tsaanp = 1;\n\t}\n\n\t/* filter for ip packets only\n\t*/\n\tif (sc->an_cache_iponly && !saanp) {\n\t\treturn;\n\t}\n\n\t/* filter for broadcast/multicast only\n\t */\n\tif (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0)) {\n\t\treturn;\n\t}\n\n#ifdef SIGDEBUG\n\tprintf(\"an: q value %x (MSB=0x%x, LSB=0x%x) \\n\",\n\t    rx_quality & 0xffff, rx_quality >> 8, rx_quality & 0xff);\n#endif\n\n\t/* find the ip header.  we want to store the ip_src\n\t * address.\n\t */\n\tif (saanp) {\n\t\tip = mtod(m, struct ip *);\n\t}\n\n\t/* do a linear search for a matching MAC address\n\t * in the cache table\n\t * . MAC address is 6 bytes,\n\t * . var w_nextitem holds total number of entries already cached\n\t */\n\tfor(i = 0; i < sc->an_nextitem; i++) {\n\t\tif (! bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc,  6 )) {\n\t\t\t/* Match!,\n\t\t\t * so we already have this entry,\n\t\t\t * update the data\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* did we find a matching mac address?\n\t * if yes, then overwrite a previously existing cache entry\n\t */\n\tif (i < sc->an_nextitem )   {\n\t\tcache_slot = i;\n\t}\n\t/* else, have a new address entry,so\n\t * add this new entry,\n\t * if table full, then we need to replace LRU entry\n\t */\n\telse    {\n\n\t\t/* check for space in cache table\n\t\t * note: an_nextitem also holds number of entries\n\t\t * added in the cache table\n\t\t */\n\t\tif ( sc->an_nextitem < MAXANCACHE ) {\n\t\t\tcache_slot = sc->an_nextitem;\n\t\t\tsc->an_nextitem++;\n\t\t\tsc->an_sigitems = sc->an_nextitem;\n\t\t}\n\t\t/* no space found, so simply wrap anth wrap index\n\t\t * and \"zap\" the next entry\n\t\t */\n\t\telse {\n\t\t\tif (wrapindex == MAXANCACHE) {\n\t\t\t\twrapindex = 0;\n\t\t\t}\n\t\t\tcache_slot = wrapindex++;\n\t\t}\n\t}\n\n\t/* invariant: cache_slot now points at some slot\n\t * in cache.\n\t */\n\tif (cache_slot < 0 || cache_slot >= MAXANCACHE) {\n\t\tlog(LOG_ERR, \"an_cache_store, bad index: %d of \"\n\t\t    \"[0..%d], gross cache error\\n\",\n\t\t    cache_slot, MAXANCACHE);\n\t\treturn;\n\t}\n\n\t/*  store items in cache\n\t *  .ip source address\n\t *  .mac src\n\t *  .signal, etc.\n\t */\n\tif (saanp) {\n\t\tsc->an_sigcache[cache_slot].ipsrc = ip->ip_src.s_addr;\n\t}\n\tbcopy( eh->ether_shost, sc->an_sigcache[cache_slot].macsrc,  6);\n\n\tsc->an_sigcache[cache_slot].signal = rx_quality;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "eh->ether_shost",
            "sc->an_sigcache[cache_slot].macsrc",
            "6"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"an_cache_store, bad index: %d of \"\n\t\t    \"[0..%d], gross cache error\\n\"",
            "cache_slot",
            "MAXANCACHE"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_shost",
            "sc->an_sigcache[i].macsrc",
            "6"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structip *"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"an: q value %x (MSB=0x%x, LSB=0x%x) \\n\"",
            "rx_quality & 0xffff",
            "rx_quality >> 8",
            "rx_quality & 0xff"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "eh->ether_type"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nan_cache_store (sc, eh, m, rx_quality)\n\tstruct an_softc *sc;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tunsigned short rx_quality;\n{\n\tstruct ip *ip = 0;\n\tint i;\n\tstatic int cache_slot = 0;\t/* use this cache entry */\n\tstatic int wrapindex = 0;       /* next \"free\" cache entry */\n\tint saanp=0;\n\n\t/* filters:\n\t * 1. ip only\n\t * 2. configurable filter to throw out unicast packets,\n\t * keep multicast only.\n\t */\n\n\tif ((ntohs(eh->ether_type) == 0x800)) {\n\t\tsaanp = 1;\n\t}\n\n\t/* filter for ip packets only\n\t*/\n\tif (sc->an_cache_iponly && !saanp) {\n\t\treturn;\n\t}\n\n\t/* filter for broadcast/multicast only\n\t */\n\tif (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0)) {\n\t\treturn;\n\t}\n\n#ifdef SIGDEBUG\n\tprintf(\"an: q value %x (MSB=0x%x, LSB=0x%x) \\n\",\n\t    rx_quality & 0xffff, rx_quality >> 8, rx_quality & 0xff);\n#endif\n\n\t/* find the ip header.  we want to store the ip_src\n\t * address.\n\t */\n\tif (saanp) {\n\t\tip = mtod(m, struct ip *);\n\t}\n\n\t/* do a linear search for a matching MAC address\n\t * in the cache table\n\t * . MAC address is 6 bytes,\n\t * . var w_nextitem holds total number of entries already cached\n\t */\n\tfor(i = 0; i < sc->an_nextitem; i++) {\n\t\tif (! bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc,  6 )) {\n\t\t\t/* Match!,\n\t\t\t * so we already have this entry,\n\t\t\t * update the data\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* did we find a matching mac address?\n\t * if yes, then overwrite a previously existing cache entry\n\t */\n\tif (i < sc->an_nextitem )   {\n\t\tcache_slot = i;\n\t}\n\t/* else, have a new address entry,so\n\t * add this new entry,\n\t * if table full, then we need to replace LRU entry\n\t */\n\telse    {\n\n\t\t/* check for space in cache table\n\t\t * note: an_nextitem also holds number of entries\n\t\t * added in the cache table\n\t\t */\n\t\tif ( sc->an_nextitem < MAXANCACHE ) {\n\t\t\tcache_slot = sc->an_nextitem;\n\t\t\tsc->an_nextitem++;\n\t\t\tsc->an_sigitems = sc->an_nextitem;\n\t\t}\n\t\t/* no space found, so simply wrap anth wrap index\n\t\t * and \"zap\" the next entry\n\t\t */\n\t\telse {\n\t\t\tif (wrapindex == MAXANCACHE) {\n\t\t\t\twrapindex = 0;\n\t\t\t}\n\t\t\tcache_slot = wrapindex++;\n\t\t}\n\t}\n\n\t/* invariant: cache_slot now points at some slot\n\t * in cache.\n\t */\n\tif (cache_slot < 0 || cache_slot >= MAXANCACHE) {\n\t\tlog(LOG_ERR, \"an_cache_store, bad index: %d of \"\n\t\t    \"[0..%d], gross cache error\\n\",\n\t\t    cache_slot, MAXANCACHE);\n\t\treturn;\n\t}\n\n\t/*  store items in cache\n\t *  .ip source address\n\t *  .mac src\n\t *  .signal, etc.\n\t */\n\tif (saanp) {\n\t\tsc->an_sigcache[cache_slot].ipsrc = ip->ip_src.s_addr;\n\t}\n\tbcopy( eh->ether_shost, sc->an_sigcache[cache_slot].macsrc,  6);\n\n\tsc->an_sigcache[cache_slot].signal = rx_quality;\n\n\treturn;\n}"
  },
  {
    "function_name": "an_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1228-1233",
    "snippet": "void\nan_shutdown(self)\n\tvoid *self;\n{\n\tan_stop(self);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_stop",
          "args": [
            "self"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "an_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1183-1206",
          "snippet": "void an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nvoid an_stats_update;\n\nvoid an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nan_shutdown(self)\n\tvoid *self;\n{\n\tan_stop(self);\n}"
  },
  {
    "function_name": "an_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1208-1226",
    "snippet": "void an_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tprintf(\"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\n\tan_reset(sc);\n\tan_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_reset",
      "void an_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_init",
          "args": [
            "sc"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "an_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1001-1093",
          "snippet": "void\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_init_tx_ring",
            "int an_cmd",
            "int an_write_record",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_init_tx_ring;\nint an_cmd;\nint an_write_record;\nvoid an_stats_update;\n\nvoid\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_reset",
          "args": [
            "sc"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "an_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "558-576",
          "snippet": "void an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_cmd;\n\nvoid an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nvoid an_watchdog;\n\nvoid an_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tprintf(\"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\n\tan_reset(sc);\n\tan_init(sc);\n\n\tifp->if_oerrors++;\n\n\treturn;\n}"
  },
  {
    "function_name": "an_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1183-1206",
    "snippet": "void an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_cmd",
      "void an_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UNTIMEOUT",
          "args": [
            "an_stats_update",
            "sc",
            "sc->an_stat_ch"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_DEALLOC_MEM",
            "sc->an_rdata.an_tx_fids[i]"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "0"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nvoid an_stats_update;\n\nvoid an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1095-1181",
    "snippet": "void an_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct mbuf\t\t*m0 = NULL;\n\tstruct an_txframe_802_3\ttx_frame_802_3;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\tint\t\t\tidx;\n\tunsigned char           txcontrol;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tif (!sc->an_associated)\n\t\treturn;\n\n\tidx = sc->an_rdata.an_tx_prod;\n\tbzero((char *)&tx_frame_802_3, sizeof(tx_frame_802_3));\n\n\twhile(sc->an_rdata.an_tx_ring[idx] == 0) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == NULL)\n\t\t\tbreak;\n\n\t\tid = sc->an_rdata.an_tx_fids[idx];\n\t\teh = mtod(m0, struct ether_header *);\n\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame_802_3.an_tx_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame_802_3.an_tx_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame_802_3.an_tx_802_3_payload_len =\n\t\t  m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */\n\n\t\tm_copydata(m0, sizeof(struct ether_header) - 2 ,\n\t\t    tx_frame_802_3.an_tx_802_3_payload_len,\n\t\t    (caddr_t)&sc->an_txbuf);\n\n\t\ttxcontrol=AN_TXCTL_8023;\n\t\t/* write the txcontrol only */\n\t\tan_write_data(sc, id, 0x08, (caddr_t)&txcontrol,\n\t\t\t      sizeof(txcontrol));\n\n\t\t/* 802_3 header */\n\t\tan_write_data(sc, id, 0x34, (caddr_t)&tx_frame_802_3,\n\t\t\t      sizeof(struct an_txframe_802_3));\n\n\t\t/* in mbuf header type is just before payload */\n\t\tan_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf,\n\t\t\t    tx_frame_802_3.an_tx_802_3_payload_len);\n\n\t\t/*\n\t\t * If there's a BPF listner, bounce a copy of\n\t\t * this frame to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tBPF_MTAP(ifp, m0);\n\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\n\t\tsc->an_rdata.an_tx_ring[idx] = id;\n\t\tif (an_cmd(sc, AN_CMD_TX, id))\n\t\t\tprintf(\"%s: xmit failed\\n\", sc->sc_dev.dv_xname);\n\n\t\tAN_INC(idx, AN_TX_RING_CNT);\n\t}\n\n\tif (m0 != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\tsc->an_rdata.an_tx_prod = idx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_start",
      "int an_cmd",
      "int an_write_data"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AN_INC",
          "args": [
            "idx",
            "AN_TX_RING_CNT"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: xmit failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_TX",
            "id"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m0"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_write_data",
          "args": [
            "sc",
            "id",
            "0x44",
            "(caddr_t)&sc->an_txbuf",
            "tx_frame_802_3.an_tx_802_3_payload_len"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "an_write_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "716-741",
          "snippet": "int an_write_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP0))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, ptr[i]);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        CSR_WRITE_1(sc, AN_DATA0, ptr2[i]);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_write_data",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_write_data;\nint an_seek;\n\nint an_write_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP0))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, ptr[i]);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        CSR_WRITE_1(sc, AN_DATA0, ptr2[i]);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m0",
            "sizeof(struct ether_header) - 2",
            "tx_frame_802_3.an_tx_802_3_payload_len",
            "(caddr_t)&sc->an_txbuf"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&eh->ether_shost",
            "(char *)&tx_frame_802_3.an_tx_src_addr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structether_header*"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&tx_frame_802_3",
            "sizeof(tx_frame_802_3)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_start;\nint an_cmd;\nint an_write_data;\n\nvoid an_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct mbuf\t\t*m0 = NULL;\n\tstruct an_txframe_802_3\ttx_frame_802_3;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\tint\t\t\tidx;\n\tunsigned char           txcontrol;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tif (!sc->an_associated)\n\t\treturn;\n\n\tidx = sc->an_rdata.an_tx_prod;\n\tbzero((char *)&tx_frame_802_3, sizeof(tx_frame_802_3));\n\n\twhile(sc->an_rdata.an_tx_ring[idx] == 0) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == NULL)\n\t\t\tbreak;\n\n\t\tid = sc->an_rdata.an_tx_fids[idx];\n\t\teh = mtod(m0, struct ether_header *);\n\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame_802_3.an_tx_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame_802_3.an_tx_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame_802_3.an_tx_802_3_payload_len =\n\t\t  m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */\n\n\t\tm_copydata(m0, sizeof(struct ether_header) - 2 ,\n\t\t    tx_frame_802_3.an_tx_802_3_payload_len,\n\t\t    (caddr_t)&sc->an_txbuf);\n\n\t\ttxcontrol=AN_TXCTL_8023;\n\t\t/* write the txcontrol only */\n\t\tan_write_data(sc, id, 0x08, (caddr_t)&txcontrol,\n\t\t\t      sizeof(txcontrol));\n\n\t\t/* 802_3 header */\n\t\tan_write_data(sc, id, 0x34, (caddr_t)&tx_frame_802_3,\n\t\t\t      sizeof(struct an_txframe_802_3));\n\n\t\t/* in mbuf header type is just before payload */\n\t\tan_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf,\n\t\t\t    tx_frame_802_3.an_tx_802_3_payload_len);\n\n\t\t/*\n\t\t * If there's a BPF listner, bounce a copy of\n\t\t * this frame to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tBPF_MTAP(ifp, m0);\n\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\n\t\tsc->an_rdata.an_tx_ring[idx] = id;\n\t\tif (an_cmd(sc, AN_CMD_TX, id))\n\t\t\tprintf(\"%s: xmit failed\\n\", sc->sc_dev.dv_xname);\n\n\t\tAN_INC(idx, AN_TX_RING_CNT);\n\t}\n\n\tif (m0 != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\tsc->an_rdata.an_tx_prod = idx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "an_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "1001-1093",
    "snippet": "void\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_reset",
      "int an_init_tx_ring",
      "int an_cmd",
      "int an_write_record",
      "void an_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc->an_stat_ch",
            "an_stats_update",
            "sc",
            "hz"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "AN_INTRS"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to enable MAC\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_ENABLE",
            "0"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_write_record",
          "args": [
            "sc",
            "(struct an_ltv_gen *)&sc->an_config"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "an_write_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "628-651",
          "snippet": "int an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_write_record",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_write_record;\nint an_seek;\n\nint an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&sc->arpcom.ac_enaddr",
            "(char *)&sc->an_config.an_macaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_init_tx_ring",
          "args": [
            "sc"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "an_init_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "978-999",
          "snippet": "int\nan_init_tx_ring(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tint\t\t\tid;\n\n\tif (sc->an_gone)\n\t\treturn (0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++) {\n\t\tif (an_alloc_nicmem(sc, 1518 + 0x44, &id))\n\t\t\treturn(ENOMEM);\n\t\tsc->an_rdata.an_tx_fids[i] = id;\n\t\tsc->an_rdata.an_tx_ring[i] = 0;\n\t}\n\n\tsc->an_rdata.an_tx_prod = 0;\n\tsc->an_rdata.an_tx_cons = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_init_tx_ring",
            "int an_alloc_nicmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_init_tx_ring;\nint an_alloc_nicmem;\n\nint\nan_init_tx_ring(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tint\t\t\tid;\n\n\tif (sc->an_gone)\n\t\treturn (0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++) {\n\t\tif (an_alloc_nicmem(sc, 1518 + 0x44, &id))\n\t\t\treturn(ENOMEM);\n\t\tsc->an_rdata.an_tx_fids[i] = id;\n\t\tsc->an_rdata.an_tx_ring[i] = 0;\n\t}\n\n\tsc->an_rdata.an_tx_prod = 0;\n\tsc->an_rdata.an_tx_cons = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_reset",
          "args": [
            "sc"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "an_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "558-576",
          "snippet": "void an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_cmd;\n\nvoid an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_stop",
          "args": [
            "sc"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "an_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1183-1206",
          "snippet": "void an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nvoid an_stats_update;\n\nvoid an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_init_tx_ring;\nint an_cmd;\nint an_write_record;\nvoid an_stats_update;\n\nvoid\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_init_tx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "978-999",
    "snippet": "int\nan_init_tx_ring(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tint\t\t\tid;\n\n\tif (sc->an_gone)\n\t\treturn (0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++) {\n\t\tif (an_alloc_nicmem(sc, 1518 + 0x44, &id))\n\t\t\treturn(ENOMEM);\n\t\tsc->an_rdata.an_tx_fids[i] = id;\n\t\tsc->an_rdata.an_tx_ring[i] = 0;\n\t}\n\n\tsc->an_rdata.an_tx_prod = 0;\n\tsc->an_rdata.an_tx_cons = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_init_tx_ring",
      "int an_alloc_nicmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_alloc_nicmem",
          "args": [
            "sc",
            "1518 + 0x44",
            "&id"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "an_alloc_nicmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "747-778",
          "snippet": "int an_alloc_nicmem(sc, len, id)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {\n\t\tprintf(\"%s: failed to allocate %d bytes on NIC\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\t*id = CSR_READ_2(sc, AN_ALLOC_FID);\n\n\tif (an_seek(sc, *id, 0, AN_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, 0);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_seek",
            "int an_alloc_nicmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_seek;\nint an_alloc_nicmem;\n\nint an_alloc_nicmem(sc, len, id)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {\n\t\tprintf(\"%s: failed to allocate %d bytes on NIC\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\t*id = CSR_READ_2(sc, AN_ALLOC_FID);\n\n\tif (an_seek(sc, *id, 0, AN_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, 0);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_init_tx_ring;\nint an_alloc_nicmem;\n\nint\nan_init_tx_ring(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\tint\t\t\tid;\n\n\tif (sc->an_gone)\n\t\treturn (0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++) {\n\t\tif (an_alloc_nicmem(sc, 1518 + 0x44, &id))\n\t\t\treturn(ENOMEM);\n\t\tsc->an_rdata.an_tx_fids[i] = id;\n\t\tsc->an_rdata.an_tx_ring[i] = 0;\n\t}\n\n\tsc->an_rdata.an_tx_prod = 0;\n\tsc->an_rdata.an_tx_cons = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "873-976",
    "snippet": "int an_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tint\t\t\ts, error = 0;\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\tareq;\n\tstruct ifreq\t\t*ifr;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tsc = ifp->if_softc;\n\tifr = (struct ifreq *)data;\n\n\tif (sc->an_gone)\n\t\treturn(ENODEV);\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tan_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tan_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->an_if_flags & IFF_PROMISC)) {\n\t\t\t\tan_promisc(sc, 1);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->an_if_flags & IFF_PROMISC) {\n\t\t\t\tan_promisc(sc, 0);\n\t\t\t} else\n\t\t\t\tan_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tan_stop(sc);\n\t\t}\n\t\tsc->an_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* The Aironet has no multicast filter. */\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGAIRONET:\n\t\terror = copyin(ifr->ifr_data, &areq, sizeof(areq));\n\t\tif (error)\n\t\t\tbreak;\n#ifdef ANCACHE\n\t\tif (areq.an_type == AN_RID_ZERO_CACHE) {\n\t\t\tsc->an_sigitems = sc->an_nextitem = 0;\n\t\t\tbreak;\n\t\t} else if (areq.an_type == AN_RID_READ_CACHE) {\n\t\t\tchar *pt = (char *)&areq.an_val;\n\t\t\tbcopy((char *)&sc->an_sigitems, (char *)pt,\n\t\t\t    sizeof(int));\n\t\t\tpt += sizeof(int);\n\t\t\tareq.an_len = sizeof(int) / 2;\n\t\t\tbcopy((char *)&sc->an_sigcache, (char *)pt,\n\t\t\t    sizeof(struct an_sigcache) * sc->an_sigitems);\n\t\t\tareq.an_len += ((sizeof(struct an_sigcache) *\n\t\t\t    sc->an_sigitems) / 2) + 1;\n\t\t} else\n#endif\n\t\tif (an_read_record(sc, (struct an_ltv_gen *)&areq)) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terror = copyout(&areq, ifr->ifr_data, sizeof(areq));\n\t\tbreak;\n\tcase SIOCSAIRONET:\n\t\terror = copyin(ifr->ifr_data, &areq, sizeof(areq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tan_setdef(sc, &areq);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ANCACHE\t\t\t/* enable signal strength cache */"
    ],
    "globals_used": [
      "int an_ioctl",
      "void an_promisc",
      "int an_read_record",
      "void an_setdef"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_setdef",
          "args": [
            "sc",
            "&areq"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "an_setdef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "780-834",
          "snippet": "void\nan_setdef(sc, areq)\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\t*areq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\tstruct an_ltv_genconfig\t*cfg;\n\tstruct an_ltv_ssidlist\t*ssid;\n\tstruct an_ltv_aplist\t*ap;\n\tstruct an_ltv_gen\t*sp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch (areq->an_type) {\n\tcase AN_RID_GENCONFIG:\n\t\tcfg = (struct an_ltv_genconfig *)areq;\n\n\t\tifa = ifnet_addrs[ifp->if_index - 1];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&cfg->an_macaddr, (char *)&sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN);\n\t\tbcopy((char *)&cfg->an_macaddr, LLADDR(sdl), ETHER_ADDR_LEN);\n\n\t\tbcopy((char *)cfg, (char *)&sc->an_config,\n\t\t\tsizeof(struct an_ltv_genconfig));\n\t\tbreak;\n\tcase AN_RID_SSIDLIST:\n\t\tssid = (struct an_ltv_ssidlist *)areq;\n\t\tbcopy((char *)ssid, (char *)&sc->an_ssidlist,\n\t\t\tsizeof(struct an_ltv_ssidlist));\n\t\tbreak;\n\tcase AN_RID_APLIST:\n\t\tap = (struct an_ltv_aplist *)areq;\n\t\tbcopy((char *)ap, (char *)&sc->an_aplist,\n\t\t\tsizeof(struct an_ltv_aplist));\n\t\tbreak;\n\tcase AN_RID_TX_SPEED:\n\t\tsp = (struct an_ltv_gen *)areq;\n\t\tsc->an_tx_rate = sp->an_val;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown RID: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, areq->an_type);\n\t\treturn;\n\t}\n\n\t/* Reinitialize the card. */\n\tif (ifp->if_flags & IFF_UP)\n\t\tan_init(sc);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_setdef"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_setdef;\n\nvoid\nan_setdef(sc, areq)\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\t*areq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\tstruct an_ltv_genconfig\t*cfg;\n\tstruct an_ltv_ssidlist\t*ssid;\n\tstruct an_ltv_aplist\t*ap;\n\tstruct an_ltv_gen\t*sp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch (areq->an_type) {\n\tcase AN_RID_GENCONFIG:\n\t\tcfg = (struct an_ltv_genconfig *)areq;\n\n\t\tifa = ifnet_addrs[ifp->if_index - 1];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&cfg->an_macaddr, (char *)&sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN);\n\t\tbcopy((char *)&cfg->an_macaddr, LLADDR(sdl), ETHER_ADDR_LEN);\n\n\t\tbcopy((char *)cfg, (char *)&sc->an_config,\n\t\t\tsizeof(struct an_ltv_genconfig));\n\t\tbreak;\n\tcase AN_RID_SSIDLIST:\n\t\tssid = (struct an_ltv_ssidlist *)areq;\n\t\tbcopy((char *)ssid, (char *)&sc->an_ssidlist,\n\t\t\tsizeof(struct an_ltv_ssidlist));\n\t\tbreak;\n\tcase AN_RID_APLIST:\n\t\tap = (struct an_ltv_aplist *)areq;\n\t\tbcopy((char *)ap, (char *)&sc->an_aplist,\n\t\t\tsizeof(struct an_ltv_aplist));\n\t\tbreak;\n\tcase AN_RID_TX_SPEED:\n\t\tsp = (struct an_ltv_gen *)areq;\n\t\tsc->an_tx_rate = sp->an_val;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown RID: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, areq->an_type);\n\t\treturn;\n\t}\n\n\t/* Reinitialize the card. */\n\tif (ifp->if_flags & IFF_UP)\n\t\tan_init(sc);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&areq",
            "sizeof(areq)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&areq",
            "ifr->ifr_data",
            "sizeof(areq)"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_read_record",
          "args": [
            "sc",
            "(struct an_ltv_gen *)&areq"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "an_read_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "581-623",
          "snippet": "int an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_read_record",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_read_record;\nint an_seek;\n\nint an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&sc->an_sigcache",
            "(char *)pt",
            "sizeof(struct an_sigcache) * sc->an_sigitems"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "ifr->ifr_data",
            "&areq",
            "sizeof(areq)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_stop",
          "args": [
            "sc"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "an_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1183-1206",
          "snippet": "void an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nvoid an_stats_update;\n\nvoid an_stop(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tan_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\tfor (i = 0; i < AN_TX_RING_CNT; i++)\n\t\tan_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);\n\n\tUNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_init",
          "args": [
            "sc"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "an_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1001-1093",
          "snippet": "void\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_init_tx_ring",
            "int an_cmd",
            "int an_write_record",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_init_tx_ring;\nint an_cmd;\nint an_write_record;\nvoid an_stats_update;\n\nvoid\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_promisc",
          "args": [
            "sc",
            "0"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "an_promisc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "841-871",
          "snippet": "void an_promisc(sc, promisc)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tpromisc;\n{\n\t/* Disable the MAC. */\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\t/* Set RX mode. */\n\tif (promisc &&\n\t    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)\n\t    ) {\n\t\tsc->an_rxmode = sc->an_config.an_rxmode;\n\t\tsc->an_config.an_rxmode |=\n\t\t    AN_RXMODE_LAN_MONITOR_CURBSS;\n\t} else {\n\t\tsc->an_config.an_rxmode = sc->an_rxmode;\n\t}\n\n\t/* Transfer the configuration to the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\t/* Turn the MAC back on. */\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_promisc",
            "int an_cmd",
            "int an_write_record"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_promisc;\nint an_cmd;\nint an_write_record;\n\nvoid an_promisc(sc, promisc)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tpromisc;\n{\n\t/* Disable the MAC. */\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\t/* Set RX mode. */\n\tif (promisc &&\n\t    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)\n\t    ) {\n\t\tsc->an_rxmode = sc->an_config.an_rxmode;\n\t\tsc->an_config.an_rxmode |=\n\t\t    AN_RXMODE_LAN_MONITOR_CURBSS;\n\t} else {\n\t\tsc->an_config.an_rxmode = sc->an_rxmode;\n\t}\n\n\t/* Transfer the configuration to the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\t/* Turn the MAC back on. */\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ANCACHE\t\t\t/* enable signal strength cache */\n\nint an_ioctl;\nvoid an_promisc;\nint an_read_record;\nvoid an_setdef;\n\nint an_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tint\t\t\ts, error = 0;\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\tareq;\n\tstruct ifreq\t\t*ifr;\n\tstruct ifaddr\t\t*ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tsc = ifp->if_softc;\n\tifr = (struct ifreq *)data;\n\n\tif (sc->an_gone)\n\t\treturn(ENODEV);\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tan_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tan_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->an_if_flags & IFF_PROMISC)) {\n\t\t\t\tan_promisc(sc, 1);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->an_if_flags & IFF_PROMISC) {\n\t\t\t\tan_promisc(sc, 0);\n\t\t\t} else\n\t\t\t\tan_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tan_stop(sc);\n\t\t}\n\t\tsc->an_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* The Aironet has no multicast filter. */\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGAIRONET:\n\t\terror = copyin(ifr->ifr_data, &areq, sizeof(areq));\n\t\tif (error)\n\t\t\tbreak;\n#ifdef ANCACHE\n\t\tif (areq.an_type == AN_RID_ZERO_CACHE) {\n\t\t\tsc->an_sigitems = sc->an_nextitem = 0;\n\t\t\tbreak;\n\t\t} else if (areq.an_type == AN_RID_READ_CACHE) {\n\t\t\tchar *pt = (char *)&areq.an_val;\n\t\t\tbcopy((char *)&sc->an_sigitems, (char *)pt,\n\t\t\t    sizeof(int));\n\t\t\tpt += sizeof(int);\n\t\t\tareq.an_len = sizeof(int) / 2;\n\t\t\tbcopy((char *)&sc->an_sigcache, (char *)pt,\n\t\t\t    sizeof(struct an_sigcache) * sc->an_sigitems);\n\t\t\tareq.an_len += ((sizeof(struct an_sigcache) *\n\t\t\t    sc->an_sigitems) / 2) + 1;\n\t\t} else\n#endif\n\t\tif (an_read_record(sc, (struct an_ltv_gen *)&areq)) {\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terror = copyout(&areq, ifr->ifr_data, sizeof(areq));\n\t\tbreak;\n\tcase SIOCSAIRONET:\n\t\terror = copyin(ifr->ifr_data, &areq, sizeof(areq));\n\t\tif (error)\n\t\t\tbreak;\n\t\tan_setdef(sc, &areq);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "an_promisc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "841-871",
    "snippet": "void an_promisc(sc, promisc)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tpromisc;\n{\n\t/* Disable the MAC. */\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\t/* Set RX mode. */\n\tif (promisc &&\n\t    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)\n\t    ) {\n\t\tsc->an_rxmode = sc->an_config.an_rxmode;\n\t\tsc->an_config.an_rxmode |=\n\t\t    AN_RXMODE_LAN_MONITOR_CURBSS;\n\t} else {\n\t\tsc->an_config.an_rxmode = sc->an_rxmode;\n\t}\n\n\t/* Transfer the configuration to the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\t/* Turn the MAC back on. */\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_promisc",
      "int an_cmd",
      "int an_write_record"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_ENABLE",
            "0"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to set configuration\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_write_record",
          "args": [
            "sc",
            "(struct an_ltv_gen *)&sc->an_config"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "an_write_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "628-651",
          "snippet": "int an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_write_record",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_write_record;\nint an_seek;\n\nint an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_promisc;\nint an_cmd;\nint an_write_record;\n\nvoid an_promisc(sc, promisc)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tpromisc;\n{\n\t/* Disable the MAC. */\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\t/* Set RX mode. */\n\tif (promisc &&\n\t    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)\n\t    ) {\n\t\tsc->an_rxmode = sc->an_config.an_rxmode;\n\t\tsc->an_config.an_rxmode |=\n\t\t    AN_RXMODE_LAN_MONITOR_CURBSS;\n\t} else {\n\t\tsc->an_config.an_rxmode = sc->an_rxmode;\n\t}\n\n\t/* Transfer the configuration to the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\t/* Turn the MAC back on. */\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_setdef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "780-834",
    "snippet": "void\nan_setdef(sc, areq)\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\t*areq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\tstruct an_ltv_genconfig\t*cfg;\n\tstruct an_ltv_ssidlist\t*ssid;\n\tstruct an_ltv_aplist\t*ap;\n\tstruct an_ltv_gen\t*sp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch (areq->an_type) {\n\tcase AN_RID_GENCONFIG:\n\t\tcfg = (struct an_ltv_genconfig *)areq;\n\n\t\tifa = ifnet_addrs[ifp->if_index - 1];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&cfg->an_macaddr, (char *)&sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN);\n\t\tbcopy((char *)&cfg->an_macaddr, LLADDR(sdl), ETHER_ADDR_LEN);\n\n\t\tbcopy((char *)cfg, (char *)&sc->an_config,\n\t\t\tsizeof(struct an_ltv_genconfig));\n\t\tbreak;\n\tcase AN_RID_SSIDLIST:\n\t\tssid = (struct an_ltv_ssidlist *)areq;\n\t\tbcopy((char *)ssid, (char *)&sc->an_ssidlist,\n\t\t\tsizeof(struct an_ltv_ssidlist));\n\t\tbreak;\n\tcase AN_RID_APLIST:\n\t\tap = (struct an_ltv_aplist *)areq;\n\t\tbcopy((char *)ap, (char *)&sc->an_aplist,\n\t\t\tsizeof(struct an_ltv_aplist));\n\t\tbreak;\n\tcase AN_RID_TX_SPEED:\n\t\tsp = (struct an_ltv_gen *)areq;\n\t\tsc->an_tx_rate = sp->an_val;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown RID: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, areq->an_type);\n\t\treturn;\n\t}\n\n\t/* Reinitialize the card. */\n\tif (ifp->if_flags & IFF_UP)\n\t\tan_init(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_setdef"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_init",
          "args": [
            "sc"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "an_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1001-1093",
          "snippet": "void\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_init_tx_ring",
            "int an_cmd",
            "int an_write_record",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_init_tx_ring;\nint an_cmd;\nint an_write_record;\nvoid an_stats_update;\n\nvoid\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unknown RID: %x\\n\"",
            "sc->sc_dev.dv_xname",
            "areq->an_type"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)ap",
            "(char *)&sc->an_aplist",
            "sizeof(struct an_ltv_aplist)"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "sdl"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_setdef;\n\nvoid\nan_setdef(sc, areq)\n\tstruct an_softc\t\t*sc;\n\tstruct an_req\t\t*areq;\n{\n\tstruct sockaddr_dl\t*sdl;\n\tstruct ifaddr\t\t*ifa;\n\tstruct ifnet\t\t*ifp;\n\tstruct an_ltv_genconfig\t*cfg;\n\tstruct an_ltv_ssidlist\t*ssid;\n\tstruct an_ltv_aplist\t*ap;\n\tstruct an_ltv_gen\t*sp;\n\textern struct ifaddr\t**ifnet_addrs;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tswitch (areq->an_type) {\n\tcase AN_RID_GENCONFIG:\n\t\tcfg = (struct an_ltv_genconfig *)areq;\n\n\t\tifa = ifnet_addrs[ifp->if_index - 1];\n\t\tsdl = (struct sockaddr_dl *)ifa->ifa_addr;\n\t\tbcopy((char *)&cfg->an_macaddr, (char *)&sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN);\n\t\tbcopy((char *)&cfg->an_macaddr, LLADDR(sdl), ETHER_ADDR_LEN);\n\n\t\tbcopy((char *)cfg, (char *)&sc->an_config,\n\t\t\tsizeof(struct an_ltv_genconfig));\n\t\tbreak;\n\tcase AN_RID_SSIDLIST:\n\t\tssid = (struct an_ltv_ssidlist *)areq;\n\t\tbcopy((char *)ssid, (char *)&sc->an_ssidlist,\n\t\t\tsizeof(struct an_ltv_ssidlist));\n\t\tbreak;\n\tcase AN_RID_APLIST:\n\t\tap = (struct an_ltv_aplist *)areq;\n\t\tbcopy((char *)ap, (char *)&sc->an_aplist,\n\t\t\tsizeof(struct an_ltv_aplist));\n\t\tbreak;\n\tcase AN_RID_TX_SPEED:\n\t\tsp = (struct an_ltv_gen *)areq;\n\t\tsc->an_tx_rate = sp->an_val;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown RID: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, areq->an_type);\n\t\treturn;\n\t}\n\n\t/* Reinitialize the card. */\n\tif (ifp->if_flags & IFF_UP)\n\t\tan_init(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_alloc_nicmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "747-778",
    "snippet": "int an_alloc_nicmem(sc, len, id)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {\n\t\tprintf(\"%s: failed to allocate %d bytes on NIC\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\t*id = CSR_READ_2(sc, AN_ALLOC_FID);\n\n\tif (an_seek(sc, *id, 0, AN_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, 0);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_cmd",
      "int an_seek",
      "int an_alloc_nicmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_DATA0",
            "0"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_seek",
          "args": [
            "sc",
            "*id",
            "0",
            "AN_BAP0"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "an_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "653-687",
          "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_ALLOC_FID"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_ALLOC"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_EVENT_STAT"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to allocate %d bytes on NIC\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_ALLOC_MEM",
            "len"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_seek;\nint an_alloc_nicmem;\n\nint an_alloc_nicmem(sc, len, id)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tlen;\n\tint\t\t\t*id;\n{\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {\n\t\tprintf(\"%s: failed to allocate %d bytes on NIC\\n\",\n\t\t    sc->sc_dev.dv_xname, len);\n\t\treturn(ENOMEM);\n\t}\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_ALLOC)\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\t*id = CSR_READ_2(sc, AN_ALLOC_FID);\n\n\tif (an_seek(sc, *id, 0, AN_BAP0))\n\t\treturn(EIO);\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, 0);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_write_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "716-741",
    "snippet": "int an_write_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP0))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, ptr[i]);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        CSR_WRITE_1(sc, AN_DATA0, ptr2[i]);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_write_data",
      "int an_seek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "AN_DATA0",
            "ptr2[i]"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_DATA0",
            "ptr[i]"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_seek",
          "args": [
            "sc",
            "id",
            "off",
            "AN_BAP0"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "an_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "653-687",
          "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_write_data;\nint an_seek;\n\nint an_write_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP0))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < (len / 2); i++)\n\t\tCSR_WRITE_2(sc, AN_DATA0, ptr[i]);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        CSR_WRITE_1(sc, AN_DATA0, ptr2[i]);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "689-714",
    "snippet": "int an_read_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP1))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        ptr2[i] = CSR_READ_1(sc, AN_DATA1);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_read_data",
      "int an_seek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "AN_DATA1"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_DATA1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_seek",
          "args": [
            "sc",
            "id",
            "off",
            "AN_BAP1"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "an_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "653-687",
          "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_read_data;\nint an_seek;\n\nint an_read_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP1))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        ptr2[i] = CSR_READ_1(sc, AN_DATA1);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "653-687",
    "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_seek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "offreg"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "offreg",
            "off"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "selreg",
            "id"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid data path: %x\\n\"",
            "sc->sc_dev.dv_xname",
            "chan"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_write_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "628-651",
    "snippet": "int an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_cmd",
      "int an_write_record",
      "int an_seek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_ACCESS|AN_ACCESS_WRITE",
            "ltv->an_type"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_DATA1",
            "ptr[i]"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_DATA1",
            "ltv->an_len"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_seek",
          "args": [
            "sc",
            "ltv->an_type",
            "0",
            "AN_BAP1"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "an_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "653-687",
          "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_write_record;\nint an_seek;\n\nint an_write_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti;\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))\n\t\treturn(EIO);\n\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1))\n\t\treturn(EIO);\n\n\tCSR_WRITE_2(sc, AN_DATA1, ltv->an_len);\n\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tCSR_WRITE_2(sc, AN_DATA1, ptr[i]);\n\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))\n\t\treturn(EIO);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_read_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "581-623",
    "snippet": "int an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_cmd",
      "int an_read_record",
      "int an_seek"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_DATA1"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: record length mismatch -- expected %d, got %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ltv->an_len",
            "len"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_DATA1"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_seek",
          "args": [
            "sc",
            "ltv->an_type",
            "0",
            "AN_BAP1"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "an_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "653-687",
          "snippet": "int an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_seek;\n\nint an_seek(sc, id, off, chan)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off, chan;\n{\n\tint\t\t\ti;\n\tint\t\t\tselreg, offreg;\n\n\tswitch (chan) {\n\tcase AN_BAP0:\n\t\tselreg = AN_SEL0;\n\t\toffreg = AN_OFF0;\n\t\tbreak;\n\tcase AN_BAP1:\n\t\tselreg = AN_SEL1;\n\t\toffreg = AN_OFF1;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid data path: %x\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\t\treturn(EIO);\n\t}\n\n\tCSR_WRITE_2(sc, selreg, id);\n\tCSR_WRITE_2(sc, offreg, off);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))\n\t\t\tbreak;\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_ACCESS|AN_ACCESS_READ",
            "ltv->an_type"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_read_record;\nint an_seek;\n\nint an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "558-576",
    "snippet": "void an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_reset",
      "int an_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_DISABLE",
            "0"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_cmd;\n\nvoid an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "501-551",
    "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_CLR_STUCK_BUSY"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_COMMAND"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_CMD"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_RESP2"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_RESP1"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_RESP0"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_STATUS"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_COMMAND",
            "cmd"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_COMMAND"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_EVENT_STAT"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_COMMAND",
            "cmd"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_PARAM2",
            "0"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_PARAM1",
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_PARAM0",
            "val"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "an_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "435-499",
    "snippet": "int\nan_intr(xsc)\n\tvoid\t*xsc;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\n\tsc = (struct an_softc*)xsc;\n\n\tif (sc->an_gone)\n\t\treturn 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, 0xFFFF);\n\t\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\t\treturn 0;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\n\tstatus = CSR_READ_2(sc, AN_EVENT_STAT);\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, ~AN_INTRS);\n\n\tif (status & AN_EV_AWAKE) {\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_AWAKE);\n\t}\n\n\tif (status & AN_EV_LINKSTAT) {\n\t\tif (CSR_READ_2(sc, AN_LINKSTAT) == AN_LINKSTAT_ASSOCIATED)\n\t\t\tsc->an_associated = 1;\n\t\telse\n\t\t\tsc->an_associated = 0;\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_LINKSTAT);\n\t}\n\n\tif (status & AN_EV_RX) {\n\t\tan_rxeof(sc);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);\n\t}\n\n\tif (status & AN_EV_TX) {\n\t\tan_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX);\n\t}\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tan_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX_EXC);\n\t}\n\n\tif (status & AN_EV_ALLOC)\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tan_start(ifp);\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_start",
      "void an_rxeof",
      "void an_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_start",
          "args": [
            "ifp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "an_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1095-1181",
          "snippet": "void an_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct mbuf\t\t*m0 = NULL;\n\tstruct an_txframe_802_3\ttx_frame_802_3;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\tint\t\t\tidx;\n\tunsigned char           txcontrol;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tif (!sc->an_associated)\n\t\treturn;\n\n\tidx = sc->an_rdata.an_tx_prod;\n\tbzero((char *)&tx_frame_802_3, sizeof(tx_frame_802_3));\n\n\twhile(sc->an_rdata.an_tx_ring[idx] == 0) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == NULL)\n\t\t\tbreak;\n\n\t\tid = sc->an_rdata.an_tx_fids[idx];\n\t\teh = mtod(m0, struct ether_header *);\n\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame_802_3.an_tx_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame_802_3.an_tx_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame_802_3.an_tx_802_3_payload_len =\n\t\t  m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */\n\n\t\tm_copydata(m0, sizeof(struct ether_header) - 2 ,\n\t\t    tx_frame_802_3.an_tx_802_3_payload_len,\n\t\t    (caddr_t)&sc->an_txbuf);\n\n\t\ttxcontrol=AN_TXCTL_8023;\n\t\t/* write the txcontrol only */\n\t\tan_write_data(sc, id, 0x08, (caddr_t)&txcontrol,\n\t\t\t      sizeof(txcontrol));\n\n\t\t/* 802_3 header */\n\t\tan_write_data(sc, id, 0x34, (caddr_t)&tx_frame_802_3,\n\t\t\t      sizeof(struct an_txframe_802_3));\n\n\t\t/* in mbuf header type is just before payload */\n\t\tan_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf,\n\t\t\t    tx_frame_802_3.an_tx_802_3_payload_len);\n\n\t\t/*\n\t\t * If there's a BPF listner, bounce a copy of\n\t\t * this frame to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tBPF_MTAP(ifp, m0);\n\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\n\t\tsc->an_rdata.an_tx_ring[idx] = id;\n\t\tif (an_cmd(sc, AN_CMD_TX, id))\n\t\t\tprintf(\"%s: xmit failed\\n\", sc->sc_dev.dv_xname);\n\n\t\tAN_INC(idx, AN_TX_RING_CNT);\n\t}\n\n\tif (m0 != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\tsc->an_rdata.an_tx_prod = idx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_start",
            "int an_cmd",
            "int an_write_data"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_start;\nint an_cmd;\nint an_write_data;\n\nvoid an_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct mbuf\t\t*m0 = NULL;\n\tstruct an_txframe_802_3\ttx_frame_802_3;\n\tstruct ether_header\t*eh;\n\tint\t\t\tid;\n\tint\t\t\tidx;\n\tunsigned char           txcontrol;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tif (!sc->an_associated)\n\t\treturn;\n\n\tidx = sc->an_rdata.an_tx_prod;\n\tbzero((char *)&tx_frame_802_3, sizeof(tx_frame_802_3));\n\n\twhile(sc->an_rdata.an_tx_ring[idx] == 0) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == NULL)\n\t\t\tbreak;\n\n\t\tid = sc->an_rdata.an_tx_fids[idx];\n\t\teh = mtod(m0, struct ether_header *);\n\n\t\tbcopy((char *)&eh->ether_dhost,\n\t\t    (char *)&tx_frame_802_3.an_tx_dst_addr, ETHER_ADDR_LEN);\n\t\tbcopy((char *)&eh->ether_shost,\n\t\t    (char *)&tx_frame_802_3.an_tx_src_addr, ETHER_ADDR_LEN);\n\n\t\ttx_frame_802_3.an_tx_802_3_payload_len =\n\t\t  m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */\n\n\t\tm_copydata(m0, sizeof(struct ether_header) - 2 ,\n\t\t    tx_frame_802_3.an_tx_802_3_payload_len,\n\t\t    (caddr_t)&sc->an_txbuf);\n\n\t\ttxcontrol=AN_TXCTL_8023;\n\t\t/* write the txcontrol only */\n\t\tan_write_data(sc, id, 0x08, (caddr_t)&txcontrol,\n\t\t\t      sizeof(txcontrol));\n\n\t\t/* 802_3 header */\n\t\tan_write_data(sc, id, 0x34, (caddr_t)&tx_frame_802_3,\n\t\t\t      sizeof(struct an_txframe_802_3));\n\n\t\t/* in mbuf header type is just before payload */\n\t\tan_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf,\n\t\t\t    tx_frame_802_3.an_tx_802_3_payload_len);\n\n\t\t/*\n\t\t * If there's a BPF listner, bounce a copy of\n\t\t * this frame to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tBPF_MTAP(ifp, m0);\n\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\n\t\tsc->an_rdata.an_tx_ring[idx] = id;\n\t\tif (an_cmd(sc, AN_CMD_TX, id))\n\t\t\tprintf(\"%s: xmit failed\\n\", sc->sc_dev.dv_xname);\n\n\t\tAN_INC(idx, AN_TX_RING_CNT);\n\t}\n\n\tif (m0 != NULL)\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\tsc->an_rdata.an_tx_prod = idx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "AN_INTRS"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_ALLOC"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_TX_EXC"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_txeof",
          "args": [
            "sc",
            "status"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "an_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "366-394",
          "snippet": "void\nan_txeof(sc, status)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tid = CSR_READ_2(sc, AN_TX_CMP_FID);\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tifp->if_oerrors++;\n\t} else\n\t\tifp->if_opackets++;\n\n\tif (id != sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons])\n\t\tprintf(\"%s: id mismatch: expected %x, got %x\\n\", ifp->if_xname,\n\t\t    sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons], id);\n\n\tsc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons] = 0;\n\tAN_INC(sc->an_rdata.an_tx_cons, AN_TX_RING_CNT);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_txeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_txeof;\n\nvoid\nan_txeof(sc, status)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tid = CSR_READ_2(sc, AN_TX_CMP_FID);\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tifp->if_oerrors++;\n\t} else\n\t\tifp->if_opackets++;\n\n\tif (id != sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons])\n\t\tprintf(\"%s: id mismatch: expected %x, got %x\\n\", ifp->if_xname,\n\t\t    sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons], id);\n\n\tsc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons] = 0;\n\tAN_INC(sc->an_rdata.an_tx_cons, AN_TX_RING_CNT);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_TX"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_RX"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_rxeof",
          "args": [
            "sc"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "an_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "266-364",
          "snippet": "void\nan_rxeof(sc)\n\tstruct an_softc\t *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n#ifdef ANCACHE\n\tstruct an_rxframe\trx_frame;\n#endif\n\tstruct an_rxframe_802_3\trx_frame_802_3;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid, error = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, AN_RX_FID);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.rcvif = ifp;\n\n\teh = mtod(m, struct ether_header *);\n\n#ifdef ANCACHE\n\t/* Read NIC frame header */\n\tif (an_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n#endif\n\t/* Read in the 802_3 frame header */\n\tif (an_read_data(sc, id, 0x34, (caddr_t)&rx_frame_802_3,\n\t\t\t sizeof(rx_frame_802_3))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame_802_3.an_rx_802_3_status != 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Check for insane frame length */\n\tif (rx_frame_802_3.an_rx_802_3_payload_len > MCLBYTES) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.len = m->m_len =\n\t    rx_frame_802_3.an_rx_802_3_payload_len + 12;\n\n\n\tbcopy((char *)&rx_frame_802_3.an_rx_dst_addr,\n\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy((char *)&rx_frame_802_3.an_rx_src_addr,\n\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\n\t/* in mbuf header type is just before payload */\n\terror = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type),\n\t\t\t     rx_frame_802_3.an_rx_802_3_payload_len);\n\n\tif (error) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf) {\n\t\tBPF_MTAP(ifp, m);\n\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n#ifdef ANCACHE\n\tan_cache_store(sc, eh, m, rx_frame.an_rx_signal_strength);\n#endif\n\tether_input(ifp, eh, m);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ANCACHE\t\t\t/* enable signal strength cache */"
          ],
          "globals_used": [
            "void an_rxeof",
            "int an_read_data"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ANCACHE\t\t\t/* enable signal strength cache */\n\nvoid an_rxeof;\nint an_read_data;\n\nvoid\nan_rxeof(sc)\n\tstruct an_softc\t *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n#ifdef ANCACHE\n\tstruct an_rxframe\trx_frame;\n#endif\n\tstruct an_rxframe_802_3\trx_frame_802_3;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid, error = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, AN_RX_FID);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.rcvif = ifp;\n\n\teh = mtod(m, struct ether_header *);\n\n#ifdef ANCACHE\n\t/* Read NIC frame header */\n\tif (an_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n#endif\n\t/* Read in the 802_3 frame header */\n\tif (an_read_data(sc, id, 0x34, (caddr_t)&rx_frame_802_3,\n\t\t\t sizeof(rx_frame_802_3))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame_802_3.an_rx_802_3_status != 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Check for insane frame length */\n\tif (rx_frame_802_3.an_rx_802_3_payload_len > MCLBYTES) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.len = m->m_len =\n\t    rx_frame_802_3.an_rx_802_3_payload_len + 12;\n\n\n\tbcopy((char *)&rx_frame_802_3.an_rx_dst_addr,\n\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy((char *)&rx_frame_802_3.an_rx_src_addr,\n\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\n\t/* in mbuf header type is just before payload */\n\terror = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type),\n\t\t\t     rx_frame_802_3.an_rx_802_3_payload_len);\n\n\tif (error) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf) {\n\t\tBPF_MTAP(ifp, m);\n\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n#ifdef ANCACHE\n\tan_cache_store(sc, eh, m, rx_frame.an_rx_signal_strength);\n#endif\n\tether_input(ifp, eh, m);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_LINKSTAT"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_LINKSTAT"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "AN_EV_AWAKE"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "~AN_INTRS"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_EVENT_STAT"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "0"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "0xFFFF"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_start;\nvoid an_rxeof;\nvoid an_txeof;\n\nint\nan_intr(xsc)\n\tvoid\t*xsc;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\n\tsc = (struct an_softc*)xsc;\n\n\tif (sc->an_gone)\n\t\treturn 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, 0xFFFF);\n\t\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\t\treturn 0;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\n\tstatus = CSR_READ_2(sc, AN_EVENT_STAT);\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, ~AN_INTRS);\n\n\tif (status & AN_EV_AWAKE) {\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_AWAKE);\n\t}\n\n\tif (status & AN_EV_LINKSTAT) {\n\t\tif (CSR_READ_2(sc, AN_LINKSTAT) == AN_LINKSTAT_ASSOCIATED)\n\t\t\tsc->an_associated = 1;\n\t\telse\n\t\t\tsc->an_associated = 0;\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_LINKSTAT);\n\t}\n\n\tif (status & AN_EV_RX) {\n\t\tan_rxeof(sc);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);\n\t}\n\n\tif (status & AN_EV_TX) {\n\t\tan_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX);\n\t}\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tan_txeof(sc, status);\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX_EXC);\n\t}\n\n\tif (status & AN_EV_ALLOC)\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tan_start(ifp);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "an_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "402-433",
    "snippet": "void\nan_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->an_status.an_type = AN_RID_STATUS;\n\tsc->an_status.an_len = sizeof(struct an_ltv_status);\n\tan_read_record(sc, (struct an_ltv_gen *)&sc->an_status);\n\n\tif (sc->an_status.an_opmode & AN_STATUS_OPMODE_IN_SYNC)\n\t\tsc->an_associated = 1;\n\telse\n\t\tsc->an_associated = 0;\n\n\t/* Don't do this while we're transmitting */\n\tif (!(ifp->if_flags & IFF_OACTIVE)) {\n\t\tsc->an_stats.an_len = sizeof(struct an_ltv_stats);\n\t\tsc->an_stats.an_type = AN_RID_32BITS_CUM;\n\t\tan_read_record(sc, (struct an_ltv_gen *)&sc->an_stats.an_len);\n\t}\n\n\tsplx(s);\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int an_read_record",
      "void an_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc->an_stat_ch",
            "an_stats_update",
            "sc",
            "hz"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_read_record",
          "args": [
            "sc",
            "(struct an_ltv_gen *)&sc->an_stats.an_len"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "an_read_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "581-623",
          "snippet": "int an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_read_record",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_read_record;\nint an_seek;\n\nint an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_read_record;\nvoid an_stats_update;\n\nvoid\nan_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct an_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\n\tsc->an_status.an_type = AN_RID_STATUS;\n\tsc->an_status.an_len = sizeof(struct an_ltv_status);\n\tan_read_record(sc, (struct an_ltv_gen *)&sc->an_status);\n\n\tif (sc->an_status.an_opmode & AN_STATUS_OPMODE_IN_SYNC)\n\t\tsc->an_associated = 1;\n\telse\n\t\tsc->an_associated = 0;\n\n\t/* Don't do this while we're transmitting */\n\tif (!(ifp->if_flags & IFF_OACTIVE)) {\n\t\tsc->an_stats.an_len = sizeof(struct an_ltv_stats);\n\t\tsc->an_stats.an_type = AN_RID_32BITS_CUM;\n\t\tan_read_record(sc, (struct an_ltv_gen *)&sc->an_stats.an_len);\n\t}\n\n\tsplx(s);\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n}"
  },
  {
    "function_name": "an_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "366-394",
    "snippet": "void\nan_txeof(sc, status)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tid = CSR_READ_2(sc, AN_TX_CMP_FID);\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tifp->if_oerrors++;\n\t} else\n\t\tifp->if_opackets++;\n\n\tif (id != sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons])\n\t\tprintf(\"%s: id mismatch: expected %x, got %x\\n\", ifp->if_xname,\n\t\t    sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons], id);\n\n\tsc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons] = 0;\n\tAN_INC(sc->an_rdata.an_tx_cons, AN_TX_RING_CNT);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AN_INC",
          "args": [
            "sc->an_rdata.an_tx_cons",
            "AN_TX_RING_CNT"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: id mismatch: expected %x, got %x\\n\"",
            "ifp->if_xname",
            "sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons]",
            "id"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_TX_CMP_FID"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_txeof;\n\nvoid\nan_txeof(sc, status)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tstatus;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\tid;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tid = CSR_READ_2(sc, AN_TX_CMP_FID);\n\n\tif (status & AN_EV_TX_EXC) {\n\t\tifp->if_oerrors++;\n\t} else\n\t\tifp->if_opackets++;\n\n\tif (id != sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons])\n\t\tprintf(\"%s: id mismatch: expected %x, got %x\\n\", ifp->if_xname,\n\t\t    sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons], id);\n\n\tsc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons] = 0;\n\tAN_INC(sc->an_rdata.an_tx_cons, AN_TX_RING_CNT);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "266-364",
    "snippet": "void\nan_rxeof(sc)\n\tstruct an_softc\t *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n#ifdef ANCACHE\n\tstruct an_rxframe\trx_frame;\n#endif\n\tstruct an_rxframe_802_3\trx_frame_802_3;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid, error = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, AN_RX_FID);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.rcvif = ifp;\n\n\teh = mtod(m, struct ether_header *);\n\n#ifdef ANCACHE\n\t/* Read NIC frame header */\n\tif (an_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n#endif\n\t/* Read in the 802_3 frame header */\n\tif (an_read_data(sc, id, 0x34, (caddr_t)&rx_frame_802_3,\n\t\t\t sizeof(rx_frame_802_3))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame_802_3.an_rx_802_3_status != 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Check for insane frame length */\n\tif (rx_frame_802_3.an_rx_802_3_payload_len > MCLBYTES) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.len = m->m_len =\n\t    rx_frame_802_3.an_rx_802_3_payload_len + 12;\n\n\n\tbcopy((char *)&rx_frame_802_3.an_rx_dst_addr,\n\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy((char *)&rx_frame_802_3.an_rx_src_addr,\n\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\n\t/* in mbuf header type is just before payload */\n\terror = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type),\n\t\t\t     rx_frame_802_3.an_rx_802_3_payload_len);\n\n\tif (error) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf) {\n\t\tBPF_MTAP(ifp, m);\n\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n#ifdef ANCACHE\n\tan_cache_store(sc, eh, m, rx_frame.an_rx_signal_strength);\n#endif\n\tether_input(ifp, eh, m);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ANCACHE\t\t\t/* enable signal strength cache */"
    ],
    "globals_used": [
      "void an_rxeof",
      "int an_read_data"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_cache_store",
          "args": [
            "sc",
            "eh",
            "m",
            "rx_frame.an_rx_signal_strength"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "an_cache_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1297-1414",
          "snippet": "void\nan_cache_store (sc, eh, m, rx_quality)\n\tstruct an_softc *sc;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tunsigned short rx_quality;\n{\n\tstruct ip *ip = 0;\n\tint i;\n\tstatic int cache_slot = 0;\t/* use this cache entry */\n\tstatic int wrapindex = 0;       /* next \"free\" cache entry */\n\tint saanp=0;\n\n\t/* filters:\n\t * 1. ip only\n\t * 2. configurable filter to throw out unicast packets,\n\t * keep multicast only.\n\t */\n\n\tif ((ntohs(eh->ether_type) == 0x800)) {\n\t\tsaanp = 1;\n\t}\n\n\t/* filter for ip packets only\n\t*/\n\tif (sc->an_cache_iponly && !saanp) {\n\t\treturn;\n\t}\n\n\t/* filter for broadcast/multicast only\n\t */\n\tif (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0)) {\n\t\treturn;\n\t}\n\n#ifdef SIGDEBUG\n\tprintf(\"an: q value %x (MSB=0x%x, LSB=0x%x) \\n\",\n\t    rx_quality & 0xffff, rx_quality >> 8, rx_quality & 0xff);\n#endif\n\n\t/* find the ip header.  we want to store the ip_src\n\t * address.\n\t */\n\tif (saanp) {\n\t\tip = mtod(m, struct ip *);\n\t}\n\n\t/* do a linear search for a matching MAC address\n\t * in the cache table\n\t * . MAC address is 6 bytes,\n\t * . var w_nextitem holds total number of entries already cached\n\t */\n\tfor(i = 0; i < sc->an_nextitem; i++) {\n\t\tif (! bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc,  6 )) {\n\t\t\t/* Match!,\n\t\t\t * so we already have this entry,\n\t\t\t * update the data\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* did we find a matching mac address?\n\t * if yes, then overwrite a previously existing cache entry\n\t */\n\tif (i < sc->an_nextitem )   {\n\t\tcache_slot = i;\n\t}\n\t/* else, have a new address entry,so\n\t * add this new entry,\n\t * if table full, then we need to replace LRU entry\n\t */\n\telse    {\n\n\t\t/* check for space in cache table\n\t\t * note: an_nextitem also holds number of entries\n\t\t * added in the cache table\n\t\t */\n\t\tif ( sc->an_nextitem < MAXANCACHE ) {\n\t\t\tcache_slot = sc->an_nextitem;\n\t\t\tsc->an_nextitem++;\n\t\t\tsc->an_sigitems = sc->an_nextitem;\n\t\t}\n\t\t/* no space found, so simply wrap anth wrap index\n\t\t * and \"zap\" the next entry\n\t\t */\n\t\telse {\n\t\t\tif (wrapindex == MAXANCACHE) {\n\t\t\t\twrapindex = 0;\n\t\t\t}\n\t\t\tcache_slot = wrapindex++;\n\t\t}\n\t}\n\n\t/* invariant: cache_slot now points at some slot\n\t * in cache.\n\t */\n\tif (cache_slot < 0 || cache_slot >= MAXANCACHE) {\n\t\tlog(LOG_ERR, \"an_cache_store, bad index: %d of \"\n\t\t    \"[0..%d], gross cache error\\n\",\n\t\t    cache_slot, MAXANCACHE);\n\t\treturn;\n\t}\n\n\t/*  store items in cache\n\t *  .ip source address\n\t *  .mac src\n\t *  .signal, etc.\n\t */\n\tif (saanp) {\n\t\tsc->an_sigcache[cache_slot].ipsrc = ip->ip_src.s_addr;\n\t}\n\tbcopy( eh->ether_shost, sc->an_sigcache[cache_slot].macsrc,  6);\n\n\tsc->an_sigcache[cache_slot].signal = rx_quality;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nan_cache_store (sc, eh, m, rx_quality)\n\tstruct an_softc *sc;\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tunsigned short rx_quality;\n{\n\tstruct ip *ip = 0;\n\tint i;\n\tstatic int cache_slot = 0;\t/* use this cache entry */\n\tstatic int wrapindex = 0;       /* next \"free\" cache entry */\n\tint saanp=0;\n\n\t/* filters:\n\t * 1. ip only\n\t * 2. configurable filter to throw out unicast packets,\n\t * keep multicast only.\n\t */\n\n\tif ((ntohs(eh->ether_type) == 0x800)) {\n\t\tsaanp = 1;\n\t}\n\n\t/* filter for ip packets only\n\t*/\n\tif (sc->an_cache_iponly && !saanp) {\n\t\treturn;\n\t}\n\n\t/* filter for broadcast/multicast only\n\t */\n\tif (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0)) {\n\t\treturn;\n\t}\n\n#ifdef SIGDEBUG\n\tprintf(\"an: q value %x (MSB=0x%x, LSB=0x%x) \\n\",\n\t    rx_quality & 0xffff, rx_quality >> 8, rx_quality & 0xff);\n#endif\n\n\t/* find the ip header.  we want to store the ip_src\n\t * address.\n\t */\n\tif (saanp) {\n\t\tip = mtod(m, struct ip *);\n\t}\n\n\t/* do a linear search for a matching MAC address\n\t * in the cache table\n\t * . MAC address is 6 bytes,\n\t * . var w_nextitem holds total number of entries already cached\n\t */\n\tfor(i = 0; i < sc->an_nextitem; i++) {\n\t\tif (! bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc,  6 )) {\n\t\t\t/* Match!,\n\t\t\t * so we already have this entry,\n\t\t\t * update the data\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* did we find a matching mac address?\n\t * if yes, then overwrite a previously existing cache entry\n\t */\n\tif (i < sc->an_nextitem )   {\n\t\tcache_slot = i;\n\t}\n\t/* else, have a new address entry,so\n\t * add this new entry,\n\t * if table full, then we need to replace LRU entry\n\t */\n\telse    {\n\n\t\t/* check for space in cache table\n\t\t * note: an_nextitem also holds number of entries\n\t\t * added in the cache table\n\t\t */\n\t\tif ( sc->an_nextitem < MAXANCACHE ) {\n\t\t\tcache_slot = sc->an_nextitem;\n\t\t\tsc->an_nextitem++;\n\t\t\tsc->an_sigitems = sc->an_nextitem;\n\t\t}\n\t\t/* no space found, so simply wrap anth wrap index\n\t\t * and \"zap\" the next entry\n\t\t */\n\t\telse {\n\t\t\tif (wrapindex == MAXANCACHE) {\n\t\t\t\twrapindex = 0;\n\t\t\t}\n\t\t\tcache_slot = wrapindex++;\n\t\t}\n\t}\n\n\t/* invariant: cache_slot now points at some slot\n\t * in cache.\n\t */\n\tif (cache_slot < 0 || cache_slot >= MAXANCACHE) {\n\t\tlog(LOG_ERR, \"an_cache_store, bad index: %d of \"\n\t\t    \"[0..%d], gross cache error\\n\",\n\t\t    cache_slot, MAXANCACHE);\n\t\treturn;\n\t}\n\n\t/*  store items in cache\n\t *  .ip source address\n\t *  .mac src\n\t *  .signal, etc.\n\t */\n\tif (saanp) {\n\t\tsc->an_sigcache[cache_slot].ipsrc = ip->ip_src.s_addr;\n\t}\n\tbcopy( eh->ether_shost, sc->an_sigcache[cache_slot].macsrc,  6);\n\n\tsc->an_sigcache[cache_slot].signal = rx_quality;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_dhost",
            "sc->arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_read_data",
          "args": [
            "sc",
            "id",
            "0x44",
            "(caddr_t)&(eh->ether_type)",
            "rx_frame_802_3.an_rx_802_3_payload_len"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "an_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "689-714",
          "snippet": "int an_read_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP1))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        ptr2[i] = CSR_READ_1(sc, AN_DATA1);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_read_data",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_read_data;\nint an_seek;\n\nint an_read_data(sc, id, off, buf, len)\n\tstruct an_softc\t\t*sc;\n\tint\t\t\tid, off;\n\tcaddr_t\t\t\tbuf;\n\tint\t\t\tlen;\n{\n\tint\t\t\ti;\n\tu_int16_t\t\t*ptr;\n\tu_int8_t\t\t*ptr2;\n\n\tif (off != -1) {\n\t\tif (an_seek(sc, id, off, AN_BAP1))\n\t\t\treturn(EIO);\n\t}\n\n\tptr = (u_int16_t *)buf;\n\tfor (i = 0; i < len / 2; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\ti*=2;\n\tif (i<len){\n\t        ptr2 = (u_int8_t *)buf;\n\t        ptr2[i] = CSR_READ_1(sc, AN_DATA1);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char *)&rx_frame_802_3.an_rx_src_addr",
            "(char *)&eh->ether_shost",
            "ETHER_ADDR_LEN"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "AN_RX_FID"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ANCACHE\t\t\t/* enable signal strength cache */\n\nvoid an_rxeof;\nint an_read_data;\n\nvoid\nan_rxeof(sc)\n\tstruct an_softc\t *sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct ether_header\t*eh;\n#ifdef ANCACHE\n\tstruct an_rxframe\trx_frame;\n#endif\n\tstruct an_rxframe_802_3\trx_frame_802_3;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tid, error = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tid = CSR_READ_2(sc, AN_RX_FID);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == NULL) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\tMCLGET(m, M_DONTWAIT);\n\tif (!(m->m_flags & M_EXT)) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.rcvif = ifp;\n\n\teh = mtod(m, struct ether_header *);\n\n#ifdef ANCACHE\n\t/* Read NIC frame header */\n\tif (an_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n#endif\n\t/* Read in the 802_3 frame header */\n\tif (an_read_data(sc, id, 0x34, (caddr_t)&rx_frame_802_3,\n\t\t\t sizeof(rx_frame_802_3))) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tif (rx_frame_802_3.an_rx_802_3_status != 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Check for insane frame length */\n\tif (rx_frame_802_3.an_rx_802_3_payload_len > MCLBYTES) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tm->m_pkthdr.len = m->m_len =\n\t    rx_frame_802_3.an_rx_802_3_payload_len + 12;\n\n\n\tbcopy((char *)&rx_frame_802_3.an_rx_dst_addr,\n\t    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy((char *)&rx_frame_802_3.an_rx_src_addr,\n\t    (char *)&eh->ether_shost, ETHER_ADDR_LEN);\n\n\t/* in mbuf header type is just before payload */\n\terror = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type),\n\t\t\t     rx_frame_802_3.an_rx_802_3_payload_len);\n\n\tif (error) {\n\t\tm_freem(m);\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* Handle BPF listeners. */\n\tif (ifp->if_bpf) {\n\t\tBPF_MTAP(ifp, m);\n\t\tif (ifp->if_flags & IFF_PROMISC &&\n\t\t    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,\n\t\t    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Receive packet. */\n\tm_adj(m, sizeof(struct ether_header));\n#ifdef ANCACHE\n\tan_cache_store(sc, eh, m, rx_frame.an_rx_signal_strength);\n#endif\n\tether_input(ifp, eh, m);\n\n\treturn;\n}"
  },
  {
    "function_name": "an_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
    "lines": "165-264",
    "snippet": "int\nan_attach(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t*ifp = &sc->arpcom.ac_if;\n\n\tsc->an_gone = 0;\n\tsc->an_associated = 0;\n\n\t/* disable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, 0xffff);\n\n\t/* Reset the NIC. */\n\tan_reset(sc);\n\n\t/* Load factory config */\n\tif (an_cmd(sc, AN_CMD_READCFG, 0)) {\n\t\tprintf(\"%s: failed to load config data\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read the current configuration */\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read the card capabilities */\n\tsc->an_caps.an_type = AN_RID_CAPABILITIES;\n\tsc->an_caps.an_len = sizeof(struct an_ltv_caps);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_caps)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\tbcopy((char *)&sc->an_caps.an_oemaddr,\n\t   (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\": address: %6s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = an_ioctl;\n\tifp->if_start = an_start;\n\tifp->if_watchdog = an_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbzero(sc->an_config.an_nodename, sizeof(sc->an_config.an_nodename));\n\tbcopy(AN_DEFAULT_NODENAME, sc->an_config.an_nodename,\n\t    sizeof(AN_DEFAULT_NODENAME) - 1);\n\n\tbzero(sc->an_ssidlist.an_ssid1, sizeof(sc->an_ssidlist.an_ssid1));\n\tbcopy(AN_DEFAULT_NETNAME, sc->an_ssidlist.an_ssid1,\n\t    sizeof(AN_DEFAULT_NETNAME) - 1);\n\tsc->an_ssidlist.an_ssid1_len = strlen(AN_DEFAULT_NETNAME);\n\n\tsc->an_config.an_opmode = AN_OPMODE_IBSS_ADHOC;\n\n\tsc->an_tx_rate = 0;\n\tbzero((char *)&sc->an_stats, sizeof(sc->an_stats));\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\ttimeout_set(&sc->an_stat_ch, an_stats_update, sc);\n#if NBPFILTER > 0\n\tBPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(an_shutdown, sc);\n\n\tan_init(sc);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/anreg.h>",
      "#include <dev/ic/anvar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/sysctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/timeout.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void an_reset",
      "int an_ioctl",
      "void an_start",
      "void an_watchdog",
      "int an_cmd",
      "int an_read_record",
      "void an_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "an_init",
          "args": [
            "sc"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "an_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "1001-1093",
          "snippet": "void\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_init_tx_ring",
            "int an_cmd",
            "int an_write_record",
            "void an_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_init_tx_ring;\nint an_cmd;\nint an_write_record;\nvoid an_stats_update;\n\nvoid\nan_init(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts;\n\n\tif (sc->an_gone)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\tan_stop(sc);\n\n\tsc->an_associated = 0;\n\n\t/* Allocate the TX buffers */\n\tif (an_init_tx_ring(sc)) {\n\t\tan_reset(sc);\n\t\tif (an_init_tx_ring(sc)) {\n\t\t\tprintf(\"%s: tx buffer allocation failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Set our MAC address. */\n\tbcopy((char *)&sc->arpcom.ac_enaddr,\n\t    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);\n\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;\n\telse\n\t\tsc->an_config.an_rxmode = AN_RXMODE_ADDR;\n\n\tif (ifp->if_flags & IFF_MULTICAST)\n\t\tsc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;\n\n\t/* Initialize promisc mode. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;\n\n\tsc->an_rxmode = sc->an_config.an_rxmode;\n\n\t/* Set the ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: failed to set ssid list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: failed to set AP list\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Set the configuration in the NIC */\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tif (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: failed to set configuration\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Enable the MAC */\n\tif (an_cmd(sc, AN_CMD_ENABLE, 0)) {\n\t\tprintf(\"%s: failed to enable MAC\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* enable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);\n\n\tsplx(s);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tTIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "an_shutdown",
            "sc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPFATTACH",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->an_stat_ch",
            "an_stats_update",
            "sc"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->an_stats",
            "sizeof(sc->an_stats)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "AN_DEFAULT_NETNAME"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "AN_DEFAULT_NETNAME",
            "sc->an_ssidlist.an_ssid1",
            "sizeof(AN_DEFAULT_NETNAME) - 1"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->an_ssidlist.an_ssid1",
            "sizeof(sc->an_ssidlist.an_ssid1)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->an_config.an_nodename",
            "sizeof(sc->an_config.an_nodename)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": address: %6s\\n\"",
            "ether_sprintf(sc->arpcom.ac_enaddr)"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "an_read_record",
          "args": [
            "sc",
            "(struct an_ltv_gen *)&sc->an_aplist"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "an_read_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "581-623",
          "snippet": "int an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd",
            "int an_read_record",
            "int an_seek"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\nint an_read_record;\nint an_seek;\n\nint an_read_record(sc, ltv)\n\tstruct an_softc\t\t*sc;\n\tstruct an_ltv_gen\t*ltv;\n{\n\tu_int16_t\t\t*ptr;\n\tint\t\t\ti, len;\n\n\tif (ltv->an_len == 0 || ltv->an_type == 0)\n\t\treturn(EINVAL);\n\n\t/* Tell the NIC to enter record read mode. */\n\tif (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {\n\t\tprintf(\"%s: RID access failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Seek to the record. */\n\tif (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {\n\t\tprintf(\"%s: seek to record failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn(EIO);\n\t}\n\n\t/*\n\t * Read the length and record type and make sure they\n\t * match what we expect (this verifies that we have enough\n\t * room to hold all of the returned data).\n\t */\n\tlen = CSR_READ_2(sc, AN_DATA1);\n\tif (len > ltv->an_len) {\n\t\tprintf(\"%s: record length mismatch -- expected %d, got %d\\n\",\n\t\t    sc->sc_dev.dv_xname, ltv->an_len, len);\n\t\treturn(ENOSPC);\n\t}\n\n\tltv->an_len = len;\n\n\t/* Now read the data. */\n\tptr = &ltv->an_val;\n\tfor (i = 0; i < (ltv->an_len - 1) >> 1; i++)\n\t\tptr[i] = CSR_READ_2(sc, AN_DATA1);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_cmd",
          "args": [
            "sc",
            "AN_CMD_READCFG",
            "0"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "an_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "501-551",
          "snippet": "int\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint an_cmd;\n\nint\nan_cmd(sc, cmd, val)\n\tstruct an_softc *sc;\n\tint cmd;\n\tint val;\n{\n\tint i;\n\n\tCSR_WRITE_2(sc, AN_PARAM0, val);\n\tCSR_WRITE_2(sc, AN_PARAM1, 0);\n\tCSR_WRITE_2(sc, AN_PARAM2, 0);\n\tDELAY(10);\n\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\tDELAY(10);\n\n\tfor (i = AN_TIMEOUT; i--; DELAY(10)) {\n\t\tif (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)\n\t\t\tbreak;\n\t\telse {\n\t\t\tif (CSR_READ_2(sc, AN_COMMAND) == cmd) {\n\t\t\t\tDELAY(10);\n\t\t\t\tCSR_WRITE_2(sc, AN_COMMAND, cmd);\n\t\t\t}\n\t\t}\n\t}\n/* printf(\"<<cmd %x,%d>>\", cmd, i); */\n#if 0\n\tDELAY(100);\n\tfor (i = AN_TIMEOUT; i--; DELAY(100)) {\n\t\tint s = CSR_READ_2(sc, AN_STATUS);\n\t\tCSR_READ_2(sc, AN_RESP0);\n\t\tCSR_READ_2(sc, AN_RESP1);\n\t\tCSR_READ_2(sc, AN_RESP2);\n\t\tif ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))\n\t\t\tbreak;\n\t}\n/*printf(\"<<resp %d, %x>>\", i, s);*/\n#endif\n\t/* Ack the command */\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);\n\n\tif (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {\n/*printf(\"busy\");*/\n\t\tCSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);\n\t}\n\n\tif (i <= 0)\n\t\treturn(ETIMEDOUT);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "an_reset",
          "args": [
            "sc"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "an_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/an.c",
          "lines": "558-576",
          "snippet": "void an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/anreg.h>",
            "#include <dev/ic/anvar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/timeout.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void an_reset",
            "int an_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_cmd;\n\nvoid an_reset(sc)\n\tstruct an_softc\t\t*sc;\n{\n\tif (sc->an_gone)\n\t\treturn;\n/*printf(\"ena \");*/\n\tan_cmd(sc, AN_CMD_ENABLE, 0);\n/* printf(\"rst \");*/\n\tan_cmd(sc, AN_CMD_FW_RESTART, 0);\n/*printf(\"nop \");*/\n\tan_cmd(sc, AN_CMD_NOOP2, 0);\n\n\tif (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)\n\t\tprintf(\"%s: reset failed\\n\", sc->sc_dev.dv_xname);\n\n\tan_cmd(sc, AN_CMD_DISABLE, 0);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_EVENT_ACK",
            "0xffff"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "AN_INT_EN",
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/anreg.h>\n#include <dev/ic/anvar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sysctl.h>\n#include <sys/syslog.h>\n#include <sys/timeout.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid an_reset;\nint an_ioctl;\nvoid an_start;\nvoid an_watchdog;\nint an_cmd;\nint an_read_record;\nvoid an_stats_update;\n\nint\nan_attach(sc)\n\tstruct an_softc *sc;\n{\n\tstruct ifnet\t*ifp = &sc->arpcom.ac_if;\n\n\tsc->an_gone = 0;\n\tsc->an_associated = 0;\n\n\t/* disable interrupts */\n\tCSR_WRITE_2(sc, AN_INT_EN, 0);\n\tCSR_WRITE_2(sc, AN_EVENT_ACK, 0xffff);\n\n\t/* Reset the NIC. */\n\tan_reset(sc);\n\n\t/* Load factory config */\n\tif (an_cmd(sc, AN_CMD_READCFG, 0)) {\n\t\tprintf(\"%s: failed to load config data\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read the current configuration */\n\tsc->an_config.an_type = AN_RID_GENCONFIG;\n\tsc->an_config.an_len = sizeof(struct an_ltv_genconfig);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_config)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read the card capabilities */\n\tsc->an_caps.an_type = AN_RID_CAPABILITIES;\n\tsc->an_caps.an_len = sizeof(struct an_ltv_caps);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_caps)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read ssid list */\n\tsc->an_ssidlist.an_type = AN_RID_SSIDLIST;\n\tsc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\t/* Read AP list */\n\tsc->an_aplist.an_type = AN_RID_APLIST;\n\tsc->an_aplist.an_len = sizeof(struct an_ltv_aplist);\n\tif (an_read_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {\n\t\tprintf(\"%s: read record failed\\n\", ifp->if_xname);\n\t\treturn(EIO);\n\t}\n\n\tbcopy((char *)&sc->an_caps.an_oemaddr,\n\t   (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\": address: %6s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = an_ioctl;\n\tifp->if_start = an_start;\n\tifp->if_watchdog = an_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\tbzero(sc->an_config.an_nodename, sizeof(sc->an_config.an_nodename));\n\tbcopy(AN_DEFAULT_NODENAME, sc->an_config.an_nodename,\n\t    sizeof(AN_DEFAULT_NODENAME) - 1);\n\n\tbzero(sc->an_ssidlist.an_ssid1, sizeof(sc->an_ssidlist.an_ssid1));\n\tbcopy(AN_DEFAULT_NETNAME, sc->an_ssidlist.an_ssid1,\n\t    sizeof(AN_DEFAULT_NETNAME) - 1);\n\tsc->an_ssidlist.an_ssid1_len = strlen(AN_DEFAULT_NETNAME);\n\n\tsc->an_config.an_opmode = AN_OPMODE_IBSS_ADHOC;\n\n\tsc->an_tx_rate = 0;\n\tbzero((char *)&sc->an_stats, sizeof(sc->an_stats));\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\ttimeout_set(&sc->an_stat_ch, an_stats_update, sc);\n#if NBPFILTER > 0\n\tBPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tshutdownhook_establish(an_shutdown, sc);\n\n\tan_init(sc);\n\n\treturn(0);\n}"
  }
]