[
  {
    "function_name": "ppbprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ppb.c",
    "lines": "138-150",
    "snippet": "int\nppbprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct pcibus_attach_args *pba = aux;\n\n\t/* only PCIs can attach to PPBs; easy. */\n\tif (pnp)\n\t\tprintf(\"pci at %s\", pnp);\n\tprintf(\" bus %d\", pba->pba_bus);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/pci/ppbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tppbprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" bus %d\"",
            "pba->pba_bus"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ppbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tppbprint;\n\nint\nppbprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct pcibus_attach_args *pba = aux;\n\n\t/* only PCIs can attach to PPBs; easy. */\n\tif (pnp)\n\t\tprintf(\"pci at %s\", pnp);\n\tprintf(\" bus %d\", pba->pba_bus);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "ppbattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ppb.c",
    "lines": "91-136",
    "snippet": "void\nppbattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tstruct pcibus_attach_args pba;\n\tpcireg_t busdata;\n\n\tprintf(\"\\n\");\n\n\tbusdata = pci_conf_read(pc, pa->pa_tag, PPB_REG_BUSINFO);\n\n\tif (PPB_BUSINFO_SECONDARY(busdata) == 0) {\n\t\tprintf(\"%s: not configured by system firmware\\n\",\n\t\t    self->dv_xname);\n\t\treturn;\n\t}\n\n#if 0\n\t/*\n\t * XXX can't do this, because we're not given our bus number\n\t * (we shouldn't need it), and because we've no way to\n\t * decompose our tag.\n\t */\n\t/* sanity check. */\n\tif (pa->pa_bus != PPB_BUSINFO_PRIMARY(busdata))\n\t\tpanic(\"ppbattach: bus in tag (%d) != bus in reg (%d)\",\n\t\t    pa->pa_bus, PPB_BUSINFO_PRIMARY(busdata));\n#endif\n\n\t/*\n\t * Attach the PCI bus than hangs off of it.\n\t */\n\tpba.pba_busname = \"pci\";\n\tpba.pba_iot = pa->pa_iot;\n\tpba.pba_memt = pa->pa_memt;\n\tpba.pba_dmat = pa->pa_dmat;\n\tpba.pba_pc = pc;\n\tpba.pba_bus = PPB_BUSINFO_SECONDARY(busdata);\n\tpba.pba_intrswiz = pa->pa_intrswiz;\n\tpba.pba_intrtag = pa->pa_intrtag;\n\n\tconfig_found(self, &pba, ppbprint);\n}",
    "includes": [
      "#include <dev/pci/ppbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tppbattach",
      "int\tppbprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&pba",
            "ppbprint"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPB_BUSINFO_SECONDARY",
          "args": [
            "busdata"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ppbattach: bus in tag (%d) != bus in reg (%d)\"",
            "pa->pa_bus",
            "PPB_BUSINFO_PRIMARY(busdata)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPB_BUSINFO_PRIMARY",
          "args": [
            "busdata"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPB_BUSINFO_PRIMARY",
          "args": [
            "busdata"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: not configured by system firmware\\n\"",
            "self->dv_xname"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPB_BUSINFO_SECONDARY",
          "args": [
            "busdata"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PPB_REG_BUSINFO"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ppbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tppbattach;\nint\tppbprint;\n\nvoid\nppbattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tstruct pcibus_attach_args pba;\n\tpcireg_t busdata;\n\n\tprintf(\"\\n\");\n\n\tbusdata = pci_conf_read(pc, pa->pa_tag, PPB_REG_BUSINFO);\n\n\tif (PPB_BUSINFO_SECONDARY(busdata) == 0) {\n\t\tprintf(\"%s: not configured by system firmware\\n\",\n\t\t    self->dv_xname);\n\t\treturn;\n\t}\n\n#if 0\n\t/*\n\t * XXX can't do this, because we're not given our bus number\n\t * (we shouldn't need it), and because we've no way to\n\t * decompose our tag.\n\t */\n\t/* sanity check. */\n\tif (pa->pa_bus != PPB_BUSINFO_PRIMARY(busdata))\n\t\tpanic(\"ppbattach: bus in tag (%d) != bus in reg (%d)\",\n\t\t    pa->pa_bus, PPB_BUSINFO_PRIMARY(busdata));\n#endif\n\n\t/*\n\t * Attach the PCI bus than hangs off of it.\n\t */\n\tpba.pba_busname = \"pci\";\n\tpba.pba_iot = pa->pa_iot;\n\tpba.pba_memt = pa->pa_memt;\n\tpba.pba_dmat = pa->pa_dmat;\n\tpba.pba_pc = pc;\n\tpba.pba_bus = PPB_BUSINFO_SECONDARY(busdata);\n\tpba.pba_intrswiz = pa->pa_intrswiz;\n\tpba.pba_intrtag = pa->pa_intrtag;\n\n\tconfig_found(self, &pba, ppbprint);\n}"
  },
  {
    "function_name": "ppbmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ppb.c",
    "lines": "66-89",
    "snippet": "int\nppbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\t/*\n\t * This device is mislabeled.  It is not a PCI bridge.\n\t */\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C586_PWR)\n\t\treturn (0);\n\t/*\n\t * Check the ID register to see that it's a PCI bridge.\n\t * If it is, we assume that we can deal with it; it _should_\n\t * work in a standardized way...\n\t */\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_PCI)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/ppbreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tppbmatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_SUBCLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ppbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tppbmatch;\n\nint\nppbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\t/*\n\t * This device is mislabeled.  It is not a PCI bridge.\n\t */\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C586_PWR)\n\t\treturn (0);\n\t/*\n\t * Check the ID register to see that it's a PCI bridge.\n\t * If it is, we assume that we can deal with it; it _should_\n\t * work in a standardized way...\n\t */\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_PCI)\n\t\treturn (1);\n\n\treturn (0);\n}"
  }
]