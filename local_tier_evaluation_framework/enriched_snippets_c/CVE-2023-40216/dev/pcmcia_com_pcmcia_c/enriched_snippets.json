[
  {
    "function_name": "com_pcmcia_attach2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "440-578",
    "snippet": "void\ncom_pcmcia_attach2(sc)\n\tstruct com_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t lcr;\n\n\tsc->sc_hwflags = 0;\n\tsc->sc_swflags = 0;\n\n\t/*\n\t * Probe for all known forms of UART.\n\t */\n\tlcr = bus_space_read_1(iot, ioh, com_lcr);\n\n\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\tbus_space_write_1(iot, ioh, com_efr, 0);\n\tbus_space_write_1(iot, ioh, com_lcr, 0);\n\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);\n\tdelay(100);\n\n\tswitch(bus_space_read_1(iot, ioh, com_iir) >> 6) {\n\tcase 0:\n\t\tsc->sc_uarttype = COM_UART_16450;\n\t\tbreak;\n\tcase 2:\n\t\tsc->sc_uarttype = COM_UART_16550;\n\t\tbreak;\n\tcase 3:\n\t\tsc->sc_uarttype = COM_UART_16550A;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc_uarttype = COM_UART_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0) {\n\t\t\tsc->sc_uarttype = COM_UART_ST16650;\n\t\t} else {\n\t\t\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\t\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0)\n\t\t\t\tsc->sc_uarttype = COM_UART_ST16650V2;\n\t\t}\n\t}\n\n#if NPCCOM > 0\n#ifdef i386\n\tif (sc->sc_uarttype == COM_UART_ST16650V2) {\t/* Probe for XR16850s */\n\t\tu_int8_t dlbl, dlbh;\n\n\t\t/* Enable latch access and get the current values. */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tdlbl = bus_space_read_1(iot, ioh, com_dlbl);\n\t\tdlbh = bus_space_read_1(iot, ioh, com_dlbh);\n\n\t\t/* Zero out the latch divisors */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, 0);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, 0);\n\n\t\tif (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {\n\t\t\tsc->sc_uarttype = COM_UART_XR16850;\n\t\t\tsc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);\n\t\t}\n\n\t\t/* Reset to original. */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, dlbl);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, dlbh);\n\t}\n#endif\n#endif\n\t\n\t/* Reset the LCR (latch access is probably enabled). */\n\tbus_space_write_1(iot, ioh, com_lcr, lcr);\n\tif (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */\n\t\tu_int8_t scr0, scr1, scr2;\n\n\t\tscr0 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0xa5);\n\t\tscr1 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0x5a);\n\t\tscr2 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, scr0);\n\n\t\tif ((scr1 != 0xa5) || (scr2 != 0x5a))\n\t\t\tsc->sc_uarttype = COM_UART_8250;\n\t}\n\n\t/*\n\t * Print UART type and initialize ourself.\n\t */\n\tsc->sc_fifolen = 1;\t/* default */\n\tswitch (sc->sc_uarttype) {\n\tcase COM_UART_UNKNOWN:\n\t\tprintf(\": unknown uart\\n\");\n\t\tbreak;\n\tcase COM_UART_8250:\n\t\tprintf(\": ns8250, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16450:\n\t\tprintf(\": ns16450, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550:\n\t\tprintf(\": ns16550, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550A:\n\t\tprintf(\": ns16550a, 16 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 16;\n\t\tbreak;\n\tcase COM_UART_ST16650:\n\t\tprintf(\": st16650, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_ST16650V2:\n\t\tprintf(\": st16650, 32 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 32;\n\t\tbreak;\n#if NPCCOM > 0\n#ifdef i386\n\tcase COM_UART_XR16850:\n\t\tprintf(\": xr16850 (rev %d), 128 byte fifo\\n\", sc->sc_uartrev);\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 128;\n\t\tbreak;\n#endif\n#endif\n\tdefault:\n\t\tpanic(\"comattach: bad fifo type\");\n\t}\n\n\t/* clear and disable fifo */\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);\n\t(void)bus_space_read_1(iot, ioh, com_data);\n\tbus_space_write_1(iot, ioh, com_fifo, 0);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tcom_lcr\t\tcom_cfcr"
    ],
    "globals_used": [
      "void com_pcmcia_attach2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_fifo",
            "0"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_data"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_fifo",
            "FIFO_RCV_RST | FIFO_XMT_RST"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"comattach: bad fifo type\""
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_hwflags",
            "COM_HW_FIFO"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": xr16850 (rev %d), 128 byte fifo\\n\"",
            "sc->sc_uartrev"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_hwflags",
            "COM_HW_FIFO"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "sc->sc_hwflags",
            "COM_HW_FIFO"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch",
            "scr0"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch",
            "0x5a"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch",
            "0xa5"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_scratch"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "lcr"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbh",
            "dlbh"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbl",
            "dlbl"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbl"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbh"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbh",
            "0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbl",
            "0"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbh"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_dlbl"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "lcr | LCR_DLAB"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_efr"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "LCR_EFR"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_efr"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "lcr | LCR_DLAB"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_iir"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_fifo",
            "FIFO_ENABLE"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "0"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_efr",
            "0"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr",
            "LCR_EFR"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "com_lcr"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcom_lcr\t\tcom_cfcr\n\nvoid com_pcmcia_attach2;\n\nvoid\ncom_pcmcia_attach2(sc)\n\tstruct com_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t lcr;\n\n\tsc->sc_hwflags = 0;\n\tsc->sc_swflags = 0;\n\n\t/*\n\t * Probe for all known forms of UART.\n\t */\n\tlcr = bus_space_read_1(iot, ioh, com_lcr);\n\n\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\tbus_space_write_1(iot, ioh, com_efr, 0);\n\tbus_space_write_1(iot, ioh, com_lcr, 0);\n\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);\n\tdelay(100);\n\n\tswitch(bus_space_read_1(iot, ioh, com_iir) >> 6) {\n\tcase 0:\n\t\tsc->sc_uarttype = COM_UART_16450;\n\t\tbreak;\n\tcase 2:\n\t\tsc->sc_uarttype = COM_UART_16550;\n\t\tbreak;\n\tcase 3:\n\t\tsc->sc_uarttype = COM_UART_16550A;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc_uarttype = COM_UART_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0) {\n\t\t\tsc->sc_uarttype = COM_UART_ST16650;\n\t\t} else {\n\t\t\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\t\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0)\n\t\t\t\tsc->sc_uarttype = COM_UART_ST16650V2;\n\t\t}\n\t}\n\n#if NPCCOM > 0\n#ifdef i386\n\tif (sc->sc_uarttype == COM_UART_ST16650V2) {\t/* Probe for XR16850s */\n\t\tu_int8_t dlbl, dlbh;\n\n\t\t/* Enable latch access and get the current values. */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tdlbl = bus_space_read_1(iot, ioh, com_dlbl);\n\t\tdlbh = bus_space_read_1(iot, ioh, com_dlbh);\n\n\t\t/* Zero out the latch divisors */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, 0);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, 0);\n\n\t\tif (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {\n\t\t\tsc->sc_uarttype = COM_UART_XR16850;\n\t\t\tsc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);\n\t\t}\n\n\t\t/* Reset to original. */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, dlbl);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, dlbh);\n\t}\n#endif\n#endif\n\t\n\t/* Reset the LCR (latch access is probably enabled). */\n\tbus_space_write_1(iot, ioh, com_lcr, lcr);\n\tif (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */\n\t\tu_int8_t scr0, scr1, scr2;\n\n\t\tscr0 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0xa5);\n\t\tscr1 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0x5a);\n\t\tscr2 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, scr0);\n\n\t\tif ((scr1 != 0xa5) || (scr2 != 0x5a))\n\t\t\tsc->sc_uarttype = COM_UART_8250;\n\t}\n\n\t/*\n\t * Print UART type and initialize ourself.\n\t */\n\tsc->sc_fifolen = 1;\t/* default */\n\tswitch (sc->sc_uarttype) {\n\tcase COM_UART_UNKNOWN:\n\t\tprintf(\": unknown uart\\n\");\n\t\tbreak;\n\tcase COM_UART_8250:\n\t\tprintf(\": ns8250, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16450:\n\t\tprintf(\": ns16450, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550:\n\t\tprintf(\": ns16550, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550A:\n\t\tprintf(\": ns16550a, 16 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 16;\n\t\tbreak;\n\tcase COM_UART_ST16650:\n\t\tprintf(\": st16650, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_ST16650V2:\n\t\tprintf(\": st16650, 32 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 32;\n\t\tbreak;\n#if NPCCOM > 0\n#ifdef i386\n\tcase COM_UART_XR16850:\n\t\tprintf(\": xr16850 (rev %d), 128 byte fifo\\n\", sc->sc_uartrev);\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 128;\n\t\tbreak;\n#endif\n#endif\n\tdefault:\n\t\tpanic(\"comattach: bad fifo type\");\n\t}\n\n\t/* clear and disable fifo */\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);\n\t(void)bus_space_read_1(iot, ioh, com_data);\n\tbus_space_write_1(iot, ioh, com_fifo, 0);\n}"
  },
  {
    "function_name": "com_pcmcia_disable1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "428-435",
    "snippet": "void\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void com_pcmcia_disable1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "psc->sc_pf"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid com_pcmcia_disable1;\n\nvoid\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}"
  },
  {
    "function_name": "com_pcmcia_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "418-426",
    "snippet": "void\ncom_pcmcia_disable(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);\n\tcom_pcmcia_disable1(sc);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void com_pcmcia_disable",
      "void com_pcmcia_disable1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_pcmcia_disable1",
          "args": [
            "sc"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "com_pcmcia_disable1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
          "lines": "428-435",
          "snippet": "void\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}",
          "includes": [
            "#include <dev/isa/isareg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <i386/isa/pccomvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include \"pccom.h\"",
            "#include \"com.h\"",
            "#include <dev/isa/isavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void com_pcmcia_disable1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid com_pcmcia_disable1;\n\nvoid\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "psc->sc_pf",
            "psc->sc_ih"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid com_pcmcia_disable;\nvoid com_pcmcia_disable1;\n\nvoid\ncom_pcmcia_disable(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);\n\tcom_pcmcia_disable1(sc);\n}"
  },
  {
    "function_name": "com_pcmcia_enable1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "390-416",
    "snippet": "int\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int com_pcmcia_enable1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_ccr_write",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION",
            "reg"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "87-98",
          "snippet": "void\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_ccr_write(pf, ccr, val)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n\tint val;\n{\n\n\tif ((pf->ccr_mask) & (1 << (ccr / 2))) {\n\t\tbus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,\n\t\t    pf->pf_ccr_offset + ccr, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_ccr_read",
          "args": [
            "pf",
            "PCMCIA_CCR_OPTION"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_ccr_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "77-85",
          "snippet": "int\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_ccr_read(pf, ccr)\n\tstruct pcmcia_function *pf;\n\tint ccr;\n{\n\n\treturn (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,\n\t    pf->pf_ccr_offset + ccr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "pf"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_enable1;\n\nint\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}"
  },
  {
    "function_name": "com_pcmcia_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "373-388",
    "snippet": "int\ncom_pcmcia_enable(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\n\t/* establish the interrupt. */\n\tpsc->sc_ih = pcmcia_intr_establish(pf, IPL_TTY, comintr, sc);\n\tif (psc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn com_pcmcia_enable1(sc);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int com_pcmcia_enable",
      "int com_pcmcia_enable1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_pcmcia_enable1",
          "args": [
            "sc"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "com_pcmcia_enable1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
          "lines": "390-416",
          "snippet": "int\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}",
          "includes": [
            "#include <dev/isa/isareg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <i386/isa/pccomvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include \"pccom.h\"",
            "#include \"com.h\"",
            "#include <dev/isa/isavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int com_pcmcia_enable1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_enable1;\n\nint\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't establish interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "pf",
            "IPL_TTY",
            "comintr",
            "sc"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_enable;\nint com_pcmcia_enable1;\n\nint\ncom_pcmcia_enable(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\n\t/* establish the interrupt. */\n\tpsc->sc_ih = pcmcia_intr_establish(pf, IPL_TTY, comintr, sc);\n\tif (psc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (1);\n\t}\n\treturn com_pcmcia_enable1(sc);\n}"
  },
  {
    "function_name": "com_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "354-371",
    "snippet": "int\ncom_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *)dev;\n\tint error;\n\n\t/* Release all resources.  */\n\terror = com_detach(dev, flags);\n\tif (error)\n\t    return (error);\n\n\tpcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);\n\tpcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int com_pcmcia_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "psc->sc_pf",
            "&psc->sc_pcioh"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "psc->sc_pf",
            "psc->sc_io_window"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_detach",
          "args": [
            "dev",
            "flags"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "com_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/com.c",
          "lines": "643-675",
          "snippet": "int\ncom_detach(self, flags)\n\tstruct device *self;\n\tint flags;\n{\n\tstruct com_softc *sc = (struct com_softc *)self;\n\tint maj, mn;\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == comopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances. */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\t/* XXX a symbolic constant for the cua bit would be nicer. */\n\tmn |= 0x80;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\t/* Detach and free the tty. */\n\tif (sc->sc_tty) {\n\t\ttty_detach(sc->sc_tty);\n\t\tttyfree(sc->sc_tty);\n\t}\n\n\tuntimeout(compoll, NULL);\n\tuntimeout(com_raisedtr, sc);\n\tuntimeout(comdiag, sc);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/cons.h>",
            "#include <machine/remote-sl.h>",
            "#include <dev/isa/isavar.h>\t/* XXX */",
            "#include \"com.h\"",
            "#include <dev/ic/hayespreg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <ddb/db_var.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tcom_raisedtr",
            "struct device *parent, *self;",
            "struct com_softc *sc = (void *)self;",
            "struct com_softc *sc = arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cons.h>\n#include <machine/remote-sl.h>\n#include <dev/isa/isavar.h>\t/* XXX */\n#include \"com.h\"\n#include <dev/ic/hayespreg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <dev/ic/comreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <ddb/db_var.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tcom_raisedtr;\nstruct device *parent, *self;\nstruct com_softc *sc = (void *)self;\nstruct com_softc *sc = arg;\n\nint\ncom_detach(self, flags)\n\tstruct device *self;\n\tint flags;\n{\n\tstruct com_softc *sc = (struct com_softc *)self;\n\tint maj, mn;\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == comopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances. */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\t/* XXX a symbolic constant for the cua bit would be nicer. */\n\tmn |= 0x80;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\t/* Detach and free the tty. */\n\tif (sc->sc_tty) {\n\t\ttty_detach(sc->sc_tty);\n\t\tttyfree(sc->sc_tty);\n\t}\n\n\tuntimeout(compoll, NULL);\n\tuntimeout(com_raisedtr, sc);\n\tuntimeout(comdiag, sc);\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_detach;\n\nint\ncom_pcmcia_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *)dev;\n\tint error;\n\n\t/* Release all resources.  */\n\terror = com_detach(dev, flags);\n\tif (error)\n\t    return (error);\n\n\tpcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);\n\tpcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "com_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "265-352",
    "snippet": "void\ncom_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct com_pcmcia_softc *psc = (void *) self;\n\tstruct com_softc *sc = &psc->sc_com;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tint autoalloc = 0;\n\n\tpsc->sc_pf = pa->pf;\n\nretry:\n\t/* find a cfe we can use */\n\n\tfor (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe;\n\t     cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {\n#if 0\n\t\t/*\n\t\t * Some modem cards (e.g. Xircom CM33) also have\n\t\t * mem space.  Don't bother with this check.\n\t\t */\n\t\tif (cfe->num_memspace != 0)\n\t\t\tcontinue;\n#endif\n\n\t\tif (cfe->num_iospace != 1)\n\t\t\tcontinue;\n\n\t\tif (!pcmcia_io_alloc(pa->pf,\n\t\t    autoalloc ? 0 : cfe->iospace[0].start,\n\t\t    cfe->iospace[0].length, COM_NPORTS, &psc->sc_pcioh)) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\tif (autoalloc == 0) {\n\t\tautoalloc = 1;\n\t\tgoto retry;\n\t} else if (!cfe) {\n\t\tprintf(\": can't allocate i/o space\\n\");\n\t\treturn;\n\t}\n\nfound:\n\tsc->sc_iot = psc->sc_pcioh.iot;\n\tsc->sc_ioh = psc->sc_pcioh.ioh;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (com_pcmcia_enable1(sc))\n\t\tprintf(\": function enable failed\\n\");\n\n\tsc->enabled = 1;\n\n\t/* map in the io space */\n\n\tif (pcmcia_io_map(pa->pf, ((cfe->flags & PCMCIA_CFE_IO16) ?\n\t    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8), 0, psc->sc_pcioh.size,\n\t    &psc->sc_pcioh, &psc->sc_io_window)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\" port 0x%lx/%d\", psc->sc_pcioh.addr, psc->sc_pcioh.size);\n\n\tsc->sc_iobase = -1;\n\tsc->enable = com_pcmcia_enable;\n\tsc->disable = com_pcmcia_disable;\n\t\n#ifdef notyet\n\tsc->sc_frequency = COM_FREQ;\n\n\tcom_attach_subr(sc);\n#endif\n\t/* establish the interrupt. */\n\tpsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY, comintr, sc);\n\tif (psc->sc_ih == NULL)\n\t\tprintf(\", couldn't establish interrupt\");\n\n\tcom_pcmcia_attach2(sc);\n\n#ifdef notyet\n\tsc->enabled = 0;\n\t\n\tcom_pcmcia_disable1(sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void com_pcmcia_attach",
      "int com_pcmcia_enable",
      "void com_pcmcia_disable",
      "int com_pcmcia_enable1",
      "void com_pcmcia_disable1",
      "void com_pcmcia_attach2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_pcmcia_disable1",
          "args": [
            "sc"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "com_pcmcia_disable1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
          "lines": "428-435",
          "snippet": "void\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}",
          "includes": [
            "#include <dev/isa/isareg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <i386/isa/pccomvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include \"pccom.h\"",
            "#include \"com.h\"",
            "#include <dev/isa/isavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void com_pcmcia_disable1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid com_pcmcia_disable1;\n\nvoid\ncom_pcmcia_disable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\n\tpcmcia_function_disable(psc->sc_pf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_pcmcia_attach2",
          "args": [
            "sc"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "com_pcmcia_attach2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
          "lines": "440-578",
          "snippet": "void\ncom_pcmcia_attach2(sc)\n\tstruct com_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t lcr;\n\n\tsc->sc_hwflags = 0;\n\tsc->sc_swflags = 0;\n\n\t/*\n\t * Probe for all known forms of UART.\n\t */\n\tlcr = bus_space_read_1(iot, ioh, com_lcr);\n\n\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\tbus_space_write_1(iot, ioh, com_efr, 0);\n\tbus_space_write_1(iot, ioh, com_lcr, 0);\n\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);\n\tdelay(100);\n\n\tswitch(bus_space_read_1(iot, ioh, com_iir) >> 6) {\n\tcase 0:\n\t\tsc->sc_uarttype = COM_UART_16450;\n\t\tbreak;\n\tcase 2:\n\t\tsc->sc_uarttype = COM_UART_16550;\n\t\tbreak;\n\tcase 3:\n\t\tsc->sc_uarttype = COM_UART_16550A;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc_uarttype = COM_UART_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0) {\n\t\t\tsc->sc_uarttype = COM_UART_ST16650;\n\t\t} else {\n\t\t\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\t\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0)\n\t\t\t\tsc->sc_uarttype = COM_UART_ST16650V2;\n\t\t}\n\t}\n\n#if NPCCOM > 0\n#ifdef i386\n\tif (sc->sc_uarttype == COM_UART_ST16650V2) {\t/* Probe for XR16850s */\n\t\tu_int8_t dlbl, dlbh;\n\n\t\t/* Enable latch access and get the current values. */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tdlbl = bus_space_read_1(iot, ioh, com_dlbl);\n\t\tdlbh = bus_space_read_1(iot, ioh, com_dlbh);\n\n\t\t/* Zero out the latch divisors */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, 0);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, 0);\n\n\t\tif (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {\n\t\t\tsc->sc_uarttype = COM_UART_XR16850;\n\t\t\tsc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);\n\t\t}\n\n\t\t/* Reset to original. */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, dlbl);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, dlbh);\n\t}\n#endif\n#endif\n\t\n\t/* Reset the LCR (latch access is probably enabled). */\n\tbus_space_write_1(iot, ioh, com_lcr, lcr);\n\tif (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */\n\t\tu_int8_t scr0, scr1, scr2;\n\n\t\tscr0 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0xa5);\n\t\tscr1 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0x5a);\n\t\tscr2 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, scr0);\n\n\t\tif ((scr1 != 0xa5) || (scr2 != 0x5a))\n\t\t\tsc->sc_uarttype = COM_UART_8250;\n\t}\n\n\t/*\n\t * Print UART type and initialize ourself.\n\t */\n\tsc->sc_fifolen = 1;\t/* default */\n\tswitch (sc->sc_uarttype) {\n\tcase COM_UART_UNKNOWN:\n\t\tprintf(\": unknown uart\\n\");\n\t\tbreak;\n\tcase COM_UART_8250:\n\t\tprintf(\": ns8250, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16450:\n\t\tprintf(\": ns16450, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550:\n\t\tprintf(\": ns16550, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550A:\n\t\tprintf(\": ns16550a, 16 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 16;\n\t\tbreak;\n\tcase COM_UART_ST16650:\n\t\tprintf(\": st16650, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_ST16650V2:\n\t\tprintf(\": st16650, 32 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 32;\n\t\tbreak;\n#if NPCCOM > 0\n#ifdef i386\n\tcase COM_UART_XR16850:\n\t\tprintf(\": xr16850 (rev %d), 128 byte fifo\\n\", sc->sc_uartrev);\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 128;\n\t\tbreak;\n#endif\n#endif\n\tdefault:\n\t\tpanic(\"comattach: bad fifo type\");\n\t}\n\n\t/* clear and disable fifo */\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);\n\t(void)bus_space_read_1(iot, ioh, com_data);\n\tbus_space_write_1(iot, ioh, com_fifo, 0);\n}",
          "includes": [
            "#include <dev/isa/isareg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <i386/isa/pccomvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include \"pccom.h\"",
            "#include \"com.h\"",
            "#include <dev/isa/isavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tcom_lcr\t\tcom_cfcr"
          ],
          "globals_used": [
            "void com_pcmcia_attach2"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tcom_lcr\t\tcom_cfcr\n\nvoid com_pcmcia_attach2;\n\nvoid\ncom_pcmcia_attach2(sc)\n\tstruct com_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int8_t lcr;\n\n\tsc->sc_hwflags = 0;\n\tsc->sc_swflags = 0;\n\n\t/*\n\t * Probe for all known forms of UART.\n\t */\n\tlcr = bus_space_read_1(iot, ioh, com_lcr);\n\n\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\tbus_space_write_1(iot, ioh, com_efr, 0);\n\tbus_space_write_1(iot, ioh, com_lcr, 0);\n\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);\n\tdelay(100);\n\n\tswitch(bus_space_read_1(iot, ioh, com_iir) >> 6) {\n\tcase 0:\n\t\tsc->sc_uarttype = COM_UART_16450;\n\t\tbreak;\n\tcase 2:\n\t\tsc->sc_uarttype = COM_UART_16550;\n\t\tbreak;\n\tcase 3:\n\t\tsc->sc_uarttype = COM_UART_16550A;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc_uarttype = COM_UART_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0) {\n\t\t\tsc->sc_uarttype = COM_UART_ST16650;\n\t\t} else {\n\t\t\tbus_space_write_1(iot, ioh, com_lcr, LCR_EFR);\n\t\t\tif (bus_space_read_1(iot, ioh, com_efr) == 0)\n\t\t\t\tsc->sc_uarttype = COM_UART_ST16650V2;\n\t\t}\n\t}\n\n#if NPCCOM > 0\n#ifdef i386\n\tif (sc->sc_uarttype == COM_UART_ST16650V2) {\t/* Probe for XR16850s */\n\t\tu_int8_t dlbl, dlbh;\n\n\t\t/* Enable latch access and get the current values. */\n\t\tbus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);\n\t\tdlbl = bus_space_read_1(iot, ioh, com_dlbl);\n\t\tdlbh = bus_space_read_1(iot, ioh, com_dlbh);\n\n\t\t/* Zero out the latch divisors */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, 0);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, 0);\n\n\t\tif (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {\n\t\t\tsc->sc_uarttype = COM_UART_XR16850;\n\t\t\tsc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);\n\t\t}\n\n\t\t/* Reset to original. */\n\t\tbus_space_write_1(iot, ioh, com_dlbl, dlbl);\n\t\tbus_space_write_1(iot, ioh, com_dlbh, dlbh);\n\t}\n#endif\n#endif\n\t\n\t/* Reset the LCR (latch access is probably enabled). */\n\tbus_space_write_1(iot, ioh, com_lcr, lcr);\n\tif (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */\n\t\tu_int8_t scr0, scr1, scr2;\n\n\t\tscr0 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0xa5);\n\t\tscr1 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, 0x5a);\n\t\tscr2 = bus_space_read_1(iot, ioh, com_scratch);\n\t\tbus_space_write_1(iot, ioh, com_scratch, scr0);\n\n\t\tif ((scr1 != 0xa5) || (scr2 != 0x5a))\n\t\t\tsc->sc_uarttype = COM_UART_8250;\n\t}\n\n\t/*\n\t * Print UART type and initialize ourself.\n\t */\n\tsc->sc_fifolen = 1;\t/* default */\n\tswitch (sc->sc_uarttype) {\n\tcase COM_UART_UNKNOWN:\n\t\tprintf(\": unknown uart\\n\");\n\t\tbreak;\n\tcase COM_UART_8250:\n\t\tprintf(\": ns8250, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16450:\n\t\tprintf(\": ns16450, no fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550:\n\t\tprintf(\": ns16550, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_16550A:\n\t\tprintf(\": ns16550a, 16 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 16;\n\t\tbreak;\n\tcase COM_UART_ST16650:\n\t\tprintf(\": st16650, no working fifo\\n\");\n\t\tbreak;\n\tcase COM_UART_ST16650V2:\n\t\tprintf(\": st16650, 32 byte fifo\\n\");\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 32;\n\t\tbreak;\n#if NPCCOM > 0\n#ifdef i386\n\tcase COM_UART_XR16850:\n\t\tprintf(\": xr16850 (rev %d), 128 byte fifo\\n\", sc->sc_uartrev);\n\t\tSET(sc->sc_hwflags, COM_HW_FIFO);\n\t\tsc->sc_fifolen = 128;\n\t\tbreak;\n#endif\n#endif\n\tdefault:\n\t\tpanic(\"comattach: bad fifo type\");\n\t}\n\n\t/* clear and disable fifo */\n\tbus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);\n\t(void)bus_space_read_1(iot, ioh, com_data);\n\tbus_space_write_1(iot, ioh, com_fifo, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", couldn't establish interrupt\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "pa->pf",
            "IPL_TTY",
            "comintr",
            "sc"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_attach_subr",
          "args": [
            "sc"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_io_map",
          "args": [
            "pa->pf",
            "((cfe->flags & PCMCIA_CFE_IO16) ?\n\t    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8)",
            "0",
            "psc->sc_pcioh.size",
            "&psc->sc_pcioh",
            "&psc->sc_io_window"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "624-679",
          "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_pcmcia_enable1",
          "args": [
            "sc"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "com_pcmcia_enable1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
          "lines": "390-416",
          "snippet": "int\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}",
          "includes": [
            "#include <dev/isa/isareg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <i386/isa/pccomvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include \"pccom.h\"",
            "#include \"com.h\"",
            "#include <dev/isa/isavar.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int com_pcmcia_enable1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_enable1;\n\nint\ncom_pcmcia_enable1(sc)\n\tstruct com_softc *sc;\n{\n\tstruct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;\n\tstruct pcmcia_function *pf = psc->sc_pf;\n\tint ret;\n\n\tif ((ret = pcmcia_function_enable(pf)))\n\t    return(ret);\n\n\tif ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||\n\t    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {\n\t\tint reg;\n\n\t\t/* turn off the ethernet-disable bit */\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\tif (reg & 0x08) {\n\t\t    reg &= ~0x08;\n\t\t    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t\t}\n\t}\n\n\treturn(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "pa->pf",
            "cfe"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_alloc",
          "args": [
            "pa->pf",
            "autoalloc ? 0 : cfe->iospace[0].start",
            "cfe->iospace[0].length",
            "COM_NPORTS",
            "&psc->sc_pcioh"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1803-1863",
          "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "STATIC void",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "STATIC int",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "cfe",
            "cfe_list"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&pa->pf->cfe_head"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid com_pcmcia_attach;\nint com_pcmcia_enable;\nvoid com_pcmcia_disable;\nint com_pcmcia_enable1;\nvoid com_pcmcia_disable1;\nvoid com_pcmcia_attach2;\n\nvoid\ncom_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct com_pcmcia_softc *psc = (void *) self;\n\tstruct com_softc *sc = &psc->sc_com;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tint autoalloc = 0;\n\n\tpsc->sc_pf = pa->pf;\n\nretry:\n\t/* find a cfe we can use */\n\n\tfor (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe;\n\t     cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {\n#if 0\n\t\t/*\n\t\t * Some modem cards (e.g. Xircom CM33) also have\n\t\t * mem space.  Don't bother with this check.\n\t\t */\n\t\tif (cfe->num_memspace != 0)\n\t\t\tcontinue;\n#endif\n\n\t\tif (cfe->num_iospace != 1)\n\t\t\tcontinue;\n\n\t\tif (!pcmcia_io_alloc(pa->pf,\n\t\t    autoalloc ? 0 : cfe->iospace[0].start,\n\t\t    cfe->iospace[0].length, COM_NPORTS, &psc->sc_pcioh)) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\tif (autoalloc == 0) {\n\t\tautoalloc = 1;\n\t\tgoto retry;\n\t} else if (!cfe) {\n\t\tprintf(\": can't allocate i/o space\\n\");\n\t\treturn;\n\t}\n\nfound:\n\tsc->sc_iot = psc->sc_pcioh.iot;\n\tsc->sc_ioh = psc->sc_pcioh.ioh;\n\n\t/* Enable the card. */\n\tpcmcia_function_init(pa->pf, cfe);\n\tif (com_pcmcia_enable1(sc))\n\t\tprintf(\": function enable failed\\n\");\n\n\tsc->enabled = 1;\n\n\t/* map in the io space */\n\n\tif (pcmcia_io_map(pa->pf, ((cfe->flags & PCMCIA_CFE_IO16) ?\n\t    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8), 0, psc->sc_pcioh.size,\n\t    &psc->sc_pcioh, &psc->sc_io_window)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\" port 0x%lx/%d\", psc->sc_pcioh.addr, psc->sc_pcioh.size);\n\n\tsc->sc_iobase = -1;\n\tsc->enable = com_pcmcia_enable;\n\tsc->disable = com_pcmcia_disable;\n\t\n#ifdef notyet\n\tsc->sc_frequency = COM_FREQ;\n\n\tcom_attach_subr(sc);\n#endif\n\t/* establish the interrupt. */\n\tpsc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY, comintr, sc);\n\tif (psc->sc_ih == NULL)\n\t\tprintf(\", couldn't establish interrupt\");\n\n\tcom_pcmcia_attach2(sc);\n\n#ifdef notyet\n\tsc->enabled = 0;\n\t\n\tcom_pcmcia_disable1(sc);\n#endif\n}"
  },
  {
    "function_name": "com_pcmcia_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "238-263",
    "snippet": "int\ncom_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct com_pcmcia_softc *sc = (void *) dev;\n\tint s;\n\n\ts = spltty();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_com.sc_dev.dv_xname);\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_TTY,\n\t\t    comintr, sc);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int com_pcmcia_activate"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_TTY",
            "comintr",
            "sc"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint com_pcmcia_activate;\n\nint\ncom_pcmcia_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct com_pcmcia_softc *sc = (void *) dev;\n\tint s;\n\n\ts = spltty();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_com.sc_dev.dv_xname);\n\t\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_TTY,\n\t\t    comintr, sc);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "com_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/com_pcmcia.c",
    "lines": "187-236",
    "snippet": "int\ncom_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tint i, j, comportmask;\n\n\t/* 1. Does it claim to be a serial device? */\n\tif (pa->pf->function == PCMCIA_FUNCTION_SERIAL)\n\t    return 1;\n\n\t/* 2. Does it have all four 'standard' port ranges? */\n\tcomportmask = 0;\n\tfor (cfe = pa->pf->cfe_head.sqh_first; cfe;\n\t     cfe = cfe->cfe_list.sqe_next) {\n\t\tswitch (cfe->iospace[0].start) {\n\t\tcase IO_COM1:\n\t\t\tcomportmask |= 1;\n\t\t\tbreak;\n\t\tcase IO_COM2:\n\t\t\tcomportmask |= 2;\n\t\t\tbreak;\n\t\tcase IO_COM3:\n\t\t\tcomportmask |= 4;\n\t\t\tbreak;\n\t\tcase IO_COM4:\n\t\t\tcomportmask |= 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (comportmask == 15)\n\t\treturn 1;\n\n\t/* 3. Is this a card we know about? */\n\tfor (i = 0; i < sizeof(com_pcmcia_prod)/sizeof(com_pcmcia_prod[0]);\n\t    i++) {\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tif (com_pcmcia_prod[i].cis1_info[j] &&\n\t\t\t    strcmp(com_pcmcia_prod[i].cis1_info[j],\n\t\t\t    pa->card->cis1_info[j]))\n\t\t\t\tbreak;\n\t\tif (j == 4)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/isa/isareg.h>",
      "#include <dev/ic/ns16550reg.h>",
      "#include <dev/ic/comvar.h>",
      "#include <i386/isa/pccomvar.h>",
      "#include <dev/ic/comreg.h>",
      "#include \"pccom.h\"",
      "#include \"com.h\"",
      "#include <dev/isa/isavar.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/syslog.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/select.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct com_pcmcia_product {\n\tchar *cis1_info[4];\n} com_pcmcia_prod[] = {\n\t{ PCMCIA_CIS_MEGAHERTZ_XJ2288 },\n};",
      "int com_pcmcia_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "com_pcmcia_prod[i].cis1_info[j]",
            "pa->card->cis1_info[j]"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isareg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <i386/isa/pccomvar.h>\n#include <dev/ic/comreg.h>\n#include \"pccom.h\"\n#include \"com.h\"\n#include <dev/isa/isavar.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct com_pcmcia_product {\n\tchar *cis1_info[4];\n} com_pcmcia_prod[] = {\n\t{ PCMCIA_CIS_MEGAHERTZ_XJ2288 },\n};\nint com_pcmcia_match;\n\nint\ncom_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct pcmcia_config_entry *cfe;\n\tint i, j, comportmask;\n\n\t/* 1. Does it claim to be a serial device? */\n\tif (pa->pf->function == PCMCIA_FUNCTION_SERIAL)\n\t    return 1;\n\n\t/* 2. Does it have all four 'standard' port ranges? */\n\tcomportmask = 0;\n\tfor (cfe = pa->pf->cfe_head.sqh_first; cfe;\n\t     cfe = cfe->cfe_list.sqe_next) {\n\t\tswitch (cfe->iospace[0].start) {\n\t\tcase IO_COM1:\n\t\t\tcomportmask |= 1;\n\t\t\tbreak;\n\t\tcase IO_COM2:\n\t\t\tcomportmask |= 2;\n\t\t\tbreak;\n\t\tcase IO_COM3:\n\t\t\tcomportmask |= 4;\n\t\t\tbreak;\n\t\tcase IO_COM4:\n\t\t\tcomportmask |= 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (comportmask == 15)\n\t\treturn 1;\n\n\t/* 3. Is this a card we know about? */\n\tfor (i = 0; i < sizeof(com_pcmcia_prod)/sizeof(com_pcmcia_prod[0]);\n\t    i++) {\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tif (com_pcmcia_prod[i].cis1_info[j] &&\n\t\t\t    strcmp(com_pcmcia_prod[i].cis1_info[j],\n\t\t\t    pa->card->cis1_info[j]))\n\t\t\t\tbreak;\n\t\tif (j == 4)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  }
]