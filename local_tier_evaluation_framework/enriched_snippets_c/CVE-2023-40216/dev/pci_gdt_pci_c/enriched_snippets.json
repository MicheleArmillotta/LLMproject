[
  {
    "function_name": "gdt_mpr_test_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "815-823",
    "snippet": "int\ngdt_mpr_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_test_busy(%p) \", gdt));\n\n\treturn (bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_SEMA0) & 1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_SEMA0\t0x10\t/* volatile u_int8_t, command semaphore */"
    ],
    "globals_used": [
      "int\tgdt_mpr_test_busy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_SEMA0"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_mpr_test_busy(%p) \", gdt)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_SEMA0\t0x10\t/* volatile u_int8_t, command semaphore */\n\nint\tgdt_mpr_test_busy;\n\nint\ngdt_mpr_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_test_busy(%p) \", gdt));\n\n\treturn (bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_SEMA0) & 1);\n}"
  },
  {
    "function_name": "gdt_mpr_set_sema0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "806-813",
    "snippet": "void\ngdt_mpr_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_set_sema0(%p) \", gdt));\n\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA0, 1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_SEMA0\t0x10\t/* volatile u_int8_t, command semaphore */"
    ],
    "globals_used": [
      "void\tgdt_mpr_set_sema0"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_SEMA0",
            "1"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_mpr_set_sema0(%p) \", gdt)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_SEMA0\t0x10\t/* volatile u_int8_t, command semaphore */\n\nvoid\tgdt_mpr_set_sema0;\n\nvoid\ngdt_mpr_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_set_sema0(%p) \", gdt));\n\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA0, 1);\n}"
  },
  {
    "function_name": "gdt_mpr_release_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "794-804",
    "snippet": "void\ngdt_mpr_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_release_event(%p) \", gdt));\n\n\tif (gdt_dec16(gdt->sc_cmd + GDT_CMD_OPCODE) == GDT_INIT)\n\t\tccb->gc_service |= 0x80;\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_LDOOR, 1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_LDOOR\t0x20\t/* u_int8_t, PCI to local doorbell */"
    ],
    "globals_used": [
      "void\tgdt_mpr_release_event"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_LDOOR",
            "1"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_dec16",
          "args": [
            "gdt->sc_cmd + GDT_CMD_OPCODE"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_dec16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdtvar.h",
          "lines": "253-258",
          "snippet": "static __inline__ u_int16_t\ngdt_dec16(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh16(*(u_int16_t *)addr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline__ u_int16_t\ngdt_dec16(addr)\n\tu_int8_t *addr;\n{\n\treturn letoh16(*(u_int16_t *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_mpr_release_event(%p) \", gdt)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_LDOOR\t0x20\t/* u_int8_t, PCI to local doorbell */\n\nvoid\tgdt_mpr_release_event;\n\nvoid\ngdt_mpr_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_release_event(%p) \", gdt));\n\n\tif (gdt_dec16(gdt->sc_cmd + GDT_CMD_OPCODE) == GDT_INIT)\n\t\tccb->gc_service |= 0x80;\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_LDOOR, 1);\n}"
  },
  {
    "function_name": "gdt_mpr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "764-792",
    "snippet": "void\ngdt_mpr_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_mpr_intr(%p) \", gdt));\n\n\tif (ctx->istatus & 0x80) {\t\t/* error flag */\n\t\tctx->istatus &= ~0x80;\n\t\tctx->cmd_status = bus_space_read_2(gdt->sc_dpmemt,\n\t\t    gdt->sc_dpmemh, GDT_MPR_STATUS);\n\t\tif (ctx->istatus == GDT_ASYNCINDEX) {\n\t\t\tctx->service = bus_space_read_2(gdt->sc_dpmemt,\n\t\t\t    gdt->sc_dpmemh, GDT_MPR_SERVICE);\n\t\t\tctx->info2 = bus_space_read_4(gdt->sc_dpmemt,\n\t\t\t    gdt->sc_dpmemh, GDT_MPR_INFO + sizeof (u_int32_t));\n\t\t}\n\t} else\t\t\t\t\t/* no error */\n\t\tctx->cmd_status = GDT_S_OK;\n\n\tctx->info =\n\t    bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_INFO);\n\n\tif (gdt_polling)\t\t\t/* init. -> more info */\n\t\tctx->info2 = bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_INFO + sizeof (u_int32_t));\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR, 0xff);\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA1, 0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */",
      "#define GDT_MPR_INFO\t0x18\t/* u_int32_t [2], additional info */",
      "#define GDT_MPR_SERVICE\t0x16\t/* u_int16_t, service */",
      "#define GDT_MPR_STATUS\t0x14\t/* volatile u_int16_t, command status */",
      "#define GDT_MPR_SEMA1\t0x12\t/* volatile u_int8_t, status semaphore */"
    ],
    "globals_used": [
      "void\tgdt_mpr_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_SEMA1",
            "0"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_EDOOR",
            "0xff"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_INFO + sizeof (u_int32_t)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_INFO"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_INFO + sizeof (u_int32_t)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_SERVICE"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_STATUS"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_mpr_intr(%p) \", gdt)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n#define GDT_MPR_INFO\t0x18\t/* u_int32_t [2], additional info */\n#define GDT_MPR_SERVICE\t0x16\t/* u_int16_t, service */\n#define GDT_MPR_STATUS\t0x14\t/* volatile u_int16_t, command status */\n#define GDT_MPR_SEMA1\t0x12\t/* volatile u_int8_t, status semaphore */\n\nvoid\tgdt_mpr_intr;\n\nvoid\ngdt_mpr_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_mpr_intr(%p) \", gdt));\n\n\tif (ctx->istatus & 0x80) {\t\t/* error flag */\n\t\tctx->istatus &= ~0x80;\n\t\tctx->cmd_status = bus_space_read_2(gdt->sc_dpmemt,\n\t\t    gdt->sc_dpmemh, GDT_MPR_STATUS);\n\t\tif (ctx->istatus == GDT_ASYNCINDEX) {\n\t\t\tctx->service = bus_space_read_2(gdt->sc_dpmemt,\n\t\t\t    gdt->sc_dpmemh, GDT_MPR_SERVICE);\n\t\t\tctx->info2 = bus_space_read_4(gdt->sc_dpmemt,\n\t\t\t    gdt->sc_dpmemh, GDT_MPR_INFO + sizeof (u_int32_t));\n\t\t}\n\t} else\t\t\t\t\t/* no error */\n\t\tctx->cmd_status = GDT_S_OK;\n\n\tctx->info =\n\t    bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_INFO);\n\n\tif (gdt_polling)\t\t\t/* init. -> more info */\n\t\tctx->info2 = bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_INFO + sizeof (u_int32_t));\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR, 0xff);\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA1, 0);\n}"
  },
  {
    "function_name": "gdt_mpr_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "755-762",
    "snippet": "u_int8_t\ngdt_mpr_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_get_status(%p) \", gdt));\n\n\treturn bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */"
    ],
    "globals_used": [
      "u_int8_t gdt_mpr_get_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_EDOOR"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_MISC",
            "(\"gdt_mpr_get_status(%p) \", gdt)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n\nu_int8_t gdt_mpr_get_status;\n\nu_int8_t\ngdt_mpr_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_MISC, (\"gdt_mpr_get_status(%p) \", gdt));\n\n\treturn bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR);\n}"
  },
  {
    "function_name": "gdt_mpr_copy_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "732-753",
    "snippet": "void\ngdt_mpr_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tu_int16_t cp_count = roundup(gdt->sc_cmd_len, sizeof (u_int32_t));\n\tu_int16_t dp_offset = gdt->sc_cmd_off;\n\tu_int16_t cmd_no = gdt->sc_cmd_cnt++;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_mpr_copy_cmd(%p) \", gdt));\n\n\tgdt->sc_cmd_off += cp_count;\n\n\tbus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_OFFSET,\n\t    htole16(GDT_DPMEM_COMMAND_OFFSET + dp_offset));\n\tbus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_SERV_ID,\n\t    htole16(ccb->gc_service));\n\tbus_space_write_raw_region_4(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_DPR_CMD + dp_offset, gdt->sc_cmd, cp_count);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_MPR_IC\tGDT_I960_SZ"
    ],
    "globals_used": [
      "void\tgdt_mpr_copy_cmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_raw_region_4",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_IC + GDT_DPR_CMD + dp_offset",
            "gdt->sc_cmd",
            "cp_count"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_SERV_ID",
            "htole16(ccb->gc_service)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole16",
          "args": [
            "ccb->gc_service"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_OFFSET",
            "htole16(GDT_DPMEM_COMMAND_OFFSET + dp_offset)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole16",
          "args": [
            "GDT_DPMEM_COMMAND_OFFSET + dp_offset"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_CMD",
            "(\"gdt_mpr_copy_cmd(%p) \", gdt)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "gdt->sc_cmd_len",
            "sizeof (u_int32_t)"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_MPR_IC\tGDT_I960_SZ\n\nvoid\tgdt_mpr_copy_cmd;\n\nvoid\ngdt_mpr_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\tu_int16_t cp_count = roundup(gdt->sc_cmd_len, sizeof (u_int32_t));\n\tu_int16_t dp_offset = gdt->sc_cmd_off;\n\tu_int16_t cmd_no = gdt->sc_cmd_cnt++;\n\n\tGDT_DPRINTF(GDT_D_CMD, (\"gdt_mpr_copy_cmd(%p) \", gdt));\n\n\tgdt->sc_cmd_off += cp_count;\n\n\tbus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_OFFSET,\n\t    htole16(GDT_DPMEM_COMMAND_OFFSET + dp_offset));\n\tbus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_SERV_ID,\n\t    htole16(ccb->gc_service));\n\tbus_space_write_raw_region_4(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t    GDT_MPR_IC + GDT_DPR_CMD + dp_offset, gdt->sc_cmd, cp_count);\n}"
  },
  {
    "function_name": "gdt_pcinew_test_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "720-726",
    "snippet": "int\ngdt_pcinew_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_pcinew_test_busy"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_pcinew_test_busy;\n\nint\ngdt_pcinew_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}"
  },
  {
    "function_name": "gdt_pcinew_set_sema0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "713-718",
    "snippet": "void\ngdt_pcinew_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_SEMA0_REG, 1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_SEMA0_REG\t0x40\t/* volatile u_int8_t, command semaphore */"
    ],
    "globals_used": [
      "void\tgdt_pcinew_set_sema0"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_iot",
            "gdt->sc_ioh",
            "GDT_SEMA0_REG",
            "1"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_SEMA0_REG\t0x40\t/* volatile u_int8_t, command semaphore */\n\nvoid\tgdt_pcinew_set_sema0;\n\nvoid\ngdt_pcinew_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_SEMA0_REG, 1);\n}"
  },
  {
    "function_name": "gdt_pcinew_release_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "705-711",
    "snippet": "void\ngdt_pcinew_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pcinew_release_event"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pcinew_release_event;\n\nvoid\ngdt_pcinew_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pcinew_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "697-703",
    "snippet": "void\ngdt_pcinew_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pcinew_intr"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pcinew_intr;\n\nvoid\ngdt_pcinew_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pcinew_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "689-695",
    "snippet": "u_int8_t\ngdt_pcinew_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t gdt_pcinew_get_status"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t gdt_pcinew_get_status;\n\nu_int8_t\ngdt_pcinew_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}"
  },
  {
    "function_name": "gdt_pcinew_copy_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "681-687",
    "snippet": "void\ngdt_pcinew_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pcinew_copy_cmd"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pcinew_copy_cmd;\n\nvoid\ngdt_pcinew_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pci_test_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "669-675",
    "snippet": "int\ngdt_pci_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_pci_test_busy"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_pci_test_busy;\n\nint\ngdt_pci_test_busy(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}"
  },
  {
    "function_name": "gdt_pci_set_sema0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "662-667",
    "snippet": "void\ngdt_pci_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_SEMA0, 1);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pci_set_sema0"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_SEMA0",
            "1"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pci_set_sema0;\n\nvoid\ngdt_pci_set_sema0(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_SEMA0, 1);\n}"
  },
  {
    "function_name": "gdt_pci_release_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "654-660",
    "snippet": "void\ngdt_pci_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pci_release_event"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pci_release_event;\n\nvoid\ngdt_pci_release_event(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "646-652",
    "snippet": "void\ngdt_pci_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pci_intr"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pci_intr;\n\nvoid\ngdt_pci_intr(gdt, ctx)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_intr_ctx *ctx;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pci_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "638-644",
    "snippet": "u_int8_t\ngdt_pci_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t gdt_pci_get_status"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t gdt_pci_get_status;\n\nu_int8_t\ngdt_pci_get_status(gdt)\n\tstruct gdt_softc *gdt;\n{\n\t/* XXX Not yet implemented */\n\treturn (0);\n}"
  },
  {
    "function_name": "gdt_pci_copy_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "630-636",
    "snippet": "void\ngdt_pci_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tgdt_pci_copy_cmd"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_pci_copy_cmd;\n\nvoid\ngdt_pci_copy_cmd(gdt, ccb)\n\tstruct gdt_softc *gdt;\n\tstruct gdt_ccb *ccb;\n{\n\t/* XXX Not yet implemented */\n}"
  },
  {
    "function_name": "gdt_pci_enable_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "594-624",
    "snippet": "void\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */",
      "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */",
      "#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */",
      "#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */",
      "#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */",
      "#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */"
    ],
    "globals_used": [
      "void\tgdt_pci_enable_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_EDOOR_EN",
            "bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_EDOOR_EN"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_MPR_EDOOR",
            "0xff"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_iot",
            "gdt->sc_ioh",
            "GDT_CONTROL1",
            "3"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_iot",
            "gdt->sc_ioh",
            "GDT_EDOOR_REG",
            "0xff"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_IRQEN",
            "1"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_CMD_INDEX",
            "0"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "gdt->sc_dpmemt",
            "gdt->sc_dpmemh",
            "GDT_IRQDEL",
            "1"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_CLASS",
          "args": [
            "gdt"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_DPRINTF",
          "args": [
            "GDT_D_INTR",
            "(\"gdt_pci_enable_intr(%p) \", gdt)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */\n#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */\n#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */\n#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */\n\nvoid\tgdt_pci_enable_intr;\n\nvoid\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "gdt_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "203-591",
    "snippet": "void    \ngdt_pci_attach(parent, self, aux)\n        struct device *parent, *self;\n        void *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct gdt_softc *gdt = (void *)self;\n\tbus_space_tag_t dpmemt, iomemt, iot;\n\tbus_space_handle_t dpmemh, iomemh, ioh;\n\tbus_addr_t dpmembase, iomembase, iobase;\n\tbus_size_t dpmemsize, iomemsize, iosize;\n\tu_int16_t prod;\n\tu_int32_t status = 0;\n#define DPMEM_MAPPED\t\t1\n#define IOMEM_MAPPED\t\t2\n#define IO_MAPPED\t\t4\n#define INTR_ESTABLISHED\t8\n\tint retries;\n\tu_int8_t protocol;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\n\tprintf(\": \");\n\n\tprod = PCI_PRODUCT(pa->pa_id);\n\tswitch (prod) {\n\tcase PCI_PRODUCT_VORTEX_GDT_60x0:\n\tcase PCI_PRODUCT_VORTEX_GDT_6000B:\n\t\tgdt->sc_class = GDT_PCI;\n\t\tbreak;\n\n\tcase PCI_PRODUCT_VORTEX_GDT_6x10:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x20:\n\tcase PCI_PRODUCT_VORTEX_GDT_6530:\n\tcase PCI_PRODUCT_VORTEX_GDT_6550:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x15:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x25:\n\tcase PCI_PRODUCT_VORTEX_GDT_6535:\n\tcase PCI_PRODUCT_VORTEX_GDT_6555:\n\t\tgdt->sc_class = GDT_PCINEW;\n\t\tbreak;\n\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x11RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x21RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x11RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x21RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x18RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x28RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x38RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x58RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x18RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x28RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x38RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x58RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x19RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x29RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x19RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x29RN:\n\t\tgdt->sc_class = GDT_MPR;\n\t}\n\tif (prod >= GDT_PCI_PRODUCT_FC)\n\t\tgdt->sc_class |= GDT_FC;\n\n\tif (pci_mapreg_map(pa,\n\t    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM : GDT_PCI_DPMEM,\n\t    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0, &dpmemt,\n\t    &dpmemh, &dpmembase, &dpmemsize)) {\n\t\tprintf(\"cannot map DPMEM\\n\");\n\t\tgoto bail_out;\n\t}\n\tstatus |= DPMEM_MAPPED;\n\tgdt->sc_dpmemt = dpmemt;\n\tgdt->sc_dpmemh = dpmemh;\n\tgdt->sc_dpmembase = dpmembase;\n\tgdt->sc_dmat = pa->pa_dmat;\n\n\t/*\n\t * The GDT_PCINEW series also has two other regions to map.\n\t */\n\tif (GDT_CLASS(gdt) == GDT_PCINEW) {\n\t\tif (pci_mapreg_map(pa, GDT_PCINEW_IOMEM, PCI_MAPREG_TYPE_MEM,\n\t\t    0, &iomemt, &iomemh, &iomembase, &iomemsize)) {\n\t\t\tprintf(\"cannot map memory mapped I/O ports\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\t\tstatus |= IOMEM_MAPPED;\n\n\t\tif (pci_mapreg_map(pa, GDT_PCINEW_IO, PCI_MAPREG_TYPE_IO, 0,\n\t\t    &iot, &ioh, &iobase, &iosize)) {\n\t\t\tprintf(\"cannot map I/O ports\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\t\tstatus |= IO_MAPPED;\n\t\tgdt->sc_iot = iot;\n\t\tgdt->sc_ioh = ioh;\n\t\tgdt->sc_iobase = iobase;\n\t}\n\n\tswitch (GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\t\tif (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {\n\t\t\tprintf(\"cannot write to DPMEM\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\n#if 0\n\t\t/* disable board interrupts, deinit services */\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n\t\tgdth_writeb(0x00, &dp6_ptr->io.irqen);;\n\t\tgdth_writeb(0x00, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0x00, &dp6_ptr->u.ic.Cmd_Index);\n\n\t\tgdth_writel(pcistr->dpmem, &dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0xff, &dp6_ptr->u.ic.S_Cmd_Indx);\n\t\tgdth_writeb(0, &dp6_ptr->io.event);\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xff) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error (DEINIT failed)\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tprot_ver = (unchar)gdth_readl(&dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n\t\tif (prot_ver != PROTOCOL_VERSION) {\n\t\t  printk(\"GDT-PCI: Illegal protocol version\\n\");\n\t\t  gdth_munmap(ha->brd);\n\t\t  return 0;\n\t\t}\n\n\t\tha->type = GDT_PCI;\n\t\tha->ic_all_size = sizeof(dp6_ptr->u);\n        \n\t\t/* special command to controller BIOS */\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[1]);\n\t\tgdth_writel(0x01, &dp6_ptr->u.ic.S_Info[2]);\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[3]);\n\t\tgdth_writeb(0xfe, &dp6_ptr->u.ic.S_Cmd_Indx);\n\t\tgdth_writeb(0, &dp6_ptr->io.event);\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xfe) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tgdth_writeb(0, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n#endif\n\n\t\tgdt->sc_ic_all_size = GDT_DPRAM_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_pci_copy_cmd;\n\t\tgdt->sc_get_status = gdt_pci_get_status;\n\t\tgdt->sc_intr = gdt_pci_intr;\n\t\tgdt->sc_release_event = gdt_pci_release_event;\n\t\tgdt->sc_set_sema0 = gdt_pci_set_sema0;\n\t\tgdt->sc_test_busy = gdt_pci_test_busy;\n\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\t\tif (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {\n\t\t\tprintf(\"cannot write to DPMEM\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\n#if 0\n\t\t/* disable board interrupts, deinit services */\n\t\toutb(0x00,PTR2USHORT(&ha->plx->control1));\n\t\toutb(0xff,PTR2USHORT(&ha->plx->edoor_reg));\n        \n\t\tgdth_writeb(0x00, &dp6c_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0x00, &dp6c_ptr->u.ic.Cmd_Index);\n\n\t\tgdth_writel(pcistr->dpmem, &dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0xff, &dp6c_ptr->u.ic.S_Cmd_Indx);\n\n\t\toutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\n\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xff) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error (DEINIT failed)\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tprot_ver = (unchar)gdth_readl(&dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0, &dp6c_ptr->u.ic.Status);\n\t\tif (prot_ver != PROTOCOL_VERSION) {\n\t\t  printk(\"GDT-PCI: Illegal protocol version\\n\");\n\t\t  gdth_munmap(ha->brd);\n\t\t  return 0;\n\t\t}\n\n\t\tha->type = GDT_PCINEW;\n\t\tha->ic_all_size = sizeof(dp6c_ptr->u);\n\n\t\t/* special command to controller BIOS */\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[1]);\n\t\tgdth_writel(0x01, &dp6c_ptr->u.ic.S_Info[2]);\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[3]);\n\t\tgdth_writeb(0xfe, &dp6c_ptr->u.ic.S_Cmd_Indx);\n        \n\t\toutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\n\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xfe) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tgdth_writeb(0, &dp6c_ptr->u.ic.S_Status);\n#endif\n\n\t\tgdt->sc_ic_all_size = GDT_PCINEW_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_pcinew_copy_cmd;\n\t\tgdt->sc_get_status = gdt_pcinew_get_status;\n\t\tgdt->sc_intr = gdt_pcinew_intr;\n\t\tgdt->sc_release_event = gdt_pcinew_release_event;\n\t\tgdt->sc_set_sema0 = gdt_pcinew_set_sema0;\n\t\tgdt->sc_test_busy = gdt_pcinew_test_busy;\n\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC,\n\t\t    htole32(GDT_MPR_MAGIC));\n\t\tif (bus_space_read_4(dpmemt, dpmemh, GDT_MPR_IC) !=\n\t\t    htole32(GDT_MPR_MAGIC)) {\n\t\t\tprintf(\"cannot access DPMEM at 0x%x (shadowed?)\\n\",\n\t\t\t    dpmembase);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t/*\n\t\t * XXX Here the Linux driver has a weird remapping logic I\n\t\t * don't understand.  My controller does not need it, and I\n\t\t * cannot see what purpose it serves, therefore I did not\n\t\t * do anything similar.\n\t\t */\n\n\t\tbus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\n\t\t/* Disable everything */\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(dpmemt, dpmemh, GDT_EDOOR_EN) | 4);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_CMD_INDEX,\n\t\t    0);\n\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,\n\t\t    htole32(dpmembase));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,\n\t\t    0xff);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);\n\n\t\tDELAY(20);\n\t\tretries = GDT_RETRIES;\n\t\twhile (bus_space_read_1(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_STATUS) != 0xff) {\n\t\t\tif (--retries == 0) {\n\t\t\t\tprintf(\"DEINIT failed\\n\");\n\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\t\tDELAY(1);\n\t\t}\n\n\t\tprotocol = (u_int8_t)letoh32(bus_space_read_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\t\tif (protocol != GDT_PROTOCOL_VERSION) {\n\t\t \tprintf(\"unsupported protocol %d\\n\", protocol);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t/* special commnd to controller BIOS */\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,\n\t\t    htole32(0));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), htole32(0));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t),\n\t\t    htole32(1));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t),\n\t\t    htole32(0));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,\n\t\t    0xfe);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);\n\n\t\tDELAY(20);\n\t\tretries = GDT_RETRIES;\n\t\twhile (bus_space_read_1(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_STATUS) != 0xfe) {\n\t\t\tif (--retries == 0) {\n\t\t\t\tprintf(\"initialization error\\n\");\n\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\t\tDELAY(1);\n\t\t}\n\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\n\t\tgdt->sc_ic_all_size = GDT_MPR_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_mpr_copy_cmd;\n\t\tgdt->sc_get_status = gdt_mpr_get_status;\n\t\tgdt->sc_intr = gdt_mpr_intr;\n\t\tgdt->sc_release_event = gdt_mpr_release_event;\n\t\tgdt->sc_set_sema0 = gdt_mpr_set_sema0;\n\t\tgdt->sc_test_busy = gdt_mpr_test_busy;\n\t}\n\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"couldn't map interrupt\\n\");\n\t\tgoto bail_out;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tgdt->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, gdt_intr, gdt,\n\t    gdt->sc_dev.dv_xname);\n\tif (gdt->sc_ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto bail_out;\n\t}\n\tstatus |= INTR_ESTABLISHED;\n\tif (intrstr != NULL)\n\t\tprintf(\"%s \", intrstr);\n\n\tif (gdt_attach(gdt))\n\t\tgoto bail_out;\n\n\tgdt_pci_enable_intr(gdt);\n\n\treturn;\n\n bail_out:\n\tif (status & DPMEM_MAPPED)\n\t\tbus_space_unmap(dpmemt, dpmemh, dpmemsize);\n\tif (status & IOMEM_MAPPED)\n\t\tbus_space_unmap(iomemt, iomemh, iomembase);\n\tif (status & IO_MAPPED)\n\t\tbus_space_unmap(iot, ioh, iosize);\n\tif (status & INTR_ESTABLISHED)\n\t\tpci_intr_disestablish(pa->pa_pc, gdt->sc_ih);\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_ESTABLISHED\t8",
      "#define IO_MAPPED\t\t4",
      "#define IOMEM_MAPPED\t\t2",
      "#define DPMEM_MAPPED\t\t1",
      "#define GDT_MPR_SZ\t0x4000",
      "#define GDT_MPR_IC\tGDT_I960_SZ",
      "#define GDT_I960_SZ\t0x1000",
      "#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */",
      "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */",
      "#define GDT_MPR_LDOOR\t0x20\t/* u_int8_t, PCI to local doorbell */",
      "#define GDT_PCINEW_SZ\t0x4000",
      "#define GDT_DPRAM_SZ\t0x1000",
      "#define GDT_PCINEW_DPMEM\t0x18",
      "#define GDT_PCINEW_IO\t\t0x14",
      "#define GDT_PCINEW_IOMEM\t0x10",
      "#define GDT_PCI_DPMEM\t\t0x10",
      "#define GDT_PCI_PRODUCT_FC\t0x200"
    ],
    "globals_used": [
      "void\tgdt_pci_attach",
      "void\tgdt_pci_enable_intr",
      "void\tgdt_pci_copy_cmd",
      "u_int8_t gdt_pci_get_status",
      "void\tgdt_pci_intr",
      "void\tgdt_pci_release_event",
      "void\tgdt_pci_set_sema0",
      "int\tgdt_pci_test_busy",
      "void\tgdt_pcinew_copy_cmd",
      "u_int8_t gdt_pcinew_get_status",
      "void\tgdt_pcinew_intr",
      "void\tgdt_pcinew_release_event",
      "void\tgdt_pcinew_set_sema0",
      "int\tgdt_pcinew_test_busy",
      "void\tgdt_mpr_copy_cmd",
      "u_int8_t gdt_mpr_get_status",
      "void\tgdt_mpr_intr",
      "void\tgdt_mpr_release_event",
      "void\tgdt_mpr_set_sema0",
      "int\tgdt_mpr_test_busy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_intr_disestablish",
          "args": [
            "pa->pa_pc",
            "gdt->sc_ih"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "iosize"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iomemt",
            "iomemh",
            "iomembase"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "dpmemt",
            "dpmemh",
            "dpmemsize"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdt_pci_enable_intr",
          "args": [
            "gdt"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_pci_enable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
          "lines": "594-624",
          "snippet": "void\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */",
            "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */",
            "#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */",
            "#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */",
            "#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */",
            "#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */"
          ],
          "globals_used": [
            "void\tgdt_pci_enable_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */\n#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */\n#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */\n#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */\n\nvoid\tgdt_pci_enable_intr;\n\nvoid\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdt_attach",
          "args": [
            "gdt"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/gdt_common.c",
          "lines": "105-395",
          "snippet": "int\ngdt_attach(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tu_int16_t cdev_cnt;\n\tint i, id, drv_cyls, drv_hds, drv_secs, error;\n\n\tgdt_polling = 1;\n\tgdt_from_wait = 0;\n\tgdt_clear_events(gdt);\n\n\tTAILQ_INIT(&gdt->sc_free_ccb);\n\tTAILQ_INIT(&gdt->sc_ccbq);\n\tLIST_INIT(&gdt->sc_queue);\n\n\t/* Initialize the ccbs */\n\tfor (i = 0; i < GDT_MAXCMDS; i++) {\n\t\tgdt->sc_ccbs[i].gc_cmd_index = i + 2;\n\t\terror = bus_dmamap_create(gdt->sc_dmat,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,\n\t\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t    &gdt->sc_ccbs[i].gc_dmamap_xfer);\n\t\tif (error) {\n\t\t\tprintf(\"%s: cannot create ccb dmamap (%d)\",\n\t\t\t    gdt->sc_dev.dv_xname, error);\n\t\t\treturn (1);\n\t\t}\n\t\t(void)gdt_ccb_set_cmd(gdt->sc_ccbs + i, GDT_GCF_UNUSED);\n\t\tTAILQ_INSERT_TAIL(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],\n\t\t    gc_chain);\n\t}\n\n\t/* Fill in the prototype scsi_link. */\n\tgdt->sc_link.adapter_softc = gdt;\n\tgdt->sc_link.adapter = &gdt_switch;\n\tgdt->sc_link.adapter_target = 7;\n\tgdt->sc_link.device = &gdt_dev;\n\tgdt->sc_link.openings = GDT_MAXCMDS;\t/* XXX what is optimal? */\n\tgdt->sc_link.adapter_buswidth =\n\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"screen service initialization error %d\\n\",\n\t\t     gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_MOUNT, 0xffff, 1,\n\t    0)) {\n\t\tprintf(\"cache service mount error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service post-mount initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\tcdev_cnt = (u_int16_t)gdt->sc_info;\n\n\t/* Detect number of busses */\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);\n\tgdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;\n\tgdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;\n\tgdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t    GDT_IOCHAN_RAW_DESC, GDT_INVALID_CHANNEL,\n\t    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {\n\t\tgdt->sc_bus_cnt = gdt->sc_scratch[GDT_IOC_CHAN_COUNT];\n\t\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t\tid = gdt->sc_scratch[GDT_IOC_HDR_SZ +\n\t\t\t    i * GDT_RAWIOC_SZ + GDT_RAWIOC_PROC_ID];\n\t\t\tgdt->sc_bus_id[id] = id < GDT_MAXID ? id : 0xff;\n\t\t}\n\n\t} else {\n\t\t/* New method failed, use fallback. */\n\t\tgdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO, i);\n\t\tfor (i = 0; i < GDT_MAXBUS; i++) {\n\t\t\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t\t    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,\n\t\t\t    GDT_IO_CHANNEL | GDT_INVALID_CHANNEL,\n\t\t\t    GDT_GETCH_SZ)) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tprintf(\"cannot get channel count, \"\n\t\t\t\t\t    \"error %d\\n\", gdt->sc_status);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgdt->sc_bus_id[i] =\n\t\t\t    (gdt->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?\n\t\t\t    gdt->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;\n\t\t}\n\t\tgdt->sc_bus_cnt = i;\n\t}\n\n\t/* Read cache confgiuration */\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_CINFO_SZ)) {\n\t\tprintf(\"cannot get cache info, error %d\\n\", gdt->sc_status);\n\t\treturn (1);\n\t}\n\tgdt->sc_cpar.cp_version =\n\t    gdt_dec32(gdt->sc_scratch + GDT_CPAR_VERSION);\n\tgdt->sc_cpar.cp_state = gdt_dec16(gdt->sc_scratch + GDT_CPAR_STATE);\n\tgdt->sc_cpar.cp_strategy =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_STRATEGY);\n\tgdt->sc_cpar.cp_write_back =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_WRITE_BACK);\n\tgdt->sc_cpar.cp_block_size =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_BLOCK_SIZE);\n\n\t/* Read board information and features */\n\tgdt->sc_more_proc = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_BINFO_SZ)) {\n\t\t/* XXX A lot of these assignments can probably go later */\n\t\tgdt->sc_binfo.bi_ser_no =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_SER_NO);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_OEM_ID,\n\t\t    gdt->sc_binfo.bi_oem_id, sizeof gdt->sc_binfo.bi_oem_id);\n\t\tgdt->sc_binfo.bi_ep_flags =\n\t\t    gdt_dec16(gdt->sc_scratch + GDT_BINFO_EP_FLAGS);\n\t\tgdt->sc_binfo.bi_proc_id =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_PROC_ID);\n\t\tgdt->sc_binfo.bi_memsize =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEMSIZE);\n\t\tgdt->sc_binfo.bi_mem_banks =\n\t\t    gdt->sc_scratch[GDT_BINFO_MEM_BANKS];\n\t\tgdt->sc_binfo.bi_chan_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_TYPE];\n\t\tgdt->sc_binfo.bi_chan_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_COUNT];\n\t\tgdt->sc_binfo.bi_rdongle_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RDONGLE_PRES];\n\t\tgdt->sc_binfo.bi_epr_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_EPR_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_revision =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_REVISION);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_TYPE_STRING,\n\t\t    gdt->sc_binfo.bi_type_string,\n\t\t    sizeof gdt->sc_binfo.bi_type_string);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_RAID_STRING,\n\t\t    gdt->sc_binfo.bi_raid_string,\n\t\t    sizeof gdt->sc_binfo.bi_raid_string);\n\t\tgdt->sc_binfo.bi_update_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_UPDATE_PRES];\n\t\tgdt->sc_binfo.bi_xor_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_XOR_PRES];\n\t\tgdt->sc_binfo.bi_prom_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_TYPE];\n\t\tgdt->sc_binfo.bi_prom_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_COUNT];\n\t\tgdt->sc_binfo.bi_dup_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_DUP_PRES);\n\t\tgdt->sc_binfo.bi_chan_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_CHAN_PRES);\n\t\tgdt->sc_binfo.bi_mem_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEM_PRES);\n\t\tgdt->sc_binfo.bi_ft_bus_system =\n\t\t    gdt->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];\n\t\tgdt->sc_binfo.bi_subtype_valid =\n\t\t    gdt->sc_scratch[GDT_BINFO_SUBTYPE_VALID];\n\t\tgdt->sc_binfo.bi_board_subtype =\n\t\t    gdt->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];\n\t\tgdt->sc_binfo.bi_rampar_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RAMPAR_PRES];\n\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t    GDT_BOARD_FEATURES, GDT_INVALID_CHANNEL, GDT_BFEAT_SZ)) {\n\t\t\tgdt->sc_bfeat.bf_chaining =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_CHAINING];\n\t\t\tgdt->sc_bfeat.bf_striping =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_STRIPING];\n\t\t\tgdt->sc_bfeat.bf_mirroring =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_MIRRORING];\n\t\t\tgdt->sc_bfeat.bf_raid =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_RAID];\n\t\t\tgdt->sc_more_proc = 1;\n\t\t}\n\t} else {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\t/* Read more information */\n\tif (gdt->sc_more_proc) {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"raw service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\t/* Set/get features raw service (scatter/gather) */\n\tgdt->sc_raw_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,\n\t    GDT_SCATTER_GATHER, 0, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,\n\t\t    0, 0))\n\t\t\tgdt->sc_raw_feat = gdt->sc_info;\n\n\t/* Set/get features cache service (scatter/gather) */\n\tgdt->sc_cache_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_SET_FEAT, 0,\n\t    GDT_SCATTER_GATHER, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,\n\t\t    0))\n\t\t\tgdt->sc_cache_feat = gdt->sc_info;\n\n\t/* XXX Linux reserve drives here, potentially */\n\n\t/* Scan for cache devices */\n\tfor (i = 0; i < cdev_cnt && i < GDT_MAX_HDRIVES; i++)\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INFO, i, 0,\n\t\t    0)) {\n\t\t\tgdt->sc_hdr[i].hd_present = 1;\n\t\t\tgdt->sc_hdr[i].hd_size = gdt->sc_info;\n\n\t\t\t/*\n\t\t\t * Evaluate mapping (sectors per head, heads per cyl)\n\t\t\t */\n\t\t\tgdt->sc_hdr[i].hd_size &= ~GDT_SECS32;\n\t\t\tif (gdt->sc_info2 == 0)\n\t\t\t\tgdt_eval_mapping(gdt->sc_hdr[i].hd_size,\n\t\t\t\t    &drv_cyls, &drv_hds, &drv_secs);\n\t\t\telse {\n\t\t\t\tdrv_hds = gdt->sc_info2 & 0xff;\n\t\t\t\tdrv_secs = (gdt->sc_info2 >> 8) & 0xff;\n\t\t\t\tdrv_cyls = gdt->sc_hdr[i].hd_size / drv_hds /\n\t\t\t\t    drv_secs;\n\t\t\t}\n\t\t\tgdt->sc_hdr[i].hd_heads = drv_hds;\n\t\t\tgdt->sc_hdr[i].hd_secs = drv_secs;\n\t\t\t/* Round the size */\n\t\t\tgdt->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;\n\n\t\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE,\n\t\t\t    GDT_DEVTYPE, i, 0, 0))\n\t\t\t\tgdt->sc_hdr[i].hd_devtype = gdt->sc_info;\n\t\t}\n\n\tprintf(\"dpmem %x %d-bus %d cache device%s\\n\", gdt->sc_dpmembase,\n\t    gdt->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? \"\" : \"s\");\n\tprintf(\"%s: ver %x, cache %s, strategy %d, writeback %s, blksz %d\\n\",\n\t    gdt->sc_dev.dv_xname, gdt->sc_cpar.cp_version,\n\t    gdt->sc_cpar.cp_state ? \"on\" : \"off\", gdt->sc_cpar.cp_strategy,\n\t    gdt->sc_cpar.cp_write_back ? \"on\" : \"off\",\n\t    gdt->sc_cpar.cp_block_size);\n#if 1\n\tprintf(\"%s: raw feat %x cache feat %x\\n\", gdt->sc_dev.dv_xname,\n\t    gdt->sc_raw_feat, gdt->sc_cache_feat);\n#endif\n\n\tconfig_found(&gdt->sc_dev, &gdt->sc_link, scsiprint);\n\n\tMALLOC(gdt->sc_raw_link, struct scsi_link *,\n\t    gdt->sc_bus_cnt * sizeof (struct scsi_link), M_DEVBUF, M_NOWAIT);\n\tbzero(gdt->sc_raw_link, gdt->sc_bus_cnt * sizeof (struct scsi_link));\n\n\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t/* Fill in the prototype scsi_link. */\n\t\tgdt->sc_raw_link[i].adapter_softc = gdt;\n\t\tgdt->sc_raw_link[i].adapter = &gdt_raw_switch;\n\t\tgdt->sc_raw_link[i].adapter_target = 7;\n\t\tgdt->sc_raw_link[i].device = &gdt_dev;\n\t\tgdt->sc_raw_link[i].openings = 4;\t/* XXX a guess */\n\t\tgdt->sc_raw_link[i].adapter_buswidth =\n\t\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : 16;\t/* XXX */\n\n\t\tconfig_found(&gdt->sc_dev, &gdt->sc_raw_link[i], scsiprint);\n\t}\n\n\tgdt_polling = 0;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tgdt_clear_events",
            "void\tgdt_eval_mapping",
            "int\tgdt_internal_cmd",
            "struct scsi_adapter gdt_switch = {\n\tgdt_scsi_cmd, gdtminphys, 0, 0,\n};",
            "struct scsi_adapter gdt_raw_switch = {\n\tgdt_raw_scsi_cmd, gdtminphys, 0, 0,\n};",
            "struct scsi_device gdt_dev = {\n\tNULL, NULL, NULL, NULL\n};",
            "u_int8_t gdt_polling;",
            "u_int8_t gdt_from_wait;",
            "struct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;",
            "struct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tgdt_clear_events;\nvoid\tgdt_eval_mapping;\nint\tgdt_internal_cmd;\nstruct scsi_adapter gdt_switch = {\n\tgdt_scsi_cmd, gdtminphys, 0, 0,\n};\nstruct scsi_adapter gdt_raw_switch = {\n\tgdt_raw_scsi_cmd, gdtminphys, 0, 0,\n};\nstruct scsi_device gdt_dev = {\n\tNULL, NULL, NULL, NULL\n};\nu_int8_t gdt_polling;\nu_int8_t gdt_from_wait;\nstruct scsi_xfer *\ngdt_dequeue(gdt)\n\tstruct gdt_softc *gdt;\nstruct gdt_ccb *\ngdt_get_ccb(gdt, flags)\n\tstruct gdt_softc *gdt;\n\nint\ngdt_attach(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tu_int16_t cdev_cnt;\n\tint i, id, drv_cyls, drv_hds, drv_secs, error;\n\n\tgdt_polling = 1;\n\tgdt_from_wait = 0;\n\tgdt_clear_events(gdt);\n\n\tTAILQ_INIT(&gdt->sc_free_ccb);\n\tTAILQ_INIT(&gdt->sc_ccbq);\n\tLIST_INIT(&gdt->sc_queue);\n\n\t/* Initialize the ccbs */\n\tfor (i = 0; i < GDT_MAXCMDS; i++) {\n\t\tgdt->sc_ccbs[i].gc_cmd_index = i + 2;\n\t\terror = bus_dmamap_create(gdt->sc_dmat,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, GDT_MAXOFFSETS,\n\t\t    (GDT_MAXOFFSETS - 1) << PGSHIFT, 0,\n\t\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t\t    &gdt->sc_ccbs[i].gc_dmamap_xfer);\n\t\tif (error) {\n\t\t\tprintf(\"%s: cannot create ccb dmamap (%d)\",\n\t\t\t    gdt->sc_dev.dv_xname, error);\n\t\t\treturn (1);\n\t\t}\n\t\t(void)gdt_ccb_set_cmd(gdt->sc_ccbs + i, GDT_GCF_UNUSED);\n\t\tTAILQ_INSERT_TAIL(&gdt->sc_free_ccb, &gdt->sc_ccbs[i],\n\t\t    gc_chain);\n\t}\n\n\t/* Fill in the prototype scsi_link. */\n\tgdt->sc_link.adapter_softc = gdt;\n\tgdt->sc_link.adapter = &gdt_switch;\n\tgdt->sc_link.adapter_target = 7;\n\tgdt->sc_link.device = &gdt_dev;\n\tgdt->sc_link.openings = GDT_MAXCMDS;\t/* XXX what is optimal? */\n\tgdt->sc_link.adapter_buswidth =\n\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : GDT_MAX_HDRIVES;\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCREENSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"screen service initialization error %d\\n\",\n\t\t     gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_MOUNT, 0xffff, 1,\n\t    0)) {\n\t\tprintf(\"cache service mount error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INIT, GDT_LINUX_OS, 0,\n\t    0)) {\n\t\tprintf(\"cache service post-mount initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\tcdev_cnt = (u_int16_t)gdt->sc_info;\n\n\t/* Detect number of busses */\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_VERSION, GDT_IOC_NEWEST);\n\tgdt->sc_scratch[GDT_IOC_LIST_ENTRIES] = GDT_MAXBUS;\n\tgdt->sc_scratch[GDT_IOC_FIRST_CHAN] = 0;\n\tgdt->sc_scratch[GDT_IOC_LAST_CHAN] = GDT_MAXBUS - 1;\n\tgdt_enc32(gdt->sc_scratch + GDT_IOC_LIST_OFFSET, GDT_IOC_HDR_SZ);\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t    GDT_IOCHAN_RAW_DESC, GDT_INVALID_CHANNEL,\n\t    GDT_IOC_HDR_SZ + GDT_RAWIOC_SZ)) {\n\t\tgdt->sc_bus_cnt = gdt->sc_scratch[GDT_IOC_CHAN_COUNT];\n\t\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t\tid = gdt->sc_scratch[GDT_IOC_HDR_SZ +\n\t\t\t    i * GDT_RAWIOC_SZ + GDT_RAWIOC_PROC_ID];\n\t\t\tgdt->sc_bus_id[id] = id < GDT_MAXID ? id : 0xff;\n\t\t}\n\n\t} else {\n\t\t/* New method failed, use fallback. */\n\t\tgdt_enc32(gdt->sc_scratch + GDT_GETCH_CHANNEL_NO, i);\n\t\tfor (i = 0; i < GDT_MAXBUS; i++) {\n\t\t\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t\t    GDT_SCSI_CHAN_CNT | GDT_L_CTRL_PATTERN,\n\t\t\t    GDT_IO_CHANNEL | GDT_INVALID_CHANNEL,\n\t\t\t    GDT_GETCH_SZ)) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tprintf(\"cannot get channel count, \"\n\t\t\t\t\t    \"error %d\\n\", gdt->sc_status);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgdt->sc_bus_id[i] =\n\t\t\t    (gdt->sc_scratch[GDT_GETCH_SIOP_ID] < GDT_MAXID) ?\n\t\t\t    gdt->sc_scratch[GDT_GETCH_SIOP_ID] : 0xff;\n\t\t}\n\t\tgdt->sc_bus_cnt = i;\n\t}\n\n\t/* Read cache confgiuration */\n\tif (!gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_CACHE_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_CINFO_SZ)) {\n\t\tprintf(\"cannot get cache info, error %d\\n\", gdt->sc_status);\n\t\treturn (1);\n\t}\n\tgdt->sc_cpar.cp_version =\n\t    gdt_dec32(gdt->sc_scratch + GDT_CPAR_VERSION);\n\tgdt->sc_cpar.cp_state = gdt_dec16(gdt->sc_scratch + GDT_CPAR_STATE);\n\tgdt->sc_cpar.cp_strategy =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_STRATEGY);\n\tgdt->sc_cpar.cp_write_back =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_WRITE_BACK);\n\tgdt->sc_cpar.cp_block_size =\n\t    gdt_dec16(gdt->sc_scratch + GDT_CPAR_BLOCK_SIZE);\n\n\t/* Read board information and features */\n\tgdt->sc_more_proc = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL, GDT_BOARD_INFO,\n\t    GDT_INVALID_CHANNEL, GDT_BINFO_SZ)) {\n\t\t/* XXX A lot of these assignments can probably go later */\n\t\tgdt->sc_binfo.bi_ser_no =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_SER_NO);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_OEM_ID,\n\t\t    gdt->sc_binfo.bi_oem_id, sizeof gdt->sc_binfo.bi_oem_id);\n\t\tgdt->sc_binfo.bi_ep_flags =\n\t\t    gdt_dec16(gdt->sc_scratch + GDT_BINFO_EP_FLAGS);\n\t\tgdt->sc_binfo.bi_proc_id =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_PROC_ID);\n\t\tgdt->sc_binfo.bi_memsize =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEMSIZE);\n\t\tgdt->sc_binfo.bi_mem_banks =\n\t\t    gdt->sc_scratch[GDT_BINFO_MEM_BANKS];\n\t\tgdt->sc_binfo.bi_chan_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_TYPE];\n\t\tgdt->sc_binfo.bi_chan_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_CHAN_COUNT];\n\t\tgdt->sc_binfo.bi_rdongle_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RDONGLE_PRES];\n\t\tgdt->sc_binfo.bi_epr_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_EPR_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_fw_ver =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_FW_VER);\n\t\tgdt->sc_binfo.bi_upd_revision =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_UPD_REVISION);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_TYPE_STRING,\n\t\t    gdt->sc_binfo.bi_type_string,\n\t\t    sizeof gdt->sc_binfo.bi_type_string);\n\t\tbcopy(gdt->sc_scratch + GDT_BINFO_RAID_STRING,\n\t\t    gdt->sc_binfo.bi_raid_string,\n\t\t    sizeof gdt->sc_binfo.bi_raid_string);\n\t\tgdt->sc_binfo.bi_update_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_UPDATE_PRES];\n\t\tgdt->sc_binfo.bi_xor_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_XOR_PRES];\n\t\tgdt->sc_binfo.bi_prom_type =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_TYPE];\n\t\tgdt->sc_binfo.bi_prom_count =\n\t\t    gdt->sc_scratch[GDT_BINFO_PROM_COUNT];\n\t\tgdt->sc_binfo.bi_dup_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_DUP_PRES);\n\t\tgdt->sc_binfo.bi_chan_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_CHAN_PRES);\n\t\tgdt->sc_binfo.bi_mem_pres =\n\t\t    gdt_dec32(gdt->sc_scratch + GDT_BINFO_MEM_PRES);\n\t\tgdt->sc_binfo.bi_ft_bus_system =\n\t\t    gdt->sc_scratch[GDT_BINFO_FT_BUS_SYSTEM];\n\t\tgdt->sc_binfo.bi_subtype_valid =\n\t\t    gdt->sc_scratch[GDT_BINFO_SUBTYPE_VALID];\n\t\tgdt->sc_binfo.bi_board_subtype =\n\t\t    gdt->sc_scratch[GDT_BINFO_BOARD_SUBTYPE];\n\t\tgdt->sc_binfo.bi_rampar_pres =\n\t\t    gdt->sc_scratch[GDT_BINFO_RAMPAR_PRES];\n\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_IOCTL,\n\t\t    GDT_BOARD_FEATURES, GDT_INVALID_CHANNEL, GDT_BFEAT_SZ)) {\n\t\t\tgdt->sc_bfeat.bf_chaining =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_CHAINING];\n\t\t\tgdt->sc_bfeat.bf_striping =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_STRIPING];\n\t\t\tgdt->sc_bfeat.bf_mirroring =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_MIRRORING];\n\t\t\tgdt->sc_bfeat.bf_raid =\n\t\t\t    gdt->sc_scratch[GDT_BFEAT_RAID];\n\t\t\tgdt->sc_more_proc = 1;\n\t\t}\n\t} else {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\t/* Read more information */\n\tif (gdt->sc_more_proc) {\n\t\t/* XXX Not implemented yet */\t\t\n\t}\n\n\tif (!gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_INIT, 0, 0, 0)) {\n\t\tprintf(\"raw service initialization error %d\\n\",\n\t\t    gdt->sc_status);\n\t\treturn (1);\n\t}\n\n\t/* Set/get features raw service (scatter/gather) */\n\tgdt->sc_raw_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_SET_FEAT,\n\t    GDT_SCATTER_GATHER, 0, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_SCSIRAWSERVICE, GDT_GET_FEAT, 0,\n\t\t    0, 0))\n\t\t\tgdt->sc_raw_feat = gdt->sc_info;\n\n\t/* Set/get features cache service (scatter/gather) */\n\tgdt->sc_cache_feat = 0;\n\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_SET_FEAT, 0,\n\t    GDT_SCATTER_GATHER, 0))\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_GET_FEAT, 0, 0,\n\t\t    0))\n\t\t\tgdt->sc_cache_feat = gdt->sc_info;\n\n\t/* XXX Linux reserve drives here, potentially */\n\n\t/* Scan for cache devices */\n\tfor (i = 0; i < cdev_cnt && i < GDT_MAX_HDRIVES; i++)\n\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE, GDT_INFO, i, 0,\n\t\t    0)) {\n\t\t\tgdt->sc_hdr[i].hd_present = 1;\n\t\t\tgdt->sc_hdr[i].hd_size = gdt->sc_info;\n\n\t\t\t/*\n\t\t\t * Evaluate mapping (sectors per head, heads per cyl)\n\t\t\t */\n\t\t\tgdt->sc_hdr[i].hd_size &= ~GDT_SECS32;\n\t\t\tif (gdt->sc_info2 == 0)\n\t\t\t\tgdt_eval_mapping(gdt->sc_hdr[i].hd_size,\n\t\t\t\t    &drv_cyls, &drv_hds, &drv_secs);\n\t\t\telse {\n\t\t\t\tdrv_hds = gdt->sc_info2 & 0xff;\n\t\t\t\tdrv_secs = (gdt->sc_info2 >> 8) & 0xff;\n\t\t\t\tdrv_cyls = gdt->sc_hdr[i].hd_size / drv_hds /\n\t\t\t\t    drv_secs;\n\t\t\t}\n\t\t\tgdt->sc_hdr[i].hd_heads = drv_hds;\n\t\t\tgdt->sc_hdr[i].hd_secs = drv_secs;\n\t\t\t/* Round the size */\n\t\t\tgdt->sc_hdr[i].hd_size = drv_cyls * drv_hds * drv_secs;\n\n\t\t\tif (gdt_internal_cmd(gdt, GDT_CACHESERVICE,\n\t\t\t    GDT_DEVTYPE, i, 0, 0))\n\t\t\t\tgdt->sc_hdr[i].hd_devtype = gdt->sc_info;\n\t\t}\n\n\tprintf(\"dpmem %x %d-bus %d cache device%s\\n\", gdt->sc_dpmembase,\n\t    gdt->sc_bus_cnt, cdev_cnt, cdev_cnt == 1 ? \"\" : \"s\");\n\tprintf(\"%s: ver %x, cache %s, strategy %d, writeback %s, blksz %d\\n\",\n\t    gdt->sc_dev.dv_xname, gdt->sc_cpar.cp_version,\n\t    gdt->sc_cpar.cp_state ? \"on\" : \"off\", gdt->sc_cpar.cp_strategy,\n\t    gdt->sc_cpar.cp_write_back ? \"on\" : \"off\",\n\t    gdt->sc_cpar.cp_block_size);\n#if 1\n\tprintf(\"%s: raw feat %x cache feat %x\\n\", gdt->sc_dev.dv_xname,\n\t    gdt->sc_raw_feat, gdt->sc_cache_feat);\n#endif\n\n\tconfig_found(&gdt->sc_dev, &gdt->sc_link, scsiprint);\n\n\tMALLOC(gdt->sc_raw_link, struct scsi_link *,\n\t    gdt->sc_bus_cnt * sizeof (struct scsi_link), M_DEVBUF, M_NOWAIT);\n\tbzero(gdt->sc_raw_link, gdt->sc_bus_cnt * sizeof (struct scsi_link));\n\n\tfor (i = 0; i < gdt->sc_bus_cnt; i++) {\n\t\t/* Fill in the prototype scsi_link. */\n\t\tgdt->sc_raw_link[i].adapter_softc = gdt;\n\t\tgdt->sc_raw_link[i].adapter = &gdt_raw_switch;\n\t\tgdt->sc_raw_link[i].adapter_target = 7;\n\t\tgdt->sc_raw_link[i].device = &gdt_dev;\n\t\tgdt->sc_raw_link[i].openings = 4;\t/* XXX a guess */\n\t\tgdt->sc_raw_link[i].adapter_buswidth =\n\t\t    (gdt->sc_class & GDT_FC) ? GDT_MAXID : 16;\t/* XXX */\n\n\t\tconfig_found(&gdt->sc_dev, &gdt->sc_raw_link[i], scsiprint);\n\t}\n\n\tgdt_polling = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s \"",
            "intrstr"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "ih",
            "IPL_BIO",
            "gdt_intr",
            "gdt",
            "gdt->sc_dev.dv_xname"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "ih"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_STATUS",
            "0"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_STATUS"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_LDOOR",
            "1"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_CMD_INDX",
            "0xfe"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t)",
            "htole32(0)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t)",
            "htole32(1)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t)",
            "htole32(0)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO",
            "htole32(0)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_STATUS",
            "0"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "letoh32",
          "args": [
            "bus_space_read_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_STATUS"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_LDOOR",
            "1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_CMD_INDX",
            "0xff"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_INFO",
            "htole32(dpmembase)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "dpmembase"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_CMD_INDEX",
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC + GDT_S_STATUS",
            "0"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_EDOOR",
            "0xff"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_EDOOR_EN",
            "bus_space_read_1(dpmemt, dpmemh, GDT_EDOOR_EN) | 4"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_EDOOR_EN"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_I960_SZ",
            "htole32(0)",
            "GDT_DPR_IF_SZ >> 2"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "GDT_MPR_MAGIC"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "GDT_MPR_IC",
            "htole32(GDT_MPR_MAGIC)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "GDT_MPR_MAGIC"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6c_ptr->u.ic.S_Status"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "1"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Initialization error\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readb",
          "args": [
            "&dp6c_ptr->u.ic.S_Status"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "20"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "1",
            "PTR2USHORT(&ha->plx->ldoor_reg)"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR2USHORT",
          "args": [
            "&ha->plx->ldoor_reg"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xfe",
            "&dp6c_ptr->u.ic.S_Cmd_Indx"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6c_ptr->u.ic.S_Info[3]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x01",
            "&dp6c_ptr->u.ic.S_Info[2]"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6c_ptr->u.ic.S_Info[1]"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6c_ptr->u.ic.S_Info[0]"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Illegal protocol version\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6c_ptr->u.ic.Status"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readl",
          "args": [
            "&dp6c_ptr->u.ic.S_Info[0]"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Initialization error (DEINIT failed)\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readb",
          "args": [
            "&dp6c_ptr->u.ic.S_Status"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "20"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR2USHORT",
          "args": [
            "&ha->plx->ldoor_reg"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xff",
            "&dp6c_ptr->u.ic.S_Cmd_Indx"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "pcistr->dpmem",
            "&dp6c_ptr->u.ic.S_Info[0]"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0x00",
            "&dp6c_ptr->u.ic.Cmd_Index"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0x00",
            "&dp6c_ptr->u.ic.S_Status"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR2USHORT",
          "args": [
            "&ha->plx->edoor_reg"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR2USHORT",
          "args": [
            "&ha->plx->control1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "0",
            "htole32(0)",
            "GDT_DPR_IF_SZ >> 2"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xff",
            "&dp6_ptr->io.irqdel"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6_ptr->u.ic.S_Status"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "1"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Initialization error\\n\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readb",
          "args": [
            "&dp6_ptr->u.ic.S_Status"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "20"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6_ptr->io.event"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xfe",
            "&dp6_ptr->u.ic.S_Cmd_Indx"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6_ptr->u.ic.S_Info[3]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x01",
            "&dp6_ptr->u.ic.S_Info[2]"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6_ptr->u.ic.S_Info[1]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "0x00",
            "&dp6_ptr->u.ic.S_Info[0]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Illegal protocol version\\n\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xff",
            "&dp6_ptr->io.irqdel"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6_ptr->u.ic.S_Status"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readl",
          "args": [
            "&dp6_ptr->u.ic.S_Info[0]"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "1"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_munmap",
          "args": [
            "ha->brd"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"GDT-PCI: Initialization error (DEINIT failed)\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_readb",
          "args": [
            "&dp6_ptr->u.ic.S_Status"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_delay",
          "args": [
            "20"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0",
            "&dp6_ptr->io.event"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xff",
            "&dp6_ptr->u.ic.S_Cmd_Indx"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writel",
          "args": [
            "pcistr->dpmem",
            "&dp6_ptr->u.ic.S_Info[0]"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0x00",
            "&dp6_ptr->u.ic.Cmd_Index"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0x00",
            "&dp6_ptr->u.ic.S_Status"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0x00",
            "&dp6_ptr->io.irqen"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdth_writeb",
          "args": [
            "0xff",
            "&dp6_ptr->io.irqdel"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "dpmemt",
            "dpmemh",
            "0"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_4",
          "args": [
            "dpmemt",
            "dpmemh",
            "0",
            "htole32(0)",
            "GDT_DPR_IF_SZ >> 2"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_CLASS",
          "args": [
            "gdt"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "GDT_PCINEW_IO",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&iot",
            "&ioh",
            "&iobase",
            "&iosize"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GDT_CLASS",
          "args": [
            "gdt"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GDT_CLASS",
          "args": [
            "gdt"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_ESTABLISHED\t8\n#define IO_MAPPED\t\t4\n#define IOMEM_MAPPED\t\t2\n#define DPMEM_MAPPED\t\t1\n#define GDT_MPR_SZ\t0x4000\n#define GDT_MPR_IC\tGDT_I960_SZ\n#define GDT_I960_SZ\t0x1000\n#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n#define GDT_MPR_LDOOR\t0x20\t/* u_int8_t, PCI to local doorbell */\n#define GDT_PCINEW_SZ\t0x4000\n#define GDT_DPRAM_SZ\t0x1000\n#define GDT_PCINEW_DPMEM\t0x18\n#define GDT_PCINEW_IO\t\t0x14\n#define GDT_PCINEW_IOMEM\t0x10\n#define GDT_PCI_DPMEM\t\t0x10\n#define GDT_PCI_PRODUCT_FC\t0x200\n\nvoid\tgdt_pci_attach;\nvoid\tgdt_pci_enable_intr;\nvoid\tgdt_pci_copy_cmd;\nu_int8_t gdt_pci_get_status;\nvoid\tgdt_pci_intr;\nvoid\tgdt_pci_release_event;\nvoid\tgdt_pci_set_sema0;\nint\tgdt_pci_test_busy;\nvoid\tgdt_pcinew_copy_cmd;\nu_int8_t gdt_pcinew_get_status;\nvoid\tgdt_pcinew_intr;\nvoid\tgdt_pcinew_release_event;\nvoid\tgdt_pcinew_set_sema0;\nint\tgdt_pcinew_test_busy;\nvoid\tgdt_mpr_copy_cmd;\nu_int8_t gdt_mpr_get_status;\nvoid\tgdt_mpr_intr;\nvoid\tgdt_mpr_release_event;\nvoid\tgdt_mpr_set_sema0;\nint\tgdt_mpr_test_busy;\n\nvoid    \ngdt_pci_attach(parent, self, aux)\n        struct device *parent, *self;\n        void *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tstruct gdt_softc *gdt = (void *)self;\n\tbus_space_tag_t dpmemt, iomemt, iot;\n\tbus_space_handle_t dpmemh, iomemh, ioh;\n\tbus_addr_t dpmembase, iomembase, iobase;\n\tbus_size_t dpmemsize, iomemsize, iosize;\n\tu_int16_t prod;\n\tu_int32_t status = 0;\n#define DPMEM_MAPPED\t\t1\n#define IOMEM_MAPPED\t\t2\n#define IO_MAPPED\t\t4\n#define INTR_ESTABLISHED\t8\n\tint retries;\n\tu_int8_t protocol;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\n\tprintf(\": \");\n\n\tprod = PCI_PRODUCT(pa->pa_id);\n\tswitch (prod) {\n\tcase PCI_PRODUCT_VORTEX_GDT_60x0:\n\tcase PCI_PRODUCT_VORTEX_GDT_6000B:\n\t\tgdt->sc_class = GDT_PCI;\n\t\tbreak;\n\n\tcase PCI_PRODUCT_VORTEX_GDT_6x10:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x20:\n\tcase PCI_PRODUCT_VORTEX_GDT_6530:\n\tcase PCI_PRODUCT_VORTEX_GDT_6550:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x15:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x25:\n\tcase PCI_PRODUCT_VORTEX_GDT_6535:\n\tcase PCI_PRODUCT_VORTEX_GDT_6555:\n\t\tgdt->sc_class = GDT_PCINEW;\n\t\tbreak;\n\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x11RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x21RP:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x17RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x27RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6537RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6557RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x11RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x21RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x18RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x28RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x38RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x58RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x18RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x28RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x38RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x58RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x19RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_6x29RD:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x19RN:\n\tcase PCI_PRODUCT_VORTEX_GDT_7x29RN:\n\t\tgdt->sc_class = GDT_MPR;\n\t}\n\tif (prod >= GDT_PCI_PRODUCT_FC)\n\t\tgdt->sc_class |= GDT_FC;\n\n\tif (pci_mapreg_map(pa,\n\t    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM : GDT_PCI_DPMEM,\n\t    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0, &dpmemt,\n\t    &dpmemh, &dpmembase, &dpmemsize)) {\n\t\tprintf(\"cannot map DPMEM\\n\");\n\t\tgoto bail_out;\n\t}\n\tstatus |= DPMEM_MAPPED;\n\tgdt->sc_dpmemt = dpmemt;\n\tgdt->sc_dpmemh = dpmemh;\n\tgdt->sc_dpmembase = dpmembase;\n\tgdt->sc_dmat = pa->pa_dmat;\n\n\t/*\n\t * The GDT_PCINEW series also has two other regions to map.\n\t */\n\tif (GDT_CLASS(gdt) == GDT_PCINEW) {\n\t\tif (pci_mapreg_map(pa, GDT_PCINEW_IOMEM, PCI_MAPREG_TYPE_MEM,\n\t\t    0, &iomemt, &iomemh, &iomembase, &iomemsize)) {\n\t\t\tprintf(\"cannot map memory mapped I/O ports\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\t\tstatus |= IOMEM_MAPPED;\n\n\t\tif (pci_mapreg_map(pa, GDT_PCINEW_IO, PCI_MAPREG_TYPE_IO, 0,\n\t\t    &iot, &ioh, &iobase, &iosize)) {\n\t\t\tprintf(\"cannot map I/O ports\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\t\tstatus |= IO_MAPPED;\n\t\tgdt->sc_iot = iot;\n\t\tgdt->sc_ioh = ioh;\n\t\tgdt->sc_iobase = iobase;\n\t}\n\n\tswitch (GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\t\tif (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {\n\t\t\tprintf(\"cannot write to DPMEM\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\n#if 0\n\t\t/* disable board interrupts, deinit services */\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n\t\tgdth_writeb(0x00, &dp6_ptr->io.irqen);;\n\t\tgdth_writeb(0x00, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0x00, &dp6_ptr->u.ic.Cmd_Index);\n\n\t\tgdth_writel(pcistr->dpmem, &dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0xff, &dp6_ptr->u.ic.S_Cmd_Indx);\n\t\tgdth_writeb(0, &dp6_ptr->io.event);\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xff) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error (DEINIT failed)\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tprot_ver = (unchar)gdth_readl(&dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n\t\tif (prot_ver != PROTOCOL_VERSION) {\n\t\t  printk(\"GDT-PCI: Illegal protocol version\\n\");\n\t\t  gdth_munmap(ha->brd);\n\t\t  return 0;\n\t\t}\n\n\t\tha->type = GDT_PCI;\n\t\tha->ic_all_size = sizeof(dp6_ptr->u);\n        \n\t\t/* special command to controller BIOS */\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[0]);\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[1]);\n\t\tgdth_writel(0x01, &dp6_ptr->u.ic.S_Info[2]);\n\t\tgdth_writel(0x00, &dp6_ptr->u.ic.S_Info[3]);\n\t\tgdth_writeb(0xfe, &dp6_ptr->u.ic.S_Cmd_Indx);\n\t\tgdth_writeb(0, &dp6_ptr->io.event);\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xfe) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tgdth_writeb(0, &dp6_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0xff, &dp6_ptr->io.irqdel);\n#endif\n\n\t\tgdt->sc_ic_all_size = GDT_DPRAM_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_pci_copy_cmd;\n\t\tgdt->sc_get_status = gdt_pci_get_status;\n\t\tgdt->sc_intr = gdt_pci_intr;\n\t\tgdt->sc_release_event = gdt_pci_release_event;\n\t\tgdt->sc_set_sema0 = gdt_pci_set_sema0;\n\t\tgdt->sc_test_busy = gdt_pci_test_busy;\n\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\t\tif (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {\n\t\t\tprintf(\"cannot write to DPMEM\\n\");\n\t\t\tgoto bail_out;\n\t\t}\n\n#if 0\n\t\t/* disable board interrupts, deinit services */\n\t\toutb(0x00,PTR2USHORT(&ha->plx->control1));\n\t\toutb(0xff,PTR2USHORT(&ha->plx->edoor_reg));\n        \n\t\tgdth_writeb(0x00, &dp6c_ptr->u.ic.S_Status);\n\t\tgdth_writeb(0x00, &dp6c_ptr->u.ic.Cmd_Index);\n\n\t\tgdth_writel(pcistr->dpmem, &dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0xff, &dp6c_ptr->u.ic.S_Cmd_Indx);\n\n\t\toutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\n\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xff) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error (DEINIT failed)\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tprot_ver = (unchar)gdth_readl(&dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writeb(0, &dp6c_ptr->u.ic.Status);\n\t\tif (prot_ver != PROTOCOL_VERSION) {\n\t\t  printk(\"GDT-PCI: Illegal protocol version\\n\");\n\t\t  gdth_munmap(ha->brd);\n\t\t  return 0;\n\t\t}\n\n\t\tha->type = GDT_PCINEW;\n\t\tha->ic_all_size = sizeof(dp6c_ptr->u);\n\n\t\t/* special command to controller BIOS */\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[0]);\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[1]);\n\t\tgdth_writel(0x01, &dp6c_ptr->u.ic.S_Info[2]);\n\t\tgdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[3]);\n\t\tgdth_writeb(0xfe, &dp6c_ptr->u.ic.S_Cmd_Indx);\n        \n\t\toutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\n\n\t\tretries = INIT_RETRIES;\n\t\tgdth_delay(20);\n\t\twhile (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xfe) {\n\t\t  if (--retries == 0) {\n\t\t    printk(\"GDT-PCI: Initialization error\\n\");\n\t\t    gdth_munmap(ha->brd);\n\t\t    return 0;\n\t\t  }\n\t\t  gdth_delay(1);\n\t\t}\n\t\tgdth_writeb(0, &dp6c_ptr->u.ic.S_Status);\n#endif\n\n\t\tgdt->sc_ic_all_size = GDT_PCINEW_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_pcinew_copy_cmd;\n\t\tgdt->sc_get_status = gdt_pcinew_get_status;\n\t\tgdt->sc_intr = gdt_pcinew_intr;\n\t\tgdt->sc_release_event = gdt_pcinew_release_event;\n\t\tgdt->sc_set_sema0 = gdt_pcinew_set_sema0;\n\t\tgdt->sc_test_busy = gdt_pcinew_test_busy;\n\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC,\n\t\t    htole32(GDT_MPR_MAGIC));\n\t\tif (bus_space_read_4(dpmemt, dpmemh, GDT_MPR_IC) !=\n\t\t    htole32(GDT_MPR_MAGIC)) {\n\t\t\tprintf(\"cannot access DPMEM at 0x%x (shadowed?)\\n\",\n\t\t\t    dpmembase);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t/*\n\t\t * XXX Here the Linux driver has a weird remapping logic I\n\t\t * don't understand.  My controller does not need it, and I\n\t\t * cannot see what purpose it serves, therefore I did not\n\t\t * do anything similar.\n\t\t */\n\n\t\tbus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, htole32(0),\n\t\t    GDT_DPR_IF_SZ >> 2);\n\n\t\t/* Disable everything */\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(dpmemt, dpmemh, GDT_EDOOR_EN) | 4);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_CMD_INDEX,\n\t\t    0);\n\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,\n\t\t    htole32(dpmembase));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,\n\t\t    0xff);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);\n\n\t\tDELAY(20);\n\t\tretries = GDT_RETRIES;\n\t\twhile (bus_space_read_1(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_STATUS) != 0xff) {\n\t\t\tif (--retries == 0) {\n\t\t\t\tprintf(\"DEINIT failed\\n\");\n\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\t\tDELAY(1);\n\t\t}\n\n\t\tprotocol = (u_int8_t)letoh32(bus_space_read_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\t\tif (protocol != GDT_PROTOCOL_VERSION) {\n\t\t \tprintf(\"unsupported protocol %d\\n\", protocol);\n\t\t\tgoto bail_out;\n\t\t}\n\n\t\t/* special commnd to controller BIOS */\n\t\tbus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,\n\t\t    htole32(0));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), htole32(0));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t),\n\t\t    htole32(1));\n\t\tbus_space_write_4(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t),\n\t\t    htole32(0));\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,\n\t\t    0xfe);\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);\n\n\t\tDELAY(20);\n\t\tretries = GDT_RETRIES;\n\t\twhile (bus_space_read_1(dpmemt, dpmemh,\n\t\t    GDT_MPR_IC + GDT_S_STATUS) != 0xfe) {\n\t\t\tif (--retries == 0) {\n\t\t\t\tprintf(\"initialization error\\n\");\n\t\t\t\tgoto bail_out;\n\t\t\t}\n\t\t\tDELAY(1);\n\t\t}\n\n\t\tbus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,\n\t\t    0);\n\n\t\tgdt->sc_ic_all_size = GDT_MPR_SZ;\n\n\t\tgdt->sc_copy_cmd = gdt_mpr_copy_cmd;\n\t\tgdt->sc_get_status = gdt_mpr_get_status;\n\t\tgdt->sc_intr = gdt_mpr_intr;\n\t\tgdt->sc_release_event = gdt_mpr_release_event;\n\t\tgdt->sc_set_sema0 = gdt_mpr_set_sema0;\n\t\tgdt->sc_test_busy = gdt_mpr_test_busy;\n\t}\n\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"couldn't map interrupt\\n\");\n\t\tgoto bail_out;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tgdt->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, gdt_intr, gdt,\n\t    gdt->sc_dev.dv_xname);\n\tif (gdt->sc_ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto bail_out;\n\t}\n\tstatus |= INTR_ESTABLISHED;\n\tif (intrstr != NULL)\n\t\tprintf(\"%s \", intrstr);\n\n\tif (gdt_attach(gdt))\n\t\tgoto bail_out;\n\n\tgdt_pci_enable_intr(gdt);\n\n\treturn;\n\n bail_out:\n\tif (status & DPMEM_MAPPED)\n\t\tbus_space_unmap(dpmemt, dpmemh, dpmemsize);\n\tif (status & IOMEM_MAPPED)\n\t\tbus_space_unmap(iomemt, iomemh, iomembase);\n\tif (status & IO_MAPPED)\n\t\tbus_space_unmap(iot, ioh, iosize);\n\tif (status & INTR_ESTABLISHED)\n\t\tpci_intr_disestablish(pa->pa_pc, gdt->sc_ih);\n\treturn;\n}"
  },
  {
    "function_name": "gdt_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
    "lines": "151-201",
    "snippet": "int\ngdt_pci_probe(parent, match, aux)\n        struct device *parent;\n        void *match, *aux; \n{       \n        struct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX)\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_VORTEX_GDT_60x0:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6000B:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x10:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x20:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6530:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6550:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x15:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x25:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6535:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6555:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x11RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x21RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x11RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x21RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x18RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x28RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x38RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x58RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x18RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x28RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x38RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x58RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x19RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x29RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x19RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x29RN:\n\t\t\treturn (1);\n\t\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/gdtvar.h>",
      "#include <dev/ic/gdtreg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/intr.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgdt_pci_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgdt_pci_probe;\n\nint\ngdt_pci_probe(parent, match, aux)\n        struct device *parent;\n        void *match, *aux; \n{       \n        struct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX)\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_VORTEX_GDT_60x0:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6000B:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x10:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x20:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6530:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6550:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x15:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x25:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6535:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6555:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x11RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x21RP:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x17RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x27RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6537RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6557RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x11RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x21RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x18RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x28RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x38RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x58RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x18RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x28RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x38RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x58RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x19RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_6x29RD:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x19RN:\n\t\tcase PCI_PRODUCT_VORTEX_GDT_7x29RN:\n\t\t\treturn (1);\n\t\t}\n\treturn (0);\n}"
  }
]