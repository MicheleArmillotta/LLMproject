[
  {
    "function_name": "eeprom_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "947-983",
    "snippet": "static u_short \neeprom_read(sc, location)\n\tstruct ex_softc *sc;\n\tint location;\n{\n\tint i;\n\tu_short data = 0;\n\tint read_cmd = location | EE_READ_CMD;\n\tshort ctrl_val = EECS;\n\n\tBANK_SEL(Bank2_Sel);\n\tISA_PUT(EEPROM_REG, EECS);\n\tfor (i = 8; i >= 0; i--) {\n\t\tshort outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : \n\t\t    ctrl_val;\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tISA_PUT(EEPROM_REG, outval | EESK);\n\t\tdelay(3);\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tdelay(2);\n\t}\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tfor (i = 16; i > 0; i--) {\n\t\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\t\tdelay(3);\n\t\tdata = (data << 1) | ((ISA_GET(EEPROM_REG) & EEDO) ? 1 : 0);\n\t\tISA_PUT(EEPROM_REG, ctrl_val);\n\t\tdelay(2);\n\t}\n\tctrl_val &= ~EECS;\n\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\tdelay(3);\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tdelay(2);\n\tBANK_SEL(Bank0_Sel);\n\treturn(data);\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank0_Sel"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "ctrl_val"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "ctrl_val | EESK"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "ctrl_val"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "EEPROM_REG"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "ctrl_val | EESK"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "ctrl_val"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "outval"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "outval | EESK"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "outval"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "EECS"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank2_Sel"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\nstatic u_short \neeprom_read(sc, location)\n\tstruct ex_softc *sc;\n\tint location;\n{\n\tint i;\n\tu_short data = 0;\n\tint read_cmd = location | EE_READ_CMD;\n\tshort ctrl_val = EECS;\n\n\tBANK_SEL(Bank2_Sel);\n\tISA_PUT(EEPROM_REG, EECS);\n\tfor (i = 8; i >= 0; i--) {\n\t\tshort outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : \n\t\t    ctrl_val;\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tISA_PUT(EEPROM_REG, outval | EESK);\n\t\tdelay(3);\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tdelay(2);\n\t}\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tfor (i = 16; i > 0; i--) {\n\t\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\t\tdelay(3);\n\t\tdata = (data << 1) | ((ISA_GET(EEPROM_REG) & EEDO) ? 1 : 0);\n\t\tISA_PUT(EEPROM_REG, ctrl_val);\n\t\tdelay(2);\n\t}\n\tctrl_val &= ~EECS;\n\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\tdelay(3);\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tdelay(2);\n\tBANK_SEL(Bank0_Sel);\n\treturn(data);\n}"
  },
  {
    "function_name": "ex_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "929-944",
    "snippet": "void \nex_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ex_softc *sc = ifp->if_softc;\n\n\tDODEBUG(Start_End, printf(\"ex_watchdog: start\\n\"););\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE watchdog\\n\"););\n\tifp->if_oerrors++;\n\tex_reset(sc);\n\tex_start(ifp);\n\n\tDODEBUG(Start_End, printf(\"ex_watchdog: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Status    8",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_watchdog: finish\\n\");"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_watchdog: finish\\n\""
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_start",
          "args": [
            "ifp"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ex_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "418-572",
          "snippet": "void \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Sent_Pkts 4",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Sent_Pkts 4\n#define Start_End 1\n\nvoid \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_reset",
          "args": [
            "sc"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ex_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "912-926",
          "snippet": "void \nex_reset(sc)\n\tstruct ex_softc *sc;\n{\n\tint s;\n\n\tDODEBUG(Start_End, printf(\"ex_reset: start\\n\"););\n  \n\ts = splimp();\n\tex_stop(sc);\n\tex_init(sc);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_reset: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nvoid \nex_reset(sc)\n\tstruct ex_softc *sc;\n{\n\tint s;\n\n\tDODEBUG(Start_End, printf(\"ex_reset: start\\n\"););\n  \n\ts = splimp();\n\tex_stop(sc);\n\tex_init(sc);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_reset: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Status",
            "printf(\"OIDLE watchdog\\n\");"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_watchdog: start\\n\");"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ex_softc *sc = ifp->if_softc;\n\n\tDODEBUG(Start_End, printf(\"ex_watchdog: start\\n\"););\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE watchdog\\n\"););\n\tifp->if_oerrors++;\n\tex_reset(sc);\n\tex_start(ifp);\n\n\tDODEBUG(Start_End, printf(\"ex_watchdog: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "912-926",
    "snippet": "void \nex_reset(sc)\n\tstruct ex_softc *sc;\n{\n\tint s;\n\n\tDODEBUG(Start_End, printf(\"ex_reset: start\\n\"););\n  \n\ts = splimp();\n\tex_stop(sc);\n\tex_init(sc);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_reset: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_reset: finish\\n\");"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_reset: finish\\n\""
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_init",
          "args": [
            "sc"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "328-415",
          "snippet": "void \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_stop",
          "args": [
            "sc"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ex_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "575-602",
          "snippet": "void \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nvoid \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_reset: start\\n\");"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nvoid \nex_reset(sc)\n\tstruct ex_softc *sc;\n{\n\tint s;\n\n\tDODEBUG(Start_End, printf(\"ex_reset: start\\n\"););\n  \n\ts = splimp();\n\tex_stop(sc);\n\tex_init(sc);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_reset: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "789-909",
    "snippet": "int \nex_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tregister struct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct ex_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\tDODEBUG(Start_End, printf(\"ex_ioctl: start \"););\n\n\ts = splimp();\n\n\tswitch(cmd) {\n\t\tcase SIOCSIFADDR:\n\t\t\tDODEBUG(Start_End, printf(\"SIOCSIFADDR\"););\n\t\t\tifp->if_flags |= IFF_UP;\n    \n\t\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t\tex_init(sc);\n\t\t\t\t\tarp_ifinit((struct arpcom *) ifp, ifa);\n\t\t\t\t\tbreak;\n#endif\n#ifdef IPX_NOTYET\n\t\t\t\tcase AF_IPX:\n\t\t\t\t{\n\t\t\t\t\tregister struct ipx_addr *ina = \n\t\t\t\t\t    &(IA_SIPX(ifa)->sipx_addr);\n\n\t\t\t\t\tif (ipx_nullhost(*ina))\n\t\t\t\t\tina->x_host = *(union ipx_host *) \n\t\t\t\t\t    (sc->arpcom.ac_enaddr);\n\t\t\t\t\telse {\n\t  \t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t  \t\t\t\t\tbcopy((caddr_t) \n\t\t\t\t\t\t    ina->x_host.c_host,\n\t\t\t\t\t\t    (caddr_t) \n\t\t\t\t\t\t    sc->arpcom.ac_enaddr, \n\t\t\t\t\t\t    sizeof(sc->arpcom.ac_enaddr)\n\t\t\t\t\t\t    );\n\t\t\t\t\t}\n\t\t\t\t\tex_init(sc);\n\t\t\t\t\tbreak;\n     \t\t\t\t}\n#endif\n#ifdef NS\n\t\t\t\tcase AF_NS:\n      \t\t\t\t{\n\tregister struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\n\tif (ns_nullhost(*ina))\n\t  ina->x_host = *(union ns_host *) (sc->arpcom.ac_enaddr);\n\telse {\n\t  ifp->if_flags &= ~IFF_RUNNING;\n\t  bcopy((caddr_t) ina->x_host.c_host, (caddr_t) sc->arpcom.ac_enaddr, \n\t\tsizeof(sc->arpcom.ac_enaddr));\n\t}\n\tex_init(sc);\n\tbreak;\n      }\n#endif\n    default:\n      ex_init(sc);\n      break;\n    }\n    break;\n  case SIOCGIFADDR:\n    {\n      struct sockaddr *sa;\n\n      DODEBUG(Start_End, printf(\"SIOCGIFADDR\"););\n      sa = (struct sockaddr *) &ifr->ifr_data;\n      bcopy((caddr_t) sc->arpcom.ac_enaddr, (caddr_t) sa->sa_data, \n\t    ETHER_ADDR_LEN);\n    }\n  break;\n  case SIOCSIFFLAGS:\n    DODEBUG(Start_End, printf(\"SIOCSIFFLAGS\"););\n    if ((ifp->if_flags & IFF_UP) == 0 && ifp->if_flags & IFF_RUNNING) {\n      ifp->if_flags &= ~IFF_RUNNING;\n      ex_stop(sc);\n    }\n    else\n      ex_init(sc);\n    break;\n#ifdef NODEF\n  case SIOCGHWADDR:\n    DODEBUG(Start_End, printf(\"SIOCGHWADDR\"););\n    bcopy((caddr_t) sc->sc_addr, (caddr_t) &ifr->ifr_data, sizeof(sc->sc_addr));\n    break;\n#endif\n#if 0\t\t\t\t\t\t/* XXX can we do this? */\n  case SIOCSIFMTU:\n    DODEBUG(Start_End, printf(\"SIOCSIFMTU\"););\n    if (ifr->if_mtu > ETHERMTU)\n      error = EINVAL;\n    else\n      ifp->if_mtu = ifr->ifr_mtu;\n    break;\n#endif \n  case SIOCADDMULTI:\n    DODEBUG(Start_End, printf(\"SIOCADDMULTI\"););\n  case SIOCDELMULTI:\n    DODEBUG(Start_End, printf(\"SIOCDELMULTI\"););\n    /* XXX Support not done yet. */\n    error = EINVAL;\n    break;\n  default:\n    DODEBUG(Start_End, printf(\"unknown\"););\n    error = EINVAL;\n  }\n\n  splx(s);\n\n  DODEBUG(Start_End, printf(\"\\nex_ioctl: finish\\n\"););\n  return(error);\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"\\nex_ioctl: finish\\n\");"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nex_ioctl: finish\\n\""
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"unknown\");"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCDELMULTI\");"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCADDMULTI\");"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCSIFMTU\");"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) sc->sc_addr",
            "(caddr_t) &ifr->ifr_data",
            "sizeof(sc->sc_addr)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCGHWADDR\");"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_init",
          "args": [
            "sc"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "328-415",
          "snippet": "void \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_stop",
          "args": [
            "sc"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "ex_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "575-602",
          "snippet": "void \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nvoid \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCSIFFLAGS\");"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCGIFADDR\");"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipx_nullhost",
          "args": [
            "*ina"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SIPX",
          "args": [
            "ifa"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "(struct arpcom *) ifp",
            "ifa"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"SIOCSIFADDR\");"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_ioctl: start \");"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nint \nex_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tregister struct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct ex_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\tDODEBUG(Start_End, printf(\"ex_ioctl: start \"););\n\n\ts = splimp();\n\n\tswitch(cmd) {\n\t\tcase SIOCSIFADDR:\n\t\t\tDODEBUG(Start_End, printf(\"SIOCSIFADDR\"););\n\t\t\tifp->if_flags |= IFF_UP;\n    \n\t\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t\tex_init(sc);\n\t\t\t\t\tarp_ifinit((struct arpcom *) ifp, ifa);\n\t\t\t\t\tbreak;\n#endif\n#ifdef IPX_NOTYET\n\t\t\t\tcase AF_IPX:\n\t\t\t\t{\n\t\t\t\t\tregister struct ipx_addr *ina = \n\t\t\t\t\t    &(IA_SIPX(ifa)->sipx_addr);\n\n\t\t\t\t\tif (ipx_nullhost(*ina))\n\t\t\t\t\tina->x_host = *(union ipx_host *) \n\t\t\t\t\t    (sc->arpcom.ac_enaddr);\n\t\t\t\t\telse {\n\t  \t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t  \t\t\t\t\tbcopy((caddr_t) \n\t\t\t\t\t\t    ina->x_host.c_host,\n\t\t\t\t\t\t    (caddr_t) \n\t\t\t\t\t\t    sc->arpcom.ac_enaddr, \n\t\t\t\t\t\t    sizeof(sc->arpcom.ac_enaddr)\n\t\t\t\t\t\t    );\n\t\t\t\t\t}\n\t\t\t\t\tex_init(sc);\n\t\t\t\t\tbreak;\n     \t\t\t\t}\n#endif\n#ifdef NS\n\t\t\t\tcase AF_NS:\n      \t\t\t\t{\n\tregister struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\n\tif (ns_nullhost(*ina))\n\t  ina->x_host = *(union ns_host *) (sc->arpcom.ac_enaddr);\n\telse {\n\t  ifp->if_flags &= ~IFF_RUNNING;\n\t  bcopy((caddr_t) ina->x_host.c_host, (caddr_t) sc->arpcom.ac_enaddr, \n\t\tsizeof(sc->arpcom.ac_enaddr));\n\t}\n\tex_init(sc);\n\tbreak;\n      }\n#endif\n    default:\n      ex_init(sc);\n      break;\n    }\n    break;\n  case SIOCGIFADDR:\n    {\n      struct sockaddr *sa;\n\n      DODEBUG(Start_End, printf(\"SIOCGIFADDR\"););\n      sa = (struct sockaddr *) &ifr->ifr_data;\n      bcopy((caddr_t) sc->arpcom.ac_enaddr, (caddr_t) sa->sa_data, \n\t    ETHER_ADDR_LEN);\n    }\n  break;\n  case SIOCSIFFLAGS:\n    DODEBUG(Start_End, printf(\"SIOCSIFFLAGS\"););\n    if ((ifp->if_flags & IFF_UP) == 0 && ifp->if_flags & IFF_RUNNING) {\n      ifp->if_flags &= ~IFF_RUNNING;\n      ex_stop(sc);\n    }\n    else\n      ex_init(sc);\n    break;\n#ifdef NODEF\n  case SIOCGHWADDR:\n    DODEBUG(Start_End, printf(\"SIOCGHWADDR\"););\n    bcopy((caddr_t) sc->sc_addr, (caddr_t) &ifr->ifr_data, sizeof(sc->sc_addr));\n    break;\n#endif\n#if 0\t\t\t\t\t\t/* XXX can we do this? */\n  case SIOCSIFMTU:\n    DODEBUG(Start_End, printf(\"SIOCSIFMTU\"););\n    if (ifr->if_mtu > ETHERMTU)\n      error = EINVAL;\n    else\n      ifp->if_mtu = ifr->ifr_mtu;\n    break;\n#endif \n  case SIOCADDMULTI:\n    DODEBUG(Start_End, printf(\"SIOCADDMULTI\"););\n  case SIOCDELMULTI:\n    DODEBUG(Start_End, printf(\"SIOCDELMULTI\"););\n    /* XXX Support not done yet. */\n    error = EINVAL;\n    break;\n  default:\n    DODEBUG(Start_End, printf(\"unknown\"););\n    error = EINVAL;\n  }\n\n  splx(s);\n\n  DODEBUG(Start_End, printf(\"\\nex_ioctl: finish\\n\"););\n  return(error);\n}"
  },
  {
    "function_name": "ex_rx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "689-786",
    "snippet": "void \nex_rx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rx_status, pkt_len, QQQ;\n\tregister struct mbuf *m, *ipkt;\n\tstruct ether_header *eh;\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: start\\n\"););\n\t/*\n\t * For all packets received since last receive interrupt:\n\t * - If packet ok, read it into a new mbuf and queue it to interface,\n\t *   updating statistics.\n\t * - If packet bad, just discard it, and update statistics.\n\t * Finally, advance receive stop limit in card's memory to new location.\n\t */\n\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\twhile (ISA_GET_2(IO_PORT_REG) == RCV_Done) {\n\t\trx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->rx_head = ISA_GET_2(IO_PORT_REG);\n\t\tQQQ = pkt_len = ISA_GET_2(IO_PORT_REG);\n\t\tif (rx_status & RCV_OK_bit) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tipkt = m;\n\t\t\tif (ipkt == NULL)\n\t\t\t\tifp->if_iqdrops++;\n\t\t\telse {\n\t\t\t\tipkt->m_pkthdr.rcvif = ifp;\n\t\t\t\tipkt->m_pkthdr.len = pkt_len;\n\t\t\t\tipkt->m_len = MHLEN;\n\t\t\t\twhile (pkt_len > 0) {\n\t\t\t\t\tif (pkt_len > MINCLSIZE) {\n\t\t\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\t\t\tm->m_len = MCLBYTES;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm->m_len = min(m->m_len, pkt_len);\n\t\t\t\t\t/*\n\t\t\t\t\t * NOTE: I'm assuming that all mbufs \n\t\t\t\t\t * allocated are of even length, except\n\t\t\t\t\t * for the last one in an odd-length \n\t\t\t\t\t * packet.\n\t\t\t\t\t */\n\t\t\t\t\tISA_GET_2_MULTI(IO_PORT_REG,\n\t\t\t\t\t    mtod(m, caddr_t), m->m_len / 2);\n\t\t\t\t\tif (m->m_len & 1)\n\t\t\t\t\t\t*(mtod(m, caddr_t) + \n\t\t\t\t\t\t    m->m_len - 1) = \n\t\t\t\t\t\t    ISA_GET(IO_PORT_REG);\n\t\t\t\t\tpkt_len -= m->m_len;\n\t\t\t\t\tif (pkt_len > 0) {\n\t\t\t\t\t\tMGET(m->m_next, M_DONTWAIT, \n\t\t\t\t\t\t    MT_DATA);\n\t\t\t\t\tif (m->m_next == NULL) {\n\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t}\n\t\t\t\t\tm = m->m_next;\n\t\t\t\t\tm->m_len = MLEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\teh = mtod(ipkt, struct ether_header *);\n#ifdef EXDEBUG\n\t\t\tif (debug_mask & Rcvd_Pkts) {\n\t\t\t\tif ((eh->ether_dhost[5] != 0xff) || \n\t\t\t\t    (eh->ether_dhost[0] != 0xff)) {\n\t\t\t\t\tprintf(\"Receive packet with %d data bytes: %6D -> \", QQQ, eh->ether_shost, \":\");\n\t\t\t\t\tprintf(\"%6D\\n\", eh->ether_dhost, \":\");\n\t\t\t\t} /* QQQ */\n\t\t\t}\n#endif\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, ipkt);\n#endif\n\t\t\tm_adj(ipkt, sizeof(struct ether_header));\n\t\t\tether_input(ifp, eh, ipkt);\n\t\t\tifp->if_ipackets++;\n      \t\t}\n    \t} else\n      \t\tifp->if_ierrors++;\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\t\trx_another: ;\n  \t}\n\tif (sc->rx_head < sc->rx_lower_limit + 2)\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit);\n\telse\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_head - 2);\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Rcvd_Pkts 2",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_rx_intr: finish\\n\");"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_rx_intr: finish\\n\""
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "RCV_STOP_REG",
            "sc->rx_head - 2"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "RCV_STOP_REG",
            "sc->rx_upper_limit"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->rx_head"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "ipkt"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "ipkt",
            "sizeof(struct ether_header)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "ipkt"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "ipkt",
            "structether_header*"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "ipkt"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m->m_next",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2_MULTI",
          "args": [
            "IO_PORT_REG",
            "mtod(m, caddr_t)",
            "m->m_len / 2"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "m->m_len",
            "pkt_len"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "ipkt"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->rx_head"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_rx_intr: start\\n\");"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Rcvd_Pkts 2\n#define Start_End 1\n\nvoid \nex_rx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rx_status, pkt_len, QQQ;\n\tregister struct mbuf *m, *ipkt;\n\tstruct ether_header *eh;\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: start\\n\"););\n\t/*\n\t * For all packets received since last receive interrupt:\n\t * - If packet ok, read it into a new mbuf and queue it to interface,\n\t *   updating statistics.\n\t * - If packet bad, just discard it, and update statistics.\n\t * Finally, advance receive stop limit in card's memory to new location.\n\t */\n\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\twhile (ISA_GET_2(IO_PORT_REG) == RCV_Done) {\n\t\trx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->rx_head = ISA_GET_2(IO_PORT_REG);\n\t\tQQQ = pkt_len = ISA_GET_2(IO_PORT_REG);\n\t\tif (rx_status & RCV_OK_bit) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tipkt = m;\n\t\t\tif (ipkt == NULL)\n\t\t\t\tifp->if_iqdrops++;\n\t\t\telse {\n\t\t\t\tipkt->m_pkthdr.rcvif = ifp;\n\t\t\t\tipkt->m_pkthdr.len = pkt_len;\n\t\t\t\tipkt->m_len = MHLEN;\n\t\t\t\twhile (pkt_len > 0) {\n\t\t\t\t\tif (pkt_len > MINCLSIZE) {\n\t\t\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\t\t\tm->m_len = MCLBYTES;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm->m_len = min(m->m_len, pkt_len);\n\t\t\t\t\t/*\n\t\t\t\t\t * NOTE: I'm assuming that all mbufs \n\t\t\t\t\t * allocated are of even length, except\n\t\t\t\t\t * for the last one in an odd-length \n\t\t\t\t\t * packet.\n\t\t\t\t\t */\n\t\t\t\t\tISA_GET_2_MULTI(IO_PORT_REG,\n\t\t\t\t\t    mtod(m, caddr_t), m->m_len / 2);\n\t\t\t\t\tif (m->m_len & 1)\n\t\t\t\t\t\t*(mtod(m, caddr_t) + \n\t\t\t\t\t\t    m->m_len - 1) = \n\t\t\t\t\t\t    ISA_GET(IO_PORT_REG);\n\t\t\t\t\tpkt_len -= m->m_len;\n\t\t\t\t\tif (pkt_len > 0) {\n\t\t\t\t\t\tMGET(m->m_next, M_DONTWAIT, \n\t\t\t\t\t\t    MT_DATA);\n\t\t\t\t\tif (m->m_next == NULL) {\n\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t}\n\t\t\t\t\tm = m->m_next;\n\t\t\t\t\tm->m_len = MLEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\teh = mtod(ipkt, struct ether_header *);\n#ifdef EXDEBUG\n\t\t\tif (debug_mask & Rcvd_Pkts) {\n\t\t\t\tif ((eh->ether_dhost[5] != 0xff) || \n\t\t\t\t    (eh->ether_dhost[0] != 0xff)) {\n\t\t\t\t\tprintf(\"Receive packet with %d data bytes: %6D -> \", QQQ, eh->ether_shost, \":\");\n\t\t\t\t\tprintf(\"%6D\\n\", eh->ether_dhost, \":\");\n\t\t\t\t} /* QQQ */\n\t\t\t}\n#endif\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, ipkt);\n#endif\n\t\t\tm_adj(ipkt, sizeof(struct ether_header));\n\t\t\tether_input(ifp, eh, ipkt);\n\t\t\tifp->if_ipackets++;\n      \t\t}\n    \t} else\n      \t\tifp->if_ierrors++;\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\t\trx_another: ;\n  \t}\n\tif (sc->rx_head < sc->rx_lower_limit + 2)\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit);\n\telse\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_head - 2);\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_tx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "653-686",
    "snippet": "void \nex_tx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint tx_status;\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: start\\n\"););\n\t/*\n\t * - Cancel the watchdog.\n\t * For all packets transmitted since last transmit interrupt:\n\t * - Advance chain pointer to next queued packet.\n\t * - Update statistics.\n\t */\n\tifp->if_timer = 0;\n\twhile (sc->tx_head != sc->tx_tail) {\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_head);\n\t\tif (! ISA_GET_2(IO_PORT_REG) & Done_bit)\n\t\t\tbreak;\n\t\ttx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->tx_head = ISA_GET_2(IO_PORT_REG);\n\t\tif (tx_status & TX_OK_bit)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\t\tifp->if_collisions += tx_status & No_Collisions_bits;\n\t}\n\n\t/* The card should be ready to accept more packets now. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE tx_intr\\n\"););\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Status    8",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_tx_intr: finish\\n\");"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_tx_intr: finish\\n\""
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Status",
            "printf(\"OIDLE tx_intr\\n\");"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->tx_head"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_tx_intr: start\\n\");"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_tx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint tx_status;\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: start\\n\"););\n\t/*\n\t * - Cancel the watchdog.\n\t * For all packets transmitted since last transmit interrupt:\n\t * - Advance chain pointer to next queued packet.\n\t * - Update statistics.\n\t */\n\tifp->if_timer = 0;\n\twhile (sc->tx_head != sc->tx_tail) {\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_head);\n\t\tif (! ISA_GET_2(IO_PORT_REG) & Done_bit)\n\t\t\tbreak;\n\t\ttx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->tx_head = ISA_GET_2(IO_PORT_REG);\n\t\tif (tx_status & TX_OK_bit)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\t\tifp->if_collisions += tx_status & No_Collisions_bits;\n\t}\n\n\t/* The card should be ready to accept more packets now. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE tx_intr\\n\"););\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: finish\\n\"););\n}"
  },
  {
    "function_name": "exintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "605-650",
    "snippet": "int \nexintr(arg)\n\tvoid *arg;\n{\n\tstruct ex_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint int_status, send_pkts;\n\tint handled;\n\n\tDODEBUG(Start_End, printf(\"exintr: start\\n\"););\n\n#ifdef EXDEBUG\n\tif (++exintr_count != 1)\n\t\tprintf(\"WARNING: nested interrupt (%d). Mail the author.\\n\", \n\t \t    exintr_count);\n#endif\n\n\tsend_pkts = 0;\n\twhile ((int_status = ISA_GET(STATUS_REG)) & (Tx_Int | Rx_Int)) {\n\t\tif (int_status & Rx_Int) {\n\t\t\tISA_PUT(STATUS_REG, Rx_Int);\n\t\t\thandled = 1;\n\t\t\tex_rx_intr(sc);\n\t\t} else if (int_status & Tx_Int) {\n\t\t\tISA_PUT(STATUS_REG, Tx_Int);\n\t\t\thandled = 1;\n\t\t\tex_tx_intr(sc);\n\t\t\tsend_pkts = 1;\n  \t\t} else\n\t\t\thandled = 0;\n   \t}\n\n  \t/*\n\t * If any packet has been transmitted, and there are queued packets to\n \t * be sent, attempt to send more packets to the network card.\n\t */\n\n\tif (send_pkts && (ifp->if_snd.ifq_head != NULL))\n\t\tex_start(ifp);\n#ifdef EXDEBUG\n\texintr_count--;\n#endif\n\tDODEBUG(Start_End, printf(\"exintr: finish\\n\"););\n\n\treturn handled;\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"exintr: finish\\n\");"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"exintr: finish\\n\""
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_start",
          "args": [
            "ifp"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ex_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "418-572",
          "snippet": "void \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Sent_Pkts 4",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Sent_Pkts 4\n#define Start_End 1\n\nvoid \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_tx_intr",
          "args": [
            "sc"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ex_tx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "653-686",
          "snippet": "void \nex_tx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint tx_status;\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: start\\n\"););\n\t/*\n\t * - Cancel the watchdog.\n\t * For all packets transmitted since last transmit interrupt:\n\t * - Advance chain pointer to next queued packet.\n\t * - Update statistics.\n\t */\n\tifp->if_timer = 0;\n\twhile (sc->tx_head != sc->tx_tail) {\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_head);\n\t\tif (! ISA_GET_2(IO_PORT_REG) & Done_bit)\n\t\t\tbreak;\n\t\ttx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->tx_head = ISA_GET_2(IO_PORT_REG);\n\t\tif (tx_status & TX_OK_bit)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\t\tifp->if_collisions += tx_status & No_Collisions_bits;\n\t}\n\n\t/* The card should be ready to accept more packets now. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE tx_intr\\n\"););\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_tx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint tx_status;\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: start\\n\"););\n\t/*\n\t * - Cancel the watchdog.\n\t * For all packets transmitted since last transmit interrupt:\n\t * - Advance chain pointer to next queued packet.\n\t * - Update statistics.\n\t */\n\tifp->if_timer = 0;\n\twhile (sc->tx_head != sc->tx_tail) {\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_head);\n\t\tif (! ISA_GET_2(IO_PORT_REG) & Done_bit)\n\t\t\tbreak;\n\t\ttx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->tx_head = ISA_GET_2(IO_PORT_REG);\n\t\tif (tx_status & TX_OK_bit)\n\t\t\tifp->if_opackets++;\n\t\telse\n\t\t\tifp->if_oerrors++;\n\t\tifp->if_collisions += tx_status & No_Collisions_bits;\n\t}\n\n\t/* The card should be ready to accept more packets now. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE tx_intr\\n\"););\n\n\tDODEBUG(Start_End, printf(\"ex_tx_intr: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "STATUS_REG",
            "Tx_Int"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_rx_intr",
          "args": [
            "sc"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ex_rx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "689-786",
          "snippet": "void \nex_rx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rx_status, pkt_len, QQQ;\n\tregister struct mbuf *m, *ipkt;\n\tstruct ether_header *eh;\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: start\\n\"););\n\t/*\n\t * For all packets received since last receive interrupt:\n\t * - If packet ok, read it into a new mbuf and queue it to interface,\n\t *   updating statistics.\n\t * - If packet bad, just discard it, and update statistics.\n\t * Finally, advance receive stop limit in card's memory to new location.\n\t */\n\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\twhile (ISA_GET_2(IO_PORT_REG) == RCV_Done) {\n\t\trx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->rx_head = ISA_GET_2(IO_PORT_REG);\n\t\tQQQ = pkt_len = ISA_GET_2(IO_PORT_REG);\n\t\tif (rx_status & RCV_OK_bit) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tipkt = m;\n\t\t\tif (ipkt == NULL)\n\t\t\t\tifp->if_iqdrops++;\n\t\t\telse {\n\t\t\t\tipkt->m_pkthdr.rcvif = ifp;\n\t\t\t\tipkt->m_pkthdr.len = pkt_len;\n\t\t\t\tipkt->m_len = MHLEN;\n\t\t\t\twhile (pkt_len > 0) {\n\t\t\t\t\tif (pkt_len > MINCLSIZE) {\n\t\t\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\t\t\tm->m_len = MCLBYTES;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm->m_len = min(m->m_len, pkt_len);\n\t\t\t\t\t/*\n\t\t\t\t\t * NOTE: I'm assuming that all mbufs \n\t\t\t\t\t * allocated are of even length, except\n\t\t\t\t\t * for the last one in an odd-length \n\t\t\t\t\t * packet.\n\t\t\t\t\t */\n\t\t\t\t\tISA_GET_2_MULTI(IO_PORT_REG,\n\t\t\t\t\t    mtod(m, caddr_t), m->m_len / 2);\n\t\t\t\t\tif (m->m_len & 1)\n\t\t\t\t\t\t*(mtod(m, caddr_t) + \n\t\t\t\t\t\t    m->m_len - 1) = \n\t\t\t\t\t\t    ISA_GET(IO_PORT_REG);\n\t\t\t\t\tpkt_len -= m->m_len;\n\t\t\t\t\tif (pkt_len > 0) {\n\t\t\t\t\t\tMGET(m->m_next, M_DONTWAIT, \n\t\t\t\t\t\t    MT_DATA);\n\t\t\t\t\tif (m->m_next == NULL) {\n\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t}\n\t\t\t\t\tm = m->m_next;\n\t\t\t\t\tm->m_len = MLEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\teh = mtod(ipkt, struct ether_header *);\n#ifdef EXDEBUG\n\t\t\tif (debug_mask & Rcvd_Pkts) {\n\t\t\t\tif ((eh->ether_dhost[5] != 0xff) || \n\t\t\t\t    (eh->ether_dhost[0] != 0xff)) {\n\t\t\t\t\tprintf(\"Receive packet with %d data bytes: %6D -> \", QQQ, eh->ether_shost, \":\");\n\t\t\t\t\tprintf(\"%6D\\n\", eh->ether_dhost, \":\");\n\t\t\t\t} /* QQQ */\n\t\t\t}\n#endif\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, ipkt);\n#endif\n\t\t\tm_adj(ipkt, sizeof(struct ether_header));\n\t\t\tether_input(ifp, eh, ipkt);\n\t\t\tifp->if_ipackets++;\n      \t\t}\n    \t} else\n      \t\tifp->if_ierrors++;\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\t\trx_another: ;\n  \t}\n\tif (sc->rx_head < sc->rx_lower_limit + 2)\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit);\n\telse\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_head - 2);\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Rcvd_Pkts 2",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Rcvd_Pkts 2\n#define Start_End 1\n\nvoid \nex_rx_intr(sc)\n\tstruct ex_softc *sc;\n{\n\tregister struct ifnet *ifp = &sc->arpcom.ac_if;\n\tint rx_status, pkt_len, QQQ;\n\tregister struct mbuf *m, *ipkt;\n\tstruct ether_header *eh;\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: start\\n\"););\n\t/*\n\t * For all packets received since last receive interrupt:\n\t * - If packet ok, read it into a new mbuf and queue it to interface,\n\t *   updating statistics.\n\t * - If packet bad, just discard it, and update statistics.\n\t * Finally, advance receive stop limit in card's memory to new location.\n\t */\n\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\twhile (ISA_GET_2(IO_PORT_REG) == RCV_Done) {\n\t\trx_status = ISA_GET_2(IO_PORT_REG);\n\t\tsc->rx_head = ISA_GET_2(IO_PORT_REG);\n\t\tQQQ = pkt_len = ISA_GET_2(IO_PORT_REG);\n\t\tif (rx_status & RCV_OK_bit) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tipkt = m;\n\t\t\tif (ipkt == NULL)\n\t\t\t\tifp->if_iqdrops++;\n\t\t\telse {\n\t\t\t\tipkt->m_pkthdr.rcvif = ifp;\n\t\t\t\tipkt->m_pkthdr.len = pkt_len;\n\t\t\t\tipkt->m_len = MHLEN;\n\t\t\t\twhile (pkt_len > 0) {\n\t\t\t\t\tif (pkt_len > MINCLSIZE) {\n\t\t\t\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\t\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\t\t\t\tm->m_len = MCLBYTES;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm->m_len = min(m->m_len, pkt_len);\n\t\t\t\t\t/*\n\t\t\t\t\t * NOTE: I'm assuming that all mbufs \n\t\t\t\t\t * allocated are of even length, except\n\t\t\t\t\t * for the last one in an odd-length \n\t\t\t\t\t * packet.\n\t\t\t\t\t */\n\t\t\t\t\tISA_GET_2_MULTI(IO_PORT_REG,\n\t\t\t\t\t    mtod(m, caddr_t), m->m_len / 2);\n\t\t\t\t\tif (m->m_len & 1)\n\t\t\t\t\t\t*(mtod(m, caddr_t) + \n\t\t\t\t\t\t    m->m_len - 1) = \n\t\t\t\t\t\t    ISA_GET(IO_PORT_REG);\n\t\t\t\t\tpkt_len -= m->m_len;\n\t\t\t\t\tif (pkt_len > 0) {\n\t\t\t\t\t\tMGET(m->m_next, M_DONTWAIT, \n\t\t\t\t\t\t    MT_DATA);\n\t\t\t\t\tif (m->m_next == NULL) {\n\t\t\t\t\t\tm_freem(ipkt);\n\t\t\t\t\t\tifp->if_iqdrops++;\n\t\t\t\t\t\tgoto rx_another;\n\t\t\t\t\t}\n\t\t\t\t\tm = m->m_next;\n\t\t\t\t\tm->m_len = MLEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\teh = mtod(ipkt, struct ether_header *);\n#ifdef EXDEBUG\n\t\t\tif (debug_mask & Rcvd_Pkts) {\n\t\t\t\tif ((eh->ether_dhost[5] != 0xff) || \n\t\t\t\t    (eh->ether_dhost[0] != 0xff)) {\n\t\t\t\t\tprintf(\"Receive packet with %d data bytes: %6D -> \", QQQ, eh->ether_shost, \":\");\n\t\t\t\t\tprintf(\"%6D\\n\", eh->ether_dhost, \":\");\n\t\t\t\t} /* QQQ */\n\t\t\t}\n#endif\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, ipkt);\n#endif\n\t\t\tm_adj(ipkt, sizeof(struct ether_header));\n\t\t\tether_input(ifp, eh, ipkt);\n\t\t\tifp->if_ipackets++;\n      \t\t}\n    \t} else\n      \t\tifp->if_ierrors++;\n\t\tISA_PUT_2(HOST_ADDR_REG, sc->rx_head);\n\t\trx_another: ;\n  \t}\n\tif (sc->rx_head < sc->rx_lower_limit + 2)\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit);\n\telse\n\t\tISA_PUT_2(RCV_STOP_REG, sc->rx_head - 2);\n\n\tDODEBUG(Start_End, printf(\"ex_rx_intr: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "STATUS_REG",
            "Rx_Int"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "STATUS_REG"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"exintr: start\\n\");"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nint \nexintr(arg)\n\tvoid *arg;\n{\n\tstruct ex_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint int_status, send_pkts;\n\tint handled;\n\n\tDODEBUG(Start_End, printf(\"exintr: start\\n\"););\n\n#ifdef EXDEBUG\n\tif (++exintr_count != 1)\n\t\tprintf(\"WARNING: nested interrupt (%d). Mail the author.\\n\", \n\t \t    exintr_count);\n#endif\n\n\tsend_pkts = 0;\n\twhile ((int_status = ISA_GET(STATUS_REG)) & (Tx_Int | Rx_Int)) {\n\t\tif (int_status & Rx_Int) {\n\t\t\tISA_PUT(STATUS_REG, Rx_Int);\n\t\t\thandled = 1;\n\t\t\tex_rx_intr(sc);\n\t\t} else if (int_status & Tx_Int) {\n\t\t\tISA_PUT(STATUS_REG, Tx_Int);\n\t\t\thandled = 1;\n\t\t\tex_tx_intr(sc);\n\t\t\tsend_pkts = 1;\n  \t\t} else\n\t\t\thandled = 0;\n   \t}\n\n  \t/*\n\t * If any packet has been transmitted, and there are queued packets to\n \t * be sent, attempt to send more packets to the network card.\n\t */\n\n\tif (send_pkts && (ifp->if_snd.ifq_head != NULL))\n\t\tex_start(ifp);\n#ifdef EXDEBUG\n\texintr_count--;\n#endif\n\tDODEBUG(Start_End, printf(\"exintr: finish\\n\"););\n\n\treturn handled;\n}"
  },
  {
    "function_name": "ex_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "575-602",
    "snippet": "void \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_stop: finish\\n\");"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_stop: finish\\n\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Reset_CMD"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "STATUS_REG",
            "All_Int"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "MASK_REG",
            "All_Int"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Rcv_Stop"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank0_Sel"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "REG1",
            "ISA_GET(REG1) & ~TriST_INT"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG1"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank1_Sel"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_stop: start\\n\");"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Start_End 1\n\nvoid \nex_stop(sc)\n\tstruct ex_softc *sc;\n{\n\tDODEBUG(Start_End, printf(\"ex_stop: start\\n\"););\n\n\t/*\n\t * Disable card operation:\n \t * - Disable the interrupt line.\n\t * - Flush transmission and disable reception.\n\t * - Mask and clear all interrupts.\n  \t * - Reset the 82595.\n\t */\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(CMD_REG, Rcv_Stop);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\tsc->tx_last = 0; /* XXX I think these two lines are not necessary, \n\t\t\t\tbecause ex_init will always be called again \n\t\t\t\tto reinit the interface. */\n\tISA_PUT(MASK_REG, All_Int);\n\tISA_PUT(STATUS_REG, All_Int);\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\tDODEBUG(Start_End, printf(\"ex_stop: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "418-572",
    "snippet": "void \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Status    8",
      "#define Sent_Pkts 4",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_start: finish\\n\");"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_start: finish\\n\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Status",
            "printf(\"OACTIVE start\\n\");"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "opkt"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "opkt"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"Resume\\n\");"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Resume_XMT_List_CMD"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"Transmit\\n\");"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Transmit_CMD"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "XMT_BAR",
            "dest"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "MASK_REG",
            "All_Int & ~(Rx_Int | Tx_Int)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "i | Ch_bit"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->tx_last + \n\t\t\t\t    XMT_Byte_Count"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET_2",
          "args": [
            "IO_PORT_REG"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->tx_last + \n\t\t\t\t    XMT_Byte_Count"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "dest"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "sc->tx_last + XMT_Chain_Point"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2_MULTI",
          "args": [
            "IO_PORT_REG",
            "tmp16",
            "1"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2_MULTI",
          "args": [
            "IO_PORT_REG",
            "mtod(m, caddr_t) \n\t\t\t\t    + i",
            "(m->m_len - i) / 2"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2_MULTI",
          "args": [
            "IO_PORT_REG",
            "tmp16",
            "1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"[%d]\", m->m_len);"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "data_len"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "next"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "IO_PORT_REG",
            "Transmit_CMD"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "HOST_ADDR_REG",
            "dest"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"2. dest=%d, next=%d. \", dest, next);"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_WRITE",
          "args": [
            "MASK_REG",
            "All_Int"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "opkt"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"i=%d, avail=%d\\n\", i, avail);"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Sent_Pkts",
            "printf(\"1. Sending packet with %d data bytes. \", data_len);"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_start: start\\n\");"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Sent_Pkts 4\n#define Start_End 1\n\nvoid \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "328-415",
    "snippet": "void \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Status    8",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_init: finish\\n\");"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_init: finish\\n\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ex_start",
          "args": [
            "ifp"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ex_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "418-572",
          "snippet": "void \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Sent_Pkts 4",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Sent_Pkts 4\n#define Start_End 1\n\nvoid \nex_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tregister struct ex_softc *sc = ifp->if_softc;\n\tint i, s, len, data_len, avail, dest, next;\n\tunsigned char tmp16[2];\n\tstruct mbuf *opkt;\n\tregister struct mbuf *m;\n\n\tDODEBUG(Start_End, printf(\"ex_start: start\\n\"););\n\n\ts = splimp();\n\n\t/*\n \t * Main loop: send outgoing packets to network card until there are no\n \t * more packets left, or the card cannot accept any more yet.\n \t */\n\twhile (((opkt = ifp->if_snd.ifq_head) != NULL) && \n\t    !(ifp->if_flags & IFF_OACTIVE)) {\n\n\t\t/*\n\t\t * Ensure there is enough free transmit buffer space for this \n\t\t * packet, including its header. Note: the header cannot wrap \n\t\t * around the end of the transmit buffer and must be kept \n\t\t * together, so we allow space for twice the length of the \n\t\t * header, just in case.\n\t\t */\n\t\tfor (len = 0, m = opkt; m != NULL; m = m->m_next)\n \t\t\tlen += m->m_len;\n    \t\tdata_len = len;\n   \t\tDODEBUG(Sent_Pkts, printf(\"1. Sending packet with %d data bytes. \", data_len););\n\t\tif (len & 1)\n   \t\t\tlen += XMT_HEADER_LEN + 1;\n\t\telse\n\t\t\tlen += XMT_HEADER_LEN;\n\t\tif ((i = sc->tx_tail - sc->tx_head) >= 0)\n\t\t\tavail = sc->tx_mem_size - i;\n\t\telse\n\t\t\tavail = -i;\n\t\tDODEBUG(Sent_Pkts, printf(\"i=%d, avail=%d\\n\", i, avail););\n    \t\tif (avail >= len + XMT_HEADER_LEN) {\n      \t\t\tIF_DEQUEUE(&ifp->if_snd, opkt);\n\n#ifdef EX_PSA_INTR      \n\t\t\t/*\n \t\t\t * Disable rx and tx interrupts, to avoid corruption of\n\t\t\t * the host address register by interrupt service \n\t\t\t * routines. XXX Is this necessary with splimp() \n\t\t\t * enabled?\n\t\t\t */\n\t\t\tISA_WRITE(MASK_REG, All_Int);\n#endif\n\n      \t\t\t/* \n\t\t\t * Compute the start and end addresses of this frame \n\t\t\t * in the tx buffer.\n\t\t\t */\n      \t\t\tdest = sc->tx_tail;\n\t\t\tnext = dest + len;\n\t\t\tif (next > sc->tx_upper_limit) {\n\t\t\t\tif ((sc->tx_upper_limit + 2 - sc->tx_tail) <= \n\t\t\t\t    XMT_HEADER_LEN) {\n\t  \t\t\t\tdest = sc->tx_lower_limit;\n\t  \t\t\t\tnext = dest + len;\n\t\t\t\t} else\n\t  \t\t\t\tnext = sc->tx_lower_limit + next - \n\t\t\t\t\t    sc->tx_upper_limit - 2;\n      \t\t\t}\n\n\t\t\t/* Build the packet frame in the card's ring buffer. */\n\t\t\tDODEBUG(Sent_Pkts, printf(\"2. dest=%d, next=%d. \", dest, next););\n\t\t\tISA_PUT_2(HOST_ADDR_REG, dest);\n\t\t\tISA_PUT_2(IO_PORT_REG, Transmit_CMD);\n\t\t\tISA_PUT_2(IO_PORT_REG, 0);\n\t\t\tISA_PUT_2(IO_PORT_REG, next);\n\t\t\tISA_PUT_2(IO_PORT_REG, data_len);\n\n\t\t\t/*\n \t\t\t * Output the packet data to the card. Ensure all \n\t\t\t * transfers are 16-bit wide, even if individual mbufs \n\t\t\t * have odd length.\n\t\t\t */\n\n\t\t\tfor (m = opkt, i = 0; m != NULL; m = m->m_next) {\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"[%d]\", m->m_len););\n\t\t\t\tif (i) {\n\t\t\t\t\ttmp16[1] = *(mtod(m, caddr_t));\n\t\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) \n\t\t\t\t    + i, (m->m_len - i) / 2);\n\t\t\t\tif ((i = (m->m_len - i) & 1))\n\t\t\t\t\ttmp16[0] = *(mtod(m, caddr_t) + \n\t\t\t\t\t    m->m_len - 1);\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);\n\n      \t\t\t/*\n\t\t\t * If there were other frames chained, update the \n\t\t\t * chain in the last one.\n\t\t\t */\n\t\t\tif (sc->tx_head != sc->tx_tail) {\n\t\t\t\tif (sc->tx_tail != dest) {\n\t\t\t\t\tISA_PUT_2(HOST_ADDR_REG, \n\t\t\t\t\t    sc->tx_last + XMT_Chain_Point);\n\t\t\t\t\tISA_PUT_2(IO_PORT_REG, dest);\n\t\t\t\t}\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\ti = ISA_GET_2(IO_PORT_REG);\n\t\t\t\tISA_PUT_2(HOST_ADDR_REG, sc->tx_last + \n\t\t\t\t    XMT_Byte_Count);\n\t\t\t\tISA_PUT_2(IO_PORT_REG, i | Ch_bit);\n      \t\t\t}\n\n      \t\t\t/*\n\t\t\t * Resume normal operation of the card:\n\t\t\t * -Make a dummy read to flush the DRAM write pipeline.\n\t\t\t * -Enable receive and transmit interrupts.\n\t\t\t * -Send Transmit or Resume_XMT command, as appropriate.\n\t\t\t */\n\t\t\tISA_GET_2(IO_PORT_REG);\n#ifdef EX_PSA_INTR\n\t\t\tISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n#endif\n\t\t\tif (sc->tx_head == sc->tx_tail) {\n\t\t\t\tISA_PUT_2(XMT_BAR, dest);\n\t\t\t\tISA_PUT(CMD_REG, Transmit_CMD);\n\t\t\t\tsc->tx_head = dest;\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Transmit\\n\"););\n\t\t\t} else {\n\t\t\t\tISA_PUT(CMD_REG, Resume_XMT_List_CMD);\n\t\t\t\tDODEBUG(Sent_Pkts, printf(\"Resume\\n\"););\n\t\t\t}\n\t\t\tsc->tx_last = dest;\n\t\t\tsc->tx_tail = next;\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf != NULL)\n\t\t\t\tbpf_mtap(ifp->if_bpf, opkt);\n#endif\n\t\t\tifp->if_timer = 2;\n\t\t\tifp->if_opackets++;\n\t\t\tm_freem(opkt);\n\t\t} else {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tDODEBUG(Status, printf(\"OACTIVE start\\n\"););\n\t\t}\n\t}\n\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_start: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Rcv_Enable_CMD"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Sel_Reset_CMD"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Status",
            "printf(\"OIDLE init\\n\");"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "XMT_BAR",
            "sc->tx_lower_limit"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "RCV_STOP_REG",
            "sc->rx_upper_limit | 0xfe"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT_2",
          "args": [
            "RCV_BAR",
            "sc->rx_lower_limit"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "STATUS_REG",
            "All_Int"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "MASK_REG",
            "All_Int & ~(Rx_Int | Tx_Int)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank0_Sel"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "REG1",
            "ISA_GET(REG1) | TriST_INT"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "XMT_UPPER_LIMIT_REG",
            "sc->tx_upper_limit >> 8"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "XMT_LOWER_LIMIT_REG",
            "sc->tx_lower_limit >> 8"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "RCV_UPPER_LIMIT_REG",
            "sc->rx_upper_limit >> 8"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "RCV_LOWER_LIMIT_REG",
            "sc->rx_lower_limit >> 8"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "INT_NO_REG",
            "(ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "INT_NO_REG"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank1_Sel"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "REG3",
            "(ISA_GET(REG3) & 0x3f)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG3"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "REG2",
            "ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG2"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "REG1",
            "ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG1"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "I_ADDR_REG0 + i",
            "sc->arpcom.ac_enaddr[i]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "EEPROM_REG",
            "temp_reg & ~Trnoff_Enable"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "EEPROM_REG"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank2_Sel"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_init: start\\n\");"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "270-325",
    "snippet": "void\nex_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ex_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\n\t/* struct ifaddr *ifa; \tXXX what are these for? */\n\t/* struct sockaddr_dl *sdl; */\n\n\tDODEBUG(Start_End, printf(\"ex_attach: start\\n\"););\n\n\t/*\n\t * Initialize the ifnet structure.\n\n\t */\n\tifp->if_softc = sc;\n\tbcopy(self->dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_output = ether_output;\n\tifp->if_start = ex_start;\n\tifp->if_ioctl = ex_ioctl;\n\tifp->if_watchdog = ex_watchdog;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST; /* XXX not done yet. \n\t\t\t\t\t\t       | IFF_MULTICAST */\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\tprintf(\": address %s, connecter \", \n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\tswitch(sc->connector) {\n\t\tcase Conn_TPE: printf(\"TPE\\n\"); break;\n\t\tcase Conn_BNC: printf(\"BNC\\n\"); break;\n\t\tcase Conn_AUI: printf(\"AUI\\n\"); break;\n\t\tdefault: printf(\"???\\n\");\n\t}\n\n\t/*\n\t * If BPF is in the kernel, call the attach for it\n\t */\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, \n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, exintr, sc, self->dv_xname);\n\tex_init(sc);\n\n\tDODEBUG(Start_End, printf(\"ex_attach: finish\\n\"););\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Conn_AUI 3",
      "#define Conn_TPE 2",
      "#define Conn_BNC 1",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_attach: finish\\n\");"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_attach: finish\\n\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ex_init",
          "args": [
            "sc"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "328-415",
          "snippet": "void \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [
            "#define Status    8",
            "#define Start_End 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Status    8\n#define Start_End 1\n\nvoid \nex_init(sc)\n\tstruct ex_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tint s, i;\n\tunsigned short temp_reg;\n\n\tDODEBUG(Start_End, printf(\"ex_init: start\\n\"););\n\n\tif (ifp->if_addrlist.tqh_first == NULL)\n\t\treturn;\n\ts = splimp();\n\tsc->arpcom.ac_if.if_timer = 0;\n\n\t/*\n\t * Load the ethernet address into the card.\n\t */\n\tBANK_SEL(Bank2_Sel);\n\ttemp_reg = ISA_GET(EEPROM_REG);\n\tif (temp_reg & Trnoff_Enable)\n\t\tISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);\n\t/*\n\t * - Setup transmit chaining and discard bad received frames.\n\t * - Match broadcast.\n\t * - Clear test mode.\n\t * - Set receiving mode.\n\t * - Set IRQ number.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | \n\t    Disc_Bad_Fr);\n\tISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);\n\tISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));\n\tBANK_SEL(Bank1_Sel);\n\tISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | \n\t    irq2eemap[sc->irq_no]);\n\n\t/*\n\t * Divide the available memory in the card into rcv and xmt buffers.\n\t * By default, I use the first 3/4 of the memory for the rcv buffer,\n\t * and the remaining 1/4 of the memory for the xmt buffer.\n\t */\n\tsc->rx_mem_size = sc->mem_size * 3 / 4;\n\tsc->tx_mem_size = sc->mem_size - sc->rx_mem_size;\n\tsc->rx_lower_limit = 0x0000;\n\tsc->rx_upper_limit = sc->rx_mem_size - 2;\n\tsc->tx_lower_limit = sc->rx_mem_size;\n\tsc->tx_upper_limit = sc->mem_size - 2;\n \tISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);\n        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);\n        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);\n\tISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);\n\t\n\t/*\n\t * Enable receive and transmit interrupts, and clear any pending int.\n\t */\n\tISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);\n\tBANK_SEL(Bank0_Sel);\n\tISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));\n\tISA_PUT(STATUS_REG, All_Int);\n\n\t/*\n\t * Initialize receive and transmit ring buffers.\n\t */\n\tISA_PUT_2(RCV_BAR, sc->rx_lower_limit);\n\tsc->rx_head = sc->rx_lower_limit;\n\tISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);\n\tISA_PUT_2(XMT_BAR, sc->tx_lower_limit);\n\tsc->tx_head = sc->tx_tail = sc->tx_lower_limit;\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tDODEBUG(Status, printf(\"OIDLE init\\n\"););\n\t\n\t/*\n\t * Final reset of the board, and enable operation.\n\t */\n\tISA_PUT(CMD_REG, Sel_Reset_CMD);\n\tdelay(2);\n\tISA_PUT(CMD_REG, Rcv_Enable_CMD);\n\n\tex_start(ifp);\n\tsplx(s);\n\n\tDODEBUG(Start_End, printf(\"ex_init: finish\\n\"););\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "exintr",
            "sc",
            "self->dv_xname"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "self->dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_attach: start\\n\");"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Conn_AUI 3\n#define Conn_TPE 2\n#define Conn_BNC 1\n#define Start_End 1\n\nvoid\nex_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ex_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\n\t/* struct ifaddr *ifa; \tXXX what are these for? */\n\t/* struct sockaddr_dl *sdl; */\n\n\tDODEBUG(Start_End, printf(\"ex_attach: start\\n\"););\n\n\t/*\n\t * Initialize the ifnet structure.\n\n\t */\n\tifp->if_softc = sc;\n\tbcopy(self->dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_output = ether_output;\n\tifp->if_start = ex_start;\n\tifp->if_ioctl = ex_ioctl;\n\tifp->if_watchdog = ex_watchdog;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST; /* XXX not done yet. \n\t\t\t\t\t\t       | IFF_MULTICAST */\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\tprintf(\": address %s, connecter \", \n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\tswitch(sc->connector) {\n\t\tcase Conn_TPE: printf(\"TPE\\n\"); break;\n\t\tcase Conn_BNC: printf(\"BNC\\n\"); break;\n\t\tcase Conn_AUI: printf(\"AUI\\n\"); break;\n\t\tdefault: printf(\"???\\n\");\n\t}\n\n\t/*\n\t * If BPF is in the kernel, call the attach for it\n\t */\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, \n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, exintr, sc, self->dv_xname);\n\tex_init(sc);\n\n\tDODEBUG(Start_End, printf(\"ex_attach: finish\\n\"););\n}"
  },
  {
    "function_name": "ex_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "187-267",
    "snippet": "int \nex_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ex_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tu_short eaddr_tmp;\n\tint tmp;\n\n\tDODEBUG(Start_End, printf(\"ex_probe: start\\n\"););\n\n\tif ((ia->ia_iobase >= 0x200) && (ia->ia_iobase <= 0x3a0)) {\n\t\tsc->sc_iot = ia->ia_iot;\n\t\tif(bus_space_map(sc->sc_iot, ia->ia_iobase, EX_IOSIZE, 0,\n\t\t    &sc->sc_ioh))\n\t\t\treturn(0);\n\n\t\tif (!look_for_card(ia, sc)) {\n\t\t\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, EX_IOSIZE);\n\t\t\treturn(0); \n\t\t}\n\t} else\n\t\treturn(0);\n\n\tia->ia_iosize = EX_IOSIZE;\n\n\t/*\n\t * Reset the card.\n\t */\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\t/*\n\t * Fill in several fields of the softc structure:\n\t *\t- I/O base address.\n\t *\t- Hardware Ethernet address.\n\t *\t- IRQ number (if not supplied in config file, read it from \n\t *\t  EEPROM).\n\t *\t- Connector type.\n\t */\n\tsc->iobase = ia->ia_iobase;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Lo);\n\tsc->arpcom.ac_enaddr[5] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[4] = eaddr_tmp >> 8;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Mid);\n\tsc->arpcom.ac_enaddr[3] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[2] = eaddr_tmp >> 8;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Hi);\n\tsc->arpcom.ac_enaddr[1] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[0] = eaddr_tmp >> 8;\n\ttmp = eeprom_read(sc, EE_IRQ_No) & IRQ_No_Mask;\n\tif (ia->ia_irq > 0) {\n\t\tif (ee2irqmap[tmp] != ia->ia_irq)\n\t\t\tprintf(\"ex: WARING: board's EEPROM is configured for IRQ %d, using %d\\n\", ee2irqmap[tmp], ia->ia_irq);\n\t\tsc->irq_no = ia->ia_irq;\n\t}\n\telse {\n\t\tsc->irq_no = ee2irqmap[tmp];\n\t\tia->ia_irq = sc->irq_no;\n\t}\n\tif (sc->irq_no == 0) {\n\t\tprintf(\"ex: invalid IRQ.\\n\");\n\t\treturn(0);\n\t}\n\tBANK_SEL(Bank2_Sel);\n\ttmp = ISA_GET(REG3);\n\tif (tmp & TPE_bit)\n\t\tsc->connector = Conn_TPE;\n\telse if (tmp & BNC_bit)\n\t\tsc->connector = Conn_BNC;\n\telse\n\t\tsc->connector = Conn_AUI;\n\tsc->mem_size = CARD_RAM_SIZE;\t/* XXX This should be read from the card\n\t\t\t\t\t       itself. */\n\n\tBANK_SEL(Bank0_Sel);\n\n\tDODEBUG(Start_End, printf(\"ex_probe: finish\\n\"););\n\treturn(1);\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [
      "#define Conn_AUI 3",
      "#define Conn_TPE 2",
      "#define Conn_BNC 1",
      "#define Start_End 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_probe: finish\\n\");"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ex_probe: finish\\n\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank0_Sel"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "REG3"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "Bank2_Sel"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeprom_read",
          "args": [
            "sc",
            "EE_IRQ_No"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "eeprom_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "947-983",
          "snippet": "static u_short \neeprom_read(sc, location)\n\tstruct ex_softc *sc;\n\tint location;\n{\n\tint i;\n\tu_short data = 0;\n\tint read_cmd = location | EE_READ_CMD;\n\tshort ctrl_val = EECS;\n\n\tBANK_SEL(Bank2_Sel);\n\tISA_PUT(EEPROM_REG, EECS);\n\tfor (i = 8; i >= 0; i--) {\n\t\tshort outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : \n\t\t    ctrl_val;\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tISA_PUT(EEPROM_REG, outval | EESK);\n\t\tdelay(3);\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tdelay(2);\n\t}\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tfor (i = 16; i > 0; i--) {\n\t\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\t\tdelay(3);\n\t\tdata = (data << 1) | ((ISA_GET(EEPROM_REG) & EEDO) ? 1 : 0);\n\t\tISA_PUT(EEPROM_REG, ctrl_val);\n\t\tdelay(2);\n\t}\n\tctrl_val &= ~EECS;\n\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\tdelay(3);\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tdelay(2);\n\tBANK_SEL(Bank0_Sel);\n\treturn(data);\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\nstatic u_short \neeprom_read(sc, location)\n\tstruct ex_softc *sc;\n\tint location;\n{\n\tint i;\n\tu_short data = 0;\n\tint read_cmd = location | EE_READ_CMD;\n\tshort ctrl_val = EECS;\n\n\tBANK_SEL(Bank2_Sel);\n\tISA_PUT(EEPROM_REG, EECS);\n\tfor (i = 8; i >= 0; i--) {\n\t\tshort outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : \n\t\t    ctrl_val;\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tISA_PUT(EEPROM_REG, outval | EESK);\n\t\tdelay(3);\n\t\tISA_PUT(EEPROM_REG, outval);\n\t\tdelay(2);\n\t}\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tfor (i = 16; i > 0; i--) {\n\t\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\t\tdelay(3);\n\t\tdata = (data << 1) | ((ISA_GET(EEPROM_REG) & EEDO) ? 1 : 0);\n\t\tISA_PUT(EEPROM_REG, ctrl_val);\n\t\tdelay(2);\n\t}\n\tctrl_val &= ~EECS;\n\tISA_PUT(EEPROM_REG, ctrl_val | EESK);\n\tdelay(3);\n\tISA_PUT(EEPROM_REG, ctrl_val);\n\tdelay(2);\n\tBANK_SEL(Bank0_Sel);\n\treturn(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISA_PUT",
          "args": [
            "CMD_REG",
            "Reset_CMD"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "EX_IOSIZE"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "look_for_card",
          "args": [
            "ia",
            "sc"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "look_for_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
          "lines": "164-184",
          "snippet": "static int \nlook_for_card(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct ex_softc *sc;\n{\n\tint count1, count2;\n\n\t/*\n\t * Check for the i82595 signature, and check that the round robin\n\t * counter actually advances.\n\t */\n\tif (((count1 = ISA_GET(ID_REG)) & Id_Mask) != Id_Sig)\n\t\treturn(0);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tif ((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}",
          "includes": [
            "#include <dev/isa/if_exreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ex.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\nstatic int \nlook_for_card(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct ex_softc *sc;\n{\n\tint count1, count2;\n\n\t/*\n\t * Check for the i82595 signature, and check that the round robin\n\t * counter actually advances.\n\t */\n\tif (((count1 = ISA_GET(ID_REG)) & Id_Mask) != Id_Sig)\n\t\treturn(0);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tif ((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "ia->ia_iobase",
            "EX_IOSIZE",
            "0",
            "&sc->sc_ioh"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DODEBUG",
          "args": [
            "Start_End",
            "printf(\"ex_probe: start\\n\");"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\n#define Conn_AUI 3\n#define Conn_TPE 2\n#define Conn_BNC 1\n#define Start_End 1\n\nint \nex_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ex_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\tu_short eaddr_tmp;\n\tint tmp;\n\n\tDODEBUG(Start_End, printf(\"ex_probe: start\\n\"););\n\n\tif ((ia->ia_iobase >= 0x200) && (ia->ia_iobase <= 0x3a0)) {\n\t\tsc->sc_iot = ia->ia_iot;\n\t\tif(bus_space_map(sc->sc_iot, ia->ia_iobase, EX_IOSIZE, 0,\n\t\t    &sc->sc_ioh))\n\t\t\treturn(0);\n\n\t\tif (!look_for_card(ia, sc)) {\n\t\t\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, EX_IOSIZE);\n\t\t\treturn(0); \n\t\t}\n\t} else\n\t\treturn(0);\n\n\tia->ia_iosize = EX_IOSIZE;\n\n\t/*\n\t * Reset the card.\n\t */\n\tISA_PUT(CMD_REG, Reset_CMD);\n\tdelay(200);\n\n\t/*\n\t * Fill in several fields of the softc structure:\n\t *\t- I/O base address.\n\t *\t- Hardware Ethernet address.\n\t *\t- IRQ number (if not supplied in config file, read it from \n\t *\t  EEPROM).\n\t *\t- Connector type.\n\t */\n\tsc->iobase = ia->ia_iobase;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Lo);\n\tsc->arpcom.ac_enaddr[5] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[4] = eaddr_tmp >> 8;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Mid);\n\tsc->arpcom.ac_enaddr[3] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[2] = eaddr_tmp >> 8;\n\teaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Hi);\n\tsc->arpcom.ac_enaddr[1] = eaddr_tmp & 0xff;\n\tsc->arpcom.ac_enaddr[0] = eaddr_tmp >> 8;\n\ttmp = eeprom_read(sc, EE_IRQ_No) & IRQ_No_Mask;\n\tif (ia->ia_irq > 0) {\n\t\tif (ee2irqmap[tmp] != ia->ia_irq)\n\t\t\tprintf(\"ex: WARING: board's EEPROM is configured for IRQ %d, using %d\\n\", ee2irqmap[tmp], ia->ia_irq);\n\t\tsc->irq_no = ia->ia_irq;\n\t}\n\telse {\n\t\tsc->irq_no = ee2irqmap[tmp];\n\t\tia->ia_irq = sc->irq_no;\n\t}\n\tif (sc->irq_no == 0) {\n\t\tprintf(\"ex: invalid IRQ.\\n\");\n\t\treturn(0);\n\t}\n\tBANK_SEL(Bank2_Sel);\n\ttmp = ISA_GET(REG3);\n\tif (tmp & TPE_bit)\n\t\tsc->connector = Conn_TPE;\n\telse if (tmp & BNC_bit)\n\t\tsc->connector = Conn_BNC;\n\telse\n\t\tsc->connector = Conn_AUI;\n\tsc->mem_size = CARD_RAM_SIZE;\t/* XXX This should be read from the card\n\t\t\t\t\t       itself. */\n\n\tBANK_SEL(Bank0_Sel);\n\n\tDODEBUG(Start_End, printf(\"ex_probe: finish\\n\"););\n\treturn(1);\n}"
  },
  {
    "function_name": "look_for_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ex.c",
    "lines": "164-184",
    "snippet": "static int \nlook_for_card(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct ex_softc *sc;\n{\n\tint count1, count2;\n\n\t/*\n\t * Check for the i82595 signature, and check that the round robin\n\t * counter actually advances.\n\t */\n\tif (((count1 = ISA_GET(ID_REG)) & Id_Mask) != Id_Sig)\n\t\treturn(0);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tif ((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}",
    "includes": [
      "#include <dev/isa/if_exreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "ID_REG"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "ID_REG"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "ID_REG"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_GET",
          "args": [
            "ID_REG"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_exreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ex.h\"\n\nstatic int \nlook_for_card(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct ex_softc *sc;\n{\n\tint count1, count2;\n\n\t/*\n\t * Check for the i82595 signature, and check that the round robin\n\t * counter actually advances.\n\t */\n\tif (((count1 = ISA_GET(ID_REG)) & Id_Mask) != Id_Sig)\n\t\treturn(0);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tcount2 = ISA_GET(ID_REG);\n\tif ((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits))\n\t\treturn(1);\n\telse\n\t\treturn(0);\n}"
  }
]