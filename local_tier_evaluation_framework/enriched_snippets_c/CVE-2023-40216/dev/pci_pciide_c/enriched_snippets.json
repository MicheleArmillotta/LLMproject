[
  {
    "function_name": "pdc202xx_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2888-2916",
    "snippet": "int\npdc202xx_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t scr;\n\n\trv = 0;\n\tscr = bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif (scr & PDC2xx_SCR_INT(i)) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n        }\n\treturn rv;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int  pdc202xx_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d: bogus intr\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "i"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcintr",
          "args": [
            "wdc_cp"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "wdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "748-771",
          "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDC2xx_SCR_INT",
          "args": [
            "i"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_SCR"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pdc202xx_pci_intr;\n\nint\npdc202xx_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t scr;\n\n\trv = 0;\n\tscr = bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif (scr & PDC2xx_SCR_INT(i)) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n        }\n\treturn rv;\n}"
  },
  {
    "function_name": "pdc202xx_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2780-2886",
    "snippet": "void\npdc202xx_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tpcireg_t mode, st;\n\tu_int32_t idedma_ctl, scr, atapi;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint channel = chp->channel;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tidedma_ctl = 0;\n\n\t/* Per channel settings */\n\tif (PDC_IS_262(sc)) {\n\t\tscr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66);\n\t\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\t\t/* Trim UDMA mode */\n\t\tif ((st & PDC262_STATE_80P(channel)) == 0 ||\n\t\t    (chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode <= 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode <= 2)) {\n\t\t\tif (chp->ch_drive[0].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[0].UDMA_mode = 2;\n\t\t\tif (chp->ch_drive[1].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[1].UDMA_mode = 2;\n\t\t}\n\t\t/* Set U66 if needed */\n\t\tif ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode > 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode > 2))\n\t\t\tscr |= PDC262_U66_EN(channel);\n\t\telse\n\t\t\tscr &= ~PDC262_U66_EN(channel);\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66, scr);\n\t\tif (chp->ch_drive[0].drive_flags & DRIVE_ATAPI ||\n\t\t    chp->ch_drive[1].drive_flags & DRIVE_ATAPI) {\n\t\t\tif (((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[1].drive_flags & DRIVE_DMA)) ||\n\t\t\t    ((chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[0].drive_flags & DRIVE_DMA)))\n\t\t\t\tatapi = 0;\n\t\t\telse\n\t\t\t\tatapi = PDC262_ATAPI_UDMA;\n\t\t\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    PDC262_ATAPI(channel), atapi);\n\t\t}\n\t}\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tmode = 0;\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t   pdc2xx_udma_mb[drvp->UDMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_udma_mc[drvp->UDMA_mode]);\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[drvp->DMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_dma_mc[drvp->DMA_mode]);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[0]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t    pdc2xx_dma_mc[0]);\n\t\t}\n\t\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[drvp->PIO_mode]);\n\t\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[drvp->PIO_mode]);\n\t\tif (drvp->drive_flags & DRIVE_ATA)\n\t\t\tmode |= PDC2xx_TIM_PRE;\n\t\tmode |= PDC2xx_TIM_SYNC | PDC2xx_TIM_ERRDY;\n\t\tif (drvp->PIO_mode >= 3) {\n\t\t\tmode |= PDC2xx_TIM_IORDY;\n\t\t\tif (drive == 0)\n\t\t\t\tmode |= PDC2xx_TIM_IORDYp;\n\t\t}\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_channel: %s:%d:%d \"\n\t\t    \"timings 0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, \n\t\t    chp->channel, drive, mode), DEBUG_PROBE);\n\t\t    pci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(chp->channel, drive), mode);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void pdc202xx_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes",
      "__P((int, pcireg_t));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL",
            "idedma_ctl"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_TIM(chp->channel, drive)",
            "mode"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_channel: %s:%d:%d \"\n\t\t    \"timings 0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, \n\t\t    chp->channel, drive, mode)",
            "DEBUG_PROBE"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_PB",
          "args": [
            "mode",
            "pdc2xx_pb[drvp->PIO_mode]"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_PA",
          "args": [
            "mode",
            "pdc2xx_pa[drvp->PIO_mode]"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MC",
          "args": [
            "mode",
            "pdc2xx_dma_mc[0]"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MB",
          "args": [
            "mode",
            "pdc2xx_dma_mb[0]"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MC",
          "args": [
            "mode",
            "pdc2xx_dma_mc[drvp->DMA_mode]"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MB",
          "args": [
            "mode",
            "pdc2xx_dma_mb[drvp->DMA_mode]"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MC",
          "args": [
            "mode",
            "pdc2xx_udma_mc[drvp->UDMA_mode]"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MB",
          "args": [
            "mode",
            "pdc2xx_udma_mb[drvp->UDMA_mode]"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC262_ATAPI(channel)",
            "atapi"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_ATAPI",
          "args": [
            "channel"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC262_U66",
            "scr"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_U66_EN",
          "args": [
            "channel"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_U66_EN",
          "args": [
            "channel"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_STATE_80P",
          "args": [
            "channel"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_STATE"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC262_U66"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC_IS_262",
          "args": [
            "sc"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid pdc202xx_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n__P((int, pcireg_t));\n\nvoid\npdc202xx_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tpcireg_t mode, st;\n\tu_int32_t idedma_ctl, scr, atapi;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint channel = chp->channel;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tidedma_ctl = 0;\n\n\t/* Per channel settings */\n\tif (PDC_IS_262(sc)) {\n\t\tscr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66);\n\t\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\t\t/* Trim UDMA mode */\n\t\tif ((st & PDC262_STATE_80P(channel)) == 0 ||\n\t\t    (chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode <= 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode <= 2)) {\n\t\t\tif (chp->ch_drive[0].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[0].UDMA_mode = 2;\n\t\t\tif (chp->ch_drive[1].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[1].UDMA_mode = 2;\n\t\t}\n\t\t/* Set U66 if needed */\n\t\tif ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode > 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode > 2))\n\t\t\tscr |= PDC262_U66_EN(channel);\n\t\telse\n\t\t\tscr &= ~PDC262_U66_EN(channel);\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66, scr);\n\t\tif (chp->ch_drive[0].drive_flags & DRIVE_ATAPI ||\n\t\t    chp->ch_drive[1].drive_flags & DRIVE_ATAPI) {\n\t\t\tif (((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[1].drive_flags & DRIVE_DMA)) ||\n\t\t\t    ((chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[0].drive_flags & DRIVE_DMA)))\n\t\t\t\tatapi = 0;\n\t\t\telse\n\t\t\t\tatapi = PDC262_ATAPI_UDMA;\n\t\t\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    PDC262_ATAPI(channel), atapi);\n\t\t}\n\t}\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tmode = 0;\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t   pdc2xx_udma_mb[drvp->UDMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_udma_mc[drvp->UDMA_mode]);\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[drvp->DMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_dma_mc[drvp->DMA_mode]);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[0]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t    pdc2xx_dma_mc[0]);\n\t\t}\n\t\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[drvp->PIO_mode]);\n\t\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[drvp->PIO_mode]);\n\t\tif (drvp->drive_flags & DRIVE_ATA)\n\t\t\tmode |= PDC2xx_TIM_PRE;\n\t\tmode |= PDC2xx_TIM_SYNC | PDC2xx_TIM_ERRDY;\n\t\tif (drvp->PIO_mode >= 3) {\n\t\t\tmode |= PDC2xx_TIM_IORDY;\n\t\t\tif (drive == 0)\n\t\t\t\tmode |= PDC2xx_TIM_IORDYp;\n\t\t}\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_channel: %s:%d:%d \"\n\t\t    \"timings 0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, \n\t\t    chp->channel, drive, mode), DEBUG_PROBE);\n\t\t    pci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(chp->channel, drive), mode);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "pdc202xx_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2659-2778",
    "snippet": "void\npdc202xx_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t interface, st, mode;\n\tbus_size_t cmdsize, ctlsize;\n\n\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: controller state 0x%x\\n\", st),\n\t    DEBUG_PROBE);\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\t/* turn off  RAID mode */\n\tst &= ~PDC2xx_STATE_IDERAID;\n\n\t/*\n \t * can't rely on the PCI_CLASS_REG content if the chip was in raid\n\t * mode. We have to fake interface\n\t */\n\tinterface = PCIIDE_INTERFACE_SETTABLE(0) | PCIIDE_INTERFACE_SETTABLE(1);\n\tif (st & PDC2xx_STATE_NATIVE)\n\t\tinterface |= PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tsc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tif (PDC_IS_262(sc))\n\t\tsc->sc_wdcdev.UDMA_cap = 4;\n\telse\n\t\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = pdc202xx_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\t/* setup failsafe defaults */\n\tmode = 0;\n\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);\n\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);\n\tmode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);\n\tmode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: channel %d drive 0 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),\n\t\t    DEBUG_PROBE);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 0),\n\t\t    mode | PDC2xx_TIM_IORDYp);\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: channel %d drive 1 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag,\n\t \t    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 1),\n\t\t    mode);\n\t}\n\n\tmode = PDC2xx_SCR_DMA;\n\tif (PDC_IS_262(sc)) {\n\t\tmode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);\n\t} else {\n\t\t/* the BIOS set it up this way */\n\t\tmode = PDC2xx_SCR_SET_GEN(mode, 0x1);\n\t}\n\tmode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */\n\tmode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: initial SCR  0x%x, now 0x%x\\n\",\n\t    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR), mode),\n\t    DEBUG_PROBE);\n\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR, mode);\n\n\t/* controller initial state register is OK even without BIOS */\n\t/* Set DMA mode to IDE DMA compatibility */\n\tmode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: primary mode 0x%x\", mode ),\n\t    DEBUG_PROBE);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,\n\t    mode | 0x1);\n\tmode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);\n\tWDCDEBUG_PRINT((\", secondary mode 0x%x\\n\", mode ), DEBUG_PROBE);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,\n\t    mode | 0x1);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((st & (PDC_IS_262(sc) ?\n\t\t    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel))) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pdc202xx_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t    continue;\n\t\tif (pciiide_chan_candisable(cp))\n\t\t\tst &= ~(PDC_IS_262(sc) ?\n\t\t\t    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel));\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tpdc202xx_setup_channel(&cp->wdc_channel);\n        }\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: new controller state 0x%x\\n\", st),\n\t    DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_STATE, st);\n\treturn;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void pdc202xx_chip_map",
      "void pdc202xx_setup_channel",
      "int  pdc202xx_pci_intr",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_STATE",
            "st"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: new controller state 0x%x\\n\", st)",
            "DEBUG_PROBE"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdc202xx_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "pdc202xx_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "2780-2886",
          "snippet": "void\npdc202xx_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tpcireg_t mode, st;\n\tu_int32_t idedma_ctl, scr, atapi;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint channel = chp->channel;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tidedma_ctl = 0;\n\n\t/* Per channel settings */\n\tif (PDC_IS_262(sc)) {\n\t\tscr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66);\n\t\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\t\t/* Trim UDMA mode */\n\t\tif ((st & PDC262_STATE_80P(channel)) == 0 ||\n\t\t    (chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode <= 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode <= 2)) {\n\t\t\tif (chp->ch_drive[0].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[0].UDMA_mode = 2;\n\t\t\tif (chp->ch_drive[1].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[1].UDMA_mode = 2;\n\t\t}\n\t\t/* Set U66 if needed */\n\t\tif ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode > 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode > 2))\n\t\t\tscr |= PDC262_U66_EN(channel);\n\t\telse\n\t\t\tscr &= ~PDC262_U66_EN(channel);\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66, scr);\n\t\tif (chp->ch_drive[0].drive_flags & DRIVE_ATAPI ||\n\t\t    chp->ch_drive[1].drive_flags & DRIVE_ATAPI) {\n\t\t\tif (((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[1].drive_flags & DRIVE_DMA)) ||\n\t\t\t    ((chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[0].drive_flags & DRIVE_DMA)))\n\t\t\t\tatapi = 0;\n\t\t\telse\n\t\t\t\tatapi = PDC262_ATAPI_UDMA;\n\t\t\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    PDC262_ATAPI(channel), atapi);\n\t\t}\n\t}\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tmode = 0;\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t   pdc2xx_udma_mb[drvp->UDMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_udma_mc[drvp->UDMA_mode]);\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[drvp->DMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_dma_mc[drvp->DMA_mode]);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[0]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t    pdc2xx_dma_mc[0]);\n\t\t}\n\t\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[drvp->PIO_mode]);\n\t\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[drvp->PIO_mode]);\n\t\tif (drvp->drive_flags & DRIVE_ATA)\n\t\t\tmode |= PDC2xx_TIM_PRE;\n\t\tmode |= PDC2xx_TIM_SYNC | PDC2xx_TIM_ERRDY;\n\t\tif (drvp->PIO_mode >= 3) {\n\t\t\tmode |= PDC2xx_TIM_IORDY;\n\t\t\tif (drive == 0)\n\t\t\t\tmode |= PDC2xx_TIM_IORDYp;\n\t\t}\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_channel: %s:%d:%d \"\n\t\t    \"timings 0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, \n\t\t    chp->channel, drive, mode), DEBUG_PROBE);\n\t\t    pci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(chp->channel, drive), mode);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "void pdc202xx_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid pdc202xx_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n__P((int, pcireg_t));\n\nvoid\npdc202xx_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tpcireg_t mode, st;\n\tu_int32_t idedma_ctl, scr, atapi;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint channel = chp->channel;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tidedma_ctl = 0;\n\n\t/* Per channel settings */\n\tif (PDC_IS_262(sc)) {\n\t\tscr = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66);\n\t\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\t\t/* Trim UDMA mode */\n\t\tif ((st & PDC262_STATE_80P(channel)) == 0 ||\n\t\t    (chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode <= 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode <= 2)) {\n\t\t\tif (chp->ch_drive[0].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[0].UDMA_mode = 2;\n\t\t\tif (chp->ch_drive[1].UDMA_mode > 2)\n\t\t\t\tchp->ch_drive[1].UDMA_mode = 2;\n\t\t}\n\t\t/* Set U66 if needed */\n\t\tif ((chp->ch_drive[0].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[0].UDMA_mode > 2) ||\n\t\t    (chp->ch_drive[1].drive_flags & DRIVE_UDMA &&\n\t\t    chp->ch_drive[1].UDMA_mode > 2))\n\t\t\tscr |= PDC262_U66_EN(channel);\n\t\telse\n\t\t\tscr &= ~PDC262_U66_EN(channel);\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    PDC262_U66, scr);\n\t\tif (chp->ch_drive[0].drive_flags & DRIVE_ATAPI ||\n\t\t    chp->ch_drive[1].drive_flags & DRIVE_ATAPI) {\n\t\t\tif (((chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[1].drive_flags & DRIVE_DMA)) ||\n\t\t\t    ((chp->ch_drive[1].drive_flags & DRIVE_UDMA) &&\n\t\t\t    !(chp->ch_drive[0].drive_flags & DRIVE_UDMA) &&\n\t\t\t    (chp->ch_drive[0].drive_flags & DRIVE_DMA)))\n\t\t\t\tatapi = 0;\n\t\t\telse\n\t\t\t\tatapi = PDC262_ATAPI_UDMA;\n\t\t\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    PDC262_ATAPI(channel), atapi);\n\t\t}\n\t}\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tmode = 0;\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t   pdc2xx_udma_mb[drvp->UDMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_udma_mc[drvp->UDMA_mode]);\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[drvp->DMA_mode]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t   pdc2xx_dma_mc[drvp->DMA_mode]);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t} else {\n\t\t\tmode = PDC2xx_TIM_SET_MB(mode,\n\t\t\t    pdc2xx_dma_mb[0]);\n\t\t\tmode = PDC2xx_TIM_SET_MC(mode,\n\t\t\t    pdc2xx_dma_mc[0]);\n\t\t}\n\t\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[drvp->PIO_mode]);\n\t\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[drvp->PIO_mode]);\n\t\tif (drvp->drive_flags & DRIVE_ATA)\n\t\t\tmode |= PDC2xx_TIM_PRE;\n\t\tmode |= PDC2xx_TIM_SYNC | PDC2xx_TIM_ERRDY;\n\t\tif (drvp->PIO_mode >= 3) {\n\t\t\tmode |= PDC2xx_TIM_IORDY;\n\t\t\tif (drive == 0)\n\t\t\t\tmode |= PDC2xx_TIM_IORDYp;\n\t\t}\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_channel: %s:%d:%d \"\n\t\t    \"timings 0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, \n\t\t    chp->channel, drive, mode), DEBUG_PROBE);\n\t\t    pci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(chp->channel, drive), mode);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDC246_STATE_EN",
          "args": [
            "channel"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_STATE_EN",
          "args": [
            "channel"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC_IS_262",
          "args": [
            "sc"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "pdc202xx_pci_intr"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDC246_STATE_EN",
          "args": [
            "channel"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC262_STATE_EN",
          "args": [
            "channel"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC_IS_262",
          "args": [
            "sc"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_SM",
            "mode | 0x1"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", secondary mode 0x%x\\n\", mode )",
            "DEBUG_PROBE"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_SM"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_PM",
            "mode | 0x1"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: primary mode 0x%x\", mode )",
            "DEBUG_PROBE"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_PM"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_SCR",
            "mode"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: initial SCR  0x%x, now 0x%x\\n\",\n\t    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR), mode)",
            "DEBUG_PROBE"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "PDC2xx_SCR"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_SCR_SET_POLL",
          "args": [
            "mode",
            "0x1"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_SCR_SET_I2C",
          "args": [
            "mode",
            "0x3"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_SCR_SET_GEN",
          "args": [
            "mode",
            "0x1"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_SCR_SET_GEN",
          "args": [
            "mode",
            "PDC262_SCR_GEN_LAT"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC_IS_262",
          "args": [
            "sc"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_TIM(channel, 1)",
            "mode"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM",
          "args": [
            "channel",
            "1"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: channel %d drive 1 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag,\n\t \t    PDC2xx_TIM(channel, 1)), mode)",
            "DEBUG_PROBE"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_TIM(channel, 1)"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM",
          "args": [
            "channel",
            "1"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_TIM(channel, 0)",
            "mode | PDC2xx_TIM_IORDYp"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM",
          "args": [
            "channel",
            "0"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: channel %d drive 0 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp)",
            "DEBUG_PROBE"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_TIM(channel, 0)"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM",
          "args": [
            "channel",
            "0"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MC",
          "args": [
            "mode",
            "pdc2xx_dma_mc[0]"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_MB",
          "args": [
            "mode",
            "pdc2xx_dma_mb[0]"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_PB",
          "args": [
            "mode",
            "pdc2xx_pb[0]"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDC2xx_TIM_SET_PA",
          "args": [
            "mode",
            "pdc2xx_pa[0]"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDC_IS_262",
          "args": [
            "sc"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "1"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "0"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_SETTABLE",
          "args": [
            "1"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_SETTABLE",
          "args": [
            "0"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pdc202xx_setup_chip: controller state 0x%x\\n\", st)",
            "DEBUG_PROBE"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PDC2xx_STATE"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid pdc202xx_chip_map;\nvoid pdc202xx_setup_channel;\nint  pdc202xx_pci_intr;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\npdc202xx_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t interface, st, mode;\n\tbus_size_t cmdsize, ctlsize;\n\n\tst = pci_conf_read(sc->sc_pc, sc->sc_tag, PDC2xx_STATE);\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: controller state 0x%x\\n\", st),\n\t    DEBUG_PROBE);\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\t/* turn off  RAID mode */\n\tst &= ~PDC2xx_STATE_IDERAID;\n\n\t/*\n \t * can't rely on the PCI_CLASS_REG content if the chip was in raid\n\t * mode. We have to fake interface\n\t */\n\tinterface = PCIIDE_INTERFACE_SETTABLE(0) | PCIIDE_INTERFACE_SETTABLE(1);\n\tif (st & PDC2xx_STATE_NATIVE)\n\t\tinterface |= PCIIDE_INTERFACE_PCI(0) | PCIIDE_INTERFACE_PCI(1);\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tsc->sc_wdcdev.cap = WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tif (PDC_IS_262(sc))\n\t\tsc->sc_wdcdev.UDMA_cap = 4;\n\telse\n\t\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = pdc202xx_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\t/* setup failsafe defaults */\n\tmode = 0;\n\tmode = PDC2xx_TIM_SET_PA(mode, pdc2xx_pa[0]);\n\tmode = PDC2xx_TIM_SET_PB(mode, pdc2xx_pb[0]);\n\tmode = PDC2xx_TIM_SET_MB(mode, pdc2xx_dma_mb[0]);\n\tmode = PDC2xx_TIM_SET_MC(mode, pdc2xx_dma_mc[0]);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: channel %d drive 0 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t    PDC2xx_TIM(channel, 0)), mode | PDC2xx_TIM_IORDYp),\n\t\t    DEBUG_PROBE);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 0),\n\t\t    mode | PDC2xx_TIM_IORDYp);\n\t\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: channel %d drive 1 \"\n\t\t    \"initial timings  0x%x, now 0x%x\\n\", channel,\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag,\n\t \t    PDC2xx_TIM(channel, 1)), mode), DEBUG_PROBE);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_TIM(channel, 1),\n\t\t    mode);\n\t}\n\n\tmode = PDC2xx_SCR_DMA;\n\tif (PDC_IS_262(sc)) {\n\t\tmode = PDC2xx_SCR_SET_GEN(mode, PDC262_SCR_GEN_LAT);\n\t} else {\n\t\t/* the BIOS set it up this way */\n\t\tmode = PDC2xx_SCR_SET_GEN(mode, 0x1);\n\t}\n\tmode = PDC2xx_SCR_SET_I2C(mode, 0x3); /* ditto */\n\tmode = PDC2xx_SCR_SET_POLL(mode, 0x1); /* ditto */\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: initial SCR  0x%x, now 0x%x\\n\",\n\t    bus_space_read_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR), mode),\n\t    DEBUG_PROBE);\n\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SCR, mode);\n\n\t/* controller initial state register is OK even without BIOS */\n\t/* Set DMA mode to IDE DMA compatibility */\n\tmode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM);\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: primary mode 0x%x\", mode ),\n\t    DEBUG_PROBE);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_PM,\n\t    mode | 0x1);\n\tmode = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM);\n\tWDCDEBUG_PRINT((\", secondary mode 0x%x\\n\", mode ), DEBUG_PROBE);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh, PDC2xx_SM,\n\t    mode | 0x1);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((st & (PDC_IS_262(sc) ?\n\t\t    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel))) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pdc202xx_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t    continue;\n\t\tif (pciiide_chan_candisable(cp))\n\t\t\tst &= ~(PDC_IS_262(sc) ?\n\t\t\t    PDC262_STATE_EN(channel):PDC246_STATE_EN(channel));\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tpdc202xx_setup_channel(&cp->wdc_channel);\n        }\n\tWDCDEBUG_PRINT((\"pdc202xx_setup_chip: new controller state 0x%x\\n\", st),\n\t    DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PDC2xx_STATE, st);\n\treturn;\n}"
  },
  {
    "function_name": "acer_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2626-2654",
    "snippet": "int\nacer_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t chids;\n\n\trv = 0;\n\tchids = pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CHIDS);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif (chids & ACER_CHIDS_INT(i)) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "int  acer_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d: bogus intr\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "i"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcintr",
          "args": [
            "wdc_cp"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "wdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "748-771",
          "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACER_CHIDS_INT",
          "args": [
            "i"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_CHIDS"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nint  acer_pci_intr;\n\nint\nacer_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t chids;\n\n\trv = 0;\n\tchids = pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CHIDS);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif (chids & ACER_CHIDS_INT(i)) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "acer_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2548-2624",
    "snippet": "void\nacer_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t acer_fifo_udma;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tacer_fifo_udma = pci_conf_read(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA);\n\tWDCDEBUG_PRINT((\"acer_setup_channel: old fifo/udma reg 0x%x\\n\", \n\t    acer_fifo_udma), DEBUG_PROBE);\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tWDCDEBUG_PRINT((\"acer_setup_channel: old timings reg for \"\n\t\t    \"channel %d drive %d 0x%x\\n\", chp->channel, drive,\n\t\t    pciide_pci_read(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive))), DEBUG_PROBE);\n\t\t/* clear FIFO/DMA mode */\n\t\tacer_fifo_udma &= ~(ACER_FTH_OPL(chp->channel, drive, 0x3) |\n\t\t    ACER_UDMA_EN(chp->channel, drive) |\n\t\t    ACER_UDMA_TIM(chp->channel, drive, 0x7));\n\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) {\n\t\t\tacer_fifo_udma |=\n\t\t\t    ACER_FTH_OPL(chp->channel, drive, 0x1);\n\t\t\tgoto pio;\n\t\t}\n\n\t\tacer_fifo_udma |= ACER_FTH_OPL(chp->channel, drive, 0x2);\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tacer_fifo_udma |= ACER_UDMA_EN(chp->channel, drive);\n\t\t\tacer_fifo_udma |= \n\t\t\t    ACER_UDMA_TIM(chp->channel, drive,\n\t\t\t\tacer_udma[drvp->UDMA_mode]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive),\n\t\t    acer_pio[drvp->PIO_mode]);\n\t}\n\tWDCDEBUG_PRINT((\"acer_setup_channel: new fifo/udma reg 0x%x\\n\",\n\t    acer_fifo_udma), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA, acer_fifo_udma);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "static __inline void pciide_pci_write",
      "void acer_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL",
            "idedma_ctl"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_FTH_UDMA",
            "acer_fifo_udma"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"acer_setup_channel: new fifo/udma reg 0x%x\\n\",\n\t    acer_fifo_udma)",
            "DEBUG_PROBE"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_IDETIM(chp->channel, drive)",
            "acer_pio[drvp->PIO_mode]"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACER_IDETIM",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_UDMA_TIM",
          "args": [
            "chp->channel",
            "drive",
            "acer_udma[drvp->UDMA_mode]"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_UDMA_EN",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_FTH_OPL",
          "args": [
            "chp->channel",
            "drive",
            "0x2"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_FTH_OPL",
          "args": [
            "chp->channel",
            "drive",
            "0x1"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_UDMA_TIM",
          "args": [
            "chp->channel",
            "drive",
            "0x7"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_UDMA_EN",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACER_FTH_OPL",
          "args": [
            "chp->channel",
            "drive",
            "0x3"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"acer_setup_channel: old timings reg for \"\n\t\t    \"channel %d drive %d 0x%x\\n\", chp->channel, drive,\n\t\t    pciide_pci_read(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive)))",
            "DEBUG_PROBE"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_IDETIM(chp->channel, drive)"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACER_IDETIM",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"acer_setup_channel: old fifo/udma reg 0x%x\\n\", \n\t    acer_fifo_udma)",
            "DEBUG_PROBE"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_FTH_UDMA"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid acer_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\nacer_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t acer_fifo_udma;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tacer_fifo_udma = pci_conf_read(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA);\n\tWDCDEBUG_PRINT((\"acer_setup_channel: old fifo/udma reg 0x%x\\n\", \n\t    acer_fifo_udma), DEBUG_PROBE);\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tWDCDEBUG_PRINT((\"acer_setup_channel: old timings reg for \"\n\t\t    \"channel %d drive %d 0x%x\\n\", chp->channel, drive,\n\t\t    pciide_pci_read(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive))), DEBUG_PROBE);\n\t\t/* clear FIFO/DMA mode */\n\t\tacer_fifo_udma &= ~(ACER_FTH_OPL(chp->channel, drive, 0x3) |\n\t\t    ACER_UDMA_EN(chp->channel, drive) |\n\t\t    ACER_UDMA_TIM(chp->channel, drive, 0x7));\n\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) {\n\t\t\tacer_fifo_udma |=\n\t\t\t    ACER_FTH_OPL(chp->channel, drive, 0x1);\n\t\t\tgoto pio;\n\t\t}\n\n\t\tacer_fifo_udma |= ACER_FTH_OPL(chp->channel, drive, 0x2);\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tacer_fifo_udma |= ACER_UDMA_EN(chp->channel, drive);\n\t\t\tacer_fifo_udma |= \n\t\t\t    ACER_UDMA_TIM(chp->channel, drive,\n\t\t\t\tacer_udma[drvp->UDMA_mode]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive),\n\t\t    acer_pio[drvp->PIO_mode]);\n\t}\n\tWDCDEBUG_PRINT((\"acer_setup_channel: new fifo/udma reg 0x%x\\n\",\n\t    acer_fifo_udma), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA, acer_fifo_udma);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "acer_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2474-2546",
    "snippet": "void\nacer_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t cr, interface;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = acer_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CDRC,\n\t    (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CDRC) |\n\t\tACER_CDRC_DMA_EN) & ~ACER_CDRC_FIFO_DISABLE);\n\n\n\t/* Enable \"microsoft register bits\" R/W. */\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR3,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR3) | ACER_CCAR3_PI);\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR1,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR1) &\n\t    ~(ACER_CHANSTATUS_RO|PCIIDE_CHAN_RO(0)|PCIIDE_CHAN_RO(1)));\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR2,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &\n\t    ~ACER_CHANSTATUSREGS_RO);\n\tcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG);\n\tcr |= (PCIIDE_CHANSTATUS_EN << PCI_INTERFACE_SHIFT);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);\n\t/* Don't use cr, re-read the real register content instead */\n\tinterface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t    PCI_CLASS_REG));\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((interface & PCIIDE_CHAN_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    acer_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tcr &= ~(PCIIDE_CHAN_EN(channel) << PCI_INTERFACE_SHIFT);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t    PCI_CLASS_REG, cr);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tacer_setup_channel(&cp->wdc_channel);\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "static __inline void pciide_pci_write",
      "void acer_chip_map",
      "void acer_setup_channel",
      "int  acer_pci_intr",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acer_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "acer_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "2548-2624",
          "snippet": "void\nacer_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t acer_fifo_udma;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tacer_fifo_udma = pci_conf_read(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA);\n\tWDCDEBUG_PRINT((\"acer_setup_channel: old fifo/udma reg 0x%x\\n\", \n\t    acer_fifo_udma), DEBUG_PROBE);\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tWDCDEBUG_PRINT((\"acer_setup_channel: old timings reg for \"\n\t\t    \"channel %d drive %d 0x%x\\n\", chp->channel, drive,\n\t\t    pciide_pci_read(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive))), DEBUG_PROBE);\n\t\t/* clear FIFO/DMA mode */\n\t\tacer_fifo_udma &= ~(ACER_FTH_OPL(chp->channel, drive, 0x3) |\n\t\t    ACER_UDMA_EN(chp->channel, drive) |\n\t\t    ACER_UDMA_TIM(chp->channel, drive, 0x7));\n\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) {\n\t\t\tacer_fifo_udma |=\n\t\t\t    ACER_FTH_OPL(chp->channel, drive, 0x1);\n\t\t\tgoto pio;\n\t\t}\n\n\t\tacer_fifo_udma |= ACER_FTH_OPL(chp->channel, drive, 0x2);\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tacer_fifo_udma |= ACER_UDMA_EN(chp->channel, drive);\n\t\t\tacer_fifo_udma |= \n\t\t\t    ACER_UDMA_TIM(chp->channel, drive,\n\t\t\t\tacer_udma[drvp->UDMA_mode]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive),\n\t\t    acer_pio[drvp->PIO_mode]);\n\t}\n\tWDCDEBUG_PRINT((\"acer_setup_channel: new fifo/udma reg 0x%x\\n\",\n\t    acer_fifo_udma), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA, acer_fifo_udma);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read",
            "static __inline void pciide_pci_write",
            "void acer_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid acer_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\nacer_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t acer_fifo_udma;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tacer_fifo_udma = pci_conf_read(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA);\n\tWDCDEBUG_PRINT((\"acer_setup_channel: old fifo/udma reg 0x%x\\n\", \n\t    acer_fifo_udma), DEBUG_PROBE);\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tWDCDEBUG_PRINT((\"acer_setup_channel: old timings reg for \"\n\t\t    \"channel %d drive %d 0x%x\\n\", chp->channel, drive,\n\t\t    pciide_pci_read(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive))), DEBUG_PROBE);\n\t\t/* clear FIFO/DMA mode */\n\t\tacer_fifo_udma &= ~(ACER_FTH_OPL(chp->channel, drive, 0x3) |\n\t\t    ACER_UDMA_EN(chp->channel, drive) |\n\t\t    ACER_UDMA_TIM(chp->channel, drive, 0x7));\n\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) {\n\t\t\tacer_fifo_udma |=\n\t\t\t    ACER_FTH_OPL(chp->channel, drive, 0x1);\n\t\t\tgoto pio;\n\t\t}\n\n\t\tacer_fifo_udma |= ACER_FTH_OPL(chp->channel, drive, 0x2);\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tacer_fifo_udma |= ACER_UDMA_EN(chp->channel, drive);\n\t\t\tacer_fifo_udma |= \n\t\t\t    ACER_UDMA_TIM(chp->channel, drive,\n\t\t\t\tacer_udma[drvp->UDMA_mode]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    ACER_IDETIM(chp->channel, drive),\n\t\t    acer_pio[drvp->PIO_mode]);\n\t}\n\tWDCDEBUG_PRINT((\"acer_setup_channel: new fifo/udma reg 0x%x\\n\",\n\t    acer_fifo_udma), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, ACER_FTH_UDMA, acer_fifo_udma);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG",
            "cr"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHAN_EN",
          "args": [
            "channel"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "acer_pci_intr"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHAN_EN",
          "args": [
            "channel"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t    PCI_CLASS_REG)"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG",
            "cr"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_CCAR2",
            "pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &\n\t    ~ACER_CHANSTATUSREGS_RO"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "ACER_CCAR2"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHAN_RO",
          "args": [
            "1"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHAN_RO",
          "args": [
            "0"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid acer_chip_map;\nvoid acer_setup_channel;\nint  acer_pci_intr;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\nacer_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t cr, interface;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = acer_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CDRC,\n\t    (pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CDRC) |\n\t\tACER_CDRC_DMA_EN) & ~ACER_CDRC_FIFO_DISABLE);\n\n\n\t/* Enable \"microsoft register bits\" R/W. */\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR3,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR3) | ACER_CCAR3_PI);\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR1,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR1) &\n\t    ~(ACER_CHANSTATUS_RO|PCIIDE_CHAN_RO(0)|PCIIDE_CHAN_RO(1)));\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, ACER_CCAR2,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, ACER_CCAR2) &\n\t    ~ACER_CHANSTATUSREGS_RO);\n\tcr = pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG);\n\tcr |= (PCIIDE_CHANSTATUS_EN << PCI_INTERFACE_SHIFT);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG, cr);\n\t/* Don't use cr, re-read the real register content instead */\n\tinterface = PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t    PCI_CLASS_REG));\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((interface & PCIIDE_CHAN_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    acer_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tcr &= ~(PCIIDE_CHAN_EN(channel) << PCI_INTERFACE_SHIFT);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t\t    PCI_CLASS_REG, cr);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tacer_setup_channel(&cp->wdc_channel);\n\t}\n}"
  },
  {
    "function_name": "sis_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2407-2472",
    "snippet": "void\nsis_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t sis_tim;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tWDCDEBUG_PRINT((\"sis_setup_channel: old timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, \n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel))),\n\t    DEBUG_PROBE);\n\tsis_tim = 0;\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)\n\t\t\tgoto pio;\n\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tsis_tim |= sis_udma_tim[drvp->UDMA_mode] << \n\t\t\t    SIS_TIM_UDMA_TIME_OFF(drive);\n\t\t\tsis_tim |= SIS_TIM_UDMA_EN(drive);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tsis_tim |= sis_pio_act[drvp->PIO_mode] <<\n\t\t    SIS_TIM_ACT_OFF(drive);\n\t\tsis_tim |= sis_pio_rec[drvp->PIO_mode] <<\n\t\t    SIS_TIM_REC_OFF(drive);\n\t}\n\tWDCDEBUG_PRINT((\"sis_setup_channel: new timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, sis_tim), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel), sis_tim);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void sis_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL",
            "idedma_ctl"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "SIS_TIM(chp->channel)",
            "sis_tim"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM",
          "args": [
            "chp->channel"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"sis_setup_channel: new timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, sis_tim)",
            "DEBUG_PROBE"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM_REC_OFF",
          "args": [
            "drive"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM_ACT_OFF",
          "args": [
            "drive"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM_UDMA_EN",
          "args": [
            "drive"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM_UDMA_TIME_OFF",
          "args": [
            "drive"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"sis_setup_channel: old timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, \n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel)))",
            "DEBUG_PROBE"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "SIS_TIM(chp->channel)"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIS_TIM",
          "args": [
            "chp->channel"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid sis_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\nsis_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t sis_tim;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tWDCDEBUG_PRINT((\"sis_setup_channel: old timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, \n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel))),\n\t    DEBUG_PROBE);\n\tsis_tim = 0;\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)\n\t\t\tgoto pio;\n\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tsis_tim |= sis_udma_tim[drvp->UDMA_mode] << \n\t\t\t    SIS_TIM_UDMA_TIME_OFF(drive);\n\t\t\tsis_tim |= SIS_TIM_UDMA_EN(drive);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tsis_tim |= sis_pio_act[drvp->PIO_mode] <<\n\t\t    SIS_TIM_ACT_OFF(drive);\n\t\tsis_tim |= sis_pio_rec[drvp->PIO_mode] <<\n\t\t    SIS_TIM_REC_OFF(drive);\n\t}\n\tWDCDEBUG_PRINT((\"sis_setup_channel: new timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, sis_tim), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel), sis_tim);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "sis_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2336-2405",
    "snippet": "void\nsis_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tu_int8_t sis_ctr0 = pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_CTRL0);\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tpcireg_t rev = PCI_REVISION(pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t    PCI_CLASS_REG));\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tif (rev >= 0xd0)\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t}\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA)\n\t\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = sis_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |\n\t    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((channel == 0 && (sis_ctr0 & SIS_CTRL0_CHAN0_EN) == 0) ||\n\t \t    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tif (channel == 0)\n\t\t\t\tsis_ctr0 &= ~SIS_CTRL0_CHAN0_EN;\n\t\t\telse\n\t\t\t\tsis_ctr0 &= ~SIS_CTRL0_CHAN1_EN;\n\t\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_CTRL0,\n\t\t\t    sis_ctr0);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tsis_setup_channel(&cp->wdc_channel);\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "static __inline void pciide_pci_write",
      "void sis_chip_map",
      "void sis_setup_channel",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr",
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sis_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "sis_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "2407-2472",
          "snippet": "void\nsis_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t sis_tim;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tWDCDEBUG_PRINT((\"sis_setup_channel: old timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, \n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel))),\n\t    DEBUG_PROBE);\n\tsis_tim = 0;\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)\n\t\t\tgoto pio;\n\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tsis_tim |= sis_udma_tim[drvp->UDMA_mode] << \n\t\t\t    SIS_TIM_UDMA_TIME_OFF(drive);\n\t\t\tsis_tim |= SIS_TIM_UDMA_EN(drive);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tsis_tim |= sis_pio_act[drvp->PIO_mode] <<\n\t\t    SIS_TIM_ACT_OFF(drive);\n\t\tsis_tim |= sis_pio_rec[drvp->PIO_mode] <<\n\t\t    SIS_TIM_REC_OFF(drive);\n\t}\n\tWDCDEBUG_PRINT((\"sis_setup_channel: new timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, sis_tim), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel), sis_tim);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "void sis_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid sis_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\nsis_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t sis_tim;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tWDCDEBUG_PRINT((\"sis_setup_channel: old timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, \n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel))),\n\t    DEBUG_PROBE);\n\tsis_tim = 0;\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)\n\t\t\tgoto pio;\n\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tsis_tim |= sis_udma_tim[drvp->UDMA_mode] << \n\t\t\t    SIS_TIM_UDMA_TIME_OFF(drive);\n\t\t\tsis_tim |= SIS_TIM_UDMA_EN(drive);\n\t\t} else {\n\t\t\t/*\n\t\t\t * use Multiword DMA\n\t\t\t * Timings will be used for both PIO and DMA,\n\t\t\t * so adjust DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode > (drvp->DMA_mode + 2))\n\t\t\t\tdrvp->PIO_mode = drvp->DMA_mode + 2;\n\t\t\tif (drvp->DMA_mode + 2 > (drvp->PIO_mode))\n\t\t\t\tdrvp->DMA_mode = (drvp->PIO_mode > 2) ?\n\t\t\t\t    drvp->PIO_mode - 2 : 0;\n\t\t\tif (drvp->DMA_mode == 0)\n\t\t\t\tdrvp->PIO_mode = 0;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\npio:\t\tsis_tim |= sis_pio_act[drvp->PIO_mode] <<\n\t\t    SIS_TIM_ACT_OFF(drive);\n\t\tsis_tim |= sis_pio_rec[drvp->PIO_mode] <<\n\t\t    SIS_TIM_REC_OFF(drive);\n\t}\n\tWDCDEBUG_PRINT((\"sis_setup_channel: new timings reg for \"\n\t    \"channel %d 0x%x\\n\", chp->channel, sis_tim), DEBUG_PROBE);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, SIS_TIM(chp->channel), sis_tim);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "SIS_CTRL0",
            "sis_ctr0"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "pciide_pci_intr"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "SIS_MISC"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_REVISION",
          "args": [
            "pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t    PCI_CLASS_REG)"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid sis_chip_map;\nvoid sis_setup_channel;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\nint\tpciide_pci_intr;\n\nvoid\nsis_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tu_int8_t sis_ctr0 = pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_CTRL0);\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tpcireg_t rev = PCI_REVISION(pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\t\t    PCI_CLASS_REG));\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tif (rev >= 0xd0)\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t}\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA)\n\t\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = sis_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_MISC,\n\t    pciide_pci_read(sc->sc_pc, sc->sc_tag, SIS_MISC) |\n\t    SIS_MISC_TIM_SEL | SIS_MISC_FIFO_SIZE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\t\tif ((channel == 0 && (sis_ctr0 & SIS_CTRL0_CHAN0_EN) == 0) ||\n\t \t    (channel == 1 && (sis_ctr0 & SIS_CTRL0_CHAN1_EN) == 0)) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tif (channel == 0)\n\t\t\t\tsis_ctr0 &= ~SIS_CTRL0_CHAN0_EN;\n\t\t\telse\n\t\t\t\tsis_ctr0 &= ~SIS_CTRL0_CHAN1_EN;\n\t\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag, SIS_CTRL0,\n\t\t\t    sis_ctr0);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tsis_setup_channel(&cp->wdc_channel);\n\t}\n}"
  },
  {
    "function_name": "cy693_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2287-2334",
    "snippet": "void\ncy693_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t cy_cmd_ctrl;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint dma_mode = -1;\n\n\tcy_cmd_ctrl = idedma_ctl = 0;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t\t/* use Multiword DMA */\n\t\t\tif (dma_mode == -1 || dma_mode > drvp->DMA_mode)\n\t\t\t\tdma_mode = drvp->DMA_mode;\n\t\t}\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_REC_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_REC_OFF(drive));\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL, cy_cmd_ctrl);\n\tchp->ch_drive[0].DMA_mode = dma_mode;\n\tchp->ch_drive[1].DMA_mode = dma_mode;\n\tpciide_print_modes(cp);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void cy693_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL",
            "idedma_ctl"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CY_CMD_CTRL",
            "cy_cmd_ctrl"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CMD_CTRL_IOR_REC_OFF",
          "args": [
            "drive"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CMD_CTRL_IOR_PULSE_OFF",
          "args": [
            "drive"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CMD_CTRL_IOW_REC_OFF",
          "args": [
            "drive"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CMD_CTRL_IOW_PULSE_OFF",
          "args": [
            "drive"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid cy693_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\ncy693_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t cy_cmd_ctrl;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint dma_mode = -1;\n\n\tcy_cmd_ctrl = idedma_ctl = 0;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t\t/* use Multiword DMA */\n\t\t\tif (dma_mode == -1 || dma_mode > drvp->DMA_mode)\n\t\t\t\tdma_mode = drvp->DMA_mode;\n\t\t}\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_REC_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_REC_OFF(drive));\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL, cy_cmd_ctrl);\n\tchp->ch_drive[0].DMA_mode = dma_mode;\n\tchp->ch_drive[1].DMA_mode = dma_mode;\n\tpciide_print_modes(cp);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n}"
  },
  {
    "function_name": "cy693_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2208-2285",
    "snippet": "void\ncy693_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{       \n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint compatchan;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\t/*\n\t * this chip has 2 PCI IDE functions, one for primary and one for\n\t * secondary. So we need to call pciide_mapregs_compat() with\n\t * the real channel\n\t */\n\tif (pa->pa_function == 1) {\n\t\tcompatchan = 0;\n\t} else if (pa->pa_function == 2) {\n\t\tcompatchan = 1;\n\t} else {\n\t\tprintf(\"%s: unexpected PCI function %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);\n\t\treturn;\n\t}\n\tif (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {\n\t\tprintf(\": DMA\");\n\t\tpciide_mapreg_dma(sc, pa);\n\t} else {\n\t\tprintf(\": no DMA\");\n\t\tsc->sc_dma_ok = 0;\n\t}\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = cy693_setup_channel;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = 1;\n\n\t/* Only one channel for this chip; if we are here it's enabled */\n\tcp = &sc->pciide_channels[0];\n\t\tsc->wdc_chanarray[0] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(0);\n\tcp->wdc_channel.channel = 0;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s\"\n\t\t    \"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tcp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;\n\tcp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;\n\twdcattach(&cp->wdc_channel);\n\tif (pciiide_chan_candisable(cp)) {\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PCI_COMMAND_STATUS_REG, 0);\n\t}\n\tpciide_map_compat_intr(pa, cp, compatchan, interface);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tWDCDEBUG_PRINT((\"cy693_chip_map: old timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)),DEBUG_PROBE);\n\tcy693_setup_channel(&cp->wdc_channel);\n\tWDCDEBUG_PRINT((\"cy693_chip_map: new timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)), DEBUG_PROBE);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void cy693_chip_map",
      "void cy693_setup_channel",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "int\tpciide_mapregs_compat",
      "void\tpciide_mapreg_dma",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"cy693_chip_map: new timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL))",
            "DEBUG_PROBE"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CY_CMD_CTRL"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy693_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "cy693_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "2287-2334",
          "snippet": "void\ncy693_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t cy_cmd_ctrl;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint dma_mode = -1;\n\n\tcy_cmd_ctrl = idedma_ctl = 0;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t\t/* use Multiword DMA */\n\t\t\tif (dma_mode == -1 || dma_mode > drvp->DMA_mode)\n\t\t\t\tdma_mode = drvp->DMA_mode;\n\t\t}\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_REC_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_REC_OFF(drive));\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL, cy_cmd_ctrl);\n\tchp->ch_drive[0].DMA_mode = dma_mode;\n\tchp->ch_drive[1].DMA_mode = dma_mode;\n\tpciide_print_modes(cp);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void cy693_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid cy693_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\ncy693_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tint drive;\n\tu_int32_t cy_cmd_ctrl;\n\tu_int32_t idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint dma_mode = -1;\n\n\tcy_cmd_ctrl = idedma_ctl = 0;\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t\t/* use Multiword DMA */\n\t\t\tif (dma_mode == -1 || dma_mode > drvp->DMA_mode)\n\t\t\t\tdma_mode = drvp->DMA_mode;\n\t\t}\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOW_REC_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_pulse[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_PULSE_OFF(drive));\n\t\tcy_cmd_ctrl |= (cy_pio_rec[drvp->PIO_mode] <<\n\t\t    CY_CMD_CTRL_IOR_REC_OFF(drive));\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL, cy_cmd_ctrl);\n\tchp->ch_drive[0].DMA_mode = dma_mode;\n\tchp->ch_drive[1].DMA_mode = dma_mode;\n\tpciide_print_modes(cp);\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL, idedma_ctl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"cy693_chip_map: old timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL))",
            "DEBUG_PROBE"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CY_CMD_CTRL"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "compatchan",
            "interface"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG",
            "0"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcattach",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "wdcattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "469-657",
          "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int   wdprint",
            "int at_poll = AT_POLL;",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\"\n\t\t    \"cannot allocate memory for command queue\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct channel_queue)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHANNEL_NAME",
          "args": [
            "0"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid cy693_chip_map;\nvoid cy693_setup_channel;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nint\tpciide_mapregs_compat;\nvoid\tpciide_mapreg_dma;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\ncy693_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{       \n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint compatchan;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\t/*\n\t * this chip has 2 PCI IDE functions, one for primary and one for\n\t * secondary. So we need to call pciide_mapregs_compat() with\n\t * the real channel\n\t */\n\tif (pa->pa_function == 1) {\n\t\tcompatchan = 0;\n\t} else if (pa->pa_function == 2) {\n\t\tcompatchan = 1;\n\t} else {\n\t\tprintf(\"%s: unexpected PCI function %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, pa->pa_function);\n\t\treturn;\n\t}\n\tif (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {\n\t\tprintf(\": DMA\");\n\t\tpciide_mapreg_dma(sc, pa);\n\t} else {\n\t\tprintf(\": no DMA\");\n\t\tsc->sc_dma_ok = 0;\n\t}\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = cy693_setup_channel;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = 1;\n\n\t/* Only one channel for this chip; if we are here it's enabled */\n\tcp = &sc->pciide_channels[0];\n\t\tsc->wdc_chanarray[0] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(0);\n\tcp->wdc_channel.channel = 0;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s\"\n\t\t    \"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tcp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;\n\tcp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;\n\twdcattach(&cp->wdc_channel);\n\tif (pciiide_chan_candisable(cp)) {\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PCI_COMMAND_STATUS_REG, 0);\n\t}\n\tpciide_map_compat_intr(pa, cp, compatchan, interface);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tWDCDEBUG_PRINT((\"cy693_chip_map: old timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)),DEBUG_PROBE);\n\tcy693_setup_channel(&cp->wdc_channel);\n\tWDCDEBUG_PRINT((\"cy693_chip_map: new timings reg 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, CY_CMD_CTRL)), DEBUG_PROBE);\n}"
  },
  {
    "function_name": "cmd0643_6_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2161-2206",
    "snippet": "void\ncmd0643_6_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t tim;\n\tu_int32_t idedma_ctl;\n\tint drive;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\ttim = cmd0643_6_data_tim_pio[drvp->PIO_mode];\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\t/*\n\t\t\t * use Multiword DMA.\n\t\t\t * Timings will be used for both PIO and DMA, so adjust\n\t\t\t * DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode >= 3 &&\n\t\t\t    (drvp->DMA_mode + 2) > drvp->PIO_mode) {\n\t\t\t\tdrvp->DMA_mode = drvp->PIO_mode - 2;\n\t\t\t}\n\t\t\ttim = cmd0643_6_data_tim_dma[drvp->DMA_mode];\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    CMD_DATA_TIM(chp->channel, drive), tim);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void pciide_pci_write",
      "void cmd0643_6_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel)",
            "idedma_ctl"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CMD_DATA_TIM(chp->channel, drive)",
            "tim"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMD_DATA_TIM",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\nvoid cmd0643_6_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\ncmd0643_6_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t tim;\n\tu_int32_t idedma_ctl;\n\tint drive;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\ttim = cmd0643_6_data_tim_pio[drvp->PIO_mode];\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\t/*\n\t\t\t * use Multiword DMA.\n\t\t\t * Timings will be used for both PIO and DMA, so adjust\n\t\t\t * DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode >= 3 &&\n\t\t\t    (drvp->DMA_mode + 2) > drvp->PIO_mode) {\n\t\t\t\tdrvp->DMA_mode = drvp->PIO_mode - 2;\n\t\t\t}\n\t\t\ttim = cmd0643_6_data_tim_dma[drvp->DMA_mode];\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    CMD_DATA_TIM(chp->channel, drive), tim);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "cmd0643_6_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2104-2159",
    "snippet": "void\ncmd0643_6_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\t/*\n\t * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE\n\t * and base adresses registers can be disabled at\n\t * hardware level. In this case, the device is wired\n\t * in compat mode and its first channel is always enabled,\n \t * but we can't rely on PCI_COMMAND_IO_ENABLE.\n\t * In fact, it seems that the first channel of the CMD PCI0640\n\t * can't be disabled.\n\t*/\n\n#ifdef PCIIDE_CMD064x_DISABLE\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n#endif\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = cmd0643_6_setup_channel;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tWDCDEBUG_PRINT((\"cmd0643_6_chip_map: old timings reg 0x%x 0x%x\\n\",\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),\n\t\tDEBUG_PROBE);\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tcmd_channel_map(pa, sc, channel);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tcmd0643_6_setup_channel(&cp->wdc_channel);\n\t}\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_DMA_MODE, CMD_DMA_MULTIPLE);\n\tWDCDEBUG_PRINT((\"cmd0643_6_chip_map: timings reg now 0x%x 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),\n\t    DEBUG_PROBE);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "static __inline void pciide_pci_write",
      "void cmd0643_6_chip_map",
      "void cmd0643_6_setup_channel",
      "void cmd_channel_map",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"cmd0643_6_chip_map: timings reg now 0x%x 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x58))",
            "DEBUG_PROBE"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "0x58"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "0x54"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CMD_DMA_MODE",
            "CMD_DMA_MULTIPLE"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd0643_6_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "cmd0643_6_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "2161-2206",
          "snippet": "void\ncmd0643_6_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t tim;\n\tu_int32_t idedma_ctl;\n\tint drive;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\ttim = cmd0643_6_data_tim_pio[drvp->PIO_mode];\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\t/*\n\t\t\t * use Multiword DMA.\n\t\t\t * Timings will be used for both PIO and DMA, so adjust\n\t\t\t * DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode >= 3 &&\n\t\t\t    (drvp->DMA_mode + 2) > drvp->PIO_mode) {\n\t\t\t\tdrvp->DMA_mode = drvp->PIO_mode - 2;\n\t\t\t}\n\t\t\ttim = cmd0643_6_data_tim_dma[drvp->DMA_mode];\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    CMD_DATA_TIM(chp->channel, drive), tim);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "void cmd0643_6_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\nvoid cmd0643_6_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\ncmd0643_6_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t tim;\n\tu_int32_t idedma_ctl;\n\tint drive;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\ttim = cmd0643_6_data_tim_pio[drvp->PIO_mode];\n\t\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t\t/*\n\t\t\t * use Multiword DMA.\n\t\t\t * Timings will be used for both PIO and DMA, so adjust\n\t\t\t * DMA mode if needed\n\t\t\t */\n\t\t\tif (drvp->PIO_mode >= 3 &&\n\t\t\t    (drvp->DMA_mode + 2) > drvp->PIO_mode) {\n\t\t\t\tdrvp->DMA_mode = drvp->PIO_mode - 2;\n\t\t\t}\n\t\t\ttim = cmd0643_6_data_tim_dma[drvp->DMA_mode];\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tpciide_pci_write(sc->sc_pc, sc->sc_tag,\n\t\t    CMD_DATA_TIM(chp->channel, drive), tim);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_channel_map",
          "args": [
            "pa",
            "sc",
            "channel"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_channel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1978-2032",
          "snippet": "void\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read",
            "static __inline void pciide_pci_write",
            "void cmd_channel_map",
            "int  cmd_pci_intr",
            "__P((int, pcireg_t));",
            "void\tpciide_mapchan",
            "int\tpciiide_chan_candisable",
            "void\tpciide_map_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid cmd_channel_map;\nint  cmd_pci_intr;\n__P((int, pcireg_t));\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"cmd0643_6_chip_map: old timings reg 0x%x 0x%x\\n\",\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x58))",
            "DEBUG_PROBE"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "0x58"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "0x54"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": DMA\""
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic __inline void pciide_pci_write;\nvoid cmd0643_6_chip_map;\nvoid cmd0643_6_setup_channel;\nvoid cmd_channel_map;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\n\nvoid\ncmd0643_6_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\t/*\n\t * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE\n\t * and base adresses registers can be disabled at\n\t * hardware level. In this case, the device is wired\n\t * in compat mode and its first channel is always enabled,\n \t * but we can't rely on PCI_COMMAND_IO_ENABLE.\n\t * In fact, it seems that the first channel of the CMD PCI0640\n\t * can't be disabled.\n\t*/\n\n#ifdef PCIIDE_CMD064x_DISABLE\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n#endif\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = cmd0643_6_setup_channel;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tWDCDEBUG_PRINT((\"cmd0643_6_chip_map: old timings reg 0x%x 0x%x\\n\",\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t\tpci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),\n\t\tDEBUG_PROBE);\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tcmd_channel_map(pa, sc, channel);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tcmd0643_6_setup_channel(&cp->wdc_channel);\n\t}\n\tpciide_pci_write(sc->sc_pc, sc->sc_tag, CMD_DMA_MODE, CMD_DMA_MULTIPLE);\n\tWDCDEBUG_PRINT((\"cmd0643_6_chip_map: timings reg now 0x%x 0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x54),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, 0x58)),\n\t    DEBUG_PROBE);\n}"
  },
  {
    "function_name": "cmd_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2066-2102",
    "snippet": "void\ncmd_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tint channel;\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\t/*\n \t * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE\n\t * and base adresses registers can be disabled at\n \t * hardware level. In this case, the device is wired\n\t * in compat mode and its first channel is always enabled,\n\t * but we can't rely on PCI_COMMAND_IO_ENABLE.\n\t * In fact, it seems that the first channel of the CMD PCI0640\n\t * can't be disabled.\n \t */\n\n#ifdef PCIIDE_CMD064x_DISABLE\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n#endif\n\n\tprintf(\": no DMA\");\n\tsc->sc_dma_ok = 0;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcmd_channel_map(pa, sc, channel);\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void cmd_chip_map",
      "void cmd_channel_map",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_channel_map",
          "args": [
            "pa",
            "sc",
            "channel"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_channel_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1978-2032",
          "snippet": "void\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read",
            "static __inline void pciide_pci_write",
            "void cmd_channel_map",
            "int  cmd_pci_intr",
            "__P((int, pcireg_t));",
            "void\tpciide_mapchan",
            "int\tpciiide_chan_candisable",
            "void\tpciide_map_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid cmd_channel_map;\nint  cmd_pci_intr;\n__P((int, pcireg_t));\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": no DMA\""
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid cmd_chip_map;\nvoid cmd_channel_map;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nvoid\ncmd_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tint channel;\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\t/*\n \t * For a CMD PCI064x, the use of PCI_COMMAND_IO_ENABLE\n\t * and base adresses registers can be disabled at\n \t * hardware level. In this case, the device is wired\n\t * in compat mode and its first channel is always enabled,\n\t * but we can't rely on PCI_COMMAND_IO_ENABLE.\n\t * In fact, it seems that the first channel of the CMD PCI0640\n\t * can't be disabled.\n \t */\n\n#ifdef PCIIDE_CMD064x_DISABLE\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n#endif\n\n\tprintf(\": no DMA\");\n\tsc->sc_dma_ok = 0;\n\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcmd_channel_map(pa, sc, channel);\n\t}\n}"
  },
  {
    "function_name": "cmd_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "2034-2064",
    "snippet": "int\ncmd_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t priirq, secirq;\n\n\trv = 0;\n\tpriirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);\n\tsecirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif ((i == 0 && (priirq & CMD_CONF_DRV0_INTR)) ||\n\t\t    (i == 1 && (secirq & CMD_ARTTIM23_IRQ))) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "int  cmd_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d: bogus intr\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "i"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcintr",
          "args": [
            "wdc_cp"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "wdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "748-771",
          "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CMD_ARTTIM23"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nint  cmd_pci_intr;\n\nint\ncmd_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv; \n\tu_int32_t priirq, secirq;\n\n\trv = 0;\n\tpriirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CONF);\n\tsecirq = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_ARTTIM23);\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\tif ((i == 0 && (priirq & CMD_CONF_DRV0_INTR)) ||\n\t\t    (i == 1 && (secirq & CMD_ARTTIM23_IRQ))) {\n\t\t\tcrv = wdcintr(wdc_cp);\n\t\t\tif (crv == 0)\n\t\t\t\tprintf(\"%s:%d: bogus intr\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, i);\n\t\t\telse\n\t\t\t\trv = 1;\n\t\t}\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "cmd_channel_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1978-2032",
    "snippet": "void\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read",
      "static __inline void pciide_pci_write",
      "void cmd_channel_map",
      "int  cmd_pci_intr",
      "__P((int, pcireg_t));",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_pci_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "CMD_CTRL",
            "ctrl"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "143-156",
          "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void pciide_pci_write",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "cmd_pci_intr"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct channel_queue)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHANNEL_NAME",
          "args": [
            "channel"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_pci_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "CMD_CTRL"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_pci_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "132-141",
          "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline u_int8_t pciide_pci_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\nstatic __inline void pciide_pci_write;\nvoid cmd_channel_map;\nint  cmd_pci_intr;\n__P((int, pcireg_t));\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\n\nvoid\ncmd_channel_map(pa, sc, channel)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_softc *sc;\n\tint channel;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tbus_size_t cmdsize, ctlsize;\n\tu_int8_t ctrl = pciide_pci_read(sc->sc_pc, sc->sc_tag, CMD_CTRL);\n\tpcireg_t interface =\n\t    PCI_INTERFACE(pci_conf_read(sc->sc_pc, sc->sc_tag, PCI_CLASS_REG));\n\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\n\tif (channel > 0) {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    sc->pciide_channels[0].wdc_channel.ch_queue;\n\t} else {\n\t\tcp->wdc_channel.ch_queue =\n\t\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\t}\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\n\t\t    \"%s: %s cannot allocate memory for command queue\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\t/*\n\t * with a CMD PCI64x, if we get here, the first channel is enabled:\n\t * there's no way to disable the first channel without disabling\n\t * the whole device\n\t */\n\t if (channel != 0 && (ctrl & CMD_CTRL_2PORT) == 0) {\n\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn;\n\t}\n\n\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize, cmd_pci_intr);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif (channel == 1) {\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tctrl &= ~CMD_CTRL_2PORT;\n\t\t\tpciide_pci_write(pa->pa_pc, pa->pa_tag,\n\t\t\t    CMD_CTRL, ctrl);\n\t\t}\n\t}\n\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n}"
  },
  {
    "function_name": "apollo_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1900-1976",
    "snippet": "void\napollo_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);\n\tdatatim_reg &= ~APO_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AP0_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= APO_UDMA_EN(chp->channel, drive) |\n\t\t\t    APO_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    APO_UDMA_TIME(chp->channel, drive,\n\t\t\t\tapollo_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    APO_DATATIM_PULSE(chp->channel, drive,\n\t\t\tapollo_pio_set[mode]) |\n\t\t    APO_DATATIM_RECOV(chp->channel, drive,\n\t\t\tapollo_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void apollo_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_UDMA",
            "udmatim_reg"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_DATATIM",
            "datatim_reg"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel)",
            "idedma_ctl"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_DATATIM_RECOV",
          "args": [
            "chp->channel",
            "drive",
            "apollo_pio_rec[mode]"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_DATATIM_PULSE",
          "args": [
            "chp->channel",
            "drive",
            "apollo_pio_set[mode]"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_UDMA_TIME",
          "args": [
            "chp->channel",
            "drive",
            "apollo_udma_tim[drvp->UDMA_mode]"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_UDMA_EN_MTH",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_UDMA_EN",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AP0_UDMA_MASK",
          "args": [
            "chp->channel"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_DATATIM_MASK",
          "args": [
            "chp->channel"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_UDMA"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_DATATIM"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid apollo_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\napollo_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);\n\tdatatim_reg &= ~APO_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AP0_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= APO_UDMA_EN(chp->channel, drive) |\n\t\t\t    APO_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    APO_UDMA_TIME(chp->channel, drive,\n\t\t\t\tapollo_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    APO_DATATIM_PULSE(chp->channel, drive,\n\t\t\tapollo_pio_set[mode]) |\n\t\t    APO_DATATIM_RECOV(chp->channel, drive,\n\t\t\tapollo_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);\n}"
  },
  {
    "function_name": "apollo_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1829-1898",
    "snippet": "void\napollo_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint channel;\n\tu_int32_t ideconf;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C586A_IDE)\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t}\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = apollo_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\t\n\tWDCDEBUG_PRINT((\"apollo_chip_map: old APO_IDECONF=0x%x, \"\n\t    \"APO_CTLMISC=0x%x, APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_CTLMISC),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)),\n\t    DEBUG_PROBE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\n\t\tideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF);\n\t\tif ((ideconf & APO_IDECONF_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tideconf &= ~APO_IDECONF_EN(channel);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_IDECONF,\n\t\t\t\t    ideconf);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tapollo_setup_channel(&sc->pciide_channels[channel].wdc_channel);\n\t}\n\tWDCDEBUG_PRINT((\"apollo_chip_map: APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)), DEBUG_PROBE);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void apollo_chip_map",
      "void apollo_setup_channel",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr",
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"apollo_chip_map: APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA))",
            "DEBUG_PROBE"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_UDMA"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_DATATIM"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apollo_setup_channel",
          "args": [
            "&sc->pciide_channels[channel].wdc_channel"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "apollo_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1900-1976",
          "snippet": "void\napollo_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);\n\tdatatim_reg &= ~APO_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AP0_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= APO_UDMA_EN(chp->channel, drive) |\n\t\t\t    APO_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    APO_UDMA_TIME(chp->channel, drive,\n\t\t\t\tapollo_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    APO_DATATIM_PULSE(chp->channel, drive,\n\t\t\tapollo_pio_set[mode]) |\n\t\t    APO_DATATIM_RECOV(chp->channel, drive,\n\t\t\tapollo_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void apollo_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid apollo_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\napollo_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA);\n\tdatatim_reg &= ~APO_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AP0_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= APO_UDMA_EN(chp->channel, drive) |\n\t\t\t    APO_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    APO_UDMA_TIME(chp->channel, drive,\n\t\t\t\tapollo_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    APO_DATATIM_PULSE(chp->channel, drive,\n\t\t\tapollo_pio_set[mode]) |\n\t\t    APO_DATATIM_RECOV(chp->channel, drive,\n\t\t\tapollo_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_UDMA, udmatim_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_IDECONF",
            "ideconf"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APO_IDECONF_EN",
          "args": [
            "channel"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "pciide_pci_intr"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "APO_IDECONF_EN",
          "args": [
            "channel"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_IDECONF"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"apollo_chip_map: old APO_IDECONF=0x%x, \"\n\t    \"APO_CTLMISC=0x%x, APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_CTLMISC),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA))",
            "DEBUG_PROBE"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_UDMA"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_DATATIM"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_CTLMISC"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "APO_IDECONF"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid apollo_chip_map;\nvoid apollo_setup_channel;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\nint\tpciide_pci_intr;\n\nvoid\napollo_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint channel;\n\tu_int32_t ideconf;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_VIATECH_VT82C586A_IDE)\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t}\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32 | WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 2;\n\tsc->sc_wdcdev.set_modes = apollo_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\t\n\tWDCDEBUG_PRINT((\"apollo_chip_map: old APO_IDECONF=0x%x, \"\n\t    \"APO_CTLMISC=0x%x, APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_CTLMISC),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)),\n\t    DEBUG_PROBE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\n\t\tideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, APO_IDECONF);\n\t\tif ((ideconf & APO_IDECONF_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tideconf &= ~APO_IDECONF_EN(channel);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, APO_IDECONF,\n\t\t\t\t    ideconf);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tapollo_setup_channel(&sc->pciide_channels[channel].wdc_channel);\n\t}\n\tWDCDEBUG_PRINT((\"apollo_chip_map: APO_DATATIM=0x%x, APO_UDMA=0x%x\\n\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_DATATIM),\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, APO_UDMA)), DEBUG_PROBE);\n}"
  },
  {
    "function_name": "amd756_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1751-1827",
    "snippet": "void\namd756_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);\n\tdatatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_TIME(chp->channel, drive,\n\t\t\t\tamd756_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    AMD756_DATATIM_PULSE(chp->channel, drive,\n\t\t\tamd756_pio_set[mode]) |\n\t\t    AMD756_DATATIM_RECOV(chp->channel, drive,\n\t\t\tamd756_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void amd756_setup_channel",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_UDMA",
            "udmatim_reg"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_DATATIM",
            "datatim_reg"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel)",
            "idedma_ctl"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_DATATIM_RECOV",
          "args": [
            "chp->channel",
            "drive",
            "amd756_pio_rec[mode]"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_DATATIM_PULSE",
          "args": [
            "chp->channel",
            "drive",
            "amd756_pio_set[mode]"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_UDMA_TIME",
          "args": [
            "chp->channel",
            "drive",
            "amd756_udma_tim[drvp->UDMA_mode]"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_UDMA_EN_MTH",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_UDMA_EN",
          "args": [
            "chp->channel",
            "drive"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMD756_UDMA_MASK",
          "args": [
            "chp->channel"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AMD756_DATATIM_MASK",
          "args": [
            "chp->channel"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_UDMA"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_DATATIM"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid amd756_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\namd756_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);\n\tdatatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_TIME(chp->channel, drive,\n\t\t\t\tamd756_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    AMD756_DATATIM_PULSE(chp->channel, drive,\n\t\t\tamd756_pio_set[mode]) |\n\t\t    AMD756_DATATIM_RECOV(chp->channel, drive,\n\t\t\tamd756_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);\n}"
  },
  {
    "function_name": "amd756_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1693-1749",
    "snippet": "void\namd756_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint channel;\n\tpcireg_t chanenable;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t\t\t     WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 4;\n\tsc->sc_wdcdev.set_modes = amd756_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tchanenable = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN);\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\n\t\tif ((chanenable & AMD756_CHAN_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\n\t\tif (pciiide_chan_candisable(cp))\n\t\t\tchanenable &= ~AMD756_CHAN_EN(channel);\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\n\t\tamd756_setup_channel(&cp->wdc_channel);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN,\n\t    chanenable);\n\treturn;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void amd756_chip_map",
      "void amd756_setup_channel",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr",
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_CHANSTATUS_EN",
            "chanenable"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amd756_setup_channel",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "amd756_setup_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1751-1827",
          "snippet": "void\namd756_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);\n\tdatatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_TIME(chp->channel, drive,\n\t\t\t\tamd756_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    AMD756_DATATIM_PULSE(chp->channel, drive,\n\t\t\tamd756_pio_set[mode]) |\n\t\t    AMD756_DATATIM_RECOV(chp->channel, drive,\n\t\t\tamd756_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void amd756_setup_channel",
            "void pciide_channel_dma_setup",
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid amd756_setup_channel;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\namd756_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int32_t udmatim_reg, datatim_reg;\n\tu_int8_t idedma_ctl;\n\tint mode, drive;\n\tstruct ata_drive_datas *drvp;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\n\tidedma_ctl = 0;\n\tdatatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_DATATIM);\n\tudmatim_reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_UDMA);\n\tdatatim_reg &= ~AMD756_DATATIM_MASK(chp->channel);\n\tudmatim_reg &= ~AMD756_UDMA_MASK(chp->channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* add timing values, setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0)) {\n\t\t\tmode = drvp->PIO_mode;\n\t\t\tgoto pio;\n\t\t}\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmatim_reg |= AMD756_UDMA_EN(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_EN_MTH(chp->channel, drive) |\n\t\t\t    AMD756_UDMA_TIME(chp->channel, drive,\n\t\t\t\tamd756_udma_tim[drvp->UDMA_mode]);\n\t\t\t/* can use PIO timings, MW DMA unused */\n\t\t\tmode = drvp->PIO_mode;\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\t/* mode = min(pio, dma+2) */\n\t\t\tif (drvp->PIO_mode <= (drvp->DMA_mode +2))\n\t\t\t\tmode = drvp->PIO_mode;\n\t\t\telse\n\t\t\t\tmode = drvp->DMA_mode + 2;\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\npio:\t\t/* setup PIO mode */\n\t\tif (mode <= 2) {\n\t\t\tdrvp->DMA_mode = 0;\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\tdrvp->PIO_mode = mode;\n\t\t\tdrvp->DMA_mode = mode - 2;\n\t\t}\n\t\tdatatim_reg |=\n\t\t    AMD756_DATATIM_PULSE(chp->channel, drive,\n\t\t\tamd756_pio_set[mode]) |\n\t\t    AMD756_DATATIM_RECOV(chp->channel, drive,\n\t\t\tamd756_pio_rec[mode]);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpciide_print_modes(cp);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_DATATIM, datatim_reg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_UDMA, udmatim_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMD756_CHAN_EN",
          "args": [
            "channel"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "interface",
            "&cmdsize",
            "&ctlsize",
            "pciide_pci_intr"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AMD756_CHAN_EN",
          "args": [
            "channel"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "AMD756_CHANSTATUS_EN"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid amd756_chip_map;\nvoid amd756_setup_channel;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\nint\tpciide_pci_intr;\n\nvoid\namd756_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tint channel;\n\tpcireg_t chanenable;\n\tbus_size_t cmdsize, ctlsize;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA | WDC_CAPABILITY_UDMA;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t\t\t     WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap = 4;\n\tsc->sc_wdcdev.set_modes = amd756_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tchanenable = pci_conf_read(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN);\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t\tcontinue;\n\n\t\tif ((chanenable & AMD756_CHAN_EN(channel)) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\tpciide_mapchan(pa, cp, interface, &cmdsize, &ctlsize,\n\t\t    pciide_pci_intr);\n\n\t\tif (pciiide_chan_candisable(cp))\n\t\t\tchanenable &= ~AMD756_CHAN_EN(channel);\n\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\n\t\tamd756_setup_channel(&cp->wdc_channel);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, AMD756_CHANSTATUS_EN,\n\t    chanenable);\n\treturn;\n}"
  },
  {
    "function_name": "piix_setup_sidetim_timings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1679-1691",
    "snippet": "static u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int32_t piix_setup_sidetim_timings"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_RTC_SET",
          "args": [
            "piix_rtc_pio[mode]",
            "channel"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_ISP_SET",
          "args": [
            "piix_isp_pio[mode]",
            "channel"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_RTC_SET",
          "args": [
            "piix_rtc_dma[mode]",
            "channel"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_ISP_SET",
          "args": [
            "piix_isp_dma[mode]",
            "channel"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_sidetim_timings;\n\nstatic u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}"
  },
  {
    "function_name": "piix_setup_idetim_drvs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1623-1676",
    "snippet": "static u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int32_t piix_setup_idetim_drvs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "ret",
            "PIIX_IDETIM_PPE(drive)",
            "channel"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_PPE",
          "args": [
            "drive"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "ret",
            "PIIX_IDETIM_IE(drive)",
            "channel"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_IE",
          "args": [
            "drive"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "ret",
            "PIIX_IDETIM_TIME(drive)",
            "channel"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_TIME",
          "args": [
            "drive"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "ret",
            "PIIX_IDETIM_DTE(drive)",
            "channel"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_DTE",
          "args": [
            "drive"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "ret",
            "PIIX_IDETIM_TIME(drive)",
            "channel"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_TIME",
          "args": [
            "drive"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_drvs;\n\nstatic u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "piix_setup_idetim_timings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1603-1620",
    "snippet": "static u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int32_t piix_setup_idetim_timings"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "0",
            "PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode])",
            "channel"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_RTC_SET",
          "args": [
            "piix_rtc_pio[mode]"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_ISP_SET",
          "args": [
            "piix_isp_pio[mode]"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "0",
            "PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode])",
            "channel"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_RTC_SET",
          "args": [
            "piix_rtc_dma[mode]"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_ISP_SET",
          "args": [
            "piix_isp_dma[mode]"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_timings;\n\nstatic u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}"
  },
  {
    "function_name": "piix3_4_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1499-1599",
    "snippet": "void\npiix3_4_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int32_t oidetim, idetim, sidetim, udmareg, ideconf, idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tint channel = chp->channel;\n\n\toidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\tsidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM);\n\tudmareg = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG);\n\tideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG);\n\tidetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, channel);\n\tsidetim &= ~(PIIX_SIDETIM_ISP_MASK(channel) |\n\t    PIIX_SIDETIM_RTC_MASK(channel));\n\n\tidedma_ctl = 0;\n\t/* If channel disabled, no need to go further */\n\tif ((PIIX_IDETIM_READ(oidetim, channel) & PIIX_IDETIM_IDE) == 0)\n\t\treturn;\n\t/* set up new idetim: Enable IDE registers decode */\n\tidetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE, channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tudmareg &= ~(PIIX_UDMACTL_DRV_EN(channel, drive) |\n\t\t    PIIX_UDMATIM_SET(0x3, channel, drive));\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0))\n\t\t\tgoto pio;\n\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t    ideconf |= PIIX_CONFIG_PINGPONG;\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) {\n\t\t\t/* setup Ultra/66 */\n\t\t\tif (drvp->UDMA_mode > 2 &&\n\t\t\t    (ideconf & PIIX_CONFIG_CR(channel, drive)) == 0)\n\t\t\t\tdrvp->UDMA_mode = 2;\n\t\t\tif (drvp->UDMA_mode > 2)\n\t\t\t\tideconf |= PIIX_CONFIG_UDMA66(channel, drive);\n\t\t\telse\n\t\t\t\tideconf &= ~PIIX_CONFIG_UDMA66(channel, drive);\n\t\t}\n\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmareg |= PIIX_UDMACTL_DRV_EN( channel,drive);\n\t\t\tudmareg |= PIIX_UDMATIM_SET(\n\t\t\t    piix4_sct_udma[drvp->UDMA_mode], channel, drive);\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\tif (drive == 0) {\n\t\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t\t    drvp->DMA_mode, 1, channel);\n\t\t\t} else {\n\t\t\t\tsidetim |= piix_setup_sidetim_timings(\n\t\t\t\t\tdrvp->DMA_mode, 1, channel);\n\t\t\t\tidetim =PIIX_IDETIM_SET(idetim,\n\t\t\t\t    PIIX_IDETIM_SITRE, channel);\n\t\t\t}\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\npio:\t\t/* use PIO mode */\n\t\tidetim |= piix_setup_idetim_drvs(drvp);\n\t\tif (drive == 0) {\n\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t    drvp->PIO_mode, 0, channel);\n\t\t} else {\n\t\t\tsidetim |= piix_setup_sidetim_timings(\n\t\t\t\tdrvp->PIO_mode, 0, channel);\n\t\t\tidetim =PIIX_IDETIM_SET(idetim,\n\t\t\t    PIIX_IDETIM_SITRE, channel);\n\t\t}\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),\n\t\t    idedma_ctl);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM, sidetim);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG, udmareg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_CONFIG, ideconf);\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void piix3_4_setup_channel",
      "static u_int32_t piix_setup_idetim_timings",
      "static u_int32_t piix_setup_idetim_drvs",
      "static u_int32_t piix_setup_sidetim_timings",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_CONFIG",
            "ideconf"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_UDMAREG",
            "udmareg"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_SIDETIM",
            "sidetim"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM",
            "idetim"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel)",
            "idedma_ctl"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "idetim",
            "PIIX_IDETIM_SITRE",
            "channel"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "piix_setup_sidetim_timings",
          "args": [
            "drvp->PIO_mode",
            "0",
            "channel"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_sidetim_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1679-1691",
          "snippet": "static u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_sidetim_timings"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_sidetim_timings;\n\nstatic u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "piix_setup_idetim_timings",
          "args": [
            "drvp->PIO_mode",
            "0",
            "channel"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_idetim_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1603-1620",
          "snippet": "static u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_idetim_timings"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_timings;\n\nstatic u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "piix_setup_idetim_drvs",
          "args": [
            "drvp"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_idetim_drvs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1623-1676",
          "snippet": "static u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_idetim_drvs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_drvs;\n\nstatic u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "idetim",
            "PIIX_IDETIM_SITRE",
            "channel"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_UDMATIM_SET",
          "args": [
            "piix4_sct_udma[drvp->UDMA_mode]",
            "channel",
            "drive"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_UDMACTL_DRV_EN",
          "args": [
            "channel",
            "drive"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_CONFIG_UDMA66",
          "args": [
            "channel",
            "drive"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_CONFIG_UDMA66",
          "args": [
            "channel",
            "drive"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_CONFIG_CR",
          "args": [
            "channel",
            "drive"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_UDMATIM_SET",
          "args": [
            "0x3",
            "channel",
            "drive"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_UDMACTL_DRV_EN",
          "args": [
            "channel",
            "drive"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "idetim",
            "PIIX_IDETIM_IDE",
            "channel"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_READ",
          "args": [
            "oidetim",
            "channel"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_RTC_MASK",
          "args": [
            "channel"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_SIDETIM_ISP_MASK",
          "args": [
            "channel"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_CLEAR",
          "args": [
            "oidetim",
            "0xffff",
            "channel"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_CONFIG"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_UDMAREG"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_SIDETIM"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid piix3_4_setup_channel;\nstatic u_int32_t piix_setup_idetim_timings;\nstatic u_int32_t piix_setup_idetim_drvs;\nstatic u_int32_t piix_setup_sidetim_timings;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\npiix3_4_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct ata_drive_datas *drvp;\n\tu_int32_t oidetim, idetim, sidetim, udmareg, ideconf, idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tint channel = chp->channel;\n\n\toidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\tsidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM);\n\tudmareg = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG);\n\tideconf = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG);\n\tidetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, channel);\n\tsidetim &= ~(PIIX_SIDETIM_ISP_MASK(channel) |\n\t    PIIX_SIDETIM_RTC_MASK(channel));\n\n\tidedma_ctl = 0;\n\t/* If channel disabled, no need to go further */\n\tif ((PIIX_IDETIM_READ(oidetim, channel) & PIIX_IDETIM_IDE) == 0)\n\t\treturn;\n\t/* set up new idetim: Enable IDE registers decode */\n\tidetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE, channel);\n\n\t/* setup DMA if needed */\n\tpciide_channel_dma_setup(cp);\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tudmareg &= ~(PIIX_UDMACTL_DRV_EN(channel, drive) |\n\t\t    PIIX_UDMATIM_SET(0x3, channel, drive));\n\t\tdrvp = &chp->ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0))\n\t\t\tgoto pio;\n\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t    ideconf |= PIIX_CONFIG_PINGPONG;\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) {\n\t\t\t/* setup Ultra/66 */\n\t\t\tif (drvp->UDMA_mode > 2 &&\n\t\t\t    (ideconf & PIIX_CONFIG_CR(channel, drive)) == 0)\n\t\t\t\tdrvp->UDMA_mode = 2;\n\t\t\tif (drvp->UDMA_mode > 2)\n\t\t\t\tideconf |= PIIX_CONFIG_UDMA66(channel, drive);\n\t\t\telse\n\t\t\t\tideconf &= ~PIIX_CONFIG_UDMA66(channel, drive);\n\t\t}\n\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_UDMA) &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA)) {\n\t\t\t/* use Ultra/DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\tudmareg |= PIIX_UDMACTL_DRV_EN( channel,drive);\n\t\t\tudmareg |= PIIX_UDMATIM_SET(\n\t\t\t    piix4_sct_udma[drvp->UDMA_mode], channel, drive);\n\t\t} else {\n\t\t\t/* use Multiword DMA */\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t\tif (drive == 0) {\n\t\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t\t    drvp->DMA_mode, 1, channel);\n\t\t\t} else {\n\t\t\t\tsidetim |= piix_setup_sidetim_timings(\n\t\t\t\t\tdrvp->DMA_mode, 1, channel);\n\t\t\t\tidetim =PIIX_IDETIM_SET(idetim,\n\t\t\t\t    PIIX_IDETIM_SITRE, channel);\n\t\t\t}\n\t\t}\n\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\npio:\t\t/* use PIO mode */\n\t\tidetim |= piix_setup_idetim_drvs(drvp);\n\t\tif (drive == 0) {\n\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t    drvp->PIO_mode, 0, channel);\n\t\t} else {\n\t\t\tsidetim |= piix_setup_sidetim_timings(\n\t\t\t\tdrvp->PIO_mode, 0, channel);\n\t\t\tidetim =PIIX_IDETIM_SET(idetim,\n\t\t\t    PIIX_IDETIM_SITRE, channel);\n\t\t}\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),\n\t\t    idedma_ctl);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM, sidetim);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG, udmareg);\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_CONFIG, ideconf);\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "piix_setup_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1390-1497",
    "snippet": "void\npiix_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t mode[2], drive;\n\tu_int32_t oidetim, idetim, idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp = cp->wdc_channel.ch_drive;\n \n\toidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\tidetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, chp->channel);\n\tidedma_ctl = 0;\n\n\t/* set up new idetim: Enable IDE registers decode */\n\tidetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE,\n\t    chp->channel);\n\n\t/* setup DMA */\n\tpciide_channel_dma_setup(cp);\n\n\t/*\n\t * Here we have to mess up with drives mode: PIIX can't have\n\t * different timings for master and slave drives.\n\t * We need to find the best combination.\n\t */\n\n\t/* If both drives supports DMA, take the lower mode */\n\tif ((drvp[0].drive_flags & DRIVE_DMA) &&\n\t    (drvp[1].drive_flags & DRIVE_DMA)) {\n\t\tmode[0] = mode[1] =\n\t\t    min(drvp[0].DMA_mode, drvp[1].DMA_mode);\n\t\t    drvp[0].DMA_mode = mode[0];\n\t\t    drvp[1].DMA_mode = mode[1];\n\t\tgoto ok;\n\t}\n\t/*\n\t * If only one drive supports DMA, use its mode, and\n\t * put the other one in PIO mode 0 if mode not compatible\n\t */\n\tif (drvp[0].drive_flags & DRIVE_DMA) {\n\t\tmode[0] = drvp[0].DMA_mode;\n\t\tmode[1] = drvp[1].PIO_mode;\n\t\tif (piix_isp_pio[mode[1]] != piix_isp_dma[mode[0]] ||\n\t\t    piix_rtc_pio[mode[1]] != piix_rtc_dma[mode[0]])\n\t\t\tmode[1] = drvp[1].PIO_mode = 0;\n\t\tgoto ok;\n\t}\n\tif (drvp[1].drive_flags & DRIVE_DMA) {\n\t\tmode[1] = drvp[1].DMA_mode;\n\t\tmode[0] = drvp[0].PIO_mode;\n\t\tif (piix_isp_pio[mode[0]] != piix_isp_dma[mode[1]] ||\n\t\t    piix_rtc_pio[mode[0]] != piix_rtc_dma[mode[1]])\n\t\t\tmode[0] = drvp[0].PIO_mode = 0;\n\t\tgoto ok;\n\t}\n\t/*\n\t * If both drives are not DMA, takes the lower mode, unless\n\t * one of them is PIO mode < 2\n\t */\n\tif (drvp[0].PIO_mode < 2) {\n\t\tmode[0] = drvp[0].PIO_mode = 0;\n\t\tmode[1] = drvp[1].PIO_mode;\n\t} else if (drvp[1].PIO_mode < 2) {\n\t\tmode[1] = drvp[1].PIO_mode = 0;\n\t\tmode[0] = drvp[0].PIO_mode;\n\t} else {\n\t\tmode[0] = mode[1] =\n\t\t    min(drvp[1].PIO_mode, drvp[0].PIO_mode);\n\t\tdrvp[0].PIO_mode = mode[0];\n\t\tdrvp[1].PIO_mode = mode[1];\n\t}\nok:\t/* The modes are setup */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif (drvp[drive].drive_flags & DRIVE_DMA) {\n\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t    mode[drive], 1, chp->channel);\n\t\t\tgoto end;\n\t\t}\n\t}\n\t/* If we are there, none of the drives are DMA */\n\tif (mode[0] >= 2)\n\t\tidetim |= piix_setup_idetim_timings(\n\t\t    mode[0], 0, chp->channel);\n\telse \n\t\tidetim |= piix_setup_idetim_timings(\n\t\t    mode[1], 0, chp->channel);\nend:\t/*\n\t * timing mode is now set up in the controller. Enable\n\t * it per-drive\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\t/* If no drive, skip */\n\t\tif ((drvp[drive].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tidetim |= piix_setup_idetim_drvs(&drvp[drive]);\n\t\tif (drvp[drive].drive_flags & DRIVE_DMA)\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);\n\tpciide_print_modes(cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void piix_setup_channel",
      "static u_int32_t piix_setup_idetim_timings",
      "static u_int32_t piix_setup_idetim_drvs",
      "void pciide_channel_dma_setup",
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_print_modes",
          "args": [
            "cp"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1110-1136",
          "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_modes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM",
            "idetim"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel)",
            "idedma_ctl"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "piix_setup_idetim_drvs",
          "args": [
            "&drvp[drive]"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_idetim_drvs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1623-1676",
          "snippet": "static u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_idetim_drvs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_drvs;\n\nstatic u_int32_t\npiix_setup_idetim_drvs(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tu_int32_t ret = 0;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tu_int8_t channel = chp->channel;\n\tu_int8_t drive = drvp->drive;\n\n\t/*\n\t * If drive is using UDMA, timings setups are independant\n\t * So just check DMA and PIO here.\n\t */\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\t/* if mode = DMA mode 0, use compatible timings */\n\t\tif ((drvp->drive_flags & DRIVE_DMA) &&\n\t\t    drvp->DMA_mode == 0) {\n\t\t\tdrvp->PIO_mode = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\t\t/*\n\t\t * PIO and DMA timings are the same, use fast timings for PIO\n\t\t * too, else use compat timings.\n\t\t */\n\t\tif ((piix_isp_pio[drvp->PIO_mode] !=\n\t\t    piix_isp_dma[drvp->DMA_mode]) ||\n\t\t    (piix_rtc_pio[drvp->PIO_mode] !=\n\t\t    piix_rtc_dma[drvp->DMA_mode]))\n\t\t\tdrvp->PIO_mode = 0;\n\t\t/* if PIO mode <= 2, use compat timings for PIO */\n\t\tif (drvp->PIO_mode <= 2) {\n\t\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_DTE(drive),\n\t\t\t    channel);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * Now setup PIO modes. If mode < 2, use compat timings.\n\t * Else enable fast timings. Enable IORDY and prefetch/post\n\t * if PIO mode >= 3.\n\t */\n\n\tif (drvp->PIO_mode < 2)\n\t\treturn ret;\n\n\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_TIME(drive), channel);\n\tif (drvp->PIO_mode >= 3) {\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_IE(drive), channel);\n\t\tret = PIIX_IDETIM_SET(ret, PIIX_IDETIM_PPE(drive), channel);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "piix_setup_idetim_timings",
          "args": [
            "mode[1]",
            "0",
            "chp->channel"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_idetim_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1603-1620",
          "snippet": "static u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_idetim_timings"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_idetim_timings;\n\nstatic u_int32_t\npiix_setup_idetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\t\n\tif (dma)\n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_dma[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_dma[mode]),\n\t\t    channel);\n\telse \n\t\treturn PIIX_IDETIM_SET(0,\n\t\t    PIIX_IDETIM_ISP_SET(piix_isp_pio[mode]) | \n\t\t    PIIX_IDETIM_RTC_SET(piix_rtc_pio[mode]),\n\t\t    channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "drvp[1].PIO_mode",
            "drvp[0].PIO_mode"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "piix_setup_sidetim_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1679-1691",
          "snippet": "static u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t piix_setup_sidetim_timings"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic u_int32_t piix_setup_sidetim_timings;\n\nstatic u_int32_t\npiix_setup_sidetim_timings(mode, dma, channel)\n\tu_int8_t mode;\n\tu_int8_t dma;\n\tu_int8_t channel;\n{\n\tif (dma)\n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_dma[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_dma[mode], channel);\n\telse \n\t\treturn PIIX_SIDETIM_ISP_SET(piix_isp_pio[mode], channel) |\n\t\t    PIIX_SIDETIM_RTC_SET(piix_rtc_pio[mode], channel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_channel_dma_setup",
          "args": [
            "cp"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_channel_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "721-748",
          "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_channel_dma_setup",
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_SET",
          "args": [
            "idetim",
            "PIIX_IDETIM_IDE",
            "chp->channel"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_CLEAR",
          "args": [
            "oidetim",
            "0xffff",
            "chp->channel"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid piix_setup_channel;\nstatic u_int32_t piix_setup_idetim_timings;\nstatic u_int32_t piix_setup_idetim_drvs;\nvoid pciide_channel_dma_setup;\nvoid pciide_print_modes;\n\nvoid\npiix_setup_channel(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t mode[2], drive;\n\tu_int32_t oidetim, idetim, idedma_ctl;\n\tstruct pciide_channel *cp = (struct pciide_channel*)chp;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp = cp->wdc_channel.ch_drive;\n \n\toidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\tidetim = PIIX_IDETIM_CLEAR(oidetim, 0xffff, chp->channel);\n\tidedma_ctl = 0;\n\n\t/* set up new idetim: Enable IDE registers decode */\n\tidetim = PIIX_IDETIM_SET(idetim, PIIX_IDETIM_IDE,\n\t    chp->channel);\n\n\t/* setup DMA */\n\tpciide_channel_dma_setup(cp);\n\n\t/*\n\t * Here we have to mess up with drives mode: PIIX can't have\n\t * different timings for master and slave drives.\n\t * We need to find the best combination.\n\t */\n\n\t/* If both drives supports DMA, take the lower mode */\n\tif ((drvp[0].drive_flags & DRIVE_DMA) &&\n\t    (drvp[1].drive_flags & DRIVE_DMA)) {\n\t\tmode[0] = mode[1] =\n\t\t    min(drvp[0].DMA_mode, drvp[1].DMA_mode);\n\t\t    drvp[0].DMA_mode = mode[0];\n\t\t    drvp[1].DMA_mode = mode[1];\n\t\tgoto ok;\n\t}\n\t/*\n\t * If only one drive supports DMA, use its mode, and\n\t * put the other one in PIO mode 0 if mode not compatible\n\t */\n\tif (drvp[0].drive_flags & DRIVE_DMA) {\n\t\tmode[0] = drvp[0].DMA_mode;\n\t\tmode[1] = drvp[1].PIO_mode;\n\t\tif (piix_isp_pio[mode[1]] != piix_isp_dma[mode[0]] ||\n\t\t    piix_rtc_pio[mode[1]] != piix_rtc_dma[mode[0]])\n\t\t\tmode[1] = drvp[1].PIO_mode = 0;\n\t\tgoto ok;\n\t}\n\tif (drvp[1].drive_flags & DRIVE_DMA) {\n\t\tmode[1] = drvp[1].DMA_mode;\n\t\tmode[0] = drvp[0].PIO_mode;\n\t\tif (piix_isp_pio[mode[0]] != piix_isp_dma[mode[1]] ||\n\t\t    piix_rtc_pio[mode[0]] != piix_rtc_dma[mode[1]])\n\t\t\tmode[0] = drvp[0].PIO_mode = 0;\n\t\tgoto ok;\n\t}\n\t/*\n\t * If both drives are not DMA, takes the lower mode, unless\n\t * one of them is PIO mode < 2\n\t */\n\tif (drvp[0].PIO_mode < 2) {\n\t\tmode[0] = drvp[0].PIO_mode = 0;\n\t\tmode[1] = drvp[1].PIO_mode;\n\t} else if (drvp[1].PIO_mode < 2) {\n\t\tmode[1] = drvp[1].PIO_mode = 0;\n\t\tmode[0] = drvp[0].PIO_mode;\n\t} else {\n\t\tmode[0] = mode[1] =\n\t\t    min(drvp[1].PIO_mode, drvp[0].PIO_mode);\n\t\tdrvp[0].PIO_mode = mode[0];\n\t\tdrvp[1].PIO_mode = mode[1];\n\t}\nok:\t/* The modes are setup */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif (drvp[drive].drive_flags & DRIVE_DMA) {\n\t\t\tidetim |= piix_setup_idetim_timings(\n\t\t\t    mode[drive], 1, chp->channel);\n\t\t\tgoto end;\n\t\t}\n\t}\n\t/* If we are there, none of the drives are DMA */\n\tif (mode[0] >= 2)\n\t\tidetim |= piix_setup_idetim_timings(\n\t\t    mode[0], 0, chp->channel);\n\telse \n\t\tidetim |= piix_setup_idetim_timings(\n\t\t    mode[1], 0, chp->channel);\nend:\t/*\n\t * timing mode is now set up in the controller. Enable\n\t * it per-drive\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\t/* If no drive, skip */\n\t\tif ((drvp[drive].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tidetim |= piix_setup_idetim_drvs(&drvp[drive]);\n\t\tif (drvp[drive].drive_flags & DRIVE_DMA)\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t}\n\tif (idedma_ctl != 0) {\n\t\t/* Add software bits in status register */\n\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * chp->channel),\n\t\t    idedma_ctl);\n\t}\n\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM, idetim);\n\tpciide_print_modes(cp);\n}"
  },
  {
    "function_name": "piix_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1275-1388",
    "snippet": "void\npiix_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tu_int32_t idetim;\n\tbus_size_t cmdsize, ctlsize;\n\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)); \n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tswitch(sc->sc_pp->ide_product) {\n\t\tcase PCI_PRODUCT_INTEL_82371AB_IDE:\n\t\tcase PCI_PRODUCT_INTEL_82801AA_IDE:\n\t\tcase PCI_PRODUCT_INTEL_82801AB_IDE:\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t\t}\n\t}\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap =\n\t    (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) ? 4 : 2;\n\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE)\n\t\tsc->sc_wdcdev.set_modes = piix_setup_channel;\n\telse\n\t\tsc->sc_wdcdev.set_modes = piix3_4_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tWDCDEBUG_PRINT((\"piix_setup_chip: old idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),\n\t    DEBUG_PROBE);\n\tif (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {\n\t\tWDCDEBUG_PRINT((\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),\n\t\t    DEBUG_PROBE);\n\t\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {\n\t\t\tWDCDEBUG_PRINT((\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),\n\t\t\t    DEBUG_PROBE);\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t\tWDCDEBUG_PRINT((\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),\n\t\t\t    DEBUG_PROBE);\n\t\t}\n\n\t}\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_PROBE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\t/* PIIX is compat-only */\n\t\tif (pciide_chansetup(sc, channel, 0) == 0)\n\t\t\tcontinue;\n\t\tidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\t\tif ((PIIX_IDETIM_READ(idetim, channel) &\n\t\t    PIIX_IDETIM_IDE) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\t/* PIIX are compat-only pciide devices */\n\t\tpciide_mapchan(pa, cp, 0, &cmdsize, &ctlsize, pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tidetim = PIIX_IDETIM_CLEAR(idetim, PIIX_IDETIM_IDE,\n\t\t\t    channel);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM,\n\t\t\t    idetim);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, 0);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tsc->sc_wdcdev.set_modes(&cp->wdc_channel);\n\t}\n\n\tWDCDEBUG_PRINT((\"piix_setup_chip: idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),\n\t    DEBUG_PROBE);\n\tif (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {\n\t\tWDCDEBUG_PRINT((\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),\n\t\t    DEBUG_PROBE);\n\t\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {\n\t\t\tWDCDEBUG_PRINT((\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),\n\t\t\t        DEBUG_PROBE);\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t\tWDCDEBUG_PRINT((\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),\n\t\t\tDEBUG_PROBE);\n\t\t}\n\t}\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_PROBE);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "void piix_chip_map",
      "void piix_setup_channel",
      "void piix3_4_setup_channel",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "int\tpciide_chipen",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_mapchan",
      "int\tpciiide_chan_candisable",
      "void\tpciide_map_compat_intr",
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"\\n\")",
            "DEBUG_PROBE"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG))",
            "DEBUG_PROBE"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_CONFIG"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG))",
            "DEBUG_PROBE"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_UDMAREG"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM))",
            "DEBUG_PROBE"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_SIDETIM"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"piix_setup_chip: idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM))",
            "DEBUG_PROBE"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_wdcdev.set_modes",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "0"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM",
            "idetim"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_CLEAR",
          "args": [
            "idetim",
            "PIIX_IDETIM_IDE",
            "channel"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciiide_chan_candisable",
          "args": [
            "cp"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "pciiide_chan_candisable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1051-1063",
          "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciiide_chan_candisable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapchan",
          "args": [
            "pa",
            "cp",
            "0",
            "&cmdsize",
            "&ctlsize",
            "pciide_pci_intr"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1024-1045",
          "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_mapregs_compat",
            "int\tpciide_mapregs_native",
            "void\tpciide_mapchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s ignored (disabled)\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PIIX_IDETIM_READ",
          "args": [
            "idetim",
            "channel"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "0"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"\\n\")",
            "DEBUG_PROBE"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG))",
            "DEBUG_PROBE"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_CONFIG"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG))",
            "DEBUG_PROBE"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_UDMAREG"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM))",
            "DEBUG_PROBE"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_SIDETIM"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"piix_setup_chip: old idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM))",
            "DEBUG_PROBE"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PIIX_IDETIM"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nvoid piix_chip_map;\nvoid piix_setup_channel;\nvoid piix3_4_setup_channel;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nint\tpciide_chipen;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_mapchan;\nint\tpciiide_chan_candisable;\nvoid\tpciide_map_compat_intr;\nint\tpciide_pci_intr;\n\nvoid\npiix_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tint channel;\n\tu_int32_t idetim;\n\tbus_size_t cmdsize, ctlsize;\n\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)); \n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tprintf(\": DMA\");\n\tpciide_mapreg_dma(sc, pa);\n\tif (sc->sc_dma_ok) {\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\t\tswitch(sc->sc_pp->ide_product) {\n\t\tcase PCI_PRODUCT_INTEL_82371AB_IDE:\n\t\tcase PCI_PRODUCT_INTEL_82801AA_IDE:\n\t\tcase PCI_PRODUCT_INTEL_82801AB_IDE:\n\t\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA;\n\t\t}\n\t}\n\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32 |\n\t    WDC_CAPABILITY_MODE;\n\tsc->sc_wdcdev.PIO_cap = 4;\n\tsc->sc_wdcdev.DMA_cap = 2;\n\tsc->sc_wdcdev.UDMA_cap =\n\t    (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE) ? 4 : 2;\n\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82371FB_IDE)\n\t\tsc->sc_wdcdev.set_modes = piix_setup_channel;\n\telse\n\t\tsc->sc_wdcdev.set_modes = piix3_4_setup_channel;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tWDCDEBUG_PRINT((\"piix_setup_chip: old idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),\n\t    DEBUG_PROBE);\n\tif (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {\n\t\tWDCDEBUG_PRINT((\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),\n\t\t    DEBUG_PROBE);\n\t\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {\n\t\t\tWDCDEBUG_PRINT((\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),\n\t\t\t    DEBUG_PROBE);\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t\tWDCDEBUG_PRINT((\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),\n\t\t\t    DEBUG_PROBE);\n\t\t}\n\n\t}\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_PROBE);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\t/* PIIX is compat-only */\n\t\tif (pciide_chansetup(sc, channel, 0) == 0)\n\t\t\tcontinue;\n\t\tidetim = pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM);\n\t\tif ((PIIX_IDETIM_READ(idetim, channel) &\n\t\t    PIIX_IDETIM_IDE) == 0) {\n\t\t\tprintf(\"%s: %s ignored (disabled)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t\tcontinue;\n\t\t}\n\t\t/* PIIX are compat-only pciide devices */\n\t\tpciide_mapchan(pa, cp, 0, &cmdsize, &ctlsize, pciide_pci_intr);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tif (pciiide_chan_candisable(cp)) {\n\t\t\tidetim = PIIX_IDETIM_CLEAR(idetim, PIIX_IDETIM_IDE,\n\t\t\t    channel);\n\t\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PIIX_IDETIM,\n\t\t\t    idetim);\n\t\t}\n\t\tpciide_map_compat_intr(pa, cp, channel, 0);\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\tsc->sc_wdcdev.set_modes(&cp->wdc_channel);\n\t}\n\n\tWDCDEBUG_PRINT((\"piix_setup_chip: idetim=0x%x\",\n\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_IDETIM)),\n\t    DEBUG_PROBE);\n\tif (sc->sc_pp->ide_product != PCI_PRODUCT_INTEL_82371FB_IDE) {\n\t\tWDCDEBUG_PRINT((\", sidetim=0x%x\",\n\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_SIDETIM)),\n\t\t    DEBUG_PROBE);\n\t\tif (sc->sc_wdcdev.cap & WDC_CAPABILITY_UDMA) {\n\t\t\tWDCDEBUG_PRINT((\", udamreg 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_UDMAREG)),\n\t\t\t        DEBUG_PROBE);\n\t\t}\n\t\tif (sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AA_IDE ||\n\t\t    sc->sc_pp->ide_product == PCI_PRODUCT_INTEL_82801AB_IDE) {\n\t\t\tWDCDEBUG_PRINT((\", IDE_CONTROL 0x%x\",\n\t\t\t    pci_conf_read(sc->sc_pc, sc->sc_tag, PIIX_CONFIG)),\n\t\t\tDEBUG_PROBE);\n\t\t}\n\t}\n\tWDCDEBUG_PRINT((\"\\n\"), DEBUG_PROBE);\n}"
  },
  {
    "function_name": "default_chip_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1138-1273",
    "snippet": "void\ndefault_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tpcireg_t csr;\n\tint channel, drive;\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t idedma_ctl;\n\tbus_size_t cmdsize, ctlsize;\n\tchar *failreason;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tif (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {\n\t\tprintf(\": DMA\");\n\t\tif (sc->sc_pp == &default_product_desc &&\n\t\t    (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags &\n\t\t    PCIIDE_OPTIONS_DMA) == 0) {\n\t\t\tprintf(\" (unsupported)\");\n\t\t\tsc->sc_dma_ok = 0;\n\t\t} else {\n\t\t\tpciide_mapreg_dma(sc, pa);\n\t\tif (sc->sc_dma_ok != 0)\n\t\t\tprintf(\", (partial support)\");\n\t\t}\n\t} else {\n\t\tprintf(\": no DMA\");\n\t\tsc->sc_dma_ok = 0;\n\t}\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->sc_wdcdev.DMA_cap = 0;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t    continue;\n\t\tif (interface & PCIIDE_INTERFACE_PCI(channel)) {\n\t\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,\n\t\t\t    &ctlsize, pciide_pci_intr);\n\t\t} else {\n\t\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t\t    channel, &cmdsize, &ctlsize);\n\t\t}\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to see if something appears to be there.\n\t\t */\n\t\tfailreason = NULL;\n\t\tif (!wdcprobe(&cp->wdc_channel)) {\n\t\t\tfailreason = \"not responding; disabled or no drives?\";\n\t\t\tgoto next;\n\t\t}\n\t\t/*\n\t\t * Now, make sure it's actually attributable to this PCI IDE\n\t\t * channel by trying to access the channel again while the\n\t\t * PCI IDE controller's I/O space is disabled.  (If the\n\t\t * channel no longer appears to be there, it belongs to\n\t\t * this controller.)  YUCK!\n\t\t */\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t  \t    PCI_COMMAND_STATUS_REG);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG,\n\t\t    csr & ~PCI_COMMAND_IO_ENABLE);\n\t\tif (wdcprobe(&cp->wdc_channel))\n\t\t\tfailreason = \"other hardware responding at addresses\";\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PCI_COMMAND_STATUS_REG, csr);\nnext:\n\t\tif (failreason) {\n\t\t\tprintf(\"%s: %s ignored (%s)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,\n\t\t\t    failreason);\n\t\t\tcp->hw_ok = 0;\n\t\t\tbus_space_unmap(cp->wdc_channel.cmd_iot,\n\t\t\t    cp->wdc_channel.cmd_ioh, cmdsize);\n\t\t\tbus_space_unmap(cp->wdc_channel.ctl_iot,\n\t\t\t    cp->wdc_channel.ctl_ioh, ctlsize);\n\t\t} else {\n\t\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\t}\n\t\tif (cp->hw_ok) {\n\t\t\tcp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;\n\t\t\tcp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;\n\t\t\twdcattach(&cp->wdc_channel);\n\t\t}\n\t}\n\n\tif (sc->sc_dma_ok == 0)\n\t\treturn;\n\n\t/* Allocate DMA maps */\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tidedma_ctl = 0;\n\t\tcp = &sc->pciide_channels[channel];\n\t\tfor (drive = 0; drive < 2; drive++) {\n\t\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t\t/* If no drive, skip */\n\t\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (pciide_dma_table_setup(sc, channel, drive) != 0) {\n\t\t\t\t/* Abort DMA setup */\n\t\t\t\tprintf(\"%s:%d:%d: cannot allocate DMA maps, \"\n\t\t\t\t    \"using PIO transfers\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t\t    channel, drive);\n\t\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\t}\n\t\t\tprintf(\"%s:%d:%d: using DMA data transfers\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    channel, drive);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tif (idedma_ctl != 0) {\n\t\t\t/* Add software bits in status register */\n\t\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),\n\t\t\t    idedma_ctl);\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define PCIIDE_OPTIONS_DMA\t0x01"
    ],
    "globals_used": [
      "void default_chip_map",
      "int  pciide_dma_table_setup",
      "void pciide_print_channels",
      "__P((int, pcireg_t));",
      "const struct pciide_product_desc default_product_desc = {\n\t0,\t\t\t\t/* Generic PCI IDE controller */\n\t0,\n\tdefault_chip_map\n};",
      "int\tpciide_chipen",
      "int\tpciide_mapregs_compat",
      "int\tpciide_mapregs_native",
      "void\tpciide_mapreg_dma",
      "int\tpciide_chansetup",
      "void\tpciide_map_compat_intr",
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel)",
            "idedma_ctl"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDEDMA_CTL_DRV_DMA",
          "args": [
            "drive"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: using DMA data transfers\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "channel",
            "drive"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_dma_table_setup",
          "args": [
            "sc",
            "channel",
            "drive"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_dma_table_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "750-821",
          "snippet": "int\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint  pciide_dma_table_setup;\n\nint\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcattach",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "wdcattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "469-657",
          "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int   wdprint",
            "int at_poll = AT_POLL;",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_map_compat_intr",
          "args": [
            "pa",
            "cp",
            "channel",
            "interface"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_map_compat_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1069-1090",
          "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpciide_map_compat_intr",
            "int\tpciide_compat_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "cp->wdc_channel.ctl_iot",
            "cp->wdc_channel.ctl_ioh",
            "ctlsize"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "cp->wdc_channel.cmd_iot",
            "cp->wdc_channel.cmd_ioh",
            "cmdsize"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcprobe",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "wdcprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "358-449",
          "snippet": "int\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr & ~PCI_COMMAND_IO_ENABLE"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_mapregs_compat",
          "args": [
            "pa",
            "cp",
            "channel",
            "&cmdsize",
            "&ctlsize"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapregs_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "538-573",
          "snippet": "int\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciide_mapregs_compat"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_compat;\n\nint\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapregs_native",
          "args": [
            "pa",
            "cp",
            "&cmdsize",
            "&ctlsize",
            "pciide_pci_intr"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapregs_native",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "575-636",
          "snippet": "int\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciide_mapregs_native"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_native;\n\nint\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "channel"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pciide_chansetup",
          "args": [
            "sc",
            "channel",
            "interface"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chansetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "998-1020",
          "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chansetup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_print_channels",
          "args": [
            "sc->sc_wdcdev.nchannels",
            "interface"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_print_channels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "1092-1108",
          "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pciide_print_channels",
            "__P((int, pcireg_t));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapreg_dma",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapreg_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "638-673",
          "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int  pciide_dma_init",
            "void pciide_dma_start",
            "int  pciide_dma_finish",
            "void\tpciide_mapreg_dma"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_chipen",
          "args": [
            "sc",
            "pa"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_chipen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "520-535",
          "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, pcireg_t));",
            "int\tpciide_chipen"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG)"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_CLASS_REG"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define PCIIDE_OPTIONS_DMA\t0x01\n\nvoid default_chip_map;\nint  pciide_dma_table_setup;\nvoid pciide_print_channels;\n__P((int, pcireg_t));\nconst struct pciide_product_desc default_product_desc = {\n\t0,\t\t\t\t/* Generic PCI IDE controller */\n\t0,\n\tdefault_chip_map\n};\nint\tpciide_chipen;\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapreg_dma;\nint\tpciide_chansetup;\nvoid\tpciide_map_compat_intr;\nint\tpciide_pci_intr;\n\nvoid\ndefault_chip_map(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tstruct pciide_channel *cp;\n\tpcireg_t interface = PCI_INTERFACE(pci_conf_read(sc->sc_pc,\n\t\t\t\t    sc->sc_tag, PCI_CLASS_REG));\n\tpcireg_t csr;\n\tint channel, drive;\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t idedma_ctl;\n\tbus_size_t cmdsize, ctlsize;\n\tchar *failreason;\n\n\tif (pciide_chipen(sc, pa) == 0)\n\t\treturn;\n\n\tif (interface & PCIIDE_INTERFACE_BUS_MASTER_DMA) {\n\t\tprintf(\": DMA\");\n\t\tif (sc->sc_pp == &default_product_desc &&\n\t\t    (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags &\n\t\t    PCIIDE_OPTIONS_DMA) == 0) {\n\t\t\tprintf(\" (unsupported)\");\n\t\t\tsc->sc_dma_ok = 0;\n\t\t} else {\n\t\t\tpciide_mapreg_dma(sc, pa);\n\t\tif (sc->sc_dma_ok != 0)\n\t\t\tprintf(\", (partial support)\");\n\t\t}\n\t} else {\n\t\tprintf(\": no DMA\");\n\t\tsc->sc_dma_ok = 0;\n\t}\n\tif (sc->sc_dma_ok)\n\t\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->sc_wdcdev.DMA_cap = 0;\n\tsc->sc_wdcdev.channels = sc->wdc_chanarray;\n\tsc->sc_wdcdev.nchannels = PCIIDE_NUM_CHANNELS;\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;\n\n\tpciide_print_channels(sc->sc_wdcdev.nchannels, interface);\n\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tcp = &sc->pciide_channels[channel];\n\t\tif (pciide_chansetup(sc, channel, interface) == 0)\n\t\t    continue;\n\t\tif (interface & PCIIDE_INTERFACE_PCI(channel)) {\n\t\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, &cmdsize,\n\t\t\t    &ctlsize, pciide_pci_intr);\n\t\t} else {\n\t\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t\t    channel, &cmdsize, &ctlsize);\n\t\t}\n\t\tif (cp->hw_ok == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to see if something appears to be there.\n\t\t */\n\t\tfailreason = NULL;\n\t\tif (!wdcprobe(&cp->wdc_channel)) {\n\t\t\tfailreason = \"not responding; disabled or no drives?\";\n\t\t\tgoto next;\n\t\t}\n\t\t/*\n\t\t * Now, make sure it's actually attributable to this PCI IDE\n\t\t * channel by trying to access the channel again while the\n\t\t * PCI IDE controller's I/O space is disabled.  (If the\n\t\t * channel no longer appears to be there, it belongs to\n\t\t * this controller.)  YUCK!\n\t\t */\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t  \t    PCI_COMMAND_STATUS_REG);\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag, PCI_COMMAND_STATUS_REG,\n\t\t    csr & ~PCI_COMMAND_IO_ENABLE);\n\t\tif (wdcprobe(&cp->wdc_channel))\n\t\t\tfailreason = \"other hardware responding at addresses\";\n\t\tpci_conf_write(sc->sc_pc, sc->sc_tag,\n\t\t    PCI_COMMAND_STATUS_REG, csr);\nnext:\n\t\tif (failreason) {\n\t\t\tprintf(\"%s: %s ignored (%s)\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name,\n\t\t\t    failreason);\n\t\t\tcp->hw_ok = 0;\n\t\t\tbus_space_unmap(cp->wdc_channel.cmd_iot,\n\t\t\t    cp->wdc_channel.cmd_ioh, cmdsize);\n\t\t\tbus_space_unmap(cp->wdc_channel.ctl_iot,\n\t\t\t    cp->wdc_channel.ctl_ioh, ctlsize);\n\t\t} else {\n\t\t\tpciide_map_compat_intr(pa, cp, channel, interface);\n\t\t}\n\t\tif (cp->hw_ok) {\n\t\t\tcp->wdc_channel.data32iot = cp->wdc_channel.cmd_iot;\n\t\t\tcp->wdc_channel.data32ioh = cp->wdc_channel.cmd_ioh;\n\t\t\twdcattach(&cp->wdc_channel);\n\t\t}\n\t}\n\n\tif (sc->sc_dma_ok == 0)\n\t\treturn;\n\n\t/* Allocate DMA maps */\n\tfor (channel = 0; channel < sc->sc_wdcdev.nchannels; channel++) {\n\t\tidedma_ctl = 0;\n\t\tcp = &sc->pciide_channels[channel];\n\t\tfor (drive = 0; drive < 2; drive++) {\n\t\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t\t/* If no drive, skip */\n\t\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((drvp->drive_flags & DRIVE_DMA) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (pciide_dma_table_setup(sc, channel, drive) != 0) {\n\t\t\t\t/* Abort DMA setup */\n\t\t\t\tprintf(\"%s:%d:%d: cannot allocate DMA maps, \"\n\t\t\t\t    \"using PIO transfers\\n\",\n\t\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t\t    channel, drive);\n\t\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t\t}\n\t\t\tprintf(\"%s:%d:%d: using DMA data transfers\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    channel, drive);\n\t\t\tidedma_ctl |= IDEDMA_CTL_DRV_DMA(drive);\n\t\t}\n\t\tif (idedma_ctl != 0) {\n\t\t\t/* Add software bits in status register */\n\t\t\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\t\t    IDEDMA_CTL + (IDEDMA_SCH_OFFSET * channel),\n\t\t\t    idedma_ctl);\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "pciide_print_modes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1110-1136",
    "snippet": "void\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pciide_print_modes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_modes;\n\nvoid\npciide_print_modes(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tint drive;\n\tstruct channel_softc *chp;\n\tstruct ata_drive_datas *drvp;\n\n\tchp = &cp->wdc_channel;\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &chp->ch_drive[drive];\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s(%s:%d:%d): using PIO mode %d\",\n\t\t    drvp->drive_name,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    chp->channel, drive, drvp->PIO_mode);\n\t\tif (drvp->drive_flags & DRIVE_DMA)\n\t\t\tprintf(\", DMA mode %d\", drvp->DMA_mode);\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_mode);\n\t\tif (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA))\n\t\t\tprintf(\" (using DMA data transfers)\");\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "pciide_print_channels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1092-1108",
    "snippet": "void\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pciide_print_channels",
      "__P((int, pcireg_t));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "i"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_SETTABLE",
          "args": [
            "i"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHANNEL_NAME",
          "args": [
            "i"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_print_channels;\n__P((int, pcireg_t));\n\nvoid\npciide_print_channels(nchannels, interface)\n\tint nchannels;\n\tpcireg_t interface;\n{\n\tint i;\n\n\tfor (i = 0; i < nchannels; i++) {\n\t\tprintf(\", %s %s to %s\", PCIIDE_CHANNEL_NAME(i),\n\t\t    (interface & PCIIDE_INTERFACE_SETTABLE(i)) ?   \n\t\t    \"configured\" : \"wired\",\n\t\t    (interface & PCIIDE_INTERFACE_PCI(i)) ? \"native-PCI\" :\n\t\t    \"compatibility\");\n\t\t    }\n\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "pciide_map_compat_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1069-1090",
    "snippet": "void\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpciide_map_compat_intr",
      "int\tpciide_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no compatibility interrupt for use by %s\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_machdep_compat_intr_establish",
          "args": [
            "&sc->sc_wdcdev.sc_dev",
            "pa",
            "compatchan",
            "pciide_compat_intr",
            "cp"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "wdc_cp->channel"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tpciide_map_compat_intr;\nint\tpciide_compat_intr;\n\nvoid\npciide_map_compat_intr(pa, cp, compatchan, interface)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan, interface;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\tif ((interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel)) != 0)\n\t\treturn;\n\n\tcp->ih = pciide_machdep_compat_intr_establish(&sc->sc_wdcdev.sc_dev,\n\t    pa, compatchan, pciide_compat_intr, cp);\n\tif (cp->ih == NULL) {\n\t\tprintf(\"%s: no compatibility interrupt for use by %s\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tcp->hw_ok = 0;\n\t}\n}"
  },
  {
    "function_name": "pciiide_chan_candisable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1051-1063",
    "snippet": "int\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciiide_chan_candisable"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciiide_chan_candisable;\n\nint\npciiide_chan_candisable(cp)\n\tstruct pciide_channel *cp;\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif ((wdc_cp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (wdc_cp->ch_drive[1].drive_flags & DRIVE) == 0) {\n\t\tcp->hw_ok = 0;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pciide_mapchan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "1024-1045",
    "snippet": "void\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((int, pcireg_t));",
      "int\tpciide_mapregs_compat",
      "int\tpciide_mapregs_native",
      "void\tpciide_mapchan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcattach",
          "args": [
            "wdc_cp"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "wdcattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "469-657",
          "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int   wdprint",
            "int at_poll = AT_POLL;",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapregs_compat",
          "args": [
            "pa",
            "cp",
            "wdc_cp->channel",
            "cmdsizep",
            "ctlsizep"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapregs_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "538-573",
          "snippet": "int\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciide_mapregs_compat"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_compat;\n\nint\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_mapregs_native",
          "args": [
            "pa",
            "cp",
            "cmdsizep",
            "ctlsizep",
            "pci_intr"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_mapregs_native",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "575-636",
          "snippet": "int\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpciide_mapregs_native"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_native;\n\nint\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_INTERFACE_PCI",
          "args": [
            "wdc_cp->channel"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_mapregs_compat;\nint\tpciide_mapregs_native;\nvoid\tpciide_mapchan;\n\nvoid\npciide_mapchan(pa, cp, interface, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tpcireg_t interface;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tif (interface & PCIIDE_INTERFACE_PCI(wdc_cp->channel))\n\t\tcp->hw_ok = pciide_mapregs_native(pa, cp, cmdsizep, ctlsizep,\n\t\t    pci_intr);\n\telse\n\t\tcp->hw_ok = pciide_mapregs_compat(pa, cp,\n\t\t    wdc_cp->channel, cmdsizep, ctlsizep);\n\tif (cp->hw_ok == 0)\n\t\treturn;\n\twdc_cp->data32iot = wdc_cp->cmd_iot;\n\twdc_cp->data32ioh = wdc_cp->cmd_ioh;\n\twdcattach(wdc_cp);\n}"
  },
  {
    "function_name": "pciide_chansetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "998-1020",
    "snippet": "int\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((int, pcireg_t));",
      "int\tpciide_chansetup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct channel_queue)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_CHANNEL_NAME",
          "args": [
            "channel"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chansetup;\n\nint\npciide_chansetup(sc, channel, interface)\n\tstruct pciide_softc *sc;\n\tint channel;\n\tpcireg_t interface;\n{\n\tstruct pciide_channel *cp = &sc->pciide_channels[channel];\n\tsc->wdc_chanarray[channel] = &cp->wdc_channel;\n\tcp->name = PCIIDE_CHANNEL_NAME(channel);\n\tcp->wdc_channel.channel = channel;\n\tcp->wdc_channel.wdc = &sc->sc_wdcdev;\n\tcp->wdc_channel.ch_queue =\n\t    malloc(sizeof(struct channel_queue), M_DEVBUF, M_NOWAIT);\n\tif (cp->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\"%s: %s \"\n\t\t\t\"cannot allocate memory for command queue\",\n\t\tsc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\t return 0;\n\t}\n\n\treturn 1;\n\n}"
  },
  {
    "function_name": "pciide_dma_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "935-995",
    "snippet": "int\npciide_dma_finish(v, channel, drive, flags)\n\tvoid *v;\n\tint channel, drive;\n\tint flags;\n{\n\tstruct pciide_softc *sc = v;\n\tu_int8_t status;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* Unload the map of the data buffer */\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, \n\t    0,\n\t    dma_maps->dmamap_xfer->dm_mapsize,\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, \n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n#endif\n\n\tbus_dmamap_unload(sc->sc_dmat, dma_maps->dmamap_xfer);\n\n\tstatus = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel);\n\tWDCDEBUG_PRINT((\"pciide_dma_finish: status 0x%x\\n\", status),\n\t    DEBUG_XFERS);\n\n\t/* stop DMA channel */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) & ~IDEDMA_CMD_START);\n\n\t/* Clear status bits */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,\n\t    status);\n\n\tif ((status & IDEDMA_CTL_ERR) != 0) {\n\t\tprintf(\"%s:%d:%d: Bus-Master DMA error: status=0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive, status);\n\t\treturn -1;\n\t}\n\n\tif ((flags & WDC_DMA_POLL) == 0 && (status & IDEDMA_CTL_INTR) == 0) {\n\t\tprintf(\"%s:%d:%d: Bus-Master DMA error: missing interrupt, \"\n\t\t    \"status=0x%x\\n\", sc->sc_wdcdev.sc_dev.dv_xname, channel,\n\t\t    drive, status);\n\t\treturn -1;\n\t}\n\n\tif ((status & IDEDMA_CTL_ACT) != 0) {\n\t\t/* data underrun, may be a valid condition for ATAPI */\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "int  pciide_dma_finish"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: Bus-Master DMA error: missing interrupt, \"\n\t\t    \"status=0x%x\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "channel",
            "drive",
            "status"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel",
            "status"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel",
            "bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) & ~IDEDMA_CMD_START"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pciide_dma_finish: status 0x%x\\n\", status)",
            "DEBUG_XFERS"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer",
            "(flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer",
            "0",
            "dma_maps->dmamap_xfer->dm_mapsize",
            "(flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nint  pciide_dma_finish;\n\nint\npciide_dma_finish(v, channel, drive, flags)\n\tvoid *v;\n\tint channel, drive;\n\tint flags;\n{\n\tstruct pciide_softc *sc = v;\n\tu_int8_t status;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* Unload the map of the data buffer */\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, \n\t    0,\n\t    dma_maps->dmamap_xfer->dm_mapsize,\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer, \n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n#endif\n\n\tbus_dmamap_unload(sc->sc_dmat, dma_maps->dmamap_xfer);\n\n\tstatus = bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel);\n\tWDCDEBUG_PRINT((\"pciide_dma_finish: status 0x%x\\n\", status),\n\t    DEBUG_XFERS);\n\n\t/* stop DMA channel */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) & ~IDEDMA_CMD_START);\n\n\t/* Clear status bits */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,\n\t    status);\n\n\tif ((status & IDEDMA_CTL_ERR) != 0) {\n\t\tprintf(\"%s:%d:%d: Bus-Master DMA error: status=0x%x\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, channel, drive, status);\n\t\treturn -1;\n\t}\n\n\tif ((flags & WDC_DMA_POLL) == 0 && (status & IDEDMA_CTL_INTR) == 0) {\n\t\tprintf(\"%s:%d:%d: Bus-Master DMA error: missing interrupt, \"\n\t\t    \"status=0x%x\\n\", sc->sc_wdcdev.sc_dev.dv_xname, channel,\n\t\t    drive, status);\n\t\treturn -1;\n\t}\n\n\tif ((status & IDEDMA_CTL_ACT) != 0) {\n\t\t/* data underrun, may be a valid condition for ATAPI */\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pciide_dma_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "921-933",
    "snippet": "void\npciide_dma_start(v, channel, drive, flags)\n\tvoid *v;\n\tint channel, drive, flags;\n{\n\tstruct pciide_softc *sc = v;\n\n\tWDCDEBUG_PRINT((\"pciide_dma_start\\n\"),DEBUG_XFERS);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) | IDEDMA_CMD_START);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void pciide_dma_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel",
            "bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) | IDEDMA_CMD_START"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pciide_dma_start\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid pciide_dma_start;\n\nvoid\npciide_dma_start(v, channel, drive, flags)\n\tvoid *v;\n\tint channel, drive, flags;\n{\n\tstruct pciide_softc *sc = v;\n\n\tWDCDEBUG_PRINT((\"pciide_dma_start\\n\"),DEBUG_XFERS);\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CMD + IDEDMA_SCH_OFFSET * channel) | IDEDMA_CMD_START);\n}"
  },
  {
    "function_name": "pciide_dma_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "823-919",
    "snippet": "int\npciide_dma_init(v, channel, drive, databuf, datalen, flags)\n\tvoid *v;\n\tint channel, drive;\n\tvoid *databuf;\n\tsize_t datalen;\n\tint flags;\n{\n\tstruct pciide_softc *sc = v;\n\tint error, seg;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\terror = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_xfer,\n\t    databuf, datalen, NULL, BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tprintf(\"%s:%d: unable to load xfer DMA map for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,\n\t    0,\n\t    dma_maps->dmamap_xfer->dm_mapsize,\t\t\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n#endif\n\n\tfor (seg = 0; seg < dma_maps->dmamap_xfer->dm_nsegs; seg++) {\n#ifdef DIAGNOSTIC\n\t\t/* A segment must not cross a 64k boundary */\n\t\t{\n\t\tu_long phys = dma_maps->dmamap_xfer->dm_segs[seg].ds_addr;\n\t\tu_long len = dma_maps->dmamap_xfer->dm_segs[seg].ds_len;\n\t\tif ((phys & ~IDEDMA_BYTE_COUNT_MASK) !=\n\t\t    ((phys + len - 1) & ~IDEDMA_BYTE_COUNT_MASK)) {\n\t\t\tprintf(\"pciide_dma: segment %d physical addr 0x%lx\"\n\t\t\t    \" len 0x%lx not properly aligned\\n\",\n\t\t\t    seg, phys, len);\n\t\t\tpanic(\"pciide_dma: buf align\");\n\t\t}\n\t\t}\n#endif\n\t\tdma_maps->dma_table[seg].base_addr =\n\t\t    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_addr);\n\t\tdma_maps->dma_table[seg].byte_count =\n\t\t    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_len &\n\t\t    IDEDMA_BYTE_COUNT_MASK);\n\t\tWDCDEBUG_PRINT((\"\\t seg %d len %d addr 0x%x\\n\",\n\t\t   seg, pcitoh(dma_maps->dma_table[seg].byte_count),\n\t\t   pcitoh(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);\n\n\t}\n\tdma_maps->dma_table[dma_maps->dmamap_xfer->dm_nsegs -1].byte_count |=\n\t    htopci(IDEDMA_BYTE_COUNT_EOT);\n\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, \n\t    0,\n\t    dma_maps->dmamap_table->dm_mapsize,\n\t    BUS_DMASYNC_PREWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, \n\t    BUS_DMASYNC_PREWRITE);\n#endif\n\n\t/* Maps are ready. Start DMA function */\n#ifdef DIAGNOSTIC\n\tif (dma_maps->dmamap_table->dm_segs[0].ds_addr & ~IDEDMA_TBL_MASK) {\n\t\tprintf(\"pciide_dma_init: addr 0x%lx not properly aligned\\n\",\n\t\t    dma_maps->dmamap_table->dm_segs[0].ds_addr);\n\t\tpanic(\"pciide_dma_init: table align\");\n\t}\n#endif\n\n\t/* Clear status bits */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CTL + IDEDMA_SCH_OFFSET * channel));\n\t/* Write table addr */\n\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_TBL + IDEDMA_SCH_OFFSET * channel,\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr);\n\t/* set read/write */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    (flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE: 0);\n\treturn 0;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_DMA   0x01"
    ],
    "globals_used": [
      "int  pciide_dma_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel",
            "(flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE: 0"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_TBL + IDEDMA_SCH_OFFSET * channel",
            "dma_maps->dmamap_table->dm_segs[0].ds_addr"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel",
            "bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CTL + IDEDMA_SCH_OFFSET * channel)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_dma_iot",
            "sc->sc_dma_ioh",
            "IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pciide_dma_init: table align\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pciide_dma_init: addr 0x%lx not properly aligned\\n\"",
            "dma_maps->dmamap_table->dm_segs[0].ds_addr"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_table",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_table",
            "0",
            "dma_maps->dmamap_table->dm_mapsize",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htopci",
          "args": [
            "IDEDMA_BYTE_COUNT_EOT"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"\\t seg %d len %d addr 0x%x\\n\",\n\t\t   seg, pcitoh(dma_maps->dma_table[seg].byte_count),\n\t\t   pcitoh(dma_maps->dma_table[seg].base_addr))",
            "DEBUG_DMA"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcitoh",
          "args": [
            "dma_maps->dma_table[seg].base_addr"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcitoh",
          "args": [
            "dma_maps->dma_table[seg].byte_count"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htopci",
          "args": [
            "dma_maps->dmamap_xfer->dm_segs[seg].ds_len &\n\t\t    IDEDMA_BYTE_COUNT_MASK"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htopci",
          "args": [
            "dma_maps->dmamap_xfer->dm_segs[seg].ds_addr"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pciide_dma: buf align\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer",
            "(flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer",
            "0",
            "dma_maps->dmamap_xfer->dm_mapsize",
            "(flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_xfer",
            "databuf",
            "datalen",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_DMA   0x01\n\nint  pciide_dma_init;\n\nint\npciide_dma_init(v, channel, drive, databuf, datalen, flags)\n\tvoid *v;\n\tint channel, drive;\n\tvoid *databuf;\n\tsize_t datalen;\n\tint flags;\n{\n\tstruct pciide_softc *sc = v;\n\tint error, seg;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\terror = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_xfer,\n\t    databuf, datalen, NULL, BUS_DMA_NOWAIT);\n\tif (error) {\n\t\tprintf(\"%s:%d: unable to load xfer DMA map for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,\n\t    0,\n\t    dma_maps->dmamap_xfer->dm_mapsize,\t\t\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_xfer,\n\t    (flags & WDC_DMA_READ) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n#endif\n\n\tfor (seg = 0; seg < dma_maps->dmamap_xfer->dm_nsegs; seg++) {\n#ifdef DIAGNOSTIC\n\t\t/* A segment must not cross a 64k boundary */\n\t\t{\n\t\tu_long phys = dma_maps->dmamap_xfer->dm_segs[seg].ds_addr;\n\t\tu_long len = dma_maps->dmamap_xfer->dm_segs[seg].ds_len;\n\t\tif ((phys & ~IDEDMA_BYTE_COUNT_MASK) !=\n\t\t    ((phys + len - 1) & ~IDEDMA_BYTE_COUNT_MASK)) {\n\t\t\tprintf(\"pciide_dma: segment %d physical addr 0x%lx\"\n\t\t\t    \" len 0x%lx not properly aligned\\n\",\n\t\t\t    seg, phys, len);\n\t\t\tpanic(\"pciide_dma: buf align\");\n\t\t}\n\t\t}\n#endif\n\t\tdma_maps->dma_table[seg].base_addr =\n\t\t    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_addr);\n\t\tdma_maps->dma_table[seg].byte_count =\n\t\t    htopci(dma_maps->dmamap_xfer->dm_segs[seg].ds_len &\n\t\t    IDEDMA_BYTE_COUNT_MASK);\n\t\tWDCDEBUG_PRINT((\"\\t seg %d len %d addr 0x%x\\n\",\n\t\t   seg, pcitoh(dma_maps->dma_table[seg].byte_count),\n\t\t   pcitoh(dma_maps->dma_table[seg].base_addr)), DEBUG_DMA);\n\n\t}\n\tdma_maps->dma_table[dma_maps->dmamap_xfer->dm_nsegs -1].byte_count |=\n\t    htopci(IDEDMA_BYTE_COUNT_EOT);\n\n#ifndef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, \n\t    0,\n\t    dma_maps->dmamap_table->dm_mapsize,\n\t    BUS_DMASYNC_PREWRITE);\n#else\n\tbus_dmamap_sync(sc->sc_dmat, dma_maps->dmamap_table, \n\t    BUS_DMASYNC_PREWRITE);\n#endif\n\n\t/* Maps are ready. Start DMA function */\n#ifdef DIAGNOSTIC\n\tif (dma_maps->dmamap_table->dm_segs[0].ds_addr & ~IDEDMA_TBL_MASK) {\n\t\tprintf(\"pciide_dma_init: addr 0x%lx not properly aligned\\n\",\n\t\t    dma_maps->dmamap_table->dm_segs[0].ds_addr);\n\t\tpanic(\"pciide_dma_init: table align\");\n\t}\n#endif\n\n\t/* Clear status bits */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CTL + IDEDMA_SCH_OFFSET * channel,\n\t    bus_space_read_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t\tIDEDMA_CTL + IDEDMA_SCH_OFFSET * channel));\n\t/* Write table addr */\n\tbus_space_write_4(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_TBL + IDEDMA_SCH_OFFSET * channel,\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr);\n\t/* set read/write */\n\tbus_space_write_1(sc->sc_dma_iot, sc->sc_dma_ioh,\n\t    IDEDMA_CMD + IDEDMA_SCH_OFFSET * channel,\n\t    (flags & WDC_DMA_READ) ? IDEDMA_CMD_WRITE: 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "pciide_dma_table_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "750-821",
    "snippet": "int\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "int  pciide_dma_table_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "channel",
            "drive",
            "error"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "IDEDMA_BYTE_COUNT_MAX",
            "NIDEDMA_TABLES",
            "IDEDMA_BYTE_COUNT_MAX",
            "IDEDMA_BYTE_COUNT_ALIGN",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&dma_maps->dmamap_xfer"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr)",
            "DEBUG_PROBE"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "dma_maps->dmamap_table",
            "dma_maps->dma_table",
            "dma_table_size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "dma_table_size",
            "1",
            "dma_table_size",
            "IDEDMA_TBL_ALIGN",
            "BUS_DMA_NOWAIT",
            "&dma_maps->dmamap_table"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr)",
            "DEBUG_PROBE"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "dma_table_size",
            "(caddr_t *)&dma_maps->dma_table",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "dma_table_size",
            "IDEDMA_TBL_ALIGN",
            "IDEDMA_TBL_ALIGN",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint  pciide_dma_table_setup;\n\nint\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pciide_channel_dma_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "721-748",
    "snippet": "void\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pciide_channel_dma_setup",
      "int  pciide_dma_table_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pciide_dma_table_setup",
          "args": [
            "sc",
            "cp->wdc_channel.channel",
            "drive"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "pciide_dma_table_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
          "lines": "750-821",
          "snippet": "int\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <machine/bswap.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/pci/pciide_pdc202xx_reg.h>",
            "#include <dev/pci/pciide_acer_reg.h>",
            "#include <dev/pci/pciide_sis_reg.h>",
            "#include <dev/pci/pciide_cy693_reg.h>",
            "#include <dev/pci/pciide_cmd_reg.h>",
            "#include <dev/pci/pciide_apollo_reg.h>",
            "#include <dev/pci/pciide_amd_reg.h>",
            "#include <dev/pci/pciide_piix_reg.h>",
            "#include <dev/pci/pciidevar.h>",
            "#include <dev/pci/pciidereg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int  pciide_dma_table_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint  pciide_dma_table_setup;\n\nint\npciide_dma_table_setup(sc, channel, drive)\n\tstruct pciide_softc *sc;\n\tint channel, drive;\n{\n\tbus_dma_segment_t seg;\n\tint error, rseg;\n\tconst bus_size_t dma_table_size =\n\t    sizeof(struct idedma_table) * NIDEDMA_TABLES;\n\tstruct pciide_dma_maps *dma_maps =\n\t    &sc->pciide_channels[channel].dma_maps[drive];\n\n\t/* If table was already allocated, just return */\n\tif (dma_maps->dma_table)\n\t\treturn 0;\n\n\t/* Allocate memory for the DMA tables and map it */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, dma_table_size,\n\t    IDEDMA_TBL_ALIGN, IDEDMA_TBL_ALIGN, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to allocate table DMA for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t    dma_table_size,\n\t    (caddr_t *)&dma_maps->dma_table,\n\t    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s:%d: unable to map table DMA for\"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: table at %p len %ld, \"\n\t    \"phy 0x%lx\\n\", dma_maps->dma_table, dma_table_size,\n\t    seg.ds_addr), DEBUG_PROBE);\n\n\t/* Create and load table DMA map for this disk */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, dma_table_size,\n\t    1, dma_table_size, IDEDMA_TBL_ALIGN, BUS_DMA_NOWAIT,\n\t    &dma_maps->dmamap_table)) != 0) {\n\t\tprintf(\"%s:%d: unable to create table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat,\n\t    dma_maps->dmamap_table,\n\t    dma_maps->dma_table,\n\t    dma_table_size, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s:%d: unable to load table DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\tWDCDEBUG_PRINT((\"pciide_dma_table_setup: phy addr of table 0x%lx\\n\",\n\t    dma_maps->dmamap_table->dm_segs[0].ds_addr), DEBUG_PROBE);\n\t/* Create a xfer DMA map for this drive */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, IDEDMA_BYTE_COUNT_MAX,\n\t    NIDEDMA_TABLES, IDEDMA_BYTE_COUNT_MAX, IDEDMA_BYTE_COUNT_ALIGN,\n\t    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &dma_maps->dmamap_xfer)) != 0) {\n\t\tprintf(\"%s:%d: unable to create xfer DMA map for \"\n\t\t    \"drive %d, error=%d\\n\", sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t    channel, drive, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciide_channel_dma_setup;\nint  pciide_dma_table_setup;\n\nvoid\npciide_channel_dma_setup(cp)\n\tstruct pciide_channel *cp;\n{\n\tint drive;\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct ata_drive_datas *drvp;\n\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tdrvp = &cp->wdc_channel.ch_drive[drive];\n\t\t/* If no drive, skip */\n\t\tif ((drvp->drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\t\t/* setup DMA if needed */\n\t\tif (((drvp->drive_flags & DRIVE_DMA) == 0 &&\n\t\t    (drvp->drive_flags & DRIVE_UDMA) == 0) ||\n\t\t    sc->sc_dma_ok == 0) {\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pciide_dma_table_setup(sc, cp->wdc_channel.channel, drive)\n\t\t    != 0) {\n\t\t\t/* Abort DMA setup */\n\t\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pciide_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "689-719",
    "snippet": "int\npciide_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv;\n\n\trv = 0;\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\t/* if this channel not waiting for intr, skip */\n\t\tif ((wdc_cp->ch_flags & WDCF_IRQ_WAIT) == 0)\n\t\t\tcontinue;\n\n\t\tcrv = wdcintr(wdc_cp);\n\t\tif (crv == 0)\n\t\t\t;\t\t/* leave rv alone */\n\t\telse if (crv == 1)\n\t\t\trv = 1;\t\t/* claim the intr */\n\t\telse if (rv == 0)\t/* crv should be -1 in this case */\n\t\t\trv = crv;\t/* if we've done no better, take it */\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciide_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcintr",
          "args": [
            "wdc_cp"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "wdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "748-771",
          "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_pci_intr;\n\nint\npciide_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_softc *sc = arg;\n\tstruct pciide_channel *cp;\n\tstruct channel_softc *wdc_cp;\n\tint i, rv, crv;\n\n\trv = 0;\n\tfor (i = 0; i < sc->sc_wdcdev.nchannels; i++) {\n\t\tcp = &sc->pciide_channels[i];\n\t\twdc_cp = &cp->wdc_channel;\n\n\t\t/* If a compat channel skip. */\n\t\tif (cp->compat)\n\t\t\tcontinue;\n\t\t/* if this channel not waiting for intr, skip */\n\t\tif ((wdc_cp->ch_flags & WDCF_IRQ_WAIT) == 0)\n\t\t\tcontinue;\n\n\t\tcrv = wdcintr(wdc_cp);\n\t\tif (crv == 0)\n\t\t\t;\t\t/* leave rv alone */\n\t\telse if (crv == 1)\n\t\t\trv = 1;\t\t/* claim the intr */\n\t\telse if (rv == 0)\t/* crv should be -1 in this case */\n\t\t\trv = crv;\t/* if we've done no better, take it */\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "pciide_compat_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "675-687",
    "snippet": "int\npciide_compat_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_channel *cp = arg;\n\n#ifdef DIAGNOSTIC\n\t/* should only be called for a compat channel */\n\tif (cp->compat == 0)\n\t\tpanic(\"pciide compat intr called for non-compat chan %p\\n\", cp);\n#endif\n\treturn (wdcintr(&cp->wdc_channel));\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciide_compat_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcintr",
          "args": [
            "&cp->wdc_channel"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "wdcintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "748-771",
          "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pciide compat intr called for non-compat chan %p\\n\"",
            "cp"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_compat_intr;\n\nint\npciide_compat_intr(arg)\n\tvoid *arg;\n{\n\tstruct pciide_channel *cp = arg;\n\n#ifdef DIAGNOSTIC\n\t/* should only be called for a compat channel */\n\tif (cp->compat == 0)\n\t\tpanic(\"pciide compat intr called for non-compat chan %p\\n\", cp);\n#endif\n\treturn (wdcintr(&cp->wdc_channel));\n}"
  },
  {
    "function_name": "pciide_mapreg_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "638-673",
    "snippet": "void\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int  pciide_dma_init",
      "void pciide_dma_start",
      "int  pciide_dma_finish",
      "void\tpciide_mapreg_dma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", (unuseable)\""
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCIIDE_REG_BUS_MASTER_DMA",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&sc->sc_dma_iot",
            "&sc->sc_dma_ioh",
            "NULL",
            "NULL"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint  pciide_dma_init;\nvoid pciide_dma_start;\nint  pciide_dma_finish;\nvoid\tpciide_mapreg_dma;\n\nvoid\npciide_mapreg_dma(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\t/*\n\t * Map DMA registers\n\t *\n\t * Note that sc_dma_ok is the right variable to test to see if\n\t * DMA can be done.  If the interface doesn't support DMA,\n\t * sc_dma_ok will never be non-zero.  If the DMA regs couldn't\n\t * be mapped, it'll be zero.  I.e., sc_dma_ok will only be\n\t * non-zero if the interface supports DMA and the registers\n\t * could be mapped.\n\t *\n\t * XXX Note that despite the fact that the Bus Master IDE specs\n\t * XXX say that \"The bus master IDE function uses 16 bytes of IO\n\t * XXX space,\" some controllers (at least the United\n\t * XXX Microelectronics UM8886BF) place it in memory space.\n\t * XXX eventually, we should probably read the register and check\n\t * XXX which type it is.  Either that or 'quirk' certain devices.\n\t */\n\n\tsc->sc_dma_ok = (pci_mapreg_map(pa,\n\t    PCIIDE_REG_BUS_MASTER_DMA, PCI_MAPREG_TYPE_IO, 0,\n\t    &sc->sc_dma_iot, &sc->sc_dma_ioh, NULL, NULL) == 0);\n\tsc->sc_dmat = pa->pa_dmat;\n\tif (sc->sc_dma_ok == 0) {\n\t\tprintf(\", (unuseable)\"); /* couldn't map registers */\n\t} else {\n\t\tsc->sc_wdcdev.dma_arg = sc;\n\t\tsc->sc_wdcdev.dma_init = pciide_dma_init;\n\t\tsc->sc_wdcdev.dma_start = pciide_dma_start;\n\t\tsc->sc_wdcdev.dma_finish = pciide_dma_finish;\n\t}\n}"
  },
  {
    "function_name": "pciide_mapregs_native",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "575-636",
    "snippet": "int\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciide_mapregs_native"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "wdc_cp->cmd_iot",
            "wdc_cp->cmd_ioh",
            "*cmdsizep"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't map %s ctl regs\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCIIDE_REG_CTL_BASE(wdc_cp->channel)",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&wdc_cp->ctl_iot",
            "&wdc_cp->ctl_ioh",
            "NULL",
            "ctlsizep"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCIIDE_REG_CTL_BASE",
          "args": [
            "wdc_cp->channel"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_REG_CMD_BASE",
          "args": [
            "wdc_cp->channel"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_BIO",
            "pci_intr",
            "sc"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_BIO",
            "pci_intr",
            "sc",
            "sc->sc_wdcdev.sc_dev.dv_xname"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "intrhandle"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&intrhandle"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_native;\n\nint\npciide_mapregs_native(pa, cp, cmdsizep, ctlsizep, pci_intr)\n\tstruct pci_attach_args * pa;\n\tstruct pciide_channel *cp;\n\tbus_size_t *cmdsizep, *ctlsizep;\n\tint (*pci_intr) __P((void *));\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\tconst char *intrstr;\n\tpci_intr_handle_t intrhandle;\n\n\tcp->compat = 0;\n\n\tif (sc->sc_pci_ih == NULL) {\n\t\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t    pa->pa_intrline, &intrhandle) != 0) {\n\t\t\tprintf(\"%s: couldn't map native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\treturn 0;\n\t\t}\t\n\t\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n#ifdef __OpenBSD__\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc,\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n#else\n\t\tsc->sc_pci_ih = pci_intr_establish(pa->pa_pc,\n\t\t    intrhandle, IPL_BIO, pci_intr, sc);\n#endif\n\t\tif (sc->sc_pci_ih != NULL) {\n\t\t\tprintf(\"%s: using %s for native-PCI interrupt\\n\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname,\n\t\t\t    intrstr ? intrstr : \"unknown interrupt\");\n\t\t} else {\n\t\t\tprintf(\"%s: couldn't establish native-PCI interrupt\",\n\t\t\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\t\t\tif (intrstr != NULL)\n\t\t\t\tprintf(\" at %s\", intrstr);\n\t\t\tprintf(\"\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcp->ih = sc->sc_pci_ih;\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CMD_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->cmd_iot, &wdc_cp->cmd_ioh, NULL, cmdsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn 0;\n\t}\n\n\tif (pci_mapreg_map(pa, PCIIDE_REG_CTL_BASE(wdc_cp->channel),\n\t    PCI_MAPREG_TYPE_IO, 0,\n\t    &wdc_cp->ctl_iot, &wdc_cp->ctl_ioh, NULL, ctlsizep) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh, *cmdsizep);\n\t\treturn 0;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "pciide_mapregs_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "538-573",
    "snippet": "int\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciide_mapregs_compat"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "wdc_cp->cmd_iot",
            "wdc_cp->cmd_ioh",
            "PCIIDE_COMPAT_CMD_SIZE"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't map %s ctl regs\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "cp->name"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "wdc_cp->ctl_iot",
            "PCIIDE_COMPAT_CTL_BASE(compatchan)",
            "PCIIDE_COMPAT_CTL_SIZE",
            "0",
            "&wdc_cp->ctl_ioh"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_COMPAT_CTL_BASE",
          "args": [
            "compatchan"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "wdc_cp->cmd_iot",
            "PCIIDE_COMPAT_CMD_BASE(compatchan)",
            "PCIIDE_COMPAT_CMD_SIZE",
            "0",
            "&wdc_cp->cmd_ioh"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCIIDE_COMPAT_CMD_BASE",
          "args": [
            "compatchan"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciide_mapregs_compat;\n\nint\npciide_mapregs_compat(pa, cp, compatchan, cmdsizep, ctlsizep)\n\tstruct pci_attach_args *pa;\n\tstruct pciide_channel *cp;\n\tint compatchan;\n\tbus_size_t *cmdsizep, *ctlsizep;\n{\n\tstruct pciide_softc *sc = (struct pciide_softc *)cp->wdc_channel.wdc;\n\tstruct channel_softc *wdc_cp = &cp->wdc_channel;\n\n\tcp->compat = 1;\n\t*cmdsizep = PCIIDE_COMPAT_CMD_SIZE;\n\t*ctlsizep = PCIIDE_COMPAT_CTL_SIZE;\n\n\twdc_cp->cmd_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->cmd_iot, PCIIDE_COMPAT_CMD_BASE(compatchan),\n\t    PCIIDE_COMPAT_CMD_SIZE, 0, &wdc_cp->cmd_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s cmd regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\treturn (0);\n\t}\n\n\twdc_cp->ctl_iot = pa->pa_iot;\n\n\tif (bus_space_map(wdc_cp->ctl_iot, PCIIDE_COMPAT_CTL_BASE(compatchan),\n\t    PCIIDE_COMPAT_CTL_SIZE, 0, &wdc_cp->ctl_ioh) != 0) {\n\t\tprintf(\"%s: couldn't map %s ctl regs\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, cp->name);\n\t\tbus_space_unmap(wdc_cp->cmd_iot, wdc_cp->cmd_ioh,\n\t\t    PCIIDE_COMPAT_CMD_SIZE);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}"
  },
  {
    "function_name": "pciide_chipen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "520-535",
    "snippet": "int\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((int, pcireg_t));",
      "int\tpciide_chipen"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": device disabled (at %s)\\n\"",
            "(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pc",
            "sc->sc_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, pcireg_t));\nint\tpciide_chipen;\n\nint\npciide_chipen(sc, pa)\n\tstruct pciide_softc *sc;\n\tstruct pci_attach_args *pa;\n{\n\tpcireg_t csr;\n\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0) {\n\t\tcsr = pci_conf_read(sc->sc_pc, sc->sc_tag,\n\t\tPCI_COMMAND_STATUS_REG);\n\tprintf(\": device disabled (at %s)\\n\",\n\t\t(csr & PCI_COMMAND_IO_ENABLE) == 0 ?\n\t\t\"device\" : \"bridge\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "pciide_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "480-517",
    "snippet": "void\npciide_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpcitag_t tag = pa->pa_tag;\n\tstruct pciide_softc *sc = (struct pciide_softc *)self;\n\tpcireg_t csr;\n\tchar devinfo[256];\n\n\tsc->sc_pp = pciide_lookup_product(pa->pa_id);\n\tif (sc->sc_pp == NULL) {\n\t\tsc->sc_pp = &default_product_desc;\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);\n\t}\n\n\tsc->sc_pc = pa->pa_pc;\n\tsc->sc_tag = pa->pa_tag;\n\n\n#ifdef WDCDEBUG\n       if (wdcdebug_pciide_mask & DEBUG_PROBE)\n               printf(\"sc_pc %s, sc_tag %s\\n\", sc->sc_pc, sc->sc_tag);\n#endif\n\n\tsc->sc_pp->chip_map(sc, pa);\n\n\tif (sc->sc_dma_ok) {\n\t\tcsr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t\tcsr |= PCI_COMMAND_MASTER_ENABLE;\n\t\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide: command/status register=%x\\n\",\n\t    pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG)), DEBUG_PROBE);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "__P((int, pcireg_t));",
      "const struct pciide_product_desc default_product_desc = {\n\t0,\t\t\t\t/* Generic PCI IDE controller */\n\t0,\n\tdefault_chip_map\n};",
      "void\tpciide_attach",
      "const struct pciide_product_desc* pciide_lookup_product",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"pciide: command/status register=%x\\n\",\n\t    pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG))",
            "DEBUG_PROBE"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG",
            "csr"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_pp->chip_map",
          "args": [
            "sc",
            "pa"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sc_pc %s, sc_tag %s\\n\"",
            "sc->sc_pc",
            "sc->sc_tag"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_devinfo",
          "args": [
            "pa->pa_id",
            "pa->pa_class",
            "0",
            "devinfo"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_subr.c",
          "lines": "215-306",
          "snippet": "void\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}",
          "includes": [
            "#include <dev/pci/pcidevs_data.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
          ],
          "globals_used": [
            "struct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs_data.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nstruct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};\n\nvoid\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pciide_lookup_product",
          "args": [
            "pa->pa_id"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\n__P((int, pcireg_t));\nconst struct pciide_product_desc default_product_desc = {\n\t0,\t\t\t\t/* Generic PCI IDE controller */\n\t0,\n\tdefault_chip_map\n};\nvoid\tpciide_attach;\nconst struct pciide_product_desc* pciide_lookup_product;\nvoid *aux;\n\nvoid\npciide_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpcitag_t tag = pa->pa_tag;\n\tstruct pciide_softc *sc = (struct pciide_softc *)self;\n\tpcireg_t csr;\n\tchar devinfo[256];\n\n\tsc->sc_pp = pciide_lookup_product(pa->pa_id);\n\tif (sc->sc_pp == NULL) {\n\t\tsc->sc_pp = &default_product_desc;\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);\n\t}\n\n\tsc->sc_pc = pa->pa_pc;\n\tsc->sc_tag = pa->pa_tag;\n\n\n#ifdef WDCDEBUG\n       if (wdcdebug_pciide_mask & DEBUG_PROBE)\n               printf(\"sc_pc %s, sc_tag %s\\n\", sc->sc_pc, sc->sc_tag);\n#endif\n\n\tsc->sc_pp->chip_map(sc, pa);\n\n\tif (sc->sc_dma_ok) {\n\t\tcsr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\t\tcsr |= PCI_COMMAND_MASTER_ENABLE;\n\t\tpci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);\n\t}\n\n\tWDCDEBUG_PRINT((\"pciide: command/status register=%x\\n\",\n\t    pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG)), DEBUG_PROBE);\n}"
  },
  {
    "function_name": "pciide_pci_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "143-156",
    "snippet": "static __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void pciide_pci_write",
      "__P((int, pcireg_t));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa",
            "(reg & ~0x03)",
            "pcival"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa",
            "(reg & ~0x03)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void pciide_pci_write;\n__P((int, pcireg_t));\n\nstatic __inline void\npciide_pci_write(pc, pa, reg, val)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n\tu_int8_t val;\n{\n\tpcireg_t pcival;\n\n\tpcival = pci_conf_read(pc, pa, (reg & ~0x03));\n\tpcival &= ~(0xff << ((reg & 0x03) * 8));\n\tpcival |= (val << ((reg & 0x03) * 8));\n\tpci_conf_write(pc, pa, (reg & ~0x03), pcival);\n}"
  },
  {
    "function_name": "pciide_pci_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pciide.c",
    "lines": "132-141",
    "snippet": "static __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}",
    "includes": [
      "#include <machine/bswap.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/pci/pciide_pdc202xx_reg.h>",
      "#include <dev/pci/pciide_acer_reg.h>",
      "#include <dev/pci/pciide_sis_reg.h>",
      "#include <dev/pci/pciide_cy693_reg.h>",
      "#include <dev/pci/pciide_cmd_reg.h>",
      "#include <dev/pci/pciide_apollo_reg.h>",
      "#include <dev/pci/pciide_amd_reg.h>",
      "#include <dev/pci/pciide_piix_reg.h>",
      "#include <dev/pci/pciidevar.h>",
      "#include <dev/pci/pciidereg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline u_int8_t pciide_pci_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa",
            "(reg & ~0x03)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bswap.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/pci/pciide_pdc202xx_reg.h>\n#include <dev/pci/pciide_acer_reg.h>\n#include <dev/pci/pciide_sis_reg.h>\n#include <dev/pci/pciide_cy693_reg.h>\n#include <dev/pci/pciide_cmd_reg.h>\n#include <dev/pci/pciide_apollo_reg.h>\n#include <dev/pci/pciide_amd_reg.h>\n#include <dev/pci/pciide_piix_reg.h>\n#include <dev/pci/pciidevar.h>\n#include <dev/pci/pciidereg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline u_int8_t pciide_pci_read;\n\nstatic __inline u_int8_t\npciide_pci_read(pc, pa, reg)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pa;\n\tint reg;\n{\n\n\treturn (pci_conf_read(pc, pa, (reg & ~0x03)) >>\n\t    ((reg & 0x03) * 8) & 0xff);\n}"
  }
]