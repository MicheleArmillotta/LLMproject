[
  {
    "function_name": "lmc_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_obsd.c",
    "lines": "402-411",
    "snippet": "static void\nlmc_shutdown(void *arg)\n{\n\tlmc_softc_t * const sc = arg;\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\n\tsc->lmc_miireg16 = 0;  /* deassert ready, and all others too */\n\tlmc_led_on(sc, LMC_MII16_LED_ALL);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void lmc_shutdown(void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lmc_led_on",
          "args": [
            "sc",
            "LMC_MII16_LED_ALL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_led_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "193-198",
          "snippet": "void\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_led_on(lmc_softc_t * const sc, u_int32_t led)\n{\n\tsc->lmc_miireg16 &= ~led;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_shutdown(void *arg);\n\nstatic void\nlmc_shutdown(void *arg)\n{\n\tlmc_softc_t * const sc = arg;\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\n\tsc->lmc_miireg16 = 0;  /* deassert ready, and all others too */\n\tlmc_led_on(sc, LMC_MII16_LED_ALL);\n}"
  },
  {
    "function_name": "lmc_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_obsd.c",
    "lines": "230-400",
    "snippet": "static void\nlmc_pci_attach(struct device * const parent,\n\t\tstruct device * const self, void * const aux)\n{\n\tu_int32_t revinfo, cfdainfo, id, ssid;\n\tpci_intr_handle_t intrhandle;\n\tconst char *intrstr;\n#if 0\n\tvm_offset_t pa_csrs;\n#endif\n\tunsigned csroffset = LMC_PCI_CSROFFSET;\n\tunsigned csrsize = LMC_PCI_CSRSIZE;\n\tlmc_csrptr_t csr_base;\n\tlmc_spl_t s;\n\tlmc_intrfunc_t (*intr_rtn)(void *) = lmc_intr_normal;\n\tlmc_softc_t * const sc = (lmc_softc_t *) self;\n\tstruct pci_attach_args * const pa = (struct pci_attach_args *) aux;\n\textern lmc_media_t lmc_hssi_media;\n\textern lmc_media_t lmc_ds3_media;\n\textern lmc_media_t lmc_t1_media;\n\textern lmc_media_t lmc_ssi_media;\n\n\trevinfo  = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFRV) & 0xFF;\n\tid       = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFID);\n\tcfdainfo = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFDA);\n\tssid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SSID);\n\n\tswitch (PCI_CHIPID(ssid)) {\n\tcase PCI_PRODUCT_LMC_HSSI:\n\t\tprintf(\": Lan Media Corporation HSSI\\n\");\n\t\tsc->lmc_media = &lmc_hssi_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_DS3:\n\t\tprintf(\": Lan Media Corporation DS3\\n\");\n\t\tsc->lmc_media = &lmc_ds3_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_SSI:\n\t\tprintf(\": Lan Media Corporation SSI\\n\");\n\t\tsc->lmc_media = &lmc_ssi_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_DS1:\n\t\tprintf(\": Lan Media Corporation T1\\n\");\n\t\tsc->lmc_media = &lmc_t1_media;\n\t\tbreak;\n\t}\n\n        sc->lmc_pci_busno = parent;\n        sc->lmc_pci_devno = pa->pa_device;\n\n\tsc->lmc_chipid = LMC_21140A;\n\tsc->lmc_features |= LMC_HAVE_STOREFWD;\n\tif (sc->lmc_chipid == LMC_21140A && revinfo <= 0x22)\n\t\tsc->lmc_features |= LMC_HAVE_RXBADOVRFLW;\n\n\tif (cfdainfo & (TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE)) {\n\t\tcfdainfo &= ~(TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE);\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_CFDA, cfdainfo);\n\t\tDELAY(11 * 1000);\n\t}\n\n\tbcopy(self->dv_xname, sc->lmc_if.if_xname, IFNAMSIZ);\n\tsc->lmc_if.if_softc = sc;\n\tsc->lmc_pc = pa->pa_pc;\n\n\tsc->lmc_revinfo = revinfo;\n\tsc->lmc_if.if_softc = sc;\n\n\tcsr_base = 0;\n\t{\n\t\tbus_space_tag_t iot, memt;\n\t\tbus_space_handle_t ioh, memh;\n\t\tint ioh_valid, memh_valid;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\t\tioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO,\n\t\t\t\t\t    0, &iot, &ioh, NULL, NULL) == 0);\n\t\tmemh_valid = (pci_mapreg_map(pa, PCI_CBMA,\n\t\t\t\t\t     PCI_MAPREG_TYPE_MEM |\n\t\t\t\t\t     PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t\t\t     0, &memt, &memh, NULL,\n\t\t\t\t\t     NULL) == 0);\n#endif\n\n\n\t\tif (memh_valid) {\n\t\t\tsc->lmc_bustag = memt;\n\t\t\tsc->lmc_bushandle = memh;\n\t\t} else if (ioh_valid) {\n\t\t\tsc->lmc_bustag = iot;\n\t\t\tsc->lmc_bushandle = ioh;\n\t\t} else {\n\t\t\tprintf(\"%s: unable to map device registers\\n\",\n\t\t\t       sc->lmc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\t/* Make sure bus mastering is enabled. */\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE);\n\t}\n\n\tlmc_initcsrs(sc, csr_base + csroffset, csrsize);\n\tlmc_initring(sc, &sc->lmc_rxinfo, sc->lmc_rxdescs,\n\t\t       LMC_RXDESCS);\n\tlmc_initring(sc, &sc->lmc_txinfo, sc->lmc_txdescs,\n\t\t       LMC_TXDESCS);\n\n\tlmc_gpio_mkinput(sc, 0xff);\n\tsc->lmc_gpio = 0;  /* drive no signals yet */\n\n\tsc->lmc_media->defaults(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN); /* down */\n\n\t/*\n\t * Make sure there won't be any interrupts or such...\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\n\t/*\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tDELAY(100);\n\n\tlmc_read_macaddr(sc);\n\n        if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n                         pa->pa_intrline, &intrhandle)) {\n\t\t printf(\"%s: couldn't map interrupt\\n\",\n\t\t\tsc->lmc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n\n#if defined(__OpenBSD__)\n\tsc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t\tintr_rtn, sc, self->dv_xname);\n#else\n\tsc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t\tintr_rtn, sc);\n#endif\n\n\tif (sc->lmc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t       sc->lmc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n        printf(\"%s: pass %d.%d, serial \" LMC_EADDR_FMT \", %s\\n\",\n               sc->lmc_dev.dv_xname,\n               (sc->lmc_revinfo & 0xF0) >> 4, sc->lmc_revinfo & 0x0F,\n               LMC_EADDR_ARGS(sc->lmc_enaddr), intrstr);\n\n        sc->lmc_ats = shutdownhook_establish(lmc_shutdown, sc);\n        if (sc->lmc_ats == NULL)\n\t\tprintf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t       sc->lmc_xname);\n\n\ts = LMC_RAISESPL();\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tlmc_attach(sc);\n\tLMC_RESTORESPL(s);\n}",
    "includes": [
      "#include \"i386/pci/if_lmcvar.h\"",
      "#include \"i386/pci/if_lmcioctl.h\"",
      "#include \"i386/pci/if_lmctypes.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
      "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <net/if_c_hdlc.h>",
      "#include <net/if_p2p.h>",
      "#include <net/if_types.h>",
      "#include <net/netisr.h>",
      "#include <net/if.h>",
      "#include <net/netisr.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_sppp.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/rnd.h>",
      "#include \"rnd.h\"",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nlmc_pci_probe(struct device *parent,\n#if defined (__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)\n\t       void *match,\n#else\n\t       struct cfdata *match,\n#endif\n\t       void *aux)\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;",
      "u_int32_t id;",
      "static void  lmc_pci_attach(struct device * const parent,\n\t\t\t     struct device * const self, void * const aux);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LMC_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_attach",
          "args": [
            "sc"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1420-1470",
          "snippet": "void\nlmc_attach(lmc_softc_t * const sc)\n{\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\n\tifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;\n\tifp->if_ioctl = lmc_ifioctl;\n\tifp->if_start = lmc_ifstart;\n\tifp->if_watchdog = lmc_watchdog;\n\tifp->if_timer = 1;\n\tifp->if_mtu = LMC_MTU;\n\n#if defined(__bsdi__)\n\tifp->if_type = IFT_NONE;\n\tifp->if_unit = (sc->lmc_dev.dv_unit);\n#endif\n  \n\tif_attach(ifp);\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tsppp_attach((struct ifnet *)&sc->lmc_sppp);\n\tsc->lmc_sppp.pp_flags = PP_CISCO | PP_KEEPALIVE;\n#endif\n#if defined(__bsdi__)\n\tsc->lmc_p2pcom.p2p_mdmctl = lmc_mdmctl;\n\tsc->lmc_p2pcom.p2p_getmdm = lmc_getmdm;\n\tp2p_attach(&sc->lmc_p2pcom);\n#endif\n\n#if NBPFILTER > 0\n\tLMC_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n\trnd_attach_source(&sc->lmc_rndsource, sc->lmc_dev.dv_xname,\n\t\t\t  RND_TYPE_NET, 0);\n#endif\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);",
            "static ifnet_ret_t lmc_ifstart(struct ifnet *ifp);",
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic ifnet_ret_t lmc_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t lmc_ifstart(struct ifnet *ifp);\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nvoid\nlmc_attach(lmc_softc_t * const sc)\n{\n\tstruct ifnet * const ifp = &sc->lmc_if;\n\n\tifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;\n\tifp->if_ioctl = lmc_ifioctl;\n\tifp->if_start = lmc_ifstart;\n\tifp->if_watchdog = lmc_watchdog;\n\tifp->if_timer = 1;\n\tifp->if_mtu = LMC_MTU;\n\n#if defined(__bsdi__)\n\tifp->if_type = IFT_NONE;\n\tifp->if_unit = (sc->lmc_dev.dv_unit);\n#endif\n  \n\tif_attach(ifp);\n\n#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n\tsppp_attach((struct ifnet *)&sc->lmc_sppp);\n\tsc->lmc_sppp.pp_flags = PP_CISCO | PP_KEEPALIVE;\n#endif\n#if defined(__bsdi__)\n\tsc->lmc_p2pcom.p2p_mdmctl = lmc_mdmctl;\n\tsc->lmc_p2pcom.p2p_getmdm = lmc_getmdm;\n\tp2p_attach(&sc->lmc_p2pcom);\n#endif\n\n#if NBPFILTER > 0\n\tLMC_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n\trnd_attach_source(&sc->lmc_rndsource, sc->lmc_dev.dv_xname,\n\t\t\t  RND_TYPE_NET, 0);\n#endif\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\t/*\n\t * for DS3 & DS1 adapters light the green light, led2\n\t */\n\tif (sc->lmc_cardtype == LMC_CARDTYPE_DS3 ||\n\t    sc->lmc_cardtype == LMC_CARDTYPE_T1)\n\t\tlmc_led_on (sc, LMC_MII16_LED2);\n\telse\n\t\tlmc_led_on (sc, LMC_MII16_LED0 | LMC_MII16_LED2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_reset",
          "args": [
            "sc"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "207-248",
          "snippet": "void\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_reset(lmc_softc_t * const sc)\n{\n\tsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\tsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\n\tlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\n\n\t/*\n\t * make some of the GPIO pins be outputs\n\t */\n\tlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * drive DP and RESET low to force configuration.  This also forces\n\t * the transmitter clock to be internal, but we expect to reset\n\t * that later anyway.\n\t */\n\tsc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);\n\tLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\n\n\t/*\n\t * hold for more than 10 microseconds\n\t */\n\tDELAY(50);\n\n\t/*\n\t * stop driving Xilinx-related signals\n\t */\n\tlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\n\n\t/*\n\t * busy wait for the chip to reset\n\t */\n\twhile ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);\n\n\t/*\n\t * Call media specific init routine\n\t */\n\tsc->lmc_media->init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_dec_reset",
          "args": [
            "sc"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_dec_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "250-386",
          "snippet": "void\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_CMD_RECEIVEALL 0x40000000L",
            "#define d_length2 u.bd_length2",
            "#define d_length1 u.bd_length1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#define d_length2 u.bd_length2\n#define d_length1 u.bd_length1\n\nvoid\nlmc_dec_reset(lmc_softc_t * const sc)\n{\n#ifndef __linux__\n\tlmc_ringinfo_t *ri;\n\ttulip_desc_t *di;\n#endif\n\tu_int32_t val;\n\n\t/*\n\t * disable all interrupts\n\t */\n\tsc->lmc_intrmask = 0;\n\tLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\n\n\t/*\n\t * we are, obviously, down.\n\t */\n#ifndef __linux__\n\tsc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);\n\n\tDP((\"lmc_dec_reset\\n\"));\n#endif\n\n\t/*\n\t * Reset the chip with a software reset command.\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\tDELAY(10);\n\tsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\n\n\t/*\n\t * We want:\n\t *   no ethernet address in frames we write\n\t *   disable padding (txdesc, padding disable)\n\t *   ignore runt frames (rdes0 bit 15)\n\t *   no receiver watchdog or transmitter jabber timer\n\t *       (csr15 bit 0,14 == 1)\n\t *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)\n\t */\n\n#ifndef TULIP_CMD_RECEIVEALL\n#define TULIP_CMD_RECEIVEALL 0x40000000L\n#endif\n\n\tsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\n\t\t\t       | TULIP_CMD_FULLDUPLEX\n\t\t\t       | TULIP_CMD_PASSBADPKT\n\t\t\t       | TULIP_CMD_NOHEARTBEAT\n\t\t\t       | TULIP_CMD_PORTSELECT\n\t\t\t       | TULIP_CMD_RECEIVEALL\n\t\t\t       | TULIP_CMD_MUSTBEONE\n\t\t\t       );\n\tsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\n\t\t\t\t| TULIP_CMD_THRESHOLDCTL\n\t\t\t\t| TULIP_CMD_STOREFWD\n\t\t\t\t| TULIP_CMD_TXTHRSHLDCTL\n\t\t\t\t);\n\n\tLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\n\n\t/*\n\t * disable receiver watchdog and transmit jabber\n\t */\n\tval = LMC_CSR_READ(sc, csr_sia_general);\n\tval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\n\tLMC_CSR_WRITE(sc, csr_sia_general, val);\n\n\t/*\n\t * turn off those LEDs...\n\t */\n\tsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\n\tlmc_led_on(sc, LMC_MII16_LED0);\n\n#ifndef __linux__\n\t/*\n\t * reprogram the tx desc, rx desc, and PCI bus options\n\t */\n\tLMC_CSR_WRITE(sc, csr_txlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_rxlist,\n\t\t\tLMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));\n\tLMC_CSR_WRITE(sc, csr_busmode,\n\t\t\t(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))\n\t\t\t|TULIP_BUSMODE_CACHE_ALIGN8\n\t\t\t|TULIP_BUSMODE_READMULTIPLE\n\t\t\t|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));\n\n\tsc->lmc_txq.ifq_maxlen = LMC_TXDESCS;\n\n\t/*\n\t * Free all the mbufs that were on the transmit ring.\n\t */\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\n\t\tIF_DEQUEUE(&sc->lmc_txq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n\n\t/*\n\t * reset descriptor state and reclaim all descriptors.\n\t */\n\tri = &sc->lmc_txinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++)\n\t\tdi->d_status = 0;\n\n\t/*\n\t * We need to collect all the mbufs were on the \n\t * receive ring before we reinit it either to put\n\t * them back on or to know if we have to allocate\n\t * more.\n\t */\n\tri = &sc->lmc_rxinfo;\n\tri->ri_nextin = ri->ri_nextout = ri->ri_first;\n\tri->ri_free = ri->ri_max;\n\tfor (di = ri->ri_first; di < ri->ri_last; di++) {\n\t\tdi->d_status = 0;\n\t\tdi->d_length1 = 0; di->d_addr1 = 0;\n\t\tdi->d_length2 = 0; di->d_addr2 = 0;\n\t}\n\tfor (;;) {\n\t\tstruct mbuf *m;\n\t\tIF_DEQUEUE(&sc->lmc_rxq, m);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tm_freem(m);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "LMC_RAISESPL",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: warning: couldn't establish shutdown hook\\n\"",
            "sc->lmc_xname"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "lmc_shutdown",
            "sc"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_EADDR_ARGS",
          "args": [
            "sc->lmc_enaddr"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_NET",
            "intr_rtn",
            "sc"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_NET",
            "intr_rtn",
            "sc",
            "self->dv_xname"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "intrhandle"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&intrhandle"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_read_macaddr",
          "args": [
            "sc"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_read_macaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "395-403",
          "snippet": "int\nlmc_read_macaddr(lmc_softc_t * const sc)\n{\n\tlmc_srom_read(sc);\n\n\tbcopy(sc->lmc_rombuf + 20, sc->lmc_enaddr, 6);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nint\nlmc_read_macaddr(lmc_softc_t * const sc)\n{\n\tlmc_srom_read(sc);\n\n\tbcopy(sc->lmc_rombuf + 20, sc->lmc_enaddr, 6);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LMC_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->set_link_status",
          "args": [
            "sc",
            "LMC_LINK_DOWN"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->lmc_media->defaults",
          "args": [
            "sc"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lmc_gpio_mkinput",
          "args": [
            "sc",
            "0xff"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_gpio_mkinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "179-184",
          "snippet": "void\nlmc_gpio_mkinput(lmc_softc_t * const sc, u_int32_t bits)\n{\n\tsc->lmc_gpio_io &= ~bits;\n\tLMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_gpio_mkinput(lmc_softc_t * const sc, u_int32_t bits)\n{\n\tsc->lmc_gpio_io &= ~bits;\n\tLMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_initring",
          "args": [
            "sc",
            "&sc->lmc_txinfo",
            "sc->lmc_txdescs",
            "LMC_TXDESCS"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_initring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "1472-1481",
          "snippet": "void\nlmc_initring(lmc_softc_t * const sc, lmc_ringinfo_t * const ri,\n\t       tulip_desc_t *descs, int ndescs)\n{\n\tri->ri_max = ndescs;\n\tri->ri_first = descs;\n\tri->ri_last = ri->ri_first + ri->ri_max;\n\tbzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n\tri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d_flag u.bd_flag"
          ],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d_flag u.bd_flag\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nvoid\nlmc_initring(lmc_softc_t * const sc, lmc_ringinfo_t * const ri,\n\t       tulip_desc_t *descs, int ndescs)\n{\n\tri->ri_max = ndescs;\n\tri->ri_first = descs;\n\tri->ri_last = ri->ri_first + ri->ri_max;\n\tbzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n\tri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lmc_initcsrs",
          "args": [
            "sc",
            "csr_base + csroffset",
            "csrsize"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_initcsrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc_common.c",
          "lines": "388-408",
          "snippet": "void\nlmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base,\n\t     size_t csr_size)\n{\n\tsc->lmc_csrs.csr_busmode\t= csr_base +  0 * csr_size;\n\tsc->lmc_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n\tsc->lmc_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n\tsc->lmc_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n\tsc->lmc_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n\tsc->lmc_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n\tsc->lmc_csrs.csr_command\t= csr_base +  6 * csr_size;\n\tsc->lmc_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n\tsc->lmc_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n\tsc->lmc_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n\tsc->lmc_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n\tsc->lmc_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n\tsc->lmc_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n\tsc->lmc_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n\tsc->lmc_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n\tsc->lmc_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmc_types.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmc_types.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nlmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base,\n\t     size_t csr_size)\n{\n\tsc->lmc_csrs.csr_busmode\t= csr_base +  0 * csr_size;\n\tsc->lmc_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n\tsc->lmc_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n\tsc->lmc_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n\tsc->lmc_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n\tsc->lmc_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n\tsc->lmc_csrs.csr_command\t= csr_base +  6 * csr_size;\n\tsc->lmc_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n\tsc->lmc_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n\tsc->lmc_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n\tsc->lmc_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n\tsc->lmc_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n\tsc->lmc_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n\tsc->lmc_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n\tsc->lmc_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n\tsc->lmc_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBMA",
            "PCI_MAPREG_TYPE_MEM |\n\t\t\t\t\t     PCI_MAPREG_MEM_TYPE_32BIT",
            "0",
            "&memt",
            "&memh",
            "NULL",
            "NULL"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "self->dv_xname",
            "sc->lmc_if.if_xname",
            "IFNAMSIZ"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "11 * 1000"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CFDA",
            "cfdainfo"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "ssid"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_SSID"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CFDA"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CFID"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CFRV"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\nlmc_pci_probe(struct device *parent,\n#if defined (__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)\n\t       void *match,\n#else\n\t       struct cfdata *match,\n#endif\n\t       void *aux)\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\nu_int32_t id;\nstatic void  lmc_pci_attach(struct device * const parent,\n\t\t\t     struct device * const self, void * const aux);\n\nstatic void\nlmc_pci_attach(struct device * const parent,\n\t\tstruct device * const self, void * const aux)\n{\n\tu_int32_t revinfo, cfdainfo, id, ssid;\n\tpci_intr_handle_t intrhandle;\n\tconst char *intrstr;\n#if 0\n\tvm_offset_t pa_csrs;\n#endif\n\tunsigned csroffset = LMC_PCI_CSROFFSET;\n\tunsigned csrsize = LMC_PCI_CSRSIZE;\n\tlmc_csrptr_t csr_base;\n\tlmc_spl_t s;\n\tlmc_intrfunc_t (*intr_rtn)(void *) = lmc_intr_normal;\n\tlmc_softc_t * const sc = (lmc_softc_t *) self;\n\tstruct pci_attach_args * const pa = (struct pci_attach_args *) aux;\n\textern lmc_media_t lmc_hssi_media;\n\textern lmc_media_t lmc_ds3_media;\n\textern lmc_media_t lmc_t1_media;\n\textern lmc_media_t lmc_ssi_media;\n\n\trevinfo  = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFRV) & 0xFF;\n\tid       = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFID);\n\tcfdainfo = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFDA);\n\tssid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SSID);\n\n\tswitch (PCI_CHIPID(ssid)) {\n\tcase PCI_PRODUCT_LMC_HSSI:\n\t\tprintf(\": Lan Media Corporation HSSI\\n\");\n\t\tsc->lmc_media = &lmc_hssi_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_DS3:\n\t\tprintf(\": Lan Media Corporation DS3\\n\");\n\t\tsc->lmc_media = &lmc_ds3_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_SSI:\n\t\tprintf(\": Lan Media Corporation SSI\\n\");\n\t\tsc->lmc_media = &lmc_ssi_media;\n\t\tbreak;\n\tcase PCI_PRODUCT_LMC_DS1:\n\t\tprintf(\": Lan Media Corporation T1\\n\");\n\t\tsc->lmc_media = &lmc_t1_media;\n\t\tbreak;\n\t}\n\n        sc->lmc_pci_busno = parent;\n        sc->lmc_pci_devno = pa->pa_device;\n\n\tsc->lmc_chipid = LMC_21140A;\n\tsc->lmc_features |= LMC_HAVE_STOREFWD;\n\tif (sc->lmc_chipid == LMC_21140A && revinfo <= 0x22)\n\t\tsc->lmc_features |= LMC_HAVE_RXBADOVRFLW;\n\n\tif (cfdainfo & (TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE)) {\n\t\tcfdainfo &= ~(TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE);\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_CFDA, cfdainfo);\n\t\tDELAY(11 * 1000);\n\t}\n\n\tbcopy(self->dv_xname, sc->lmc_if.if_xname, IFNAMSIZ);\n\tsc->lmc_if.if_softc = sc;\n\tsc->lmc_pc = pa->pa_pc;\n\n\tsc->lmc_revinfo = revinfo;\n\tsc->lmc_if.if_softc = sc;\n\n\tcsr_base = 0;\n\t{\n\t\tbus_space_tag_t iot, memt;\n\t\tbus_space_handle_t ioh, memh;\n\t\tint ioh_valid, memh_valid;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\t\tioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO,\n\t\t\t\t\t    0, &iot, &ioh, NULL, NULL) == 0);\n\t\tmemh_valid = (pci_mapreg_map(pa, PCI_CBMA,\n\t\t\t\t\t     PCI_MAPREG_TYPE_MEM |\n\t\t\t\t\t     PCI_MAPREG_MEM_TYPE_32BIT,\n\t\t\t\t\t     0, &memt, &memh, NULL,\n\t\t\t\t\t     NULL) == 0);\n#endif\n\n\n\t\tif (memh_valid) {\n\t\t\tsc->lmc_bustag = memt;\n\t\t\tsc->lmc_bushandle = memh;\n\t\t} else if (ioh_valid) {\n\t\t\tsc->lmc_bustag = iot;\n\t\t\tsc->lmc_bushandle = ioh;\n\t\t} else {\n\t\t\tprintf(\"%s: unable to map device registers\\n\",\n\t\t\t       sc->lmc_dev.dv_xname);\n\t\t\treturn;\n\t\t}\n\t\t/* Make sure bus mastering is enabled. */\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t     PCI_COMMAND_STATUS_REG) |\n\t\t\t       PCI_COMMAND_MASTER_ENABLE);\n\t}\n\n\tlmc_initcsrs(sc, csr_base + csroffset, csrsize);\n\tlmc_initring(sc, &sc->lmc_rxinfo, sc->lmc_rxdescs,\n\t\t       LMC_RXDESCS);\n\tlmc_initring(sc, &sc->lmc_txinfo, sc->lmc_txdescs,\n\t\t       LMC_TXDESCS);\n\n\tlmc_gpio_mkinput(sc, 0xff);\n\tsc->lmc_gpio = 0;  /* drive no signals yet */\n\n\tsc->lmc_media->defaults(sc);\n\n\tsc->lmc_media->set_link_status(sc, LMC_LINK_DOWN); /* down */\n\n\t/*\n\t * Make sure there won't be any interrupts or such...\n\t */\n\tLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n\n\t/*\n\t * Wait 10 microseconds (actually 50 PCI cycles but at \n\t * 33MHz that comes to two microseconds but wait a\n\t * bit longer anyways)\n\t */\n\tDELAY(100);\n\n\tlmc_read_macaddr(sc);\n\n        if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n                         pa->pa_intrline, &intrhandle)) {\n\t\t printf(\"%s: couldn't map interrupt\\n\",\n\t\t\tsc->lmc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, intrhandle);\n\n#if defined(__OpenBSD__)\n\tsc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t\tintr_rtn, sc, self->dv_xname);\n#else\n\tsc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t\tintr_rtn, sc);\n#endif\n\n\tif (sc->lmc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t       sc->lmc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n        printf(\"%s: pass %d.%d, serial \" LMC_EADDR_FMT \", %s\\n\",\n               sc->lmc_dev.dv_xname,\n               (sc->lmc_revinfo & 0xF0) >> 4, sc->lmc_revinfo & 0x0F,\n               LMC_EADDR_ARGS(sc->lmc_enaddr), intrstr);\n\n        sc->lmc_ats = shutdownhook_establish(lmc_shutdown, sc);\n        if (sc->lmc_ats == NULL)\n\t\tprintf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t       sc->lmc_xname);\n\n\ts = LMC_RAISESPL();\n\tlmc_dec_reset(sc);\n\tlmc_reset(sc);\n\tlmc_attach(sc);\n\tLMC_RESTORESPL(s);\n}"
  }
]