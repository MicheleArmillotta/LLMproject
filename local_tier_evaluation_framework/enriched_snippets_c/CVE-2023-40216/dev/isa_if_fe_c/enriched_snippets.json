[
  {
    "function_name": "fe_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2444-2483",
    "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + FE_DLCR7",
            "save_dlcr7"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "level",
            "\"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\"",
            "inb(iobase + FE_BMPR10)",
            "inb(iobase + FE_BMPR11)",
            "inb(iobase + FE_BMPR12)",
            "inb(iobase + FE_BMPR13)",
            "inb(iobase + FE_BMPR14)",
            "inb(iobase + FE_BMPR15)",
            "inb(iobase + FE_BMPR16)",
            "inb(iobase + FE_BMPR17)",
            "inb(iobase + FE_BMPR19)"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + FE_BMPR19"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
  },
  {
    "function_name": "fe_loadmar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2413-2441",
    "snippet": "void\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_loadmar"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: address filter changed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR6",
            "sc->proto_dlcr6 | FE_D6_DLC_ENABLE"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "outblk",
          "args": [
            "sc->sc_iobase + FE_MAR8",
            "sc->filter",
            "FE_FILTER_LEN"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "outblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "272-278",
          "snippet": "static inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_loadmar;\n\nvoid\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}"
  },
  {
    "function_name": "fe_setmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2310-2403",
    "snippet": "void\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "int\tfeintr",
      "void\tfe_init",
      "void\tfe_getmcaf",
      "void\tfe_setmode",
      "void\tfe_loadmar"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: filter change delayed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_loadmar",
          "args": [
            "sc"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "fe_loadmar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2413-2441",
          "snippet": "void\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_loadmar"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_loadmar;\n\nvoid\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase + FE_DLCR1"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->filter[0]",
            "sc->filter[1]",
            "sc->filter[2]",
            "sc->filter[3]",
            "sc->filter[4]",
            "sc->filter[5]",
            "sc->filter[6]",
            "sc->filter[7]"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_getmcaf",
          "args": [
            "&sc->sc_arpcom",
            "sc->filter"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "fe_getmcaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2238-2304",
          "snippet": "void\nfe_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_char *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_long crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif ((ifp->if_flags & IFF_PROMISC) != 0)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0x00;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0xff;\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));",
            "void\tfe_getmcaf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_getmcaf;\n\nvoid\nfe_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_char *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_long crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif ((ifp->if_flags & IFF_PROMISC) != 0)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0x00;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR5",
            "sc->proto_dlcr5 | FE_D5_AFM1"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nint\tfeintr;\nvoid\tfe_init;\nvoid\tfe_getmcaf;\nvoid\tfe_setmode;\nvoid\tfe_loadmar;\n\nvoid\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}"
  },
  {
    "function_name": "fe_getmcaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2238-2304",
    "snippet": "void\nfe_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_char *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_long crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif ((ifp->if_flags & IFF_PROMISC) != 0)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0x00;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0xff;\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));",
      "void\tfe_getmcaf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_getmcaf;\n\nvoid\nfe_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_char *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_long crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif ((ifp->if_flags & IFF_PROMISC) != 0)\n\t\tgoto allmulti;\n\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0x00;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tgoto allmulti;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif ((crc & 0x01) ^ (c & 0x01)) {\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\t\tcrc ^= 0xedb88320;\n\t\t\t\t} else\n\t\t\t\t\tcrc >>= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n\treturn;\n\nallmulti:\n\tifp->if_flags |= IFF_ALLMULTI;\n\taf[0] = af[1] = af[2] = af[3] = af[4] = af[5] = af[6] = af[7] = 0xff;\n}"
  },
  {
    "function_name": "fe_write_mbufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2107-2232",
    "snippet": "void\nfe_write_mbufs(sc, m)\n\tstruct fe_softc *sc;\n\tstruct mbuf *m;\n{\n\tint bmpr8 = sc->sc_iobase + FE_BMPR8;\n\tstruct mbuf *mp;\n\tu_char *data;\n\tu_short savebyte;\t/* WARNING: Architecture dependent! */\n\tint totlen, len, wantbyte;\n\n#if FE_DELAYED_PADDING\n\t/* Do the \"delayed padding.\" */\n\tlen = sc->txb_padding >> 1;\n\tif (len > 0) {\n\t\twhile (--len >= 0)\n\t\t\toutw(bmpr8, 0);\n\t\tsc->txb_padding = 0;\n\t}\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m->m_flags & M_PKTHDR) == 0)\n\t  \tpanic(\"fe_write_mbufs: no header mbuf\");\n\n#if FE_DEBUG >= 2\n\t/* First, count up the total number of bytes to copy. */\n\tfor (totlen = 0, mp = m; mp != 0; mp = mp->m_next)\n\t\ttotlen += mp->m_len;\n\t/* Check if this matches the one in the packet header. */\n\tif (totlen != m->m_pkthdr.len)\n\t\tlog(LOG_WARNING, \"%s: packet length mismatch? (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, totlen, m->m_pkthdr.len);\n#else\n\t/* Just use the length value in the packet header. */\n\ttotlen = m->m_pkthdr.len;\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * Should never send big packets.  If such a packet is passed,\n\t * it should be a bug of upper layer.  We just ignore it.\n\t * ... Partial (too short) packets, neither.\n\t */\n\tif (totlen > ETHER_MAX_LEN || totlen < ETHER_HDR_SIZE) {\n\t\tlog(LOG_ERR, \"%s: got a %s packet (%u bytes) to send\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    totlen < ETHER_HDR_SIZE ? \"partial\" : \"big\", totlen);\n\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Put the length word for this frame.\n\t * Does 86960 accept odd length?  -- Yes.\n\t * Do we need to pad the length to minimum size by ourselves?\n\t * -- Generally yes.  But for (or will be) the last\n\t * packet in the transmission buffer, we can skip the\n\t * padding process.  It may gain performance slightly.  FIXME.\n\t */\n\toutw(bmpr8, max(totlen, ETHER_MIN_LEN));\n\n\t/*\n\t * Update buffer status now.\n\t * Truncate the length up to an even number, since we use outw().\n\t */\n\ttotlen = (totlen + 1) & ~1;\n\tsc->txb_free -= FE_DATA_LEN_LEN + max(totlen, ETHER_MIN_LEN);\n\tsc->txb_count++;\n\n#if FE_DELAYED_PADDING\n\t/* Postpone the packet padding if necessary. */\n\tif (totlen < ETHER_MIN_LEN)\n\t\tsc->txb_padding = ETHER_MIN_LEN - totlen;\n#endif\n\n\t/*\n\t * Transfer the data from mbuf chain to the transmission buffer. \n\t * MB86960 seems to require that data be transferred as words, and\n\t * only words.  So that we require some extra code to patch\n\t * over odd-length mbufs.\n\t */\n\twantbyte = 0;\n\tfor (; m != 0; m = m->m_next) {\n\t\t/* Ignore empty mbuf. */\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the actual data to send. */\n\t\tdata = mtod(m, caddr_t);\n\n\t\t/* Finish the last byte. */\n\t\tif (wantbyte) {\n\t\t\toutw(bmpr8, savebyte | (*data << 8));\n\t\t\tdata++;\n\t\t\tlen--;\n\t\t\twantbyte = 0;\n\t\t}\n\n\t\t/* Output contiguous words. */\n\t\tif (len > 1)\n\t\t\toutsw(bmpr8, data, len >> 1);\n\n\t\t/* Save remaining byte, if there is one. */\n\t\tif (len & 1) {\n\t\t\tdata += len & ~1;\n\t\t\tsavebyte = *data;\n\t\t\twantbyte = 1;\n\t\t}\n\t}\n\n\t/* Spit the last byte, if the length is odd. */\n\tif (wantbyte)\n\t\toutw(bmpr8, savebyte);\n\n#if ! FE_DELAYED_PADDING\n\t/*\n\t * Pad the packet to the minimum length if necessary.\n\t */\n\tlen = (ETHER_MIN_LEN >> 1) - (totlen >> 1);\n\twhile (--len >= 0)\n\t\toutw(bmpr8, 0);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */",
      "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
      "#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */",
      "#define FE_DELAYED_PADDING\t0",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));",
      "void\tfe_write_mbufs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "bmpr8",
            "0"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "bmpr8",
            "savebyte"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outsw",
          "args": [
            "bmpr8",
            "data",
            "len >> 1"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "bmpr8",
            "savebyte | (*data << 8)"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "totlen",
            "ETHER_MIN_LEN"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "gusmax_mixer_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2892-3092",
          "snippet": "int\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "bmpr8",
            "max(totlen, ETHER_MIN_LEN)"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: got a %s packet (%u bytes) to send\\n\"",
            "sc->sc_dev.dv_xname",
            "totlen < ETHER_HDR_SIZE ? \"partial\" : \"big\"",
            "totlen"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"fe_write_mbufs: no header mbuf\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "bmpr8",
            "0"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */\n#define FE_DELAYED_PADDING\t0\n#define FE_DEBUG\t\t1\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_write_mbufs;\n\nvoid\nfe_write_mbufs(sc, m)\n\tstruct fe_softc *sc;\n\tstruct mbuf *m;\n{\n\tint bmpr8 = sc->sc_iobase + FE_BMPR8;\n\tstruct mbuf *mp;\n\tu_char *data;\n\tu_short savebyte;\t/* WARNING: Architecture dependent! */\n\tint totlen, len, wantbyte;\n\n#if FE_DELAYED_PADDING\n\t/* Do the \"delayed padding.\" */\n\tlen = sc->txb_padding >> 1;\n\tif (len > 0) {\n\t\twhile (--len >= 0)\n\t\t\toutw(bmpr8, 0);\n\t\tsc->txb_padding = 0;\n\t}\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m->m_flags & M_PKTHDR) == 0)\n\t  \tpanic(\"fe_write_mbufs: no header mbuf\");\n\n#if FE_DEBUG >= 2\n\t/* First, count up the total number of bytes to copy. */\n\tfor (totlen = 0, mp = m; mp != 0; mp = mp->m_next)\n\t\ttotlen += mp->m_len;\n\t/* Check if this matches the one in the packet header. */\n\tif (totlen != m->m_pkthdr.len)\n\t\tlog(LOG_WARNING, \"%s: packet length mismatch? (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, totlen, m->m_pkthdr.len);\n#else\n\t/* Just use the length value in the packet header. */\n\ttotlen = m->m_pkthdr.len;\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * Should never send big packets.  If such a packet is passed,\n\t * it should be a bug of upper layer.  We just ignore it.\n\t * ... Partial (too short) packets, neither.\n\t */\n\tif (totlen > ETHER_MAX_LEN || totlen < ETHER_HDR_SIZE) {\n\t\tlog(LOG_ERR, \"%s: got a %s packet (%u bytes) to send\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    totlen < ETHER_HDR_SIZE ? \"partial\" : \"big\", totlen);\n\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Put the length word for this frame.\n\t * Does 86960 accept odd length?  -- Yes.\n\t * Do we need to pad the length to minimum size by ourselves?\n\t * -- Generally yes.  But for (or will be) the last\n\t * packet in the transmission buffer, we can skip the\n\t * padding process.  It may gain performance slightly.  FIXME.\n\t */\n\toutw(bmpr8, max(totlen, ETHER_MIN_LEN));\n\n\t/*\n\t * Update buffer status now.\n\t * Truncate the length up to an even number, since we use outw().\n\t */\n\ttotlen = (totlen + 1) & ~1;\n\tsc->txb_free -= FE_DATA_LEN_LEN + max(totlen, ETHER_MIN_LEN);\n\tsc->txb_count++;\n\n#if FE_DELAYED_PADDING\n\t/* Postpone the packet padding if necessary. */\n\tif (totlen < ETHER_MIN_LEN)\n\t\tsc->txb_padding = ETHER_MIN_LEN - totlen;\n#endif\n\n\t/*\n\t * Transfer the data from mbuf chain to the transmission buffer. \n\t * MB86960 seems to require that data be transferred as words, and\n\t * only words.  So that we require some extra code to patch\n\t * over odd-length mbufs.\n\t */\n\twantbyte = 0;\n\tfor (; m != 0; m = m->m_next) {\n\t\t/* Ignore empty mbuf. */\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the actual data to send. */\n\t\tdata = mtod(m, caddr_t);\n\n\t\t/* Finish the last byte. */\n\t\tif (wantbyte) {\n\t\t\toutw(bmpr8, savebyte | (*data << 8));\n\t\t\tdata++;\n\t\t\tlen--;\n\t\t\twantbyte = 0;\n\t\t}\n\n\t\t/* Output contiguous words. */\n\t\tif (len > 1)\n\t\t\toutsw(bmpr8, data, len >> 1);\n\n\t\t/* Save remaining byte, if there is one. */\n\t\tif (len & 1) {\n\t\t\tdata += len & ~1;\n\t\t\tsavebyte = *data;\n\t\t\twantbyte = 1;\n\t\t}\n\t}\n\n\t/* Spit the last byte, if the length is odd. */\n\tif (wantbyte)\n\t\toutw(bmpr8, savebyte);\n\n#if ! FE_DELAYED_PADDING\n\t/*\n\t * Pad the packet to the minimum length if necessary.\n\t */\n\tlen = (ETHER_MIN_LEN >> 1) - (totlen >> 1);\n\twhile (--len >= 0)\n\t\toutw(bmpr8, 0);\n#endif\n}"
  },
  {
    "function_name": "fe_get_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "2022-2088",
    "snippet": "int\nfe_get_packet(sc, len)\n\tstruct fe_softc *sc;\n\tint len;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Allocate a header mbuf. */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = len;\n\n\t/* The following silliness is to make NFS happy. */\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n\n\t/*\n\t * Our strategy has one more problem.  There is a policy on\n\t * mbuf cluster allocation.  It says that we must have at\n\t * least MINCLSIZE (208 bytes) to allocate a cluster.  For a\n\t * packet of a size between (MHLEN - 2) to (MINCLSIZE - 2),\n\t * our code violates the rule...\n\t * On the other hand, the current code is short, simle,\n\t * and fast, however.  It does no harmful thing, just waists\n\t * some memory.  Any comments?  FIXME.\n\t */\n\n\t/* Attach a cluster if this packet doesn't fit in a normal mbuf. */\n\tif (len > MHLEN - EOFF) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * The following assumes there is room for the ether header in the\n\t * header mbuf.\n\t */\n\tm->m_data += EOFF;\n\teh = mtod(m, struct ether_header *);\n\n\t/* Set the length of this packet. */\n\tm->m_len = len;\n\n\t/* Get a packet. */\n\tinsw(sc->sc_iobase + FE_BMPR8, m->m_data, (len + 1) >> 1);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.  If so, hand off\n\t * the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tEOFF\t(EROUND - sizeof(struct ether_header))",
      "#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)"
    ],
    "globals_used": [
      "int\tfe_get_packet"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insw",
          "args": [
            "sc->sc_iobase + FE_BMPR8",
            "m->m_data",
            "(len + 1) >> 1"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n\nint\tfe_get_packet;\n\nint\nfe_get_packet(sc, len)\n\tstruct fe_softc *sc;\n\tint len;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Allocate a header mbuf. */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = len;\n\n\t/* The following silliness is to make NFS happy. */\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n\n\t/*\n\t * Our strategy has one more problem.  There is a policy on\n\t * mbuf cluster allocation.  It says that we must have at\n\t * least MINCLSIZE (208 bytes) to allocate a cluster.  For a\n\t * packet of a size between (MHLEN - 2) to (MINCLSIZE - 2),\n\t * our code violates the rule...\n\t * On the other hand, the current code is short, simle,\n\t * and fast, however.  It does no harmful thing, just waists\n\t * some memory.  Any comments?  FIXME.\n\t */\n\n\t/* Attach a cluster if this packet doesn't fit in a normal mbuf. */\n\tif (len > MHLEN - EOFF) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * The following assumes there is room for the ether header in the\n\t * header mbuf.\n\t */\n\tm->m_data += EOFF;\n\teh = mtod(m, struct ether_header *);\n\n\t/* Set the length of this packet. */\n\tm->m_len = len;\n\n\t/* Get a packet. */\n\tinsw(sc->sc_iobase + FE_BMPR8, m->m_data, (len + 1) >> 1);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.  If so, hand off\n\t * the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\treturn (1);\n}"
  },
  {
    "function_name": "fe_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1920-2015",
    "snippet": "int\nfe_ioctl(ifp, command, data)\n\tregister struct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tregister struct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ioctl(%x)\\n\", sc->sc_dev.dv_xname, command);\n#endif\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (command) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tfe_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tfe_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tfe_setmode(sc);\n\t\t}\n#if DEBUG >= 1\n\t\t/* \"ifconfig fe0 debug\" to print register dump. */\n\t\tif (ifp->if_flags & IFF_DEBUG) {\n\t\t\tlog(LOG_INFO, \"%s: SIOCSIFFLAGS(DEBUG)\\n\", sc->sc_dev.dv_xname);\n\t\t\tfe_dump(LOG_DEBUG, sc);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* Update our multicast list. */\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tfe_setmode(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_init",
      "int\tfe_ioctl",
      "void\tfe_stop",
      "void\tfe_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fe_setmode",
          "args": [
            "sc"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "fe_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2310-2403",
          "snippet": "void\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "int\tfeintr",
            "void\tfe_init",
            "void\tfe_getmcaf",
            "void\tfe_setmode",
            "void\tfe_loadmar"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nint\tfeintr;\nvoid\tfe_init;\nvoid\tfe_getmcaf;\nvoid\tfe_setmode;\nvoid\tfe_loadmar;\n\nvoid\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_DEBUG",
            "sc"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: SIOCSIFFLAGS(DEBUG)\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_init",
          "args": [
            "sc"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "fe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1230-1381",
          "snippet": "void\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)",
            "#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)",
            "#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)",
            "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
            "#define sc_enaddr\tsc_arpcom.ac_enaddr",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_init",
            "void\tfe_start",
            "void\tfe_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)\n#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)\n#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_DEBUG\t\t1\n\nvoid\tfe_init;\nvoid\tfe_start;\nvoid\tfe_setmode;\n\nvoid\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_stop",
          "args": [
            "sc"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "fe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1154-1193",
          "snippet": "void\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_stop;\n\nvoid\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "command",
            "data"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: ioctl(%x)\\n\"",
            "sc->sc_dev.dv_xname",
            "command"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_init;\nint\tfe_ioctl;\nvoid\tfe_stop;\nvoid\tfe_setmode;\n\nint\nfe_ioctl(ifp, command, data)\n\tregister struct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tregister struct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ioctl(%x)\\n\", sc->sc_dev.dv_xname, command);\n#endif\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (command) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfe_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfe_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tfe_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tfe_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tfe_setmode(sc);\n\t\t}\n#if DEBUG >= 1\n\t\t/* \"ifconfig fe0 debug\" to print register dump. */\n\t\tif (ifp->if_flags & IFF_DEBUG) {\n\t\t\tlog(LOG_INFO, \"%s: SIOCSIFFLAGS(DEBUG)\\n\", sc->sc_dev.dv_xname);\n\t\t\tfe_dump(LOG_DEBUG, sc);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* Update our multicast list. */\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tfe_setmode(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "feintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1841-1915",
    "snippet": "int\nfeintr(arg)\n\tvoid *arg;\n{\n\tstruct fe_softc *sc = arg;\n\tu_char tstat, rstat;\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: feintr()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Get interrupt conditions, masking unneeded flags.\n\t */\n\ttstat = inb(sc->sc_iobase + FE_DLCR0) & FE_TMASK;\n\trstat = inb(sc->sc_iobase + FE_DLCR1) & FE_RMASK;\n\tif (tstat == 0 && rstat == 0)\n\t\treturn (0);\n\n\t/*\n\t * Loop until there are no more new interrupt conditions.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset the conditions we are acknowledging.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, tstat);\n\t\toutb(sc->sc_iobase + FE_DLCR1, rstat);\n\n\t\t/*\n\t\t * Handle transmitter interrupts. Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t */\n\t\tif (tstat != 0)\n\t\t\tfe_tint(sc, tstat);\n\n\t\t/*\n\t\t * Handle receiver interrupts.\n\t\t */\n\t\tif (rstat != 0)\n\t\t\tfe_rint(sc, rstat);\n\n\t\t/*\n\t\t * Update the multicast address filter if it is\n\t\t * needed and possible.  We do it now, because\n\t\t * we can make sure the transmission buffer is empty,\n\t\t * and there is a good chance that the receive queue\n\t\t * is empty.  It will minimize the possibility of\n\t\t * packet lossage.\n\t\t */\n\t\tif (sc->filter_change &&\n\t\t    sc->txb_count == 0 && sc->txb_sched == 0) {\n\t\t\tfe_loadmar(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data,\n\t\t * attempt to start output on the interface. This is done\n\t\t * after handling the receiver interrupt to give the\n\t\t * receive operation priority.\n\t\t */\n\t\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE) == 0)\n\t\t\tfe_start(&sc->sc_arpcom.ac_if);\n\n\t\t/*\n\t\t * Get interrupt conditions, masking unneeded flags.\n\t\t */\n\t\ttstat = inb(sc->sc_iobase + FE_DLCR0) & FE_TMASK;\n\t\trstat = inb(sc->sc_iobase + FE_DLCR1) & FE_RMASK;\n\t\tif (tstat == 0 && rstat == 0)\n\t\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)",
      "#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "int\tfeintr",
      "void\tfe_start",
      "void\tfe_tint",
      "__P((/*struct fe_softc *, u_char*/));",
      "void\tfe_rint",
      "__P((/*struct fe_softc *, u_char*/));",
      "void\tfe_loadmar"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase + FE_DLCR1"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_start",
          "args": [
            "&sc->sc_arpcom.ac_if"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "fe_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1421-1563",
          "snippet": "void\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
            "#define FE_SINGLE_TRANSMISSION\t0",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_start",
            "static inline\nvoid\tfe_xmit",
            "void\tfe_write_mbufs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define FE_SINGLE_TRANSMISSION\t0\n#define FE_DEBUG\t\t1\n\nvoid\tfe_start;\nstatic inline\nvoid\tfe_xmit;\nvoid\tfe_write_mbufs;\n\nvoid\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_loadmar",
          "args": [
            "sc"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "fe_loadmar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2413-2441",
          "snippet": "void\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_loadmar"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_loadmar;\n\nvoid\nfe_loadmar(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Stop the DLC (transmitter and receiver). */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Select register bank 1 for MARs. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_MAR | FE_D7_POWER_UP);\n\n\t/* Copy filter value into the registers. */\n\toutblk(sc->sc_iobase + FE_MAR8, sc->filter, FE_FILTER_LEN);\n\n\t/* Restore the bank selection for BMPRs (i.e., runtime registers). */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Restart the DLC. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\n\t/* We have just updated the filter. */\n\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: address filter changed\\n\", sc->sc_dev.dv_xname);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_rint",
          "args": [
            "sc",
            "rstat"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "fe_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1708-1836",
          "snippet": "void\nfe_rint(sc, rstat)\n\tstruct fe_softc *sc;\n\tu_char rstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_char status;\n\tint i;\n\n\t/*\n\t * Update statistics if this interrupt is caused by an error.\n\t */\n\tif (rstat & (FE_D1_OVRFLO | FE_D1_CRCERR |\n\t\t     FE_D1_ALGERR | FE_D1_SRTPKT)) {\n#if FE_DEBUG >= 3\n\t\tlog(LOG_WARNING, \"%s: receive error: %b\\n\",\n\t\t    sc->sc_dev.dv_xname, rstat, FE_D1_ERRBITS);\n#endif\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * MB86960 has a flag indicating \"receive queue empty.\"\n\t * We just loop cheking the flag to pull out all received\n\t * packets.\n\t *\n\t * We limit the number of iterrations to avoid infinite loop.\n\t * It can be caused by a very slow CPU (some broken\n\t * peripheral may insert incredible number of wait cycles)\n\t * or, worse, by a broken MB86960 chip.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\t/* Stop the iterration if 86960 indicates no packets. */\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Extract A receive status byte.\n\t\t * As our 86960 is in 16 bit bus access mode, we have to\n\t\t * use inw() to get the status byte.  The significant\n\t\t * value is returned in lower 8 bits.\n\t\t */\n\t\tstatus = (u_char)inw(sc->sc_iobase + FE_BMPR8);\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: receive status = %02x\\n\",\n\t\t    sc->sc_dev.dv_xname, status);\n#endif\n\n\t\t/*\n\t\t * If there was an error, update statistics and drop\n\t\t * the packet, unless the interface is in promiscuous\n\t\t * mode.\n\t\t */\n\t\tif ((status & 0xF0) != 0x20) {\t/* XXXX ? */\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tfe_droppacket(sc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Extract the packet length.\n\t\t * It is a sum of a header (14 bytes) and a payload.\n\t\t * CRC has been stripped off by the 86960.\n\t\t */\n\t\tlen = inw(sc->sc_iobase + FE_BMPR8);\n\n\t\t/*\n\t\t * MB86965 checks the packet length and drop big packet\n\t\t * before passing it to us.  There are no chance we can\n\t\t * get [crufty] packets.  Hence, if the length exceeds\n\t\t * the specified limit, it means some serious failure,\n\t\t * such as out-of-sync on receive buffer management.\n\t\t *\n\t\t * Is this statement true?  FIXME.\n\t\t */\n\t\tif (len > ETHER_MAX_LEN || len < ETHER_HDR_SIZE) {\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: received a %s packet? (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    len < ETHER_HDR_SIZE ? \"partial\" : \"big\", len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check for a short (RUNT) packet.  We *do* check\n\t\t * but do nothing other than print a message.\n\t\t * Short packets are illegal, but does nothing bad\n\t\t * if it carries data for upper layer.\n\t\t */\n#if FE_DEBUG >= 2\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tlog(LOG_WARNING,\n\t\t\t     \"%s: received a short packet? (%u bytes)\\n\",\n\t\t\t     sc->sc_dev.dv_xname, len);\n\t\t}\n#endif \n\n\t\t/*\n\t\t * Go get a packet.\n\t\t */\n\t\tif (!fe_get_packet(sc, len)) {\n\t\t\t/* Skip a packet, updating statistics. */\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: out of mbufs; dropping packet (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\n\t\t\t/*\n\t\t\t * We stop receiving packets, even if there are\n\t\t\t * more in the buffer.  We hope we can get more\n\t\t\t * mbufs next time.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Successfully received a packet.  Update stat. */\n\t\tifp->if_ipackets++;\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)",
            "#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */",
            "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
            "#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "int\tfe_get_packet",
            "__P((/*struct fe_softc *, u_char*/));",
            "void\tfe_rint",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)\n#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */\n#define FE_DEBUG\t\t1\n\nint\tfe_get_packet;\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_rint;\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_rint(sc, rstat)\n\tstruct fe_softc *sc;\n\tu_char rstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_char status;\n\tint i;\n\n\t/*\n\t * Update statistics if this interrupt is caused by an error.\n\t */\n\tif (rstat & (FE_D1_OVRFLO | FE_D1_CRCERR |\n\t\t     FE_D1_ALGERR | FE_D1_SRTPKT)) {\n#if FE_DEBUG >= 3\n\t\tlog(LOG_WARNING, \"%s: receive error: %b\\n\",\n\t\t    sc->sc_dev.dv_xname, rstat, FE_D1_ERRBITS);\n#endif\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * MB86960 has a flag indicating \"receive queue empty.\"\n\t * We just loop cheking the flag to pull out all received\n\t * packets.\n\t *\n\t * We limit the number of iterrations to avoid infinite loop.\n\t * It can be caused by a very slow CPU (some broken\n\t * peripheral may insert incredible number of wait cycles)\n\t * or, worse, by a broken MB86960 chip.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\t/* Stop the iterration if 86960 indicates no packets. */\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Extract A receive status byte.\n\t\t * As our 86960 is in 16 bit bus access mode, we have to\n\t\t * use inw() to get the status byte.  The significant\n\t\t * value is returned in lower 8 bits.\n\t\t */\n\t\tstatus = (u_char)inw(sc->sc_iobase + FE_BMPR8);\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: receive status = %02x\\n\",\n\t\t    sc->sc_dev.dv_xname, status);\n#endif\n\n\t\t/*\n\t\t * If there was an error, update statistics and drop\n\t\t * the packet, unless the interface is in promiscuous\n\t\t * mode.\n\t\t */\n\t\tif ((status & 0xF0) != 0x20) {\t/* XXXX ? */\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tfe_droppacket(sc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Extract the packet length.\n\t\t * It is a sum of a header (14 bytes) and a payload.\n\t\t * CRC has been stripped off by the 86960.\n\t\t */\n\t\tlen = inw(sc->sc_iobase + FE_BMPR8);\n\n\t\t/*\n\t\t * MB86965 checks the packet length and drop big packet\n\t\t * before passing it to us.  There are no chance we can\n\t\t * get [crufty] packets.  Hence, if the length exceeds\n\t\t * the specified limit, it means some serious failure,\n\t\t * such as out-of-sync on receive buffer management.\n\t\t *\n\t\t * Is this statement true?  FIXME.\n\t\t */\n\t\tif (len > ETHER_MAX_LEN || len < ETHER_HDR_SIZE) {\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: received a %s packet? (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    len < ETHER_HDR_SIZE ? \"partial\" : \"big\", len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check for a short (RUNT) packet.  We *do* check\n\t\t * but do nothing other than print a message.\n\t\t * Short packets are illegal, but does nothing bad\n\t\t * if it carries data for upper layer.\n\t\t */\n#if FE_DEBUG >= 2\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tlog(LOG_WARNING,\n\t\t\t     \"%s: received a short packet? (%u bytes)\\n\",\n\t\t\t     sc->sc_dev.dv_xname, len);\n\t\t}\n#endif \n\n\t\t/*\n\t\t * Go get a packet.\n\t\t */\n\t\tif (!fe_get_packet(sc, len)) {\n\t\t\t/* Skip a packet, updating statistics. */\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: out of mbufs; dropping packet (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\n\t\t\t/*\n\t\t\t * We stop receiving packets, even if there are\n\t\t\t * more in the buffer.  We hope we can get more\n\t\t\t * mbufs next time.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Successfully received a packet.  Update stat. */\n\t\tifp->if_ipackets++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_tint",
          "args": [
            "sc",
            "tstat"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "fe_tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1569-1703",
          "snippet": "void\nfe_tint(sc, tstat)\n\tstruct fe_softc *sc;\n\tu_char tstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint left;\n\tint col;\n\n\t/*\n\t * Handle \"excessive collision\" interrupt.\n\t */\n\tif (tstat & FE_D0_COLL16) {\n\t\t/*\n\t\t * Find how many packets (including this collided one)\n\t\t * are left unsent in transmission buffer.\n\t\t */\n\t\tleft = inb(sc->sc_iobase + FE_BMPR10);\n\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: excessive collision (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, left, sc->txb_sched);\n#endif\n#if FE_DEBUG >= 3\n\t\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t\t/*\n\t\t * Update statistics.\n\t\t */\n\t\tifp->if_collisions += 16;\n\t\tifp->if_oerrors++;\n\t\tifp->if_opackets += sc->txb_sched - left;\n\n\t\t/*\n\t\t * Collision statistics has been updated.\n\t\t * Clear the collision flag on 86960 now to avoid confusion.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t/*\n\t\t * Restart transmitter, skipping the\n\t\t * collided packet.\n\t\t *\n\t\t * We *must* skip the packet to keep network running\n\t\t * properly.  Excessive collision error is an\n\t\t * indication of the network overload.  If we\n\t\t * tried sending the same packet after excessive\n\t\t * collision, the network would be filled with\n\t\t * out-of-time packets.  Packets belonging\n\t\t * to reliable transport (such as TCP) are resent\n\t\t * by some upper layer.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_BMPR11,\n\t\t    FE_B11_CTRL_SKIP | FE_B11_MODE1);\n\t\tsc->txb_sched = left - 1;\n\t}\n\n\t/*\n\t * Handle \"transmission complete\" interrupt.\n\t */\n\tif (tstat & FE_D0_TXDONE) {\n\t\t/*\n\t\t * Add in total number of collisions on last\n\t\t * transmission.  We also clear \"collision occurred\" flag\n\t\t * here.\n\t\t *\n\t\t * 86960 has a design flow on collision count on multiple\n\t\t * packet transmission.  When we send two or more packets\n\t\t * with one start command (that's what we do when the\n\t\t * transmission queue is clauded), 86960 informs us number\n\t\t * of collisions occured on the last packet on the\n\t\t * transmission only.  Number of collisions on previous\n\t\t * packets are lost.  I have told that the fact is clearly\n\t\t * stated in the Fujitsu document.\n\t\t *\n\t\t * I considered not to mind it seriously.  Collision\n\t\t * count is not so important, anyway.  Any comments?  FIXME.\n\t\t */\n\n\t\tif (inb(sc->sc_iobase + FE_DLCR0) & FE_D0_COLLID) {\n\t\t\t/* Clear collision flag. */\n\t\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t\t/* Extract collision count from 86960. */\n\t\t\tcol = inb(sc->sc_iobase + FE_DLCR4) & FE_D4_COL;\n\t\t\tif (col == 0) {\n\t\t\t\t/*\n\t\t\t\t * Status register indicates collisions,\n\t\t\t\t * while the collision count is zero.\n\t\t\t\t * This can happen after multiple packet\n\t\t\t\t * transmission, indicating that one or more\n\t\t\t\t * previous packet(s) had been collided.\n\t\t\t\t *\n\t\t\t\t * Since the accurate number of collisions\n\t\t\t\t * has been lost, we just guess it as 1;\n\t\t\t\t * Am I too optimistic?  FIXME.\n\t\t\t\t */\n\t\t\t\tcol = 1;\n\t\t\t} else\n\t\t\t\tcol >>= FE_D4_COL_SHIFT;\n\t\t\tifp->if_collisions += col;\n#if FE_DEBUG >= 4\n\t\t\tlog(LOG_WARNING, \"%s: %d collision%s (%d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, col, col == 1 ? \"\" : \"s\",\n\t\t\t    sc->txb_sched);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Update total number of successfully\n\t\t * transmitted packets.\n\t\t */\n\t\tifp->if_opackets += sc->txb_sched;\n\t\tsc->txb_sched = 0;\n\t}\n\n\tif (sc->txb_sched == 0) {\n\t\t/*\n\t\t * The transmitter is no more active.\n\t\t * Reset output active flag and watchdog timer. \n\t\t */\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\n\t\t/*\n\t\t * If more data is ready to transmit in the buffer, start\n\t\t * transmitting them.  Otherwise keep transmitter idle,\n\t\t * even if more data is queued.  This gives receive\n\t\t * process a slight priority.\n\t\t */\n\t\tif (sc->txb_count > 0)\n\t\t\tfe_xmit(sc);\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_tint",
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));",
            "static inline\nvoid\tfe_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_tint;\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nstatic inline\nvoid\tfe_xmit;\n\nvoid\nfe_tint(sc, tstat)\n\tstruct fe_softc *sc;\n\tu_char tstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint left;\n\tint col;\n\n\t/*\n\t * Handle \"excessive collision\" interrupt.\n\t */\n\tif (tstat & FE_D0_COLL16) {\n\t\t/*\n\t\t * Find how many packets (including this collided one)\n\t\t * are left unsent in transmission buffer.\n\t\t */\n\t\tleft = inb(sc->sc_iobase + FE_BMPR10);\n\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: excessive collision (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, left, sc->txb_sched);\n#endif\n#if FE_DEBUG >= 3\n\t\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t\t/*\n\t\t * Update statistics.\n\t\t */\n\t\tifp->if_collisions += 16;\n\t\tifp->if_oerrors++;\n\t\tifp->if_opackets += sc->txb_sched - left;\n\n\t\t/*\n\t\t * Collision statistics has been updated.\n\t\t * Clear the collision flag on 86960 now to avoid confusion.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t/*\n\t\t * Restart transmitter, skipping the\n\t\t * collided packet.\n\t\t *\n\t\t * We *must* skip the packet to keep network running\n\t\t * properly.  Excessive collision error is an\n\t\t * indication of the network overload.  If we\n\t\t * tried sending the same packet after excessive\n\t\t * collision, the network would be filled with\n\t\t * out-of-time packets.  Packets belonging\n\t\t * to reliable transport (such as TCP) are resent\n\t\t * by some upper layer.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_BMPR11,\n\t\t    FE_B11_CTRL_SKIP | FE_B11_MODE1);\n\t\tsc->txb_sched = left - 1;\n\t}\n\n\t/*\n\t * Handle \"transmission complete\" interrupt.\n\t */\n\tif (tstat & FE_D0_TXDONE) {\n\t\t/*\n\t\t * Add in total number of collisions on last\n\t\t * transmission.  We also clear \"collision occurred\" flag\n\t\t * here.\n\t\t *\n\t\t * 86960 has a design flow on collision count on multiple\n\t\t * packet transmission.  When we send two or more packets\n\t\t * with one start command (that's what we do when the\n\t\t * transmission queue is clauded), 86960 informs us number\n\t\t * of collisions occured on the last packet on the\n\t\t * transmission only.  Number of collisions on previous\n\t\t * packets are lost.  I have told that the fact is clearly\n\t\t * stated in the Fujitsu document.\n\t\t *\n\t\t * I considered not to mind it seriously.  Collision\n\t\t * count is not so important, anyway.  Any comments?  FIXME.\n\t\t */\n\n\t\tif (inb(sc->sc_iobase + FE_DLCR0) & FE_D0_COLLID) {\n\t\t\t/* Clear collision flag. */\n\t\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t\t/* Extract collision count from 86960. */\n\t\t\tcol = inb(sc->sc_iobase + FE_DLCR4) & FE_D4_COL;\n\t\t\tif (col == 0) {\n\t\t\t\t/*\n\t\t\t\t * Status register indicates collisions,\n\t\t\t\t * while the collision count is zero.\n\t\t\t\t * This can happen after multiple packet\n\t\t\t\t * transmission, indicating that one or more\n\t\t\t\t * previous packet(s) had been collided.\n\t\t\t\t *\n\t\t\t\t * Since the accurate number of collisions\n\t\t\t\t * has been lost, we just guess it as 1;\n\t\t\t\t * Am I too optimistic?  FIXME.\n\t\t\t\t */\n\t\t\t\tcol = 1;\n\t\t\t} else\n\t\t\t\tcol >>= FE_D4_COL_SHIFT;\n\t\t\tifp->if_collisions += col;\n#if FE_DEBUG >= 4\n\t\t\tlog(LOG_WARNING, \"%s: %d collision%s (%d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, col, col == 1 ? \"\" : \"s\",\n\t\t\t    sc->txb_sched);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Update total number of successfully\n\t\t * transmitted packets.\n\t\t */\n\t\tifp->if_opackets += sc->txb_sched;\n\t\tsc->txb_sched = 0;\n\t}\n\n\tif (sc->txb_sched == 0) {\n\t\t/*\n\t\t * The transmitter is no more active.\n\t\t * Reset output active flag and watchdog timer. \n\t\t */\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\n\t\t/*\n\t\t * If more data is ready to transmit in the buffer, start\n\t\t * transmitting them.  Otherwise keep transmitter idle,\n\t\t * even if more data is queued.  This gives receive\n\t\t * process a slight priority.\n\t\t */\n\t\tif (sc->txb_count > 0)\n\t\t\tfe_xmit(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR1",
            "rstat"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: feintr()\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)\n#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)\n#define FE_DEBUG\t\t1\n\nint\tfeintr;\nvoid\tfe_start;\nvoid\tfe_tint;\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_rint;\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_loadmar;\n\nint\nfeintr(arg)\n\tvoid *arg;\n{\n\tstruct fe_softc *sc = arg;\n\tu_char tstat, rstat;\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: feintr()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Get interrupt conditions, masking unneeded flags.\n\t */\n\ttstat = inb(sc->sc_iobase + FE_DLCR0) & FE_TMASK;\n\trstat = inb(sc->sc_iobase + FE_DLCR1) & FE_RMASK;\n\tif (tstat == 0 && rstat == 0)\n\t\treturn (0);\n\n\t/*\n\t * Loop until there are no more new interrupt conditions.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset the conditions we are acknowledging.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, tstat);\n\t\toutb(sc->sc_iobase + FE_DLCR1, rstat);\n\n\t\t/*\n\t\t * Handle transmitter interrupts. Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t */\n\t\tif (tstat != 0)\n\t\t\tfe_tint(sc, tstat);\n\n\t\t/*\n\t\t * Handle receiver interrupts.\n\t\t */\n\t\tif (rstat != 0)\n\t\t\tfe_rint(sc, rstat);\n\n\t\t/*\n\t\t * Update the multicast address filter if it is\n\t\t * needed and possible.  We do it now, because\n\t\t * we can make sure the transmission buffer is empty,\n\t\t * and there is a good chance that the receive queue\n\t\t * is empty.  It will minimize the possibility of\n\t\t * packet lossage.\n\t\t */\n\t\tif (sc->filter_change &&\n\t\t    sc->txb_count == 0 && sc->txb_sched == 0) {\n\t\t\tfe_loadmar(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data,\n\t\t * attempt to start output on the interface. This is done\n\t\t * after handling the receiver interrupt to give the\n\t\t * receive operation priority.\n\t\t */\n\t\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE) == 0)\n\t\t\tfe_start(&sc->sc_arpcom.ac_if);\n\n\t\t/*\n\t\t * Get interrupt conditions, masking unneeded flags.\n\t\t */\n\t\ttstat = inb(sc->sc_iobase + FE_DLCR0) & FE_TMASK;\n\t\trstat = inb(sc->sc_iobase + FE_DLCR1) & FE_RMASK;\n\t\tif (tstat == 0 && rstat == 0)\n\t\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "fe_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1708-1836",
    "snippet": "void\nfe_rint(sc, rstat)\n\tstruct fe_softc *sc;\n\tu_char rstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_char status;\n\tint i;\n\n\t/*\n\t * Update statistics if this interrupt is caused by an error.\n\t */\n\tif (rstat & (FE_D1_OVRFLO | FE_D1_CRCERR |\n\t\t     FE_D1_ALGERR | FE_D1_SRTPKT)) {\n#if FE_DEBUG >= 3\n\t\tlog(LOG_WARNING, \"%s: receive error: %b\\n\",\n\t\t    sc->sc_dev.dv_xname, rstat, FE_D1_ERRBITS);\n#endif\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * MB86960 has a flag indicating \"receive queue empty.\"\n\t * We just loop cheking the flag to pull out all received\n\t * packets.\n\t *\n\t * We limit the number of iterrations to avoid infinite loop.\n\t * It can be caused by a very slow CPU (some broken\n\t * peripheral may insert incredible number of wait cycles)\n\t * or, worse, by a broken MB86960 chip.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\t/* Stop the iterration if 86960 indicates no packets. */\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Extract A receive status byte.\n\t\t * As our 86960 is in 16 bit bus access mode, we have to\n\t\t * use inw() to get the status byte.  The significant\n\t\t * value is returned in lower 8 bits.\n\t\t */\n\t\tstatus = (u_char)inw(sc->sc_iobase + FE_BMPR8);\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: receive status = %02x\\n\",\n\t\t    sc->sc_dev.dv_xname, status);\n#endif\n\n\t\t/*\n\t\t * If there was an error, update statistics and drop\n\t\t * the packet, unless the interface is in promiscuous\n\t\t * mode.\n\t\t */\n\t\tif ((status & 0xF0) != 0x20) {\t/* XXXX ? */\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tfe_droppacket(sc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Extract the packet length.\n\t\t * It is a sum of a header (14 bytes) and a payload.\n\t\t * CRC has been stripped off by the 86960.\n\t\t */\n\t\tlen = inw(sc->sc_iobase + FE_BMPR8);\n\n\t\t/*\n\t\t * MB86965 checks the packet length and drop big packet\n\t\t * before passing it to us.  There are no chance we can\n\t\t * get [crufty] packets.  Hence, if the length exceeds\n\t\t * the specified limit, it means some serious failure,\n\t\t * such as out-of-sync on receive buffer management.\n\t\t *\n\t\t * Is this statement true?  FIXME.\n\t\t */\n\t\tif (len > ETHER_MAX_LEN || len < ETHER_HDR_SIZE) {\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: received a %s packet? (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    len < ETHER_HDR_SIZE ? \"partial\" : \"big\", len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check for a short (RUNT) packet.  We *do* check\n\t\t * but do nothing other than print a message.\n\t\t * Short packets are illegal, but does nothing bad\n\t\t * if it carries data for upper layer.\n\t\t */\n#if FE_DEBUG >= 2\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tlog(LOG_WARNING,\n\t\t\t     \"%s: received a short packet? (%u bytes)\\n\",\n\t\t\t     sc->sc_dev.dv_xname, len);\n\t\t}\n#endif \n\n\t\t/*\n\t\t * Go get a packet.\n\t\t */\n\t\tif (!fe_get_packet(sc, len)) {\n\t\t\t/* Skip a packet, updating statistics. */\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: out of mbufs; dropping packet (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\n\t\t\t/*\n\t\t\t * We stop receiving packets, even if there are\n\t\t\t * more in the buffer.  We hope we can get more\n\t\t\t * mbufs next time.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Successfully received a packet.  Update stat. */\n\t\tifp->if_ipackets++;\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)",
      "#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */",
      "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
      "#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "int\tfe_get_packet",
      "__P((/*struct fe_softc *, u_char*/));",
      "void\tfe_rint",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_droppacket",
          "args": [
            "sc"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "fe_droppacket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1219-1225",
          "snippet": "static inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: out of mbufs; dropping packet (%u bytes)\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_get_packet",
          "args": [
            "sc",
            "len"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "fe_get_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2022-2088",
          "snippet": "int\nfe_get_packet(sc, len)\n\tstruct fe_softc *sc;\n\tint len;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Allocate a header mbuf. */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = len;\n\n\t/* The following silliness is to make NFS happy. */\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n\n\t/*\n\t * Our strategy has one more problem.  There is a policy on\n\t * mbuf cluster allocation.  It says that we must have at\n\t * least MINCLSIZE (208 bytes) to allocate a cluster.  For a\n\t * packet of a size between (MHLEN - 2) to (MINCLSIZE - 2),\n\t * our code violates the rule...\n\t * On the other hand, the current code is short, simle,\n\t * and fast, however.  It does no harmful thing, just waists\n\t * some memory.  Any comments?  FIXME.\n\t */\n\n\t/* Attach a cluster if this packet doesn't fit in a normal mbuf. */\n\tif (len > MHLEN - EOFF) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * The following assumes there is room for the ether header in the\n\t * header mbuf.\n\t */\n\tm->m_data += EOFF;\n\teh = mtod(m, struct ether_header *);\n\n\t/* Set the length of this packet. */\n\tm->m_len = len;\n\n\t/* Get a packet. */\n\tinsw(sc->sc_iobase + FE_BMPR8, m->m_data, (len + 1) >> 1);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.  If so, hand off\n\t * the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tEOFF\t(EROUND - sizeof(struct ether_header))",
            "#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)"
          ],
          "globals_used": [
            "int\tfe_get_packet"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n\nint\tfe_get_packet;\n\nint\nfe_get_packet(sc, len)\n\tstruct fe_softc *sc;\n\tint len;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Allocate a header mbuf. */\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = len;\n\n\t/* The following silliness is to make NFS happy. */\n#define\tEROUND\t((sizeof(struct ether_header) + 3) & ~3)\n#define\tEOFF\t(EROUND - sizeof(struct ether_header))\n\n\t/*\n\t * Our strategy has one more problem.  There is a policy on\n\t * mbuf cluster allocation.  It says that we must have at\n\t * least MINCLSIZE (208 bytes) to allocate a cluster.  For a\n\t * packet of a size between (MHLEN - 2) to (MINCLSIZE - 2),\n\t * our code violates the rule...\n\t * On the other hand, the current code is short, simle,\n\t * and fast, however.  It does no harmful thing, just waists\n\t * some memory.  Any comments?  FIXME.\n\t */\n\n\t/* Attach a cluster if this packet doesn't fit in a normal mbuf. */\n\tif (len > MHLEN - EOFF) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/*\n\t * The following assumes there is room for the ether header in the\n\t * header mbuf.\n\t */\n\tm->m_data += EOFF;\n\teh = mtod(m, struct ether_header *);\n\n\t/* Set the length of this packet. */\n\tm->m_len = len;\n\n\t/* Get a packet. */\n\tinsw(sc->sc_iobase + FE_BMPR8, m->m_data, (len + 1) >> 1);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.  If so, hand off\n\t * the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase + FE_BMPR8"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "sc->sc_iobase + FE_BMPR8"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase + FE_DLCR5"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)\n#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */\n#define FE_DEBUG\t\t1\n\nint\tfe_get_packet;\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_rint;\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_rint(sc, rstat)\n\tstruct fe_softc *sc;\n\tu_char rstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint len;\n\tu_char status;\n\tint i;\n\n\t/*\n\t * Update statistics if this interrupt is caused by an error.\n\t */\n\tif (rstat & (FE_D1_OVRFLO | FE_D1_CRCERR |\n\t\t     FE_D1_ALGERR | FE_D1_SRTPKT)) {\n#if FE_DEBUG >= 3\n\t\tlog(LOG_WARNING, \"%s: receive error: %b\\n\",\n\t\t    sc->sc_dev.dv_xname, rstat, FE_D1_ERRBITS);\n#endif\n\t\tifp->if_ierrors++;\n\t}\n\n\t/*\n\t * MB86960 has a flag indicating \"receive queue empty.\"\n\t * We just loop cheking the flag to pull out all received\n\t * packets.\n\t *\n\t * We limit the number of iterrations to avoid infinite loop.\n\t * It can be caused by a very slow CPU (some broken\n\t * peripheral may insert incredible number of wait cycles)\n\t * or, worse, by a broken MB86960 chip.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\t/* Stop the iterration if 86960 indicates no packets. */\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Extract A receive status byte.\n\t\t * As our 86960 is in 16 bit bus access mode, we have to\n\t\t * use inw() to get the status byte.  The significant\n\t\t * value is returned in lower 8 bits.\n\t\t */\n\t\tstatus = (u_char)inw(sc->sc_iobase + FE_BMPR8);\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: receive status = %02x\\n\",\n\t\t    sc->sc_dev.dv_xname, status);\n#endif\n\n\t\t/*\n\t\t * If there was an error, update statistics and drop\n\t\t * the packet, unless the interface is in promiscuous\n\t\t * mode.\n\t\t */\n\t\tif ((status & 0xF0) != 0x20) {\t/* XXXX ? */\n\t\t\tif ((ifp->if_flags & IFF_PROMISC) == 0) {\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tfe_droppacket(sc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Extract the packet length.\n\t\t * It is a sum of a header (14 bytes) and a payload.\n\t\t * CRC has been stripped off by the 86960.\n\t\t */\n\t\tlen = inw(sc->sc_iobase + FE_BMPR8);\n\n\t\t/*\n\t\t * MB86965 checks the packet length and drop big packet\n\t\t * before passing it to us.  There are no chance we can\n\t\t * get [crufty] packets.  Hence, if the length exceeds\n\t\t * the specified limit, it means some serious failure,\n\t\t * such as out-of-sync on receive buffer management.\n\t\t *\n\t\t * Is this statement true?  FIXME.\n\t\t */\n\t\tif (len > ETHER_MAX_LEN || len < ETHER_HDR_SIZE) {\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: received a %s packet? (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    len < ETHER_HDR_SIZE ? \"partial\" : \"big\", len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check for a short (RUNT) packet.  We *do* check\n\t\t * but do nothing other than print a message.\n\t\t * Short packets are illegal, but does nothing bad\n\t\t * if it carries data for upper layer.\n\t\t */\n#if FE_DEBUG >= 2\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tlog(LOG_WARNING,\n\t\t\t     \"%s: received a short packet? (%u bytes)\\n\",\n\t\t\t     sc->sc_dev.dv_xname, len);\n\t\t}\n#endif \n\n\t\t/*\n\t\t * Go get a packet.\n\t\t */\n\t\tif (!fe_get_packet(sc, len)) {\n\t\t\t/* Skip a packet, updating statistics. */\n#if FE_DEBUG >= 2\n\t\t\tlog(LOG_WARNING,\n\t\t\t    \"%s: out of mbufs; dropping packet (%u bytes)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n#endif\n\t\t\tifp->if_ierrors++;\n\t\t\tfe_droppacket(sc);\n\n\t\t\t/*\n\t\t\t * We stop receiving packets, even if there are\n\t\t\t * more in the buffer.  We hope we can get more\n\t\t\t * mbufs next time.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Successfully received a packet.  Update stat. */\n\t\tifp->if_ipackets++;\n\t}\n}"
  },
  {
    "function_name": "fe_tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1569-1703",
    "snippet": "void\nfe_tint(sc, tstat)\n\tstruct fe_softc *sc;\n\tu_char tstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint left;\n\tint col;\n\n\t/*\n\t * Handle \"excessive collision\" interrupt.\n\t */\n\tif (tstat & FE_D0_COLL16) {\n\t\t/*\n\t\t * Find how many packets (including this collided one)\n\t\t * are left unsent in transmission buffer.\n\t\t */\n\t\tleft = inb(sc->sc_iobase + FE_BMPR10);\n\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: excessive collision (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, left, sc->txb_sched);\n#endif\n#if FE_DEBUG >= 3\n\t\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t\t/*\n\t\t * Update statistics.\n\t\t */\n\t\tifp->if_collisions += 16;\n\t\tifp->if_oerrors++;\n\t\tifp->if_opackets += sc->txb_sched - left;\n\n\t\t/*\n\t\t * Collision statistics has been updated.\n\t\t * Clear the collision flag on 86960 now to avoid confusion.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t/*\n\t\t * Restart transmitter, skipping the\n\t\t * collided packet.\n\t\t *\n\t\t * We *must* skip the packet to keep network running\n\t\t * properly.  Excessive collision error is an\n\t\t * indication of the network overload.  If we\n\t\t * tried sending the same packet after excessive\n\t\t * collision, the network would be filled with\n\t\t * out-of-time packets.  Packets belonging\n\t\t * to reliable transport (such as TCP) are resent\n\t\t * by some upper layer.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_BMPR11,\n\t\t    FE_B11_CTRL_SKIP | FE_B11_MODE1);\n\t\tsc->txb_sched = left - 1;\n\t}\n\n\t/*\n\t * Handle \"transmission complete\" interrupt.\n\t */\n\tif (tstat & FE_D0_TXDONE) {\n\t\t/*\n\t\t * Add in total number of collisions on last\n\t\t * transmission.  We also clear \"collision occurred\" flag\n\t\t * here.\n\t\t *\n\t\t * 86960 has a design flow on collision count on multiple\n\t\t * packet transmission.  When we send two or more packets\n\t\t * with one start command (that's what we do when the\n\t\t * transmission queue is clauded), 86960 informs us number\n\t\t * of collisions occured on the last packet on the\n\t\t * transmission only.  Number of collisions on previous\n\t\t * packets are lost.  I have told that the fact is clearly\n\t\t * stated in the Fujitsu document.\n\t\t *\n\t\t * I considered not to mind it seriously.  Collision\n\t\t * count is not so important, anyway.  Any comments?  FIXME.\n\t\t */\n\n\t\tif (inb(sc->sc_iobase + FE_DLCR0) & FE_D0_COLLID) {\n\t\t\t/* Clear collision flag. */\n\t\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t\t/* Extract collision count from 86960. */\n\t\t\tcol = inb(sc->sc_iobase + FE_DLCR4) & FE_D4_COL;\n\t\t\tif (col == 0) {\n\t\t\t\t/*\n\t\t\t\t * Status register indicates collisions,\n\t\t\t\t * while the collision count is zero.\n\t\t\t\t * This can happen after multiple packet\n\t\t\t\t * transmission, indicating that one or more\n\t\t\t\t * previous packet(s) had been collided.\n\t\t\t\t *\n\t\t\t\t * Since the accurate number of collisions\n\t\t\t\t * has been lost, we just guess it as 1;\n\t\t\t\t * Am I too optimistic?  FIXME.\n\t\t\t\t */\n\t\t\t\tcol = 1;\n\t\t\t} else\n\t\t\t\tcol >>= FE_D4_COL_SHIFT;\n\t\t\tifp->if_collisions += col;\n#if FE_DEBUG >= 4\n\t\t\tlog(LOG_WARNING, \"%s: %d collision%s (%d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, col, col == 1 ? \"\" : \"s\",\n\t\t\t    sc->txb_sched);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Update total number of successfully\n\t\t * transmitted packets.\n\t\t */\n\t\tifp->if_opackets += sc->txb_sched;\n\t\tsc->txb_sched = 0;\n\t}\n\n\tif (sc->txb_sched == 0) {\n\t\t/*\n\t\t * The transmitter is no more active.\n\t\t * Reset output active flag and watchdog timer. \n\t\t */\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\n\t\t/*\n\t\t * If more data is ready to transmit in the buffer, start\n\t\t * transmitting them.  Otherwise keep transmitter idle,\n\t\t * even if more data is queued.  This gives receive\n\t\t * process a slight priority.\n\t\t */\n\t\tif (sc->txb_count > 0)\n\t\t\tfe_xmit(sc);\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_tint",
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));",
      "static inline\nvoid\tfe_xmit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_xmit",
          "args": [
            "sc"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "fe_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1386-1410",
          "snippet": "static inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DELAYED_PADDING\t0"
          ],
          "globals_used": [
            "static inline\nvoid\tfe_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DELAYED_PADDING\t0\n\nstatic inline\nvoid\tfe_xmit;\n\nstatic inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: %d collision%s (%d)\\n\"",
            "sc->sc_dev.dv_xname",
            "col",
            "col == 1 ? \"\" : \"s\"",
            "sc->txb_sched"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase + FE_DLCR4"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR0",
            "FE_D0_COLLID"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_tint;\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nstatic inline\nvoid\tfe_xmit;\n\nvoid\nfe_tint(sc, tstat)\n\tstruct fe_softc *sc;\n\tu_char tstat;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint left;\n\tint col;\n\n\t/*\n\t * Handle \"excessive collision\" interrupt.\n\t */\n\tif (tstat & FE_D0_COLL16) {\n\t\t/*\n\t\t * Find how many packets (including this collided one)\n\t\t * are left unsent in transmission buffer.\n\t\t */\n\t\tleft = inb(sc->sc_iobase + FE_BMPR10);\n\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: excessive collision (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, left, sc->txb_sched);\n#endif\n#if FE_DEBUG >= 3\n\t\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t\t/*\n\t\t * Update statistics.\n\t\t */\n\t\tifp->if_collisions += 16;\n\t\tifp->if_oerrors++;\n\t\tifp->if_opackets += sc->txb_sched - left;\n\n\t\t/*\n\t\t * Collision statistics has been updated.\n\t\t * Clear the collision flag on 86960 now to avoid confusion.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t/*\n\t\t * Restart transmitter, skipping the\n\t\t * collided packet.\n\t\t *\n\t\t * We *must* skip the packet to keep network running\n\t\t * properly.  Excessive collision error is an\n\t\t * indication of the network overload.  If we\n\t\t * tried sending the same packet after excessive\n\t\t * collision, the network would be filled with\n\t\t * out-of-time packets.  Packets belonging\n\t\t * to reliable transport (such as TCP) are resent\n\t\t * by some upper layer.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_BMPR11,\n\t\t    FE_B11_CTRL_SKIP | FE_B11_MODE1);\n\t\tsc->txb_sched = left - 1;\n\t}\n\n\t/*\n\t * Handle \"transmission complete\" interrupt.\n\t */\n\tif (tstat & FE_D0_TXDONE) {\n\t\t/*\n\t\t * Add in total number of collisions on last\n\t\t * transmission.  We also clear \"collision occurred\" flag\n\t\t * here.\n\t\t *\n\t\t * 86960 has a design flow on collision count on multiple\n\t\t * packet transmission.  When we send two or more packets\n\t\t * with one start command (that's what we do when the\n\t\t * transmission queue is clauded), 86960 informs us number\n\t\t * of collisions occured on the last packet on the\n\t\t * transmission only.  Number of collisions on previous\n\t\t * packets are lost.  I have told that the fact is clearly\n\t\t * stated in the Fujitsu document.\n\t\t *\n\t\t * I considered not to mind it seriously.  Collision\n\t\t * count is not so important, anyway.  Any comments?  FIXME.\n\t\t */\n\n\t\tif (inb(sc->sc_iobase + FE_DLCR0) & FE_D0_COLLID) {\n\t\t\t/* Clear collision flag. */\n\t\t\toutb(sc->sc_iobase + FE_DLCR0, FE_D0_COLLID);\n\n\t\t\t/* Extract collision count from 86960. */\n\t\t\tcol = inb(sc->sc_iobase + FE_DLCR4) & FE_D4_COL;\n\t\t\tif (col == 0) {\n\t\t\t\t/*\n\t\t\t\t * Status register indicates collisions,\n\t\t\t\t * while the collision count is zero.\n\t\t\t\t * This can happen after multiple packet\n\t\t\t\t * transmission, indicating that one or more\n\t\t\t\t * previous packet(s) had been collided.\n\t\t\t\t *\n\t\t\t\t * Since the accurate number of collisions\n\t\t\t\t * has been lost, we just guess it as 1;\n\t\t\t\t * Am I too optimistic?  FIXME.\n\t\t\t\t */\n\t\t\t\tcol = 1;\n\t\t\t} else\n\t\t\t\tcol >>= FE_D4_COL_SHIFT;\n\t\t\tifp->if_collisions += col;\n#if FE_DEBUG >= 4\n\t\t\tlog(LOG_WARNING, \"%s: %d collision%s (%d)\\n\",\n\t\t\t    sc->sc_dev.dv_xname, col, col == 1 ? \"\" : \"s\",\n\t\t\t    sc->txb_sched);\n#endif\n\t\t}\n\n\t\t/*\n\t\t * Update total number of successfully\n\t\t * transmitted packets.\n\t\t */\n\t\tifp->if_opackets += sc->txb_sched;\n\t\tsc->txb_sched = 0;\n\t}\n\n\tif (sc->txb_sched == 0) {\n\t\t/*\n\t\t * The transmitter is no more active.\n\t\t * Reset output active flag and watchdog timer. \n\t\t */\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tifp->if_timer = 0;\n\n\t\t/*\n\t\t * If more data is ready to transmit in the buffer, start\n\t\t * transmitting them.  Otherwise keep transmitter idle,\n\t\t * even if more data is queued.  This gives receive\n\t\t * process a slight priority.\n\t\t */\n\t\tif (sc->txb_count > 0)\n\t\t\tfe_xmit(sc);\n\t}\n}"
  },
  {
    "function_name": "fe_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1421-1563",
    "snippet": "void\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
      "#define FE_SINGLE_TRANSMISSION\t0",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_start",
      "static inline\nvoid\tfe_xmit",
      "void\tfe_write_mbufs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_xmit",
          "args": [
            "sc"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "fe_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1386-1410",
          "snippet": "static inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DELAYED_PADDING\t0"
          ],
          "globals_used": [
            "static inline\nvoid\tfe_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DELAYED_PADDING\t0\n\nstatic inline\nvoid\tfe_xmit;\n\nstatic inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fe_write_mbufs",
          "args": [
            "sc",
            "m"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "fe_write_mbufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2107-2232",
          "snippet": "void\nfe_write_mbufs(sc, m)\n\tstruct fe_softc *sc;\n\tstruct mbuf *m;\n{\n\tint bmpr8 = sc->sc_iobase + FE_BMPR8;\n\tstruct mbuf *mp;\n\tu_char *data;\n\tu_short savebyte;\t/* WARNING: Architecture dependent! */\n\tint totlen, len, wantbyte;\n\n#if FE_DELAYED_PADDING\n\t/* Do the \"delayed padding.\" */\n\tlen = sc->txb_padding >> 1;\n\tif (len > 0) {\n\t\twhile (--len >= 0)\n\t\t\toutw(bmpr8, 0);\n\t\tsc->txb_padding = 0;\n\t}\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m->m_flags & M_PKTHDR) == 0)\n\t  \tpanic(\"fe_write_mbufs: no header mbuf\");\n\n#if FE_DEBUG >= 2\n\t/* First, count up the total number of bytes to copy. */\n\tfor (totlen = 0, mp = m; mp != 0; mp = mp->m_next)\n\t\ttotlen += mp->m_len;\n\t/* Check if this matches the one in the packet header. */\n\tif (totlen != m->m_pkthdr.len)\n\t\tlog(LOG_WARNING, \"%s: packet length mismatch? (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, totlen, m->m_pkthdr.len);\n#else\n\t/* Just use the length value in the packet header. */\n\ttotlen = m->m_pkthdr.len;\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * Should never send big packets.  If such a packet is passed,\n\t * it should be a bug of upper layer.  We just ignore it.\n\t * ... Partial (too short) packets, neither.\n\t */\n\tif (totlen > ETHER_MAX_LEN || totlen < ETHER_HDR_SIZE) {\n\t\tlog(LOG_ERR, \"%s: got a %s packet (%u bytes) to send\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    totlen < ETHER_HDR_SIZE ? \"partial\" : \"big\", totlen);\n\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Put the length word for this frame.\n\t * Does 86960 accept odd length?  -- Yes.\n\t * Do we need to pad the length to minimum size by ourselves?\n\t * -- Generally yes.  But for (or will be) the last\n\t * packet in the transmission buffer, we can skip the\n\t * padding process.  It may gain performance slightly.  FIXME.\n\t */\n\toutw(bmpr8, max(totlen, ETHER_MIN_LEN));\n\n\t/*\n\t * Update buffer status now.\n\t * Truncate the length up to an even number, since we use outw().\n\t */\n\ttotlen = (totlen + 1) & ~1;\n\tsc->txb_free -= FE_DATA_LEN_LEN + max(totlen, ETHER_MIN_LEN);\n\tsc->txb_count++;\n\n#if FE_DELAYED_PADDING\n\t/* Postpone the packet padding if necessary. */\n\tif (totlen < ETHER_MIN_LEN)\n\t\tsc->txb_padding = ETHER_MIN_LEN - totlen;\n#endif\n\n\t/*\n\t * Transfer the data from mbuf chain to the transmission buffer. \n\t * MB86960 seems to require that data be transferred as words, and\n\t * only words.  So that we require some extra code to patch\n\t * over odd-length mbufs.\n\t */\n\twantbyte = 0;\n\tfor (; m != 0; m = m->m_next) {\n\t\t/* Ignore empty mbuf. */\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the actual data to send. */\n\t\tdata = mtod(m, caddr_t);\n\n\t\t/* Finish the last byte. */\n\t\tif (wantbyte) {\n\t\t\toutw(bmpr8, savebyte | (*data << 8));\n\t\t\tdata++;\n\t\t\tlen--;\n\t\t\twantbyte = 0;\n\t\t}\n\n\t\t/* Output contiguous words. */\n\t\tif (len > 1)\n\t\t\toutsw(bmpr8, data, len >> 1);\n\n\t\t/* Save remaining byte, if there is one. */\n\t\tif (len & 1) {\n\t\t\tdata += len & ~1;\n\t\t\tsavebyte = *data;\n\t\t\twantbyte = 1;\n\t\t}\n\t}\n\n\t/* Spit the last byte, if the length is odd. */\n\tif (wantbyte)\n\t\toutw(bmpr8, savebyte);\n\n#if ! FE_DELAYED_PADDING\n\t/*\n\t * Pad the packet to the minimum length if necessary.\n\t */\n\tlen = (ETHER_MIN_LEN >> 1) - (totlen >> 1);\n\twhile (--len >= 0)\n\t\toutw(bmpr8, 0);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */",
            "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
            "#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */",
            "#define FE_DELAYED_PADDING\t0",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));",
            "void\tfe_write_mbufs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_HDR_SIZE\t14\t/* src addr, dst addr, and data type. */\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define ETHER_MIN_LEN\t60\t/* with header, without CRC. */\n#define FE_DELAYED_PADDING\t0\n#define FE_DEBUG\t\t1\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\nvoid\tfe_write_mbufs;\n\nvoid\nfe_write_mbufs(sc, m)\n\tstruct fe_softc *sc;\n\tstruct mbuf *m;\n{\n\tint bmpr8 = sc->sc_iobase + FE_BMPR8;\n\tstruct mbuf *mp;\n\tu_char *data;\n\tu_short savebyte;\t/* WARNING: Architecture dependent! */\n\tint totlen, len, wantbyte;\n\n#if FE_DELAYED_PADDING\n\t/* Do the \"delayed padding.\" */\n\tlen = sc->txb_padding >> 1;\n\tif (len > 0) {\n\t\twhile (--len >= 0)\n\t\t\toutw(bmpr8, 0);\n\t\tsc->txb_padding = 0;\n\t}\n#endif\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m->m_flags & M_PKTHDR) == 0)\n\t  \tpanic(\"fe_write_mbufs: no header mbuf\");\n\n#if FE_DEBUG >= 2\n\t/* First, count up the total number of bytes to copy. */\n\tfor (totlen = 0, mp = m; mp != 0; mp = mp->m_next)\n\t\ttotlen += mp->m_len;\n\t/* Check if this matches the one in the packet header. */\n\tif (totlen != m->m_pkthdr.len)\n\t\tlog(LOG_WARNING, \"%s: packet length mismatch? (%d/%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, totlen, m->m_pkthdr.len);\n#else\n\t/* Just use the length value in the packet header. */\n\ttotlen = m->m_pkthdr.len;\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * Should never send big packets.  If such a packet is passed,\n\t * it should be a bug of upper layer.  We just ignore it.\n\t * ... Partial (too short) packets, neither.\n\t */\n\tif (totlen > ETHER_MAX_LEN || totlen < ETHER_HDR_SIZE) {\n\t\tlog(LOG_ERR, \"%s: got a %s packet (%u bytes) to send\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    totlen < ETHER_HDR_SIZE ? \"partial\" : \"big\", totlen);\n\t\tsc->sc_arpcom.ac_if.if_oerrors++;\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Put the length word for this frame.\n\t * Does 86960 accept odd length?  -- Yes.\n\t * Do we need to pad the length to minimum size by ourselves?\n\t * -- Generally yes.  But for (or will be) the last\n\t * packet in the transmission buffer, we can skip the\n\t * padding process.  It may gain performance slightly.  FIXME.\n\t */\n\toutw(bmpr8, max(totlen, ETHER_MIN_LEN));\n\n\t/*\n\t * Update buffer status now.\n\t * Truncate the length up to an even number, since we use outw().\n\t */\n\ttotlen = (totlen + 1) & ~1;\n\tsc->txb_free -= FE_DATA_LEN_LEN + max(totlen, ETHER_MIN_LEN);\n\tsc->txb_count++;\n\n#if FE_DELAYED_PADDING\n\t/* Postpone the packet padding if necessary. */\n\tif (totlen < ETHER_MIN_LEN)\n\t\tsc->txb_padding = ETHER_MIN_LEN - totlen;\n#endif\n\n\t/*\n\t * Transfer the data from mbuf chain to the transmission buffer. \n\t * MB86960 seems to require that data be transferred as words, and\n\t * only words.  So that we require some extra code to patch\n\t * over odd-length mbufs.\n\t */\n\twantbyte = 0;\n\tfor (; m != 0; m = m->m_next) {\n\t\t/* Ignore empty mbuf. */\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\t/* Find the actual data to send. */\n\t\tdata = mtod(m, caddr_t);\n\n\t\t/* Finish the last byte. */\n\t\tif (wantbyte) {\n\t\t\toutw(bmpr8, savebyte | (*data << 8));\n\t\t\tdata++;\n\t\t\tlen--;\n\t\t\twantbyte = 0;\n\t\t}\n\n\t\t/* Output contiguous words. */\n\t\tif (len > 1)\n\t\t\toutsw(bmpr8, data, len >> 1);\n\n\t\t/* Save remaining byte, if there is one. */\n\t\tif (len & 1) {\n\t\t\tdata += len & ~1;\n\t\t\tsavebyte = *data;\n\t\t\twantbyte = 1;\n\t\t}\n\t}\n\n\t/* Spit the last byte, if the length is odd. */\n\tif (wantbyte)\n\t\toutw(bmpr8, savebyte);\n\n#if ! FE_DELAYED_PADDING\n\t/*\n\t * Pad the packet to the minimum length if necessary.\n\t */\n\tlen = (ETHER_MIN_LEN >> 1) - (totlen >> 1);\n\twhile (--len >= 0)\n\t\toutw(bmpr8, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: transmitter idle with %d buffered packets\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->txb_count"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define FE_SINGLE_TRANSMISSION\t0\n#define FE_DEBUG\t\t1\n\nvoid\tfe_start;\nstatic inline\nvoid\tfe_xmit;\nvoid\tfe_write_mbufs;\n\nvoid\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}"
  },
  {
    "function_name": "fe_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1386-1410",
    "snippet": "static inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DELAYED_PADDING\t0"
    ],
    "globals_used": [
      "static inline\nvoid\tfe_xmit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_BMPR10",
            "sc->txb_sched | FE_B10_START"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DELAYED_PADDING\t0\n\nstatic inline\nvoid\tfe_xmit;\n\nstatic inline void\nfe_xmit(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/*\n\t * Set a timer just in case we never hear from the board again.\n\t * We use longer timeout for multiple packet transmission.\n\t * I'm not sure this timer value is appropriate.  FIXME.\n\t */\n\tsc->sc_arpcom.ac_if.if_timer = 1 + sc->txb_count;\n\n\t/* Update txb variables. */\n\tsc->txb_sched = sc->txb_count;\n\tsc->txb_count = 0;\n\tsc->txb_free = sc->txb_size;\n\n#if FE_DELAYED_PADDING\n\t/* Omit the postponed padding process. */\n\tsc->txb_padding = 0;\n#endif\n\n\t/* Start transmitter, passing packets in TX buffer. */\n\toutb(sc->sc_iobase + FE_BMPR10, sc->txb_sched | FE_B10_START);\n}"
  },
  {
    "function_name": "fe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1230-1381",
    "snippet": "void\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)",
      "#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)",
      "#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)",
      "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
      "#define sc_enaddr\tsc_arpcom.ac_enaddr",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_init",
      "void\tfe_start",
      "void\tfe_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: end of fe_init()\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_start",
          "args": [
            "ifp"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "fe_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1421-1563",
          "snippet": "void\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */",
            "#define FE_SINGLE_TRANSMISSION\t0",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_start",
            "static inline\nvoid\tfe_xmit",
            "void\tfe_write_mbufs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_MAX_LEN\t1514\t/* with header, without CRC. */\n#define FE_SINGLE_TRANSMISSION\t0\n#define FE_DEBUG\t\t1\n\nvoid\tfe_start;\nstatic inline\nvoid\tfe_xmit;\nvoid\tfe_write_mbufs;\n\nvoid\nfe_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\tstruct mbuf *m;\n\n#if FE_DEBUG >= 1\n\t/* Just a sanity check. */\n\tif ((sc->txb_count == 0) != (sc->txb_free == sc->txb_size)) {\n\t\t/*\n\t\t * Txb_count and txb_free co-works to manage the\n\t\t * transmission buffer.  Txb_count keeps track of the\n\t\t * used potion of the buffer, while txb_free does unused\n\t\t * potion.  So, as long as the driver runs properly,\n\t\t * txb_count is zero if and only if txb_free is same\n\t\t * as txb_size (which represents whole buffer.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: inconsistent txb variables (%d, %d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count, sc->txb_free);\n\t\t/*\n\t\t * So, what should I do, then?\n\t\t *\n\t\t * We now know txb_count and txb_free contradicts.  We\n\t\t * cannot, however, tell which is wrong.  More\n\t\t * over, we cannot peek 86960 transmission buffer or\n\t\t * reset the transmission buffer.  (In fact, we can\n\t\t * reset the entire interface.  I don't want to do it.)\n\t\t *\n\t\t * If txb_count is incorrect, leaving it as is will cause\n\t\t * sending of gabages after next interrupt.  We have to\n\t\t * avoid it.  Hence, we reset the txb_count here.  If\n\t\t * txb_free was incorrect, resetting txb_count just loose\n\t\t * some packets.  We can live with it.\n\t\t */\n\t\tsc->txb_count = 0;\n\t}\n#endif\n\n#if FE_DEBUG >= 1\n\t/*\n\t * First, see if there are buffered packets and an idle\n\t * transmitter - should never happen at this point.\n\t */\n\tif ((sc->txb_count > 0) && (sc->txb_sched == 0)) {\n\t\tlog(LOG_ERR, \"%s: transmitter idle with %d buffered packets\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->txb_count);\n\t\tfe_xmit(sc);\n\t}\n#endif\n\n\t/*\n\t * Stop accepting more transmission packets temporarily, when\n\t * a filter change request is delayed.  Updating the MARs on\n\t * 86960 flushes the transmisstion buffer, so it is delayed\n\t * until all buffered transmission packets have been sent\n\t * out.\n\t */\n\tif (sc->filter_change) {\n\t\t/*\n\t\t * Filter change requst is delayed only when the DLC is\n\t\t * working.  DLC soon raise an interrupt after finishing\n\t\t * the work.\n\t\t */\n\t\tgoto indicate_active;\n\t}\n\n\tfor (;;) {\n\t\t/*\n\t\t * See if there is room to put another packet in the buffer.\n\t\t * We *could* do better job by peeking the send queue to\n\t\t * know the length of the next packet.  Current version just\n\t\t * tests against the worst case (i.e., longest packet).  FIXME.\n\t\t * \n\t\t * When adding the packet-peek feature, don't forget adding a\n\t\t * test on txb_count against QUEUEING_MAX.\n\t\t * There is a little chance the packet count exceeds\n\t\t * the limit.  Assume transmission buffer is 8KB (2x8KB\n\t\t * configuration) and an application sends a bunch of small\n\t\t * (i.e., minimum packet sized) packets rapidly.  An 8KB\n\t\t * buffer can hold 130 blocks of 62 bytes long...\n\t\t */\n\t\tif (sc->txb_free < ETHER_MAX_LEN + FE_DATA_LEN_LEN) {\n\t\t\t/* No room. */\n\t\t\tgoto indicate_active;\n\t\t}\n\n#if FE_SINGLE_TRANSMISSION\n\t\tif (sc->txb_count > 0) {\n\t\t\t/* Just one packet per a transmission buffer. */\n\t\t\tgoto indicate_active;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Get the next mbuf chain for a packet to send.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, m);\n\t\tif (m == 0) {\n\t\t\t/* No more packets to send. */\n\t\t\tgoto indicate_inactive;\n\t\t}\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Copy the mbuf chain into the transmission buffer.\n\t\t * txb_* variables are updated as necessary.\n\t\t */\n\t\tfe_write_mbufs(sc, m);\n\n\t\tm_freem(m);\n\n\t\t/* Start transmitter if it's idle. */\n\t\tif (sc->txb_sched == 0)\n\t\t\tfe_xmit(sc);\n\t}\n\nindicate_inactive:\n\t/*\n\t * We are using the !OACTIVE flag to indicate to\n\t * the outside world that we can accept an\n\t * additional packet rather than that the\n\t * transmitter is _actually_ active.  Indeed, the\n\t * transmitter may be active, but if we haven't\n\t * filled all the buffers with data then we still\n\t * want to accept more.\n\t */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\treturn;\n\nindicate_active:\n\t/*\n\t * The transmitter is active, and there are no room for\n\t * more outgoing packets in the transmission buffer.\n\t */\n\tifp->if_flags |= IFF_OACTIVE;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_setmode",
          "args": [
            "sc"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "fe_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2310-2403",
          "snippet": "void\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "int\tfeintr",
            "void\tfe_init",
            "void\tfe_getmcaf",
            "void\tfe_setmode",
            "void\tfe_loadmar"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nint\tfeintr;\nvoid\tfe_init;\nvoid\tfe_getmcaf;\nvoid\tfe_setmode;\nvoid\tfe_loadmar;\n\nvoid\nfe_setmode(sc)\n\tstruct fe_softc *sc;\n{\n\tint flags = sc->sc_arpcom.ac_if.if_flags;\n\n\t/*\n\t * If the interface is not running, we postpone the update\n\t * process for receive modes and multicast address filter\n\t * until the interface is restarted.  It reduces some\n\t * complicated job on maintaining chip states.  (Earlier versions\n\t * of this driver had a bug on that point...)\n\t *\n\t * To complete the trick, fe_init() calls fe_setmode() after\n\t * restarting the interface.\n\t */\n\tif ((flags & IFF_RUNNING) == 0)\n\t\treturn;\n\n\t/*\n\t * Promiscuous mode is handled separately.\n\t */\n\tif ((flags & IFF_PROMISC) != 0) {\n\t\t/*\n\t\t * Program 86960 to receive all packets on the segment\n\t\t * including those directed to other stations.\n\t\t * Multicast filter stored in MARs are ignored\n\t\t * under this setting, so we don't need to update it.\n\t\t *\n\t\t * Promiscuous mode is used solely by BPF, and BPF only\n\t\t * listens to valid (no error) packets.  So, we ignore\n\t\t * errornous ones even in this mode.\n\t\t */\n\t\toutb(sc->sc_iobase + FE_DLCR5,\n\t\t    sc->proto_dlcr5 | FE_D5_AFM0 | FE_D5_AFM1);\n\t\tsc->filter_change = 0;\n\n#if FE_DEBUG >= 3\n\t\tlog(LOG_INFO, \"%s: promiscuous mode\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * Turn the chip to the normal (non-promiscuous) mode.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5 | FE_D5_AFM1);\n\n\t/*\n\t * Find the new multicast filter value.\n\t */\n\tfe_getmcaf(&sc->sc_arpcom, sc->filter);\n\tsc->filter_change = 1;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO,\n\t    \"%s: address filter: [%02x %02x %02x %02x %02x %02x %02x %02x]\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sc->filter[0], sc->filter[1], sc->filter[2], sc->filter[3],\n\t    sc->filter[4], sc->filter[5], sc->filter[6], sc->filter[7]);\n#endif\n\n\t/*\n\t * We have to update the multicast filter in the 86960, A.S.A.P.\n\t *\n\t * Note that the DLC (Data Linc Control unit, i.e. transmitter\n\t * and receiver) must be stopped when feeding the filter, and\n\t * DLC trushes all packets in both transmission and receive\n\t * buffers when stopped.\n\t *\n\t * ... Are the above sentenses correct?  I have to check the\n\t *     manual of the MB86960A.  FIXME.\n\t *\n\t * To reduce the packet lossage, we delay the filter update\n\t * process until buffers are empty.\n\t */\n\tif (sc->txb_sched == 0 && sc->txb_count == 0 &&\n\t    (inb(sc->sc_iobase + FE_DLCR1) & FE_D1_PKTRDY) == 0) {\n\t\t/*\n\t\t * Buffers are (apparently) empty.  Load\n\t\t * the new filter value into MARs now.\n\t\t */\n\t\tfe_loadmar(sc);\n\t} else {\n\t\t/*\n\t\t * Buffers are not empty.  Mark that we have to update\n\t\t * the MARs.  The new filter will be loaded by feintr()\n\t\t * later.\n\t\t */\n#if FE_DEBUG >= 4\n\t\tlog(LOG_INFO, \"%s: filter change delayed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR1",
            "0xFF"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: receive buffer emptied (%d)\\n\"",
            "sc->sc_dev.dv_xname",
            "i"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_droppacket",
          "args": [
            "sc"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "fe_droppacket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1219-1225",
          "snippet": "static inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "sc->sc_iobase + FE_DLCR5"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outblk",
          "args": [
            "sc->sc_iobase + FE_DLCR8",
            "sc->sc_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "outblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "272-278",
          "snippet": "static inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->init",
          "args": [
            "sc"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)\n#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)\n#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_DEBUG\t\t1\n\nvoid\tfe_init;\nvoid\tfe_start;\nvoid\tfe_setmode;\n\nvoid\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
  },
  {
    "function_name": "fe_droppacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1219-1225",
    "snippet": "static inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_BMPR14",
            "FE_B14_FILTER | FE_B14_SKIP"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void\nfe_droppacket(sc)\n\tstruct fe_softc *sc;\n{\n\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER | FE_B14_SKIP);\n}"
  },
  {
    "function_name": "fe_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1199-1214",
    "snippet": "void\nfe_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n#if FE_DEBUG >= 3\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Record how many packets are lost by this accident. */\n\tsc->sc_arpcom.ac_if.if_oerrors += sc->txb_sched + sc->txb_count;\n\n\tfe_reset(sc);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_reset",
      "void\tfe_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_reset",
          "args": [
            "sc"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "fe_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1136-1146",
          "snippet": "void\nfe_reset(sc)\n\tstruct fe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tfe_stop(sc);\n\tfe_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tfe_init",
            "void\tfe_reset",
            "void\tfe_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tfe_init;\nvoid\tfe_reset;\nvoid\tfe_stop;\n\nvoid\nfe_reset(sc)\n\tstruct fe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tfe_stop(sc);\n\tfe_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_reset;\nvoid\tfe_watchdog;\n\nvoid\nfe_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fe_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n#if FE_DEBUG >= 3\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Record how many packets are lost by this accident. */\n\tsc->sc_arpcom.ac_if.if_oerrors += sc->txb_sched + sc->txb_count;\n\n\tfe_reset(sc);\n}"
  },
  {
    "function_name": "fe_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1154-1193",
    "snippet": "void\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfe_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: end of fe_stop()\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->stop",
          "args": [
            "sc"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_DLCR7",
            "sc->proto_dlcr7 | FE_D7_POWER_DOWN"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_stop;\n\nvoid\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
  },
  {
    "function_name": "fe_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "1136-1146",
    "snippet": "void\nfe_reset(sc)\n\tstruct fe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tfe_stop(sc);\n\tfe_init(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tfe_init",
      "void\tfe_reset",
      "void\tfe_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fe_init",
          "args": [
            "sc"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "fe_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1230-1381",
          "snippet": "void\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)",
            "#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)",
            "#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)",
            "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
            "#define sc_enaddr\tsc_arpcom.ac_enaddr",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_init",
            "void\tfe_start",
            "void\tfe_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_MAX_RECV_COUNT ((65536 - 2048 * 2) / 64)\n#define FE_RMASK (FE_D3_OVRFLO | FE_D3_CRCERR | \\\n\t\t  FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY)\n#define FE_TMASK (FE_D2_COLL16 | FE_D2_TXDONE)\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_DEBUG\t\t1\n\nvoid\tfe_init;\nvoid\tfe_start;\nvoid\tfe_setmode;\n\nvoid\nfe_init(sc)\n\tstruct fe_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Reset transmitter flags. */\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tifp->if_timer = 0;\n\n\tsc->txb_free = sc->txb_size;\n\tsc->txb_count = 0;\n\tsc->txb_sched = 0;\n\n\t/* Call a hook. */\n\tif (sc->init)\n\t\tsc->init(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after init hook\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to disable the chip, also.\n\t * This may also help re-programming the chip after\n\t * hot insertion of PCMCIAs.\n\t */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\n\t/* Power up the chip and select register bank for DLCRs. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_DLCR | FE_D7_POWER_UP);\n\tdelay(200);\n\n\t/* Feed the station address. */\n\toutblk(sc->sc_iobase + FE_DLCR8, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Select the BMPR bank for runtime register access. */\n\toutb(sc->sc_iobase + FE_DLCR7,\n\t    sc->proto_dlcr7 | FE_D7_RBS_BMPR | FE_D7_POWER_UP);\n\n\t/* Initialize registers. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR4, sc->proto_dlcr4);\n\toutb(sc->sc_iobase + FE_DLCR5, sc->proto_dlcr5);\n\toutb(sc->sc_iobase + FE_BMPR10, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR11, FE_B11_CTRL_SKIP);\n\toutb(sc->sc_iobase + FE_BMPR12, 0x00);\n\toutb(sc->sc_iobase + FE_BMPR13, sc->proto_bmpr13);\n\toutb(sc->sc_iobase + FE_BMPR14, FE_B14_FILTER);\n\toutb(sc->sc_iobase + FE_BMPR15, 0x00);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just before enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Enable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, FE_TMASK);\n\toutb(sc->sc_iobase + FE_DLCR3, FE_RMASK);\n\n\t/* Enable transmitter and receiver. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_ENABLE);\n\tdelay(200);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: just after enabling DLC\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * Make sure to empty the receive buffer.\n\t *\n\t * This may be redundant, but *if* the receive buffer were full\n\t * at this point, the driver would hang.  I have experienced\n\t * some strange hangups just after UP.  I hope the following\n\t * code solve the problem.\n\t *\n\t * I have changed the order of hardware initialization.\n\t * I think the receive buffer cannot have any packets at this\n\t * point in this version.  The following code *must* be\n\t * redundant now.  FIXME.\n\t */\n\tfor (i = 0; i < FE_MAX_RECV_COUNT; i++) {\n\t\tif (inb(sc->sc_iobase + FE_DLCR5) & FE_D5_BUFEMP)\n\t\t\tbreak;\n\t\tfe_droppacket(sc);\n\t}\n#if FE_DEBUG >= 1\n\tif (i >= FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_ERR, \"%s: cannot empty receive buffer\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n#endif\n#if FE_DEBUG >= 3\n\tif (i < FE_MAX_RECV_COUNT) {\n\t\tlog(LOG_INFO, \"%s: receive buffer emptied (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, i);\n\t}\n#endif\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after ERB loop\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Do we need this here? */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\t/* Clear all bits. */\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\t/* ditto. */\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after FIXME\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Set 'running' flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\n\t/*\n\t * At this point, the interface is runnung properly,\n\t * except that it receives *no* packets.  we then call\n\t * fe_setmode() to tell the chip what packets to be\n\t * received, based on the if_flags and multicast group\n\t * list.  It completes the initialization process.\n\t */\n\tfe_setmode(sc);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: after setmode\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* ...and attempt to start output. */\n\tfe_start(ifp);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_init()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_stop",
          "args": [
            "sc"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "fe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1154-1193",
          "snippet": "void\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_stop;\n\nvoid\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tfe_init;\nvoid\tfe_reset;\nvoid\tfe_stop;\n\nvoid\nfe_reset(sc)\n\tstruct fe_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tfe_stop(sc);\n\tfe_init(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "feattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "983-1131",
    "snippet": "void\nfeattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fe_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Stop the 86960. */\n\tfe_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = fe_start;\n\tifp->if_ioctl = fe_ioctl;\n\tifp->if_watchdog = fe_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/*\n\t * Set maximum size of output queue, if it has not been set.\n\t * It is done here as this driver may be started after the\n\t * system intialization (i.e., the interface is PCMCIA.)\n\t *\n\t * I'm not sure this is really necessary, but, even if it is,\n\t * it should be done somewhere else, e.g., in if_attach(),\n\t * since it must be a common workaround for all network drivers.\n\t * FIXME.\n\t */\n\tif (ifp->if_snd.ifq_maxlen == 0) {\n\t\textern int ifqmaxlen;\t\t/* Don't be so shocked... */\n\t\tifp->if_snd.ifq_maxlen = ifqmaxlen;\n\t}\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: feattach()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n#if FE_SINGLE_TRANSMISSION\n\t/* Override txb config to allocate minimum. */\n\tsc->proto_dlcr6 &= ~FE_D6_TXBSIZ\n\tsc->proto_dlcr6 |=  FE_D6_TXBSIZ_2x2KB;\n#endif\n\n\t/* Modify hardware config if it is requested. */\n\tif ((cf->cf_flags & FE_FLAGS_OVERRIDE_DLCR6) != 0)\n\t\tsc->proto_dlcr6 = cf->cf_flags & FE_FLAGS_DLCR6_VALUE;\n\n\t/* Find TX buffer size, based on the hardware dependent proto. */\n\tswitch (sc->proto_dlcr6 & FE_D6_TXBSIZ) {\n\tcase FE_D6_TXBSIZ_2x2KB:\n\t\tsc->txb_size = 2048;\n\t\tbreak;\n\tcase FE_D6_TXBSIZ_2x4KB:\n\t\tsc->txb_size = 4096;\n\t\tbreak;\n\tcase FE_D6_TXBSIZ_2x8KB:\n\t\tsc->txb_size = 8192;\n\t\tbreak;\n\tdefault:\n\t\t/* Oops, we can't work with single buffer configuration. */\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: strange TXBSIZ config; fixing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\tsc->proto_dlcr6 &= ~FE_D6_TXBSIZ;\n\t\tsc->proto_dlcr6 |=  FE_D6_TXBSIZ_2x2KB;\n\t\tsc->txb_size = 2048;\n\t\tbreak;\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, type %s\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->typestr);\n#if FE_DEBUG >= 3\n\t{\n\t\tint buf, txb, bbw, sbw, ram;\n\n\t\tbuf = txb = bbw = sbw = ram = -1;\n\t\tswitch (sc->proto_dlcr6 & FE_D6_BUFSIZ) {\n\t\tcase FE_D6_BUFSIZ_8KB:\n\t\t\tbuf = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_16KB:\n\t\t\tbuf = 16;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_32KB:\n\t\t\tbuf = 32;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_64KB:\n\t\t\tbuf = 64;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_TXBSIZ) {\n\t\tcase FE_D6_TXBSIZ_2x2KB:\n\t\t\ttxb = 2;\n\t\t\tbreak;\n\t\tcase FE_D6_TXBSIZ_2x4KB:\n\t\t\ttxb = 4;\n\t\t\tbreak;\n\t\tcase FE_D6_TXBSIZ_2x8KB:\n\t\t\ttxb = 8;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_BBW) {\n\t\tcase FE_D6_BBW_BYTE:\n\t\t\tbbw = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_BBW_WORD:\n\t\t\tbbw = 16;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_SBW) {\n\t\tcase FE_D6_SBW_BYTE:\n\t\t\tsbw = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_SBW_WORD:\n\t\t\tsbw = 16;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_SRAM) {\n\t\tcase FE_D6_SRAM_100ns:\n\t\t\tram = 100;\n\t\t\tbreak;\n\t\tcase FE_D6_SRAM_150ns:\n\t\t\tram = 150;\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%s: SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\\n\",\n\t\t    sc->sc_dev.dv_xname, buf, bbw, ram, txb, sbw);\n\t}\n#endif\n\n#if NBPFILTER > 0\n\t/* If BPF is in the kernel, call the attach for it. */\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, feintr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_FLAGS_OVERRIDE_DLCR6\t0x0080",
      "#define FE_FLAGS_DLCR6_VALUE\t0x007F",
      "#define FE_SINGLE_TRANSMISSION\t0",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "void\tfeattach",
      "int\tfeintr",
      "int\tfe_ioctl",
      "void\tfe_start",
      "void\tfe_watchdog",
      "void\tfe_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "feintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\\n\"",
            "sc->sc_dev.dv_xname",
            "buf",
            "bbw",
            "ram",
            "txb",
            "sbw"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: strange TXBSIZ config; fixing\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_stop",
          "args": [
            "sc"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "fe_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "1154-1193",
          "snippet": "void\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "void\tfe_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nvoid\tfe_stop;\n\nvoid\nfe_stop(sc)\n\tstruct fe_softc *sc;\n{\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Disable interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0x00);\n\toutb(sc->sc_iobase + FE_DLCR3, 0x00);\n\n\t/* Stop interface hardware. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Clear all interrupt status. */\n\toutb(sc->sc_iobase + FE_DLCR0, 0xFF);\n\toutb(sc->sc_iobase + FE_DLCR1, 0xFF);\n\n\t/* Put the chip in stand-by mode. */\n\tdelay(200);\n\toutb(sc->sc_iobase + FE_DLCR7, sc->proto_dlcr7 | FE_D7_POWER_DOWN);\n\tdelay(200);\n\n\t/* MAR loading can be delayed. */\n\tsc->filter_change = 0;\n\n\t/* Call a hook. */\n\tif (sc->stop)\n\t\tsc->stop(sc);\n\n#if DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_stop()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_FLAGS_OVERRIDE_DLCR6\t0x0080\n#define FE_FLAGS_DLCR6_VALUE\t0x007F\n#define FE_SINGLE_TRANSMISSION\t0\n#define FE_DEBUG\t\t1\n\nvoid\tfeattach;\nint\tfeintr;\nint\tfe_ioctl;\nvoid\tfe_start;\nvoid\tfe_watchdog;\nvoid\tfe_stop;\n\nvoid\nfeattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fe_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Stop the 86960. */\n\tfe_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = fe_start;\n\tifp->if_ioctl = fe_ioctl;\n\tifp->if_watchdog = fe_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/*\n\t * Set maximum size of output queue, if it has not been set.\n\t * It is done here as this driver may be started after the\n\t * system intialization (i.e., the interface is PCMCIA.)\n\t *\n\t * I'm not sure this is really necessary, but, even if it is,\n\t * it should be done somewhere else, e.g., in if_attach(),\n\t * since it must be a common workaround for all network drivers.\n\t * FIXME.\n\t */\n\tif (ifp->if_snd.ifq_maxlen == 0) {\n\t\textern int ifqmaxlen;\t\t/* Don't be so shocked... */\n\t\tifp->if_snd.ifq_maxlen = ifqmaxlen;\n\t}\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: feattach()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n#if FE_SINGLE_TRANSMISSION\n\t/* Override txb config to allocate minimum. */\n\tsc->proto_dlcr6 &= ~FE_D6_TXBSIZ\n\tsc->proto_dlcr6 |=  FE_D6_TXBSIZ_2x2KB;\n#endif\n\n\t/* Modify hardware config if it is requested. */\n\tif ((cf->cf_flags & FE_FLAGS_OVERRIDE_DLCR6) != 0)\n\t\tsc->proto_dlcr6 = cf->cf_flags & FE_FLAGS_DLCR6_VALUE;\n\n\t/* Find TX buffer size, based on the hardware dependent proto. */\n\tswitch (sc->proto_dlcr6 & FE_D6_TXBSIZ) {\n\tcase FE_D6_TXBSIZ_2x2KB:\n\t\tsc->txb_size = 2048;\n\t\tbreak;\n\tcase FE_D6_TXBSIZ_2x4KB:\n\t\tsc->txb_size = 4096;\n\t\tbreak;\n\tcase FE_D6_TXBSIZ_2x8KB:\n\t\tsc->txb_size = 8192;\n\t\tbreak;\n\tdefault:\n\t\t/* Oops, we can't work with single buffer configuration. */\n#if FE_DEBUG >= 2\n\t\tlog(LOG_WARNING, \"%s: strange TXBSIZ config; fixing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\tsc->proto_dlcr6 &= ~FE_D6_TXBSIZ;\n\t\tsc->proto_dlcr6 |=  FE_D6_TXBSIZ_2x2KB;\n\t\tsc->txb_size = 2048;\n\t\tbreak;\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, type %s\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr), sc->typestr);\n#if FE_DEBUG >= 3\n\t{\n\t\tint buf, txb, bbw, sbw, ram;\n\n\t\tbuf = txb = bbw = sbw = ram = -1;\n\t\tswitch (sc->proto_dlcr6 & FE_D6_BUFSIZ) {\n\t\tcase FE_D6_BUFSIZ_8KB:\n\t\t\tbuf = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_16KB:\n\t\t\tbuf = 16;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_32KB:\n\t\t\tbuf = 32;\n\t\t\tbreak;\n\t\tcase FE_D6_BUFSIZ_64KB:\n\t\t\tbuf = 64;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_TXBSIZ) {\n\t\tcase FE_D6_TXBSIZ_2x2KB:\n\t\t\ttxb = 2;\n\t\t\tbreak;\n\t\tcase FE_D6_TXBSIZ_2x4KB:\n\t\t\ttxb = 4;\n\t\t\tbreak;\n\t\tcase FE_D6_TXBSIZ_2x8KB:\n\t\t\ttxb = 8;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_BBW) {\n\t\tcase FE_D6_BBW_BYTE:\n\t\t\tbbw = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_BBW_WORD:\n\t\t\tbbw = 16;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_SBW) {\n\t\tcase FE_D6_SBW_BYTE:\n\t\t\tsbw = 8;\n\t\t\tbreak;\n\t\tcase FE_D6_SBW_WORD:\n\t\t\tsbw = 16;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (sc->proto_dlcr6 & FE_D6_SRAM) {\n\t\tcase FE_D6_SRAM_100ns:\n\t\t\tram = 100;\n\t\t\tbreak;\n\t\tcase FE_D6_SRAM_150ns:\n\t\t\tram = 150;\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%s: SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\\n\",\n\t\t    sc->sc_dev.dv_xname, buf, bbw, ram, txb, sbw);\n\t}\n#endif\n\n#if NBPFILTER > 0\n\t/* If BPF is in the kernel, call the attach for it. */\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, feintr, sc, sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "fe_init_mbh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "958-978",
    "snippet": "void\nfe_init_mbh(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Probably required after hot-insertion... */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0);\n\toutb(sc->sc_iobase + FE_DLCR3, 0);\n\n\t/* Enable master interrupt flag. */\n\toutb(sc->sc_iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_ENABLE);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tfe_init_mbh"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "sc->sc_iobase + FE_MBH0",
            "FE_MBH0_MAGIC | FE_MBH0_INTR_ENABLE"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tfe_init_mbh;\n\nvoid\nfe_init_mbh(sc)\n\tstruct fe_softc *sc;\n{\n\n\t/* Probably required after hot-insertion... */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(sc->sc_iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(sc->sc_iobase + FE_DLCR2, 0);\n\toutb(sc->sc_iobase + FE_DLCR3, 0);\n\n\t/* Enable master interrupt flag. */\n\toutb(sc->sc_iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_ENABLE);\n}"
  },
  {
    "function_name": "fe_probe_mbh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "822-955",
    "snippet": "int\nfe_probe_mbh(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint iobase = sc->sc_iobase;\n\n\tstatic struct fe_simple_probe_struct probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoes not work well. */\n#if 0\n\t/*\n\t * Test *vendor* part of the address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects clones by other vendors, or OEM product\n\t * supplied by resalers other than Fujitsu.\n\t */\n\t\t{ FE_MBH10, 0xFF, 0x00 },\n\t\t{ FE_MBH11, 0xFF, 0x00 },\n\t\t{ FE_MBH12, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"global\" and \"unicast\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_MBH10, 0x03, 0x00 },\n#endif\n        /* Just a gap?  Seems reliable, anyway. */\n\t\t{ 0x12, 0xFF, 0x00 },\n\t\t{ 0x13, 0xFF, 0x00 },\n\t\t{ 0x14, 0xFF, 0x00 },\n\t\t{ 0x15, 0xFF, 0x00 },\n\t\t{ 0x16, 0xFF, 0x00 },\n\t\t{ 0x17, 0xFF, 0x00 },\n\t\t{ 0x18, 0xFF, 0xFF },\n\t\t{ 0x19, 0xFF, 0xFF },\n\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * We need a PCMCIA flag.\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) == 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * We need explicit IRQ and supported address.\n\t */\n\tif (ia->ia_irq == IRQUNK || (iobase & ~0x3E0) != 0)\n\t\treturn (0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_probe_mbh()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if MBH10302 is on its address.\n\t * I'm not sure the following probe code works.  FIXME.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tsc->type = FE_TYPE_MBH10302;\n\tsc->typestr = \"MBH10302 (PCMCIA)\";\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_MBH10, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_NICE;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/* Setup hooks.  We need a special initialization procedure. */\n\tsc->init = fe_init_mbh;\n\n\t/*\n\t * Minimum initialization.\n\t */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if 1\t/* FIXME. */\n\t/* Initialize system bus interface and encoder/decoder operation. */\n\toutb(iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_DISABLE);\n#endif\n\n\t/*\n\t * That's all.  MBH10302 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
      "#define sc_enaddr\tsc_arpcom.ac_enaddr",
      "#define FE_FLAGS_PCMCIA\t\t0x8000",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "int\tfe_probe_mbh",
      "void\tfe_init_mbh"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + FE_MBH0",
            "FE_MBH0_MAGIC | FE_MBH0_INTR_DISABLE"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inblk",
          "args": [
            "iobase + FE_MBH10",
            "sc->sc_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "inblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "264-270",
          "snippet": "static inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_simple_probe",
          "args": [
            "iobase",
            "probe_table"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "fe_simple_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "320-331",
          "snippet": "static inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: top of fe_probe_mbh()\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n#define FE_DEBUG\t\t1\n\nint\tfe_probe_mbh;\nvoid\tfe_init_mbh;\n\nint\nfe_probe_mbh(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint iobase = sc->sc_iobase;\n\n\tstatic struct fe_simple_probe_struct probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoes not work well. */\n#if 0\n\t/*\n\t * Test *vendor* part of the address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects clones by other vendors, or OEM product\n\t * supplied by resalers other than Fujitsu.\n\t */\n\t\t{ FE_MBH10, 0xFF, 0x00 },\n\t\t{ FE_MBH11, 0xFF, 0x00 },\n\t\t{ FE_MBH12, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"global\" and \"unicast\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_MBH10, 0x03, 0x00 },\n#endif\n        /* Just a gap?  Seems reliable, anyway. */\n\t\t{ 0x12, 0xFF, 0x00 },\n\t\t{ 0x13, 0xFF, 0x00 },\n\t\t{ 0x14, 0xFF, 0x00 },\n\t\t{ 0x15, 0xFF, 0x00 },\n\t\t{ 0x16, 0xFF, 0x00 },\n\t\t{ 0x17, 0xFF, 0x00 },\n\t\t{ 0x18, 0xFF, 0xFF },\n\t\t{ 0x19, 0xFF, 0xFF },\n\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * We need a PCMCIA flag.\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) == 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * We need explicit IRQ and supported address.\n\t */\n\tif (ia->ia_irq == IRQUNK || (iobase & ~0x3E0) != 0)\n\t\treturn (0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_probe_mbh()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if MBH10302 is on its address.\n\t * I'm not sure the following probe code works.  FIXME.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tsc->type = FE_TYPE_MBH10302;\n\tsc->typestr = \"MBH10302 (PCMCIA)\";\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_MBH10, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_NICE;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/* Setup hooks.  We need a special initialization procedure. */\n\tsc->init = fe_init_mbh;\n\n\t/*\n\t * Minimum initialization.\n\t */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if 1\t/* FIXME. */\n\t/* Initialize system bus interface and encoder/decoder operation. */\n\toutb(iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_DISABLE);\n#endif\n\n\t/*\n\t * That's all.  MBH10302 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}"
  },
  {
    "function_name": "fe_probe_ati",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "602-817",
    "snippet": "int\nfe_probe_ati(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tu_char eeprom[FE_EEPROM_SIZE];\n\tu_char save16, save17;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x260, 0x280, 0x2A0, 0x240, 0x340, 0x320, 0x380, 0x300 };\n\tstatic int const irqmap[4][4] = {\n\t\t{  3,  4,  5,  9 },\n\t\t{ 10, 11, 12, 15 },\n\t\t{  3, 11,  5, 15 },\n\t\t{ 10, 11, 14, 15 },\n\t};\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2,  0x70, 0x00 },\n\t\t{ FE_DLCR4,  0x08, 0x00 },\n\t\t{ FE_DLCR5,  0x80, 0x00 },\n#if 0\n\t\t{ FE_BMPR16, 0x1B, 0x00 },\n\t\t{ FE_BMPR17, 0x7F, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Don't probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: probe (0x%x) for ATI\\n\", sc->sc_dev.dv_xname, iobase);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for MB86965A JLI mode.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/*\n\t * We should test if MB86965A is on the base address now.\n\t * Unfortunately, it is very hard to probe it reliably, since\n\t * we have no way to reset the chip under software control.\n\t * On cold boot, we could check the \"signature\" bit patterns\n\t * described in the Fujitsu document.  On warm boot, however,\n\t * we can predict almost nothing about register values.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Save old values of the registers. */\n\tsave16 = inb(iobase + FE_BMPR16);\n\tsave17 = inb(iobase + FE_BMPR17);\n\n\t/* Check if our I/O address matches config info on 86965. */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_ADDR) >> FE_B19_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\tgoto fail;\n\n\t/*\n\t * We are now almost sure we have an AT1700 at the given\n\t * address.  So, read EEPROM through 86965.  We have to write\n\t * into LSI registers to read from EEPROM.  I want to avoid it\n\t * at this stage, but I cannot test the presense of the chip\n\t * any further without reading EEPROM.  FIXME.\n\t */\n\tfe_read_eeprom(sc, eeprom);\n\n\t/* Make sure the EEPROM is turned off. */\n\toutb(iobase + FE_BMPR16, 0);\n\toutb(iobase + FE_BMPR17, 0);\n\n\t/* Make sure that config info in EEPROM and 86965 agree. */\n\tif (eeprom[FE_EEPROM_CONF] != inb(iobase + FE_BMPR19))\n\t\tgoto fail;\n\n\t/*\n\t * Determine the card type.\n\t */\n\tswitch (eeprom[FE_ATI_EEP_MODEL]) {\n\tcase FE_ATI_MODEL_AT1700T:\n\t\tsc->type = FE_TYPE_AT1700T;\n\t\tsc->typestr = \"AT-1700T\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700BT:\n\t\tsc->type = FE_TYPE_AT1700BT;\n\t\tsc->typestr = \"AT-1700BT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700FT:\n\t\tsc->type = FE_TYPE_AT1700FT;\n\t\tsc->typestr = \"AT-1700FT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700AT:\n\t\tsc->type = FE_TYPE_AT1700AT;\n\t\tsc->typestr = \"AT-1700AT\";\n\t\tbreak;\n\tdefault:\n\t\tsc->type = FE_TYPE_RE2000;\n\t\tsc->typestr = \"unknown (RE-2000?)\";\n\t\tbreak;\n\t}\n\n\t/*\n\t * Try to determine IRQ settings.\n\t * Different models use different ranges of IRQs.\n\t */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_IRQ) >> FE_B19_IRQ_SHIFT;\n\tswitch (eeprom[FE_ATI_EEP_REVISION] & 0xf0) {\n\tcase 0x30:\n\t\tirq = irqmap[3][n];\n\t\tbreak;\n\tcase 0x10:\n\tcase 0x50:\n\t\tirq = irqmap[2][n];\n\t\tbreak;\n\tcase 0x40:\n\tcase 0x60:\n\t\tif (eeprom[FE_ATI_EEP_MAGIC] & 0x04) {\n\t\t\tirq = irqmap[1][n];\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tirq = irqmap[0][n];\n\t\tbreak;\n\t}\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tbcopy(eeprom + FE_ATI_EEP_ADDR, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\tgoto fail;\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;  /* FIXME */\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n#if 0\t/* XXXX Should we use this? */\n\tsc->proto_bmpr13 = eeprom[FE_ATI_EEP_MEDIA];\n#else\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n#endif\n\n\t/*\n\t * Program the 86965 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ATI found\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Initialize 86965. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_probe_ati()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * That's all.  AT1700 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n\nfail:\n\t/* Restore register values, in the case we had no 86965. */\n\toutb(iobase + FE_BMPR16, save16);\n\toutb(iobase + FE_BMPR17, save17);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
      "#define sc_enaddr\tsc_arpcom.ac_enaddr",
      "#define FE_FLAGS_PCMCIA\t\t0x8000",
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "int\tfe_probe_ati",
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + FE_BMPR17",
            "save17"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_dump",
          "args": [
            "LOG_INFO",
            "sc"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "fe_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "2444-2483",
          "snippet": "void\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_dump(level, sc)\n\tint level;\n\tstruct fe_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tu_char save_dlcr7;\n\n\tsave_dlcr7 = inb(iobase + FE_DLCR7);\n\n\tlog(level, \"\\tDLCR = %02x %02x %02x %02x %02x %02x %02x %02x\",\n\t    inb(iobase + FE_DLCR0),  inb(iobase + FE_DLCR1),\n\t    inb(iobase + FE_DLCR2),  inb(iobase + FE_DLCR3),\n\t    inb(iobase + FE_DLCR4),  inb(iobase + FE_DLCR5),\n\t    inb(iobase + FE_DLCR6),  inb(iobase + FE_DLCR7));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_DLCR);\n\tlog(level, \"\\t       %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_DLCR8),  inb(iobase + FE_DLCR9),\n\t    inb(iobase + FE_DLCR10), inb(iobase + FE_DLCR11),\n\t    inb(iobase + FE_DLCR12), inb(iobase + FE_DLCR13),\n\t    inb(iobase + FE_DLCR14), inb(iobase + FE_DLCR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_MAR);\n\tlog(level, \"\\tMAR  = %02x %02x %02x %02x %02x %02x %02x %02x,\",\n\t    inb(iobase + FE_MAR8),   inb(iobase + FE_MAR9),\n\t    inb(iobase + FE_MAR10),  inb(iobase + FE_MAR11),\n\t    inb(iobase + FE_MAR12),  inb(iobase + FE_MAR13),\n\t    inb(iobase + FE_MAR14),  inb(iobase + FE_MAR15));\n\n\toutb(iobase + FE_DLCR7, (save_dlcr7 & ~FE_D7_RBS) | FE_D7_RBS_BMPR);\n\tlog(level, \"\\tBMPR = xx xx %02x %02x %02x %02x %02x %02x %02x %02x xx %02x.\",\n\t    inb(iobase + FE_BMPR10), inb(iobase + FE_BMPR11),\n\t    inb(iobase + FE_BMPR12), inb(iobase + FE_BMPR13),\n\t    inb(iobase + FE_BMPR14), inb(iobase + FE_BMPR15),\n\t    inb(iobase + FE_BMPR16), inb(iobase + FE_BMPR17),\n\t    inb(iobase + FE_BMPR19));\n\n\toutb(iobase + FE_DLCR7, save_dlcr7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: end of fe_probe_ati()\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "eeprom + FE_ATI_EEP_ADDR",
            "sc->sc_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: irq mismatch; kernel configured %d != board configured %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ia->ia_irq",
            "irq"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + FE_BMPR19"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_read_eeprom",
          "args": [
            "sc",
            "eeprom"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "fe_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "355-421",
          "snippet": "void\nfe_read_eeprom(sc, data)\n\tstruct fe_softc *sc;\n\tu_char *data;\n{\n\tint iobase = sc->sc_iobase;\n\tint bmpr16 = iobase + FE_BMPR16;\n\tint bmpr17 = iobase + FE_BMPR17;\n\tu_char n, val, bit;\n\n\t/* Read bytes from EEPROM; two bytes per an iterration. */\n\tfor (n = 0; n < FE_EEPROM_SIZE / 2; n++) {\n\t\t/* Reset the EEPROM interface. */\n\t\toutb(bmpr16, 0x00);\n\t\toutb(bmpr17, 0x00);\n\t\toutb(bmpr16, FE_B16_SELECT);\n\n\t\t/* Start EEPROM access. */\n\t\toutb(bmpr17, FE_B17_DATA);\n\t\tstrobe(bmpr16);\n\n\t\t/* Pass the iterration count to the chip. */\n\t\tval = 0x80 | n;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\toutb(bmpr17, (val & bit) ? FE_B17_DATA : 0);\n\t\t\tstrobe(bmpr16);\n\t\t}\n\t\toutb(bmpr17, 0x00);\n\n\t\t/* Read a byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\n\t\t/* Read one more byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\t}\n\n#if FE_DEBUG >= 3\n\t/* Report what we got. */\n\tdata -= FE_EEPROM_SIZE;\n\tlog(LOG_INFO, \"%s: EEPROM at %04x:\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t    sc->sc_dev.dv_xname, iobase,\n\t    data[ 0], data[ 1], data[ 2], data[ 3],\n\t    data[ 4], data[ 5], data[ 6], data[ 7],\n\t    data[ 8], data[ 9], data[10], data[11],\n\t    data[12], data[13], data[14], data[15],\n\t    data[16], data[17], data[18], data[19],\n\t    data[20], data[21], data[22], data[23],\n\t    data[24], data[25], data[26], data[27],\n\t    data[28], data[29], data[30], data[31]);\n#endif\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_read_eeprom(sc, data)\n\tstruct fe_softc *sc;\n\tu_char *data;\n{\n\tint iobase = sc->sc_iobase;\n\tint bmpr16 = iobase + FE_BMPR16;\n\tint bmpr17 = iobase + FE_BMPR17;\n\tu_char n, val, bit;\n\n\t/* Read bytes from EEPROM; two bytes per an iterration. */\n\tfor (n = 0; n < FE_EEPROM_SIZE / 2; n++) {\n\t\t/* Reset the EEPROM interface. */\n\t\toutb(bmpr16, 0x00);\n\t\toutb(bmpr17, 0x00);\n\t\toutb(bmpr16, FE_B16_SELECT);\n\n\t\t/* Start EEPROM access. */\n\t\toutb(bmpr17, FE_B17_DATA);\n\t\tstrobe(bmpr16);\n\n\t\t/* Pass the iterration count to the chip. */\n\t\tval = 0x80 | n;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\toutb(bmpr17, (val & bit) ? FE_B17_DATA : 0);\n\t\t\tstrobe(bmpr16);\n\t\t}\n\t\toutb(bmpr17, 0x00);\n\n\t\t/* Read a byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\n\t\t/* Read one more byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\t}\n\n#if FE_DEBUG >= 3\n\t/* Report what we got. */\n\tdata -= FE_EEPROM_SIZE;\n\tlog(LOG_INFO, \"%s: EEPROM at %04x:\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t    sc->sc_dev.dv_xname, iobase,\n\t    data[ 0], data[ 1], data[ 2], data[ 3],\n\t    data[ 4], data[ 5], data[ 6], data[ 7],\n\t    data[ 8], data[ 9], data[10], data[11],\n\t    data[12], data[13], data[14], data[15],\n\t    data[16], data[17], data[18], data[19],\n\t    data[20], data[21], data[22], data[23],\n\t    data[24], data[25], data[26], data[27],\n\t    data[28], data[29], data[30], data[31]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_simple_probe",
          "args": [
            "iobase",
            "probe_table"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "fe_simple_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "320-331",
          "snippet": "static inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: probe (0x%x) for ATI\\n\"",
            "sc->sc_dev.dv_xname",
            "iobase"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n#define FE_DEBUG\t\t1\n\nint\tfe_probe_ati;\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nint\nfe_probe_ati(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tu_char eeprom[FE_EEPROM_SIZE];\n\tu_char save16, save17;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x260, 0x280, 0x2A0, 0x240, 0x340, 0x320, 0x380, 0x300 };\n\tstatic int const irqmap[4][4] = {\n\t\t{  3,  4,  5,  9 },\n\t\t{ 10, 11, 12, 15 },\n\t\t{  3, 11,  5, 15 },\n\t\t{ 10, 11, 14, 15 },\n\t};\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2,  0x70, 0x00 },\n\t\t{ FE_DLCR4,  0x08, 0x00 },\n\t\t{ FE_DLCR5,  0x80, 0x00 },\n#if 0\n\t\t{ FE_BMPR16, 0x1B, 0x00 },\n\t\t{ FE_BMPR17, 0x7F, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Don't probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: probe (0x%x) for ATI\\n\", sc->sc_dev.dv_xname, iobase);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for MB86965A JLI mode.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/*\n\t * We should test if MB86965A is on the base address now.\n\t * Unfortunately, it is very hard to probe it reliably, since\n\t * we have no way to reset the chip under software control.\n\t * On cold boot, we could check the \"signature\" bit patterns\n\t * described in the Fujitsu document.  On warm boot, however,\n\t * we can predict almost nothing about register values.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Save old values of the registers. */\n\tsave16 = inb(iobase + FE_BMPR16);\n\tsave17 = inb(iobase + FE_BMPR17);\n\n\t/* Check if our I/O address matches config info on 86965. */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_ADDR) >> FE_B19_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\tgoto fail;\n\n\t/*\n\t * We are now almost sure we have an AT1700 at the given\n\t * address.  So, read EEPROM through 86965.  We have to write\n\t * into LSI registers to read from EEPROM.  I want to avoid it\n\t * at this stage, but I cannot test the presense of the chip\n\t * any further without reading EEPROM.  FIXME.\n\t */\n\tfe_read_eeprom(sc, eeprom);\n\n\t/* Make sure the EEPROM is turned off. */\n\toutb(iobase + FE_BMPR16, 0);\n\toutb(iobase + FE_BMPR17, 0);\n\n\t/* Make sure that config info in EEPROM and 86965 agree. */\n\tif (eeprom[FE_EEPROM_CONF] != inb(iobase + FE_BMPR19))\n\t\tgoto fail;\n\n\t/*\n\t * Determine the card type.\n\t */\n\tswitch (eeprom[FE_ATI_EEP_MODEL]) {\n\tcase FE_ATI_MODEL_AT1700T:\n\t\tsc->type = FE_TYPE_AT1700T;\n\t\tsc->typestr = \"AT-1700T\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700BT:\n\t\tsc->type = FE_TYPE_AT1700BT;\n\t\tsc->typestr = \"AT-1700BT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700FT:\n\t\tsc->type = FE_TYPE_AT1700FT;\n\t\tsc->typestr = \"AT-1700FT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700AT:\n\t\tsc->type = FE_TYPE_AT1700AT;\n\t\tsc->typestr = \"AT-1700AT\";\n\t\tbreak;\n\tdefault:\n\t\tsc->type = FE_TYPE_RE2000;\n\t\tsc->typestr = \"unknown (RE-2000?)\";\n\t\tbreak;\n\t}\n\n\t/*\n\t * Try to determine IRQ settings.\n\t * Different models use different ranges of IRQs.\n\t */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_IRQ) >> FE_B19_IRQ_SHIFT;\n\tswitch (eeprom[FE_ATI_EEP_REVISION] & 0xf0) {\n\tcase 0x30:\n\t\tirq = irqmap[3][n];\n\t\tbreak;\n\tcase 0x10:\n\tcase 0x50:\n\t\tirq = irqmap[2][n];\n\t\tbreak;\n\tcase 0x40:\n\tcase 0x60:\n\t\tif (eeprom[FE_ATI_EEP_MAGIC] & 0x04) {\n\t\t\tirq = irqmap[1][n];\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tirq = irqmap[0][n];\n\t\tbreak;\n\t}\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tbcopy(eeprom + FE_ATI_EEP_ADDR, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\tgoto fail;\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;  /* FIXME */\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n#if 0\t/* XXXX Should we use this? */\n\tsc->proto_bmpr13 = eeprom[FE_ATI_EEP_MEDIA];\n#else\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n#endif\n\n\t/*\n\t * Program the 86965 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ATI found\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Initialize 86965. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_probe_ati()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * That's all.  AT1700 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n\nfail:\n\t/* Restore register values, in the case we had no 86965. */\n\toutb(iobase + FE_BMPR16, save16);\n\toutb(iobase + FE_BMPR17, save17);\n\treturn (0);\n}"
  },
  {
    "function_name": "fe_probe_fmv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "430-597",
    "snippet": "int\nfe_probe_fmv(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x300, 0x340 };\n\tstatic int const irqmap[4] =\n\t\t{ 3, 7, 10, 15 };\n\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoesn't work. */\n\n\t\t{ FE_FMV0, FE_FMV0_MAGIC_MASK,  FE_FMV0_MAGIC_VALUE },\n\t\t{ FE_FMV1, FE_FMV1_CARDID_MASK, FE_FMV1_CARDID_ID   },\n\t\t{ FE_FMV3, FE_FMV3_EXTRA_MASK,  FE_FMV3_EXTRA_VALUE },\n#if 1\n\t/*\n\t * Test *vendor* part of the station address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects FMV-180 clone boards manufactured by other vendors.\n\t * We have to turn the test off when such cards are made available.\n\t */\n\t\t{ FE_FMV4, 0xFF, 0x00 },\n\t\t{ FE_FMV5, 0xFF, 0x00 },\n\t\t{ FE_FMV6, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"no multicast\" and \"no local\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_FMV4, 0x03, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Dont probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for FMV-180 series.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/* Simple probe. */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Check if our I/O address matches config info on EEPROM. */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_ADDR) >> FE_FMV2_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tswitch (inb(iobase + FE_FMV0) & FE_FMV0_MODEL) {\n\tcase FE_FMV0_MODEL_FMV181:\n\t\tsc->type = FE_TYPE_FMV181;\n\t\tsc->typestr = \"FMV-181\";\n\t\tbreak;\n\tcase FE_FMV0_MODEL_FMV182:\n\t\tsc->type = FE_TYPE_FMV182;\n\t\tsc->typestr = \"FMV-182\";\n\t\tbreak;\n\tdefault:\n\t  \t/* Unknown card type: maybe a new model, but... */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * An FMV-180 has successfully been proved.\n\t * Determine which IRQ to be used.\n\t *\n\t * In this version, we always get an IRQ assignment from the\n\t * FMV-180's configuration EEPROM, ignoring that specified in\n\t * config file.\n\t */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_IRQ) >> FE_FMV2_IRQ_SHIFT;\n\tirq = irqmap[n];\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_FMV4, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Register values which depend on board design. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/*\n\t * Minimum initialization of the hardware.\n\t * We write into registers; hope I/O ports have no\n\t * overlap with other boards.\n\t */\n\n\t/* Initialize ASIC. */\n\toutb(iobase + FE_FMV3, 0);\n\toutb(iobase + FE_FMV10, 0);\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Initialize 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n\t/* Turn the \"master interrupt control\" flag of ASIC on. */\n\toutb(iobase + FE_FMV3, FE_FMV3_ENABLE_FLAG);\n\n\t/*\n\t * That's all.  FMV-180 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
      "#define sc_enaddr\tsc_arpcom.ac_enaddr",
      "#define FE_FLAGS_PCMCIA\t\t0x8000"
    ],
    "globals_used": [
      "int\tfe_probe_fmv"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + FE_FMV3",
            "FE_FMV3_ENABLE_FLAG"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inblk",
          "args": [
            "iobase + FE_FMV4",
            "sc->sc_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "inblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "264-270",
          "snippet": "static inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: irq mismatch; kernel configured %d != board configured %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ia->ia_irq",
            "irq"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + FE_FMV2"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_simple_probe",
          "args": [
            "iobase",
            "probe_table"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fe_simple_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "320-331",
          "snippet": "static inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n\nint\tfe_probe_fmv;\n\nint\nfe_probe_fmv(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x300, 0x340 };\n\tstatic int const irqmap[4] =\n\t\t{ 3, 7, 10, 15 };\n\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoesn't work. */\n\n\t\t{ FE_FMV0, FE_FMV0_MAGIC_MASK,  FE_FMV0_MAGIC_VALUE },\n\t\t{ FE_FMV1, FE_FMV1_CARDID_MASK, FE_FMV1_CARDID_ID   },\n\t\t{ FE_FMV3, FE_FMV3_EXTRA_MASK,  FE_FMV3_EXTRA_VALUE },\n#if 1\n\t/*\n\t * Test *vendor* part of the station address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects FMV-180 clone boards manufactured by other vendors.\n\t * We have to turn the test off when such cards are made available.\n\t */\n\t\t{ FE_FMV4, 0xFF, 0x00 },\n\t\t{ FE_FMV5, 0xFF, 0x00 },\n\t\t{ FE_FMV6, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"no multicast\" and \"no local\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_FMV4, 0x03, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Dont probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for FMV-180 series.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/* Simple probe. */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Check if our I/O address matches config info on EEPROM. */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_ADDR) >> FE_FMV2_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tswitch (inb(iobase + FE_FMV0) & FE_FMV0_MODEL) {\n\tcase FE_FMV0_MODEL_FMV181:\n\t\tsc->type = FE_TYPE_FMV181;\n\t\tsc->typestr = \"FMV-181\";\n\t\tbreak;\n\tcase FE_FMV0_MODEL_FMV182:\n\t\tsc->type = FE_TYPE_FMV182;\n\t\tsc->typestr = \"FMV-182\";\n\t\tbreak;\n\tdefault:\n\t  \t/* Unknown card type: maybe a new model, but... */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * An FMV-180 has successfully been proved.\n\t * Determine which IRQ to be used.\n\t *\n\t * In this version, we always get an IRQ assignment from the\n\t * FMV-180's configuration EEPROM, ignoring that specified in\n\t * config file.\n\t */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_IRQ) >> FE_FMV2_IRQ_SHIFT;\n\tirq = irqmap[n];\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_FMV4, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Register values which depend on board design. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/*\n\t * Minimum initialization of the hardware.\n\t * We write into registers; hope I/O ports have no\n\t * overlap with other boards.\n\t */\n\n\t/* Initialize ASIC. */\n\toutb(iobase + FE_FMV3, 0);\n\toutb(iobase + FE_FMV10, 0);\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Initialize 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n\t/* Turn the \"master interrupt control\" flag of ASIC on. */\n\toutb(iobase + FE_FMV3, FE_FMV3_ENABLE_FLAG);\n\n\t/*\n\t * That's all.  FMV-180 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}"
  },
  {
    "function_name": "fe_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "355-421",
    "snippet": "void\nfe_read_eeprom(sc, data)\n\tstruct fe_softc *sc;\n\tu_char *data;\n{\n\tint iobase = sc->sc_iobase;\n\tint bmpr16 = iobase + FE_BMPR16;\n\tint bmpr17 = iobase + FE_BMPR17;\n\tu_char n, val, bit;\n\n\t/* Read bytes from EEPROM; two bytes per an iterration. */\n\tfor (n = 0; n < FE_EEPROM_SIZE / 2; n++) {\n\t\t/* Reset the EEPROM interface. */\n\t\toutb(bmpr16, 0x00);\n\t\toutb(bmpr17, 0x00);\n\t\toutb(bmpr16, FE_B16_SELECT);\n\n\t\t/* Start EEPROM access. */\n\t\toutb(bmpr17, FE_B17_DATA);\n\t\tstrobe(bmpr16);\n\n\t\t/* Pass the iterration count to the chip. */\n\t\tval = 0x80 | n;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\toutb(bmpr17, (val & bit) ? FE_B17_DATA : 0);\n\t\t\tstrobe(bmpr16);\n\t\t}\n\t\toutb(bmpr17, 0x00);\n\n\t\t/* Read a byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\n\t\t/* Read one more byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\t}\n\n#if FE_DEBUG >= 3\n\t/* Report what we got. */\n\tdata -= FE_EEPROM_SIZE;\n\tlog(LOG_INFO, \"%s: EEPROM at %04x:\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t    sc->sc_dev.dv_xname, iobase,\n\t    data[ 0], data[ 1], data[ 2], data[ 3],\n\t    data[ 4], data[ 5], data[ 6], data[ 7],\n\t    data[ 8], data[ 9], data[10], data[11],\n\t    data[12], data[13], data[14], data[15],\n\t    data[16], data[17], data[18], data[19],\n\t    data[20], data[21], data[22], data[23],\n\t    data[24], data[25], data[26], data[27],\n\t    data[28], data[29], data[30], data[31]);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: EEPROM at %04x:\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x\\n\"",
            "sc->sc_dev.dv_xname",
            "iobase",
            "data[ 0]",
            "data[ 1]",
            "data[ 2]",
            "data[ 3]",
            "data[ 4]",
            "data[ 5]",
            "data[ 6]",
            "data[ 7]",
            "data[ 8]",
            "data[ 9]",
            "data[10]",
            "data[11]",
            "data[12]",
            "data[13]",
            "data[14]",
            "data[15]",
            "data[16]",
            "data[17]",
            "data[18]",
            "data[19]",
            "data[20]",
            "data[21]",
            "data[22]",
            "data[23]",
            "data[24]",
            "data[25]",
            "data[26]",
            "data[27]",
            "data[28]",
            "data[29]",
            "data[30]",
            "data[31]"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "bmpr17"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strobe",
          "args": [
            "bmpr16"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "strobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "341-353",
          "snippet": "static inline void\nstrobe (int bmpr16)\n{\n\t/*\n\t * Output same value twice.  To speed-down execution?\n\t */\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void\nstrobe (int bmpr16)\n{\n\t/*\n\t * Output same value twice.  To speed-down execution?\n\t */\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "bmpr17",
            "0x00"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nvoid\nfe_read_eeprom(sc, data)\n\tstruct fe_softc *sc;\n\tu_char *data;\n{\n\tint iobase = sc->sc_iobase;\n\tint bmpr16 = iobase + FE_BMPR16;\n\tint bmpr17 = iobase + FE_BMPR17;\n\tu_char n, val, bit;\n\n\t/* Read bytes from EEPROM; two bytes per an iterration. */\n\tfor (n = 0; n < FE_EEPROM_SIZE / 2; n++) {\n\t\t/* Reset the EEPROM interface. */\n\t\toutb(bmpr16, 0x00);\n\t\toutb(bmpr17, 0x00);\n\t\toutb(bmpr16, FE_B16_SELECT);\n\n\t\t/* Start EEPROM access. */\n\t\toutb(bmpr17, FE_B17_DATA);\n\t\tstrobe(bmpr16);\n\n\t\t/* Pass the iterration count to the chip. */\n\t\tval = 0x80 | n;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\toutb(bmpr17, (val & bit) ? FE_B17_DATA : 0);\n\t\t\tstrobe(bmpr16);\n\t\t}\n\t\toutb(bmpr17, 0x00);\n\n\t\t/* Read a byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\n\t\t/* Read one more byte. */\n\t\tval = 0;\n\t\tfor (bit = 0x80; bit != 0x00; bit >>= 1) {\n\t\t\tstrobe(bmpr16);\n\t\t\tif (inb(bmpr17) & FE_B17_DATA)\n\t\t\t\tval |= bit;\n\t\t}\n\t\t*data++ = val;\n\t}\n\n#if FE_DEBUG >= 3\n\t/* Report what we got. */\n\tdata -= FE_EEPROM_SIZE;\n\tlog(LOG_INFO, \"%s: EEPROM at %04x:\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x -\"\n\t    \" %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t    sc->sc_dev.dv_xname, iobase,\n\t    data[ 0], data[ 1], data[ 2], data[ 3],\n\t    data[ 4], data[ 5], data[ 6], data[ 7],\n\t    data[ 8], data[ 9], data[10], data[11],\n\t    data[12], data[13], data[14], data[15],\n\t    data[16], data[17], data[18], data[19],\n\t    data[20], data[21], data[22], data[23],\n\t    data[24], data[25], data[26], data[27],\n\t    data[28], data[29], data[30], data[31]);\n#endif\n}"
  },
  {
    "function_name": "strobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "341-353",
    "snippet": "static inline void\nstrobe (int bmpr16)\n{\n\t/*\n\t * Output same value twice.  To speed-down execution?\n\t */\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "bmpr16",
            "FE_B16_SELECT"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void\nstrobe (int bmpr16)\n{\n\t/*\n\t * Output same value twice.  To speed-down execution?\n\t */\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT | FE_B16_CLOCK);\n\toutb(bmpr16, FE_B16_SELECT);\n\toutb(bmpr16, FE_B16_SELECT);\n}"
  },
  {
    "function_name": "fe_simple_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "320-331",
    "snippet": "static inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "addr + p->port"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nfe_simple_probe (int addr, struct fe_simple_probe_struct const * sp)\n{\n\tstruct fe_simple_probe_struct const * p;\n\n\tfor (p = sp; p->mask != 0; p++) {\n\t\tif ((inb(addr + p->port) & p->mask) != p->bits) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "feprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "287-309",
    "snippet": "int\nfeprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct fe_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n#if FE_DEBUG >= 2\n\tlog(LOG_INFO, \"%s: %s\\n\", sc->sc_dev.dv_xname, fe_version);\n#endif\n\n\t/* Probe an address. */\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (fe_probe_fmv(sc, ia))\n\t\treturn (1);\n\tif (fe_probe_ati(sc, ia))\n\t\treturn (1);\n\tif (fe_probe_mbh(sc, ia))\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FE_DEBUG\t\t1"
    ],
    "globals_used": [
      "static char const fe_version[] = FE_VERSION \" / \" FE_REG_VERSION;",
      "int\tfeprobe",
      "int\tfe_probe_fmv",
      "int\tfe_probe_ati",
      "int\tfe_probe_mbh"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fe_probe_mbh",
          "args": [
            "sc",
            "ia"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "fe_probe_mbh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "822-955",
          "snippet": "int\nfe_probe_mbh(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint iobase = sc->sc_iobase;\n\n\tstatic struct fe_simple_probe_struct probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoes not work well. */\n#if 0\n\t/*\n\t * Test *vendor* part of the address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects clones by other vendors, or OEM product\n\t * supplied by resalers other than Fujitsu.\n\t */\n\t\t{ FE_MBH10, 0xFF, 0x00 },\n\t\t{ FE_MBH11, 0xFF, 0x00 },\n\t\t{ FE_MBH12, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"global\" and \"unicast\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_MBH10, 0x03, 0x00 },\n#endif\n        /* Just a gap?  Seems reliable, anyway. */\n\t\t{ 0x12, 0xFF, 0x00 },\n\t\t{ 0x13, 0xFF, 0x00 },\n\t\t{ 0x14, 0xFF, 0x00 },\n\t\t{ 0x15, 0xFF, 0x00 },\n\t\t{ 0x16, 0xFF, 0x00 },\n\t\t{ 0x17, 0xFF, 0x00 },\n\t\t{ 0x18, 0xFF, 0xFF },\n\t\t{ 0x19, 0xFF, 0xFF },\n\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * We need a PCMCIA flag.\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) == 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * We need explicit IRQ and supported address.\n\t */\n\tif (ia->ia_irq == IRQUNK || (iobase & ~0x3E0) != 0)\n\t\treturn (0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_probe_mbh()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if MBH10302 is on its address.\n\t * I'm not sure the following probe code works.  FIXME.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tsc->type = FE_TYPE_MBH10302;\n\tsc->typestr = \"MBH10302 (PCMCIA)\";\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_MBH10, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_NICE;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/* Setup hooks.  We need a special initialization procedure. */\n\tsc->init = fe_init_mbh;\n\n\t/*\n\t * Minimum initialization.\n\t */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if 1\t/* FIXME. */\n\t/* Initialize system bus interface and encoder/decoder operation. */\n\toutb(iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_DISABLE);\n#endif\n\n\t/*\n\t * That's all.  MBH10302 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
            "#define sc_enaddr\tsc_arpcom.ac_enaddr",
            "#define FE_FLAGS_PCMCIA\t\t0x8000",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "int\tfe_probe_mbh",
            "void\tfe_init_mbh"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n#define FE_DEBUG\t\t1\n\nint\tfe_probe_mbh;\nvoid\tfe_init_mbh;\n\nint\nfe_probe_mbh(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint iobase = sc->sc_iobase;\n\n\tstatic struct fe_simple_probe_struct probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoes not work well. */\n#if 0\n\t/*\n\t * Test *vendor* part of the address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects clones by other vendors, or OEM product\n\t * supplied by resalers other than Fujitsu.\n\t */\n\t\t{ FE_MBH10, 0xFF, 0x00 },\n\t\t{ FE_MBH11, 0xFF, 0x00 },\n\t\t{ FE_MBH12, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"global\" and \"unicast\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_MBH10, 0x03, 0x00 },\n#endif\n        /* Just a gap?  Seems reliable, anyway. */\n\t\t{ 0x12, 0xFF, 0x00 },\n\t\t{ 0x13, 0xFF, 0x00 },\n\t\t{ 0x14, 0xFF, 0x00 },\n\t\t{ 0x15, 0xFF, 0x00 },\n\t\t{ 0x16, 0xFF, 0x00 },\n\t\t{ 0x17, 0xFF, 0x00 },\n\t\t{ 0x18, 0xFF, 0xFF },\n\t\t{ 0x19, 0xFF, 0xFF },\n\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * We need a PCMCIA flag.\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) == 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * We need explicit IRQ and supported address.\n\t */\n\tif (ia->ia_irq == IRQUNK || (iobase & ~0x3E0) != 0)\n\t\treturn (0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: top of fe_probe_mbh()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if MBH10302 is on its address.\n\t * I'm not sure the following probe code works.  FIXME.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tsc->type = FE_TYPE_MBH10302;\n\tsc->typestr = \"MBH10302 (PCMCIA)\";\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_MBH10, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_NICE;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/* Setup hooks.  We need a special initialization procedure. */\n\tsc->init = fe_init_mbh;\n\n\t/*\n\t * Minimum initialization.\n\t */\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Minimul initialization of 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if 1\t/* FIXME. */\n\t/* Initialize system bus interface and encoder/decoder operation. */\n\toutb(iobase + FE_MBH0, FE_MBH0_MAGIC | FE_MBH0_INTR_DISABLE);\n#endif\n\n\t/*\n\t * That's all.  MBH10302 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_probe_ati",
          "args": [
            "sc",
            "ia"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "fe_probe_ati",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "602-817",
          "snippet": "int\nfe_probe_ati(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tu_char eeprom[FE_EEPROM_SIZE];\n\tu_char save16, save17;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x260, 0x280, 0x2A0, 0x240, 0x340, 0x320, 0x380, 0x300 };\n\tstatic int const irqmap[4][4] = {\n\t\t{  3,  4,  5,  9 },\n\t\t{ 10, 11, 12, 15 },\n\t\t{  3, 11,  5, 15 },\n\t\t{ 10, 11, 14, 15 },\n\t};\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2,  0x70, 0x00 },\n\t\t{ FE_DLCR4,  0x08, 0x00 },\n\t\t{ FE_DLCR5,  0x80, 0x00 },\n#if 0\n\t\t{ FE_BMPR16, 0x1B, 0x00 },\n\t\t{ FE_BMPR17, 0x7F, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Don't probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: probe (0x%x) for ATI\\n\", sc->sc_dev.dv_xname, iobase);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for MB86965A JLI mode.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/*\n\t * We should test if MB86965A is on the base address now.\n\t * Unfortunately, it is very hard to probe it reliably, since\n\t * we have no way to reset the chip under software control.\n\t * On cold boot, we could check the \"signature\" bit patterns\n\t * described in the Fujitsu document.  On warm boot, however,\n\t * we can predict almost nothing about register values.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Save old values of the registers. */\n\tsave16 = inb(iobase + FE_BMPR16);\n\tsave17 = inb(iobase + FE_BMPR17);\n\n\t/* Check if our I/O address matches config info on 86965. */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_ADDR) >> FE_B19_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\tgoto fail;\n\n\t/*\n\t * We are now almost sure we have an AT1700 at the given\n\t * address.  So, read EEPROM through 86965.  We have to write\n\t * into LSI registers to read from EEPROM.  I want to avoid it\n\t * at this stage, but I cannot test the presense of the chip\n\t * any further without reading EEPROM.  FIXME.\n\t */\n\tfe_read_eeprom(sc, eeprom);\n\n\t/* Make sure the EEPROM is turned off. */\n\toutb(iobase + FE_BMPR16, 0);\n\toutb(iobase + FE_BMPR17, 0);\n\n\t/* Make sure that config info in EEPROM and 86965 agree. */\n\tif (eeprom[FE_EEPROM_CONF] != inb(iobase + FE_BMPR19))\n\t\tgoto fail;\n\n\t/*\n\t * Determine the card type.\n\t */\n\tswitch (eeprom[FE_ATI_EEP_MODEL]) {\n\tcase FE_ATI_MODEL_AT1700T:\n\t\tsc->type = FE_TYPE_AT1700T;\n\t\tsc->typestr = \"AT-1700T\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700BT:\n\t\tsc->type = FE_TYPE_AT1700BT;\n\t\tsc->typestr = \"AT-1700BT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700FT:\n\t\tsc->type = FE_TYPE_AT1700FT;\n\t\tsc->typestr = \"AT-1700FT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700AT:\n\t\tsc->type = FE_TYPE_AT1700AT;\n\t\tsc->typestr = \"AT-1700AT\";\n\t\tbreak;\n\tdefault:\n\t\tsc->type = FE_TYPE_RE2000;\n\t\tsc->typestr = \"unknown (RE-2000?)\";\n\t\tbreak;\n\t}\n\n\t/*\n\t * Try to determine IRQ settings.\n\t * Different models use different ranges of IRQs.\n\t */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_IRQ) >> FE_B19_IRQ_SHIFT;\n\tswitch (eeprom[FE_ATI_EEP_REVISION] & 0xf0) {\n\tcase 0x30:\n\t\tirq = irqmap[3][n];\n\t\tbreak;\n\tcase 0x10:\n\tcase 0x50:\n\t\tirq = irqmap[2][n];\n\t\tbreak;\n\tcase 0x40:\n\tcase 0x60:\n\t\tif (eeprom[FE_ATI_EEP_MAGIC] & 0x04) {\n\t\t\tirq = irqmap[1][n];\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tirq = irqmap[0][n];\n\t\tbreak;\n\t}\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tbcopy(eeprom + FE_ATI_EEP_ADDR, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\tgoto fail;\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;  /* FIXME */\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n#if 0\t/* XXXX Should we use this? */\n\tsc->proto_bmpr13 = eeprom[FE_ATI_EEP_MEDIA];\n#else\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n#endif\n\n\t/*\n\t * Program the 86965 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ATI found\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Initialize 86965. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_probe_ati()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * That's all.  AT1700 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n\nfail:\n\t/* Restore register values, in the case we had no 86965. */\n\toutb(iobase + FE_BMPR16, save16);\n\toutb(iobase + FE_BMPR17, save17);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
            "#define sc_enaddr\tsc_arpcom.ac_enaddr",
            "#define FE_FLAGS_PCMCIA\t\t0x8000",
            "#define FE_DEBUG\t\t1"
          ],
          "globals_used": [
            "int\tfe_probe_ati",
            "__P((/*struct fe_softc *, u_char*/));",
            "__P((/*struct fe_softc *, u_char*/));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n#define FE_DEBUG\t\t1\n\nint\tfe_probe_ati;\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nint\nfe_probe_ati(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tu_char eeprom[FE_EEPROM_SIZE];\n\tu_char save16, save17;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x260, 0x280, 0x2A0, 0x240, 0x340, 0x320, 0x380, 0x300 };\n\tstatic int const irqmap[4][4] = {\n\t\t{  3,  4,  5,  9 },\n\t\t{ 10, 11, 12, 15 },\n\t\t{  3, 11,  5, 15 },\n\t\t{ 10, 11, 14, 15 },\n\t};\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2,  0x70, 0x00 },\n\t\t{ FE_DLCR4,  0x08, 0x00 },\n\t\t{ FE_DLCR5,  0x80, 0x00 },\n#if 0\n\t\t{ FE_BMPR16, 0x1B, 0x00 },\n\t\t{ FE_BMPR17, 0x7F, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Don't probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n#if FE_DEBUG >= 4\n\tlog(LOG_INFO, \"%s: probe (0x%x) for ATI\\n\", sc->sc_dev.dv_xname, iobase);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for MB86965A JLI mode.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/*\n\t * We should test if MB86965A is on the base address now.\n\t * Unfortunately, it is very hard to probe it reliably, since\n\t * we have no way to reset the chip under software control.\n\t * On cold boot, we could check the \"signature\" bit patterns\n\t * described in the Fujitsu document.  On warm boot, however,\n\t * we can predict almost nothing about register values.\n\t */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Save old values of the registers. */\n\tsave16 = inb(iobase + FE_BMPR16);\n\tsave17 = inb(iobase + FE_BMPR17);\n\n\t/* Check if our I/O address matches config info on 86965. */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_ADDR) >> FE_B19_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\tgoto fail;\n\n\t/*\n\t * We are now almost sure we have an AT1700 at the given\n\t * address.  So, read EEPROM through 86965.  We have to write\n\t * into LSI registers to read from EEPROM.  I want to avoid it\n\t * at this stage, but I cannot test the presense of the chip\n\t * any further without reading EEPROM.  FIXME.\n\t */\n\tfe_read_eeprom(sc, eeprom);\n\n\t/* Make sure the EEPROM is turned off. */\n\toutb(iobase + FE_BMPR16, 0);\n\toutb(iobase + FE_BMPR17, 0);\n\n\t/* Make sure that config info in EEPROM and 86965 agree. */\n\tif (eeprom[FE_EEPROM_CONF] != inb(iobase + FE_BMPR19))\n\t\tgoto fail;\n\n\t/*\n\t * Determine the card type.\n\t */\n\tswitch (eeprom[FE_ATI_EEP_MODEL]) {\n\tcase FE_ATI_MODEL_AT1700T:\n\t\tsc->type = FE_TYPE_AT1700T;\n\t\tsc->typestr = \"AT-1700T\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700BT:\n\t\tsc->type = FE_TYPE_AT1700BT;\n\t\tsc->typestr = \"AT-1700BT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700FT:\n\t\tsc->type = FE_TYPE_AT1700FT;\n\t\tsc->typestr = \"AT-1700FT\";\n\t\tbreak;\n\tcase FE_ATI_MODEL_AT1700AT:\n\t\tsc->type = FE_TYPE_AT1700AT;\n\t\tsc->typestr = \"AT-1700AT\";\n\t\tbreak;\n\tdefault:\n\t\tsc->type = FE_TYPE_RE2000;\n\t\tsc->typestr = \"unknown (RE-2000?)\";\n\t\tbreak;\n\t}\n\n\t/*\n\t * Try to determine IRQ settings.\n\t * Different models use different ranges of IRQs.\n\t */\n\tn = (inb(iobase + FE_BMPR19) & FE_B19_IRQ) >> FE_B19_IRQ_SHIFT;\n\tswitch (eeprom[FE_ATI_EEP_REVISION] & 0xf0) {\n\tcase 0x30:\n\t\tirq = irqmap[3][n];\n\t\tbreak;\n\tcase 0x10:\n\tcase 0x50:\n\t\tirq = irqmap[2][n];\n\t\tbreak;\n\tcase 0x40:\n\tcase 0x60:\n\t\tif (eeprom[FE_ATI_EEP_MAGIC] & 0x04) {\n\t\t\tirq = irqmap[1][n];\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tirq = irqmap[0][n];\n\t\tbreak;\n\t}\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tbcopy(eeprom + FE_ATI_EEP_ADDR, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\tgoto fail;\n\n\t/* Should find all register prototypes here.  FIXME. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;  /* FIXME */\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n#if 0\t/* XXXX Should we use this? */\n\tsc->proto_bmpr13 = eeprom[FE_ATI_EEP_MEDIA];\n#else\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n#endif\n\n\t/*\n\t * Program the 86965 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: ATI found\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/* Initialize 86965. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n#if FE_DEBUG >= 3\n\tlog(LOG_INFO, \"%s: end of fe_probe_ati()\\n\", sc->sc_dev.dv_xname);\n\tfe_dump(LOG_INFO, sc);\n#endif\n\n\t/*\n\t * That's all.  AT1700 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n\nfail:\n\t/* Restore register values, in the case we had no 86965. */\n\toutb(iobase + FE_BMPR16, save16);\n\toutb(iobase + FE_BMPR17, save17);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fe_probe_fmv",
          "args": [
            "sc",
            "ia"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "fe_probe_fmv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
          "lines": "430-597",
          "snippet": "int\nfe_probe_fmv(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x300, 0x340 };\n\tstatic int const irqmap[4] =\n\t\t{ 3, 7, 10, 15 };\n\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoesn't work. */\n\n\t\t{ FE_FMV0, FE_FMV0_MAGIC_MASK,  FE_FMV0_MAGIC_VALUE },\n\t\t{ FE_FMV1, FE_FMV1_CARDID_MASK, FE_FMV1_CARDID_ID   },\n\t\t{ FE_FMV3, FE_FMV3_EXTRA_MASK,  FE_FMV3_EXTRA_VALUE },\n#if 1\n\t/*\n\t * Test *vendor* part of the station address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects FMV-180 clone boards manufactured by other vendors.\n\t * We have to turn the test off when such cards are made available.\n\t */\n\t\t{ FE_FMV4, 0xFF, 0x00 },\n\t\t{ FE_FMV5, 0xFF, 0x00 },\n\t\t{ FE_FMV6, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"no multicast\" and \"no local\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_FMV4, 0x03, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Dont probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for FMV-180 series.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/* Simple probe. */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Check if our I/O address matches config info on EEPROM. */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_ADDR) >> FE_FMV2_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tswitch (inb(iobase + FE_FMV0) & FE_FMV0_MODEL) {\n\tcase FE_FMV0_MODEL_FMV181:\n\t\tsc->type = FE_TYPE_FMV181;\n\t\tsc->typestr = \"FMV-181\";\n\t\tbreak;\n\tcase FE_FMV0_MODEL_FMV182:\n\t\tsc->type = FE_TYPE_FMV182;\n\t\tsc->typestr = \"FMV-182\";\n\t\tbreak;\n\tdefault:\n\t  \t/* Unknown card type: maybe a new model, but... */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * An FMV-180 has successfully been proved.\n\t * Determine which IRQ to be used.\n\t *\n\t * In this version, we always get an IRQ assignment from the\n\t * FMV-180's configuration EEPROM, ignoring that specified in\n\t * config file.\n\t */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_IRQ) >> FE_FMV2_IRQ_SHIFT;\n\tirq = irqmap[n];\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_FMV4, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Register values which depend on board design. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/*\n\t * Minimum initialization of the hardware.\n\t * We write into registers; hope I/O ports have no\n\t * overlap with other boards.\n\t */\n\n\t/* Initialize ASIC. */\n\toutb(iobase + FE_FMV3, 0);\n\toutb(iobase + FE_FMV10, 0);\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Initialize 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n\t/* Turn the \"master interrupt control\" flag of ASIC on. */\n\toutb(iobase + FE_FMV3, FE_FMV3_ENABLE_FLAG);\n\n\t/*\n\t * That's all.  FMV-180 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/if_fereg.h>",
            "#include <dev/ic/mb86960reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */",
            "#define sc_enaddr\tsc_arpcom.ac_enaddr",
            "#define FE_FLAGS_PCMCIA\t\t0x8000"
          ],
          "globals_used": [
            "int\tfe_probe_fmv"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define ETHER_ADDR_LEN\t6\t/* number of bytes in an address. */\n#define sc_enaddr\tsc_arpcom.ac_enaddr\n#define FE_FLAGS_PCMCIA\t\t0x8000\n\nint\tfe_probe_fmv;\n\nint\nfe_probe_fmv(sc, ia)\n\tstruct fe_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n\tint i, n;\n\tint iobase = sc->sc_iobase;\n\tint irq;\n\n\tstatic int const iomap[8] =\n\t\t{ 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x300, 0x340 };\n\tstatic int const irqmap[4] =\n\t\t{ 3, 7, 10, 15 };\n\n\tstatic struct fe_simple_probe_struct const probe_table[] = {\n\t\t{ FE_DLCR2, 0x70, 0x00 },\n\t\t{ FE_DLCR4, 0x08, 0x00 },\n\t    /*\t{ FE_DLCR5, 0x80, 0x00 },\tDoesn't work. */\n\n\t\t{ FE_FMV0, FE_FMV0_MAGIC_MASK,  FE_FMV0_MAGIC_VALUE },\n\t\t{ FE_FMV1, FE_FMV1_CARDID_MASK, FE_FMV1_CARDID_ID   },\n\t\t{ FE_FMV3, FE_FMV3_EXTRA_MASK,  FE_FMV3_EXTRA_VALUE },\n#if 1\n\t/*\n\t * Test *vendor* part of the station address for Fujitsu.\n\t * The test will gain reliability of probe process, but\n\t * it rejects FMV-180 clone boards manufactured by other vendors.\n\t * We have to turn the test off when such cards are made available.\n\t */\n\t\t{ FE_FMV4, 0xFF, 0x00 },\n\t\t{ FE_FMV5, 0xFF, 0x00 },\n\t\t{ FE_FMV6, 0xFF, 0x0E },\n#else\n\t/*\n\t * We can always verify the *first* 2 bits (in Ehternet\n\t * bit order) are \"no multicast\" and \"no local\" even for\n\t * unknown vendors.\n\t */\n\t\t{ FE_FMV4, 0x03, 0x00 },\n#endif\n\t\t{ 0 }\n\t};\n\n#if 0\n\t/*\n\t * Dont probe at all if the config says we are PCMCIA...\n\t */\n\tif ((cf->cf_flags & FE_FLAGS_PCMCIA) != 0)\n\t\treturn (0);\n#endif\n\n\t/*\n\t * See if the sepcified address is possible for FMV-180 series.\n\t */\n\tfor (i = 0; i < 8; i++) {\n\t\tif (iomap[i] == iobase)\n\t\t\tbreak;\n\t}\n\tif (i == 8)\n\t\treturn (0);\n\n\t/* Simple probe. */\n\tif (!fe_simple_probe(iobase, probe_table))\n\t\treturn (0);\n\n\t/* Check if our I/O address matches config info on EEPROM. */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_ADDR) >> FE_FMV2_ADDR_SHIFT;\n\tif (iomap[n] != iobase)\n\t\treturn (0);\n\n\t/* Determine the card type. */\n\tswitch (inb(iobase + FE_FMV0) & FE_FMV0_MODEL) {\n\tcase FE_FMV0_MODEL_FMV181:\n\t\tsc->type = FE_TYPE_FMV181;\n\t\tsc->typestr = \"FMV-181\";\n\t\tbreak;\n\tcase FE_FMV0_MODEL_FMV182:\n\t\tsc->type = FE_TYPE_FMV182;\n\t\tsc->typestr = \"FMV-182\";\n\t\tbreak;\n\tdefault:\n\t  \t/* Unknown card type: maybe a new model, but... */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * An FMV-180 has successfully been proved.\n\t * Determine which IRQ to be used.\n\t *\n\t * In this version, we always get an IRQ assignment from the\n\t * FMV-180's configuration EEPROM, ignoring that specified in\n\t * config file.\n\t */\n\tn = (inb(iobase + FE_FMV2) & FE_FMV2_IRQ) >> FE_FMV2_IRQ_SHIFT;\n\tirq = irqmap[n];\n\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != irq) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq, irq);\n\t\t\treturn (0);\n\t\t}\n\t} else\n\t\tia->ia_irq = irq;\n\n\t/*\n\t * Initialize constants in the per-line structure.\n\t */\n\n\t/* Get our station address from EEPROM. */\n\tinblk(iobase + FE_FMV4, sc->sc_enaddr, ETHER_ADDR_LEN);\n\n\t/* Make sure we got a valid station address. */\n\tif ((sc->sc_enaddr[0] & 0x03) != 0x00\n\t  || (sc->sc_enaddr[0] == 0x00\n\t    && sc->sc_enaddr[1] == 0x00\n\t    && sc->sc_enaddr[2] == 0x00))\n\t\treturn (0);\n\n\t/* Register values which depend on board design. */\n\tsc->proto_dlcr4 = FE_D4_LBC_DISABLE | FE_D4_CNTRL;\n\tsc->proto_dlcr5 = 0;\n\tsc->proto_dlcr7 = FE_D7_BYTSWP_LH | FE_D7_IDENT_EC;\n\tsc->proto_bmpr13 = FE_B13_TPTYPE_UTP | FE_B13_PORT_AUTO;\n\n\t/*\n\t * Program the 86960 as follows:\n\t *\tSRAM: 32KB, 100ns, byte-wide access.\n\t *\tTransmission buffer: 4KB x 2.\n\t *\tSystem bus interface: 16 bits.\n\t * We cannot change these values but TXBSIZE, because they\n\t * are hard-wired on the board.  Modifying TXBSIZE will affect\n\t * the driver performance.\n\t */\n\tsc->proto_dlcr6 = FE_D6_BUFSIZ_32KB | FE_D6_TXBSIZ_2x4KB\n\t\t| FE_D6_BBW_BYTE | FE_D6_SBW_WORD | FE_D6_SRAM_100ns;\n\n\t/*\n\t * Minimum initialization of the hardware.\n\t * We write into registers; hope I/O ports have no\n\t * overlap with other boards.\n\t */\n\n\t/* Initialize ASIC. */\n\toutb(iobase + FE_FMV3, 0);\n\toutb(iobase + FE_FMV10, 0);\n\n\t/* Wait for a while.  I'm not sure this is necessary.  FIXME. */\n\tdelay(200);\n\n\t/* Initialize 86960. */\n\toutb(iobase + FE_DLCR6, sc->proto_dlcr6 | FE_D6_DLC_DISABLE);\n\tdelay(200);\n\n\t/* Disable all interrupts. */\n\toutb(iobase + FE_DLCR2, 0);\n\toutb(iobase + FE_DLCR3, 0);\n\n\t/* Turn the \"master interrupt control\" flag of ASIC on. */\n\toutb(iobase + FE_FMV3, FE_FMV3_ENABLE_FLAG);\n\n\t/*\n\t * That's all.  FMV-180 occupies 32 I/O addresses, by the way.\n\t */\n\tia->ia_iosize = 32;\n\tia->ia_msize = 0;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_INFO",
            "\"%s: %s\\n\"",
            "sc->sc_dev.dv_xname",
            "fe_version"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FE_DEBUG\t\t1\n\nstatic char const fe_version[] = FE_VERSION \" / \" FE_REG_VERSION;\nint\tfeprobe;\nint\tfe_probe_fmv;\nint\tfe_probe_ati;\nint\tfe_probe_mbh;\n\nint\nfeprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct fe_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n#if FE_DEBUG >= 2\n\tlog(LOG_INFO, \"%s: %s\\n\", sc->sc_dev.dv_xname, fe_version);\n#endif\n\n\t/* Probe an address. */\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (fe_probe_fmv(sc, ia))\n\t\treturn (1);\n\tif (fe_probe_ati(sc, ia))\n\t\treturn (1);\n\tif (fe_probe_mbh(sc, ia))\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "outblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "272-278",
    "snippet": "static inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "addr++",
            "*mem++"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\noutblk (int addr, u_char const * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\toutb(addr++, *mem++);\n\t}\n}"
  },
  {
    "function_name": "inblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_fe.c",
    "lines": "264-270",
    "snippet": "static inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}",
    "includes": [
      "#include <dev/isa/if_fereg.h>",
      "#include <dev/ic/mb86960reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "__P((/*struct fe_softc *, u_char*/));",
      "__P((/*struct fe_softc *, u_char*/));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "addr++"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_fereg.h>\n#include <dev/ic/mb86960reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n__P((/*struct fe_softc *, u_char*/));\n__P((/*struct fe_softc *, u_char*/));\n\nstatic inline void\ninblk (int addr, u_char * mem, int len)\n{\n\twhile (--len >= 0) {\n\t\t*mem++ = inb(addr++);\n\t}\n}"
  }
]