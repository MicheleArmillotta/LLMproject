[
  {
    "function_name": "rf_PrintUserStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "975-1005",
    "snippet": "void \nrf_PrintUserStats(RF_Raid_t * raidPtr)\n{\n\tlong    elapsed_us, mbs, mbs_frac;\n\tstruct timeval diff;\n\n\tRF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);\n\telapsed_us = RF_TIMEVAL_TO_US(diff);\n\n\t/* 2000 sectors per megabyte, 10000000 microseconds per second */\n\tif (elapsed_us)\n\t\tmbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);\n\telse\n\t\tmbs = 0;\n\n\t/* this computes only the first digit of the fractional mb/s moved */\n\tif (elapsed_us) {\n\t\tmbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))\n\t\t    - (mbs * 10);\n\t} else {\n\t\tmbs_frac = 0;\n\t}\n\n\tprintf(\"Number of I/Os:             %ld\\n\", raidPtr->userstats.num_ios);\n\tprintf(\"Elapsed time (us):          %ld\\n\", elapsed_us);\n\tprintf(\"User I/Os per second:       %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));\n\tprintf(\"Average user response time: %ld us\\n\", RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));\n\tprintf(\"Total sectors moved:        %ld\\n\", raidPtr->userstats.num_sect_moved);\n\tprintf(\"Average access size (sect): %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));\n\tprintf(\"Achieved data rate:         %ld.%ld MB/sec\\n\", mbs, mbs_frac);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Achieved data rate:         %ld.%ld MB/sec\\n\"",
            "mbs",
            "mbs_frac"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_DB0_CHECK",
          "args": [
            "raidPtr->userstats.num_sect_moved",
            "raidPtr->userstats.num_ios"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DB0_CHECK",
          "args": [
            "raidPtr->userstats.sum_io_us",
            "raidPtr->userstats.num_ios"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DB0_CHECK",
          "args": [
            "raidPtr->userstats.num_ios",
            "(elapsed_us / 1000000)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_TO_US",
          "args": [
            "diff"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_DIFF",
          "args": [
            "&raidPtr->userstats.start",
            "&raidPtr->userstats.stop",
            "&diff"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_PrintUserStats(RF_Raid_t * raidPtr)\n{\n\tlong    elapsed_us, mbs, mbs_frac;\n\tstruct timeval diff;\n\n\tRF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);\n\telapsed_us = RF_TIMEVAL_TO_US(diff);\n\n\t/* 2000 sectors per megabyte, 10000000 microseconds per second */\n\tif (elapsed_us)\n\t\tmbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);\n\telse\n\t\tmbs = 0;\n\n\t/* this computes only the first digit of the fractional mb/s moved */\n\tif (elapsed_us) {\n\t\tmbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))\n\t\t    - (mbs * 10);\n\t} else {\n\t\tmbs_frac = 0;\n\t}\n\n\tprintf(\"Number of I/Os:             %ld\\n\", raidPtr->userstats.num_ios);\n\tprintf(\"Elapsed time (us):          %ld\\n\", elapsed_us);\n\tprintf(\"User I/Os per second:       %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));\n\tprintf(\"Average user response time: %ld us\\n\", RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));\n\tprintf(\"Total sectors moved:        %ld\\n\", raidPtr->userstats.num_sect_moved);\n\tprintf(\"Average access size (sect): %ld\\n\", RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));\n\tprintf(\"Achieved data rate:         %ld.%ld MB/sec\\n\", mbs, mbs_frac);\n}"
  },
  {
    "function_name": "rf_UpdateUserStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "964-973",
    "snippet": "void \nrf_UpdateUserStats(raidPtr, rt, numsect)\n\tRF_Raid_t *raidPtr;\n\tint     rt;\t\t/* resp time in us */\n\tint     numsect;\t/* number of sectors for this access */\n{\n\traidPtr->userstats.sum_io_us += rt;\n\traidPtr->userstats.num_ios++;\n\traidPtr->userstats.num_sect_moved += numsect;\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_UpdateUserStats(raidPtr, rt, numsect)\n\tRF_Raid_t *raidPtr;\n\tint     rt;\t\t/* resp time in us */\n\tint     numsect;\t/* number of sectors for this access */\n{\n\traidPtr->userstats.sum_io_us += rt;\n\traidPtr->userstats.num_ios++;\n\traidPtr->userstats.num_sect_moved += numsect;\n}"
  },
  {
    "function_name": "rf_StopUserStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "958-962",
    "snippet": "void \nrf_StopUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.stop);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "raidPtr->userstats.stop"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StopUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.stop);\n}"
  },
  {
    "function_name": "rf_StartUserStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "949-956",
    "snippet": "void \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "raidPtr->userstats.start"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}"
  },
  {
    "function_name": "rf_PrintThroughputStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "938-946",
    "snippet": "static void \nrf_PrintThroughputStats(RF_Raid_t * raidPtr)\n{\n\tRF_ASSERT(raidPtr->throughputstats.num_out_ios == 0);\n\tif (raidPtr->throughputstats.sum_io_us != 0) {\n\t\tprintf(\"[Througphut: %8.2f IOs/second]\\n\", raidPtr->throughputstats.num_ios\n\t\t    / (raidPtr->throughputstats.sum_io_us / 1000000.0));\n\t}\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"[Througphut: %8.2f IOs/second]\\n\"",
            "raidPtr->throughputstats.num_ios\n\t\t    / (raidPtr->throughputstats.sum_io_us / 1000000.0)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->throughputstats.num_out_ios == 0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nstatic void \nrf_PrintThroughputStats(RF_Raid_t * raidPtr)\n{\n\tRF_ASSERT(raidPtr->throughputstats.num_out_ios == 0);\n\tif (raidPtr->throughputstats.sum_io_us != 0) {\n\t\tprintf(\"[Througphut: %8.2f IOs/second]\\n\", raidPtr->throughputstats.num_ios\n\t\t    / (raidPtr->throughputstats.sum_io_us / 1000000.0));\n\t}\n}"
  },
  {
    "function_name": "rf_StopThroughputStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "923-936",
    "snippet": "static void \nrf_StopThroughputStats(RF_Raid_t * raidPtr)\n{\n\tstruct timeval diff;\n\n\tRF_LOCK_MUTEX(raidPtr->throughputstats.mutex);\n\traidPtr->throughputstats.num_out_ios--;\n\tif (raidPtr->throughputstats.num_out_ios == 0) {\n\t\tRF_GETTIME(raidPtr->throughputstats.stop);\n\t\tRF_TIMEVAL_DIFF(&raidPtr->throughputstats.start, &raidPtr->throughputstats.stop, &diff);\n\t\traidPtr->throughputstats.sum_io_us += RF_TIMEVAL_TO_US(diff);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->throughputstats.mutex"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_TO_US",
          "args": [
            "diff"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_TIMEVAL_DIFF",
          "args": [
            "&raidPtr->throughputstats.start",
            "&raidPtr->throughputstats.stop",
            "&diff"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "raidPtr->throughputstats.stop"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->throughputstats.mutex"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nstatic void \nrf_StopThroughputStats(RF_Raid_t * raidPtr)\n{\n\tstruct timeval diff;\n\n\tRF_LOCK_MUTEX(raidPtr->throughputstats.mutex);\n\traidPtr->throughputstats.num_out_ios--;\n\tif (raidPtr->throughputstats.num_out_ios == 0) {\n\t\tRF_GETTIME(raidPtr->throughputstats.stop);\n\t\tRF_TIMEVAL_DIFF(&raidPtr->throughputstats.start, &raidPtr->throughputstats.stop, &diff);\n\t\traidPtr->throughputstats.sum_io_us += RF_TIMEVAL_TO_US(diff);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);\n}"
  },
  {
    "function_name": "rf_StartThroughputStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "912-921",
    "snippet": "void \nrf_StartThroughputStats(RF_Raid_t * raidPtr)\n{\n\tRF_LOCK_MUTEX(raidPtr->throughputstats.mutex);\n\traidPtr->throughputstats.num_ios++;\n\traidPtr->throughputstats.num_out_ios++;\n\tif (raidPtr->throughputstats.num_out_ios == 1)\n\t\tRF_GETTIME(raidPtr->throughputstats.start);\n\tRF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->throughputstats.mutex"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_GETTIME",
          "args": [
            "raidPtr->throughputstats.start"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->throughputstats.mutex"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StartThroughputStats(RF_Raid_t * raidPtr)\n{\n\tRF_LOCK_MUTEX(raidPtr->throughputstats.mutex);\n\traidPtr->throughputstats.num_ios++;\n\traidPtr->throughputstats.num_out_ios++;\n\tif (raidPtr->throughputstats.num_out_ios == 1)\n\t\tRF_GETTIME(raidPtr->throughputstats.start);\n\tRF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);\n}"
  },
  {
    "function_name": "rf_InitThroughputStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "891-910",
    "snippet": "static int \nrf_InitThroughputStats(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\t/* these used by user-level raidframe only */\n\trc = rf_create_managed_mutex(listp, &raidPtr->throughputstats.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\traidPtr->throughputstats.sum_io_us = 0;\n\traidPtr->throughputstats.num_ios = 0;\n\traidPtr->throughputstats.num_out_ios = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_ConfigureDebug(RF_Config_t * cfgPtr);",
      "static int rf_ConfigureRDFreeList(RF_ShutdownList_t **);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "RF_DECLARE_STATIC_MUTEX(configureMutex)\t/* used to lock the configuration\n\t\t\t\t\t * stuff */\nstatic RF_ShutdownList_t",
      "static int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_mutex",
          "args": [
            "listp",
            "&raidPtr->throughputstats.mutex"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "69-90",
          "snippet": "int \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mutex_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void mutex_destroyer(void *);\n\nint \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_ConfigureDebug(RF_Config_t * cfgPtr);\nstatic int rf_ConfigureRDFreeList(RF_ShutdownList_t **);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nRF_DECLARE_STATIC_MUTEX(configureMutex)\t/* used to lock the configuration\n\t\t\t\t\t * stuff */\nstatic RF_ShutdownList_t;\nstatic int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);\n\nstatic int \nrf_InitThroughputStats(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\t/* these used by user-level raidframe only */\n\trc = rf_create_managed_mutex(listp, &raidPtr->throughputstats.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\traidPtr->throughputstats.sum_io_us = 0;\n\traidPtr->throughputstats.num_ios = 0;\n\traidPtr->throughputstats.num_out_ios = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ConfigureDebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "861-882",
    "snippet": "static void \nrf_ConfigureDebug(cfgPtr)\n\tRF_Config_t *cfgPtr;\n{\n\tchar   *val_p, *name_p, *white_p;\n\tlong    val;\n\tint     i;\n\n\trf_ResetDebugOptions();\n\tfor (i = 0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {\n\t\tname_p = rf_find_non_white(&cfgPtr->debugVars[i][0]);\n\t\twhite_p = rf_find_white(name_p);\t/* skip to start of 2nd\n\t\t\t\t\t\t\t * word */\n\t\tval_p = rf_find_non_white(white_p);\n\t\tif (*val_p == '0' && *(val_p + 1) == 'x')\n\t\t\tval = rf_htoi(val_p + 2);\n\t\telse\n\t\t\tval = rf_atoi(val_p);\n\t\t*white_p = '\\0';\n\t\tset_debug_option(name_p, val);\n\t}\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_ConfigureDebug(RF_Config_t * cfgPtr);",
      "static void set_debug_option(char *name, long val);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_debug_option",
          "args": [
            "name_p",
            "val"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "set_debug_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "841-856",
          "snippet": "static void \nset_debug_option(name, val)\n\tchar   *name;\n\tlong    val;\n{\n\tRF_DebugName_t *p;\n\n\tfor (p = rf_debugNames; p->name; p++) {\n\t\tif (!strcmp(p->name, name)) {\n\t\t\t*(p->ptr) = val;\n\t\t\tprintf(\"[Set debug variable %s to %ld]\\n\", name, val);\n\t\t\treturn;\n\t\t}\n\t}\n\tRF_ERRORMSG1(\"Unknown debug string \\\"%s\\\"\\n\", name);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_debug_option(char *name, long val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void set_debug_option(char *name, long val);\n\nstatic void \nset_debug_option(name, val)\n\tchar   *name;\n\tlong    val;\n{\n\tRF_DebugName_t *p;\n\n\tfor (p = rf_debugNames; p->name; p++) {\n\t\tif (!strcmp(p->name, name)) {\n\t\t\t*(p->ptr) = val;\n\t\t\tprintf(\"[Set debug variable %s to %ld]\\n\", name, val);\n\t\t\treturn;\n\t\t}\n\t}\n\tRF_ERRORMSG1(\"Unknown debug string \\\"%s\\\"\\n\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_atoi",
          "args": [
            "val_p"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "rf_atoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "124-137",
          "snippet": "int \nrf_atoi(p)\n\tchar   *p;\n{\n\tint     val = 0, negate = 0;\n\n\tif (*p == '-') {\n\t\tnegate = 1;\n\t\tp++;\n\t}\n\tfor (; ISDIGIT(*p); p++)\n\t\tval = 10 * val + (*p - '0');\n\treturn ((negate) ? -val : val);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_atoi(p)\n\tchar   *p;\n{\n\tint     val = 0, negate = 0;\n\n\tif (*p == '-') {\n\t\tnegate = 1;\n\t\tp++;\n\t}\n\tfor (; ISDIGIT(*p); p++)\n\t\tval = 10 * val + (*p - '0');\n\treturn ((negate) ? -val : val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_htoi",
          "args": [
            "val_p + 2"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rf_htoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "139-147",
          "snippet": "int \nrf_htoi(p)\n\tchar   *p;\n{\n\tint     val = 0;\n\tfor (; ISHEXCHAR(*p); p++)\n\t\tval = 16 * val + HC2INT(*p);\n\treturn (val);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_htoi(p)\n\tchar   *p;\n{\n\tint     val = 0;\n\tfor (; ISHEXCHAR(*p); p++)\n\t\tval = 16 * val + HC2INT(*p);\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_find_non_white",
          "args": [
            "white_p"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rf_find_non_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_strutils.c",
          "lines": "44-49",
          "snippet": "char   *\nrf_find_non_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p == ' ' || *p == '\\t'); p++);\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n\nchar   *\nrf_find_non_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p == ' ' || *p == '\\t'); p++);\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_find_white",
          "args": [
            "name_p"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "rf_find_white",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_strutils.c",
          "lines": "51-56",
          "snippet": "char   *\nrf_find_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p != ' ' && *p != '\\t'); p++);\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_utils.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n\nchar   *\nrf_find_white(char *p)\n{\n\tfor (; *p != '\\0' && (*p != ' ' && *p != '\\t'); p++);\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ResetDebugOptions",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ResetDebugOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_options.c",
          "lines": "72-76",
          "snippet": "void \nrf_ResetDebugOptions()\n{\n#include \"rf_optnames.h\"\n}",
          "includes": [
            "#include \"rf_optnames.h\"",
            "#include \"rf_optnames.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_archs.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_optnames.h\"\n#include \"rf_optnames.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_archs.h\"\n#include \"rf_types.h\"\n#include \"rf_threadstuff.h\"\n\nvoid \nrf_ResetDebugOptions()\n{\n#include \"rf_optnames.h\"\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_ConfigureDebug(RF_Config_t * cfgPtr);\nstatic void set_debug_option(char *name, long val);\n\nstatic void \nrf_ConfigureDebug(cfgPtr)\n\tRF_Config_t *cfgPtr;\n{\n\tchar   *val_p, *name_p, *white_p;\n\tlong    val;\n\tint     i;\n\n\trf_ResetDebugOptions();\n\tfor (i = 0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {\n\t\tname_p = rf_find_non_white(&cfgPtr->debugVars[i][0]);\n\t\twhite_p = rf_find_white(name_p);\t/* skip to start of 2nd\n\t\t\t\t\t\t\t * word */\n\t\tval_p = rf_find_non_white(white_p);\n\t\tif (*val_p == '0' && *(val_p + 1) == 'x')\n\t\t\tval = rf_htoi(val_p + 2);\n\t\telse\n\t\t\tval = rf_atoi(val_p);\n\t\t*white_p = '\\0';\n\t\tset_debug_option(name_p, val);\n\t}\n}"
  },
  {
    "function_name": "set_debug_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "841-856",
    "snippet": "static void \nset_debug_option(name, val)\n\tchar   *name;\n\tlong    val;\n{\n\tRF_DebugName_t *p;\n\n\tfor (p = rf_debugNames; p->name; p++) {\n\t\tif (!strcmp(p->name, name)) {\n\t\t\t*(p->ptr) = val;\n\t\t\tprintf(\"[Set debug variable %s to %ld]\\n\", name, val);\n\t\t\treturn;\n\t\t}\n\t}\n\tRF_ERRORMSG1(\"Unknown debug string \\\"%s\\\"\\n\", name);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_debug_option(char *name, long val);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Unknown debug string \\\"%s\\\"\\n\"",
            "name"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"[Set debug variable %s to %ld]\\n\"",
            "name",
            "val"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->name",
            "name"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void set_debug_option(char *name, long val);\n\nstatic void \nset_debug_option(name, val)\n\tchar   *name;\n\tlong    val;\n{\n\tRF_DebugName_t *p;\n\n\tfor (p = rf_debugNames; p->name; p++) {\n\t\tif (!strcmp(p->name, name)) {\n\t\t\t*(p->ptr) = val;\n\t\t\tprintf(\"[Set debug variable %s to %ld]\\n\", name, val);\n\t\t\treturn;\n\t\t}\n\t}\n\tRF_ERRORMSG1(\"Unknown debug string \\\"%s\\\"\\n\", name);\n}"
  },
  {
    "function_name": "rf_ResumeNewRequests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "810-834",
    "snippet": "void \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeCallbackDesc",
          "args": [
            "t"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeCallbackDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_callback.c",
          "lines": "89-94",
          "snippet": "void \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_callback_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_callback.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_callback_freelist;\n\nvoid \nrf_FreeCallbackDesc(p)\n\tRF_CallbackDesc_t *p;\n{\n\tRF_FREELIST_FREE(rf_callback_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "t->callbackArg"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->access_suspend_mutex"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->access_suspend_mutex"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Resuming new reqs\\n\""
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_ResumeNewRequests(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tRF_CallbackDesc_t *t, *cb;\n\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Resuming new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended--;\n\tif (raidPtr->accesses_suspended == 0)\n\t\tcb = raidPtr->quiesce_wait_list;\n\telse\n\t\tcb = NULL;\n\traidPtr->quiesce_wait_list = NULL;\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\n\twhile (cb) {\n\t\tt = cb;\n\t\tcb = cb->next;\n\t\t(t->callbackFunc) (t->callbackArg);\n\t\trf_FreeCallbackDesc(t);\n\t}\n}"
  },
  {
    "function_name": "rf_SuspendNewRequestsAndWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "785-808",
    "snippet": "int \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->access_suspend_mutex"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Quiesence reached..\\n\""
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WAIT_FOR_QUIESCENCE",
          "args": [
            "raidPtr"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->access_suspend_mutex"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_SuspendNewRequestsAndWait(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (rf_quiesceDebug)\n\t\tprintf(\"Suspending new reqs\\n\");\n\n\tRF_LOCK_MUTEX(raidPtr->access_suspend_mutex);\n\traidPtr->accesses_suspended++;\n\traidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\traidPtr->access_suspend_release = 0;\n\t\twhile (!raidPtr->access_suspend_release) {\n\t\t\tprintf(\"Suspending: Waiting for Quiesence\\n\");\n\t\t\tWAIT_FOR_QUIESCENCE(raidPtr);\n\t\t\traidPtr->waiting_for_quiescence = 0;\n\t\t}\n\t}\n\tprintf(\"Quiesence reached..\\n\");\n\n\tRF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);\n\treturn (raidPtr->waiting_for_quiescence);\n}"
  },
  {
    "function_name": "rf_SignalQuiescenceLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "769-783",
    "snippet": "void \nrf_SignalQuiescenceLock(raidPtr, reconDesc)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tif (rf_quiesceDebug) {\n\t\tprintf(\"raid%d: Signalling quiescence lock\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\traidPtr->access_suspend_release = 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\tSIGNAL_QUIESCENT_COND(raidPtr);\n\t}\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIGNAL_QUIESCENT_COND",
          "args": [
            "raidPtr"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Signalling quiescence lock\\n\"",
            "raidPtr->raidid"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_SignalQuiescenceLock(raidPtr, reconDesc)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidReconDesc_t *reconDesc;\n{\n\tif (rf_quiesceDebug) {\n\t\tprintf(\"raid%d: Signalling quiescence lock\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\traidPtr->access_suspend_release = 1;\n\n\tif (raidPtr->waiting_for_quiescence) {\n\t\tSIGNAL_QUIESCENT_COND(raidPtr);\n\t}\n}"
  },
  {
    "function_name": "rf_FailDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "749-765",
    "snippet": "int \nrf_FailDisk(\n    RF_Raid_t * raidPtr,\n    int frow,\n    int fcol,\n    int initRecon)\n{\n\tprintf(\"raid%d: Failing disk r%d c%d\\n\", raidPtr->raidid, frow, fcol);\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[frow][fcol].status = rf_ds_failed;\n\traidPtr->status[frow] = rf_rs_degraded;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (initRecon)\n\t\trf_ReconstructFailedDisk(raidPtr, frow, fcol);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ReconstructFailedDisk",
          "args": [
            "raidPtr",
            "frow",
            "fcol"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReconstructFailedDiskBasic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconstruct.c",
          "lines": "283-365",
          "snippet": "int \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_reconbuffer.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_reconutil.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include <sys/errno.h>",
            "#include <sys/buf.h>",
            "#include <sys/time.h>",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;",
            "RF_RowCol_t row;",
            "RF_RowCol_t col;",
            "RF_RaidDisk_t *spareDiskPtr;",
            "int     numDisksDone;",
            "RF_RowCol_t srow;",
            "RF_RowCol_t scol;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_reconbuffer.h\"\n#include \"rf_revent.h\"\n#include \"rf_reconutil.h\"\n#include \"rf_raid.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/buf.h>\n#include <sys/time.h>\n#include \"rf_types.h\"\n\nRF_RaidReconDesc_t *\nrf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)\n\tRF_Raid_t *raidPtr;\nRF_RowCol_t row;\nRF_RowCol_t col;\nRF_RaidDisk_t *spareDiskPtr;\nint     numDisksDone;\nRF_RowCol_t srow;\nRF_RowCol_t scol;\n\nint \nrf_ReconstructFailedDiskBasic(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tRF_RowCol_t row;\n\tRF_RowCol_t col;\n{\n\tRF_ComponentLabel_t c_label;\n\tRF_RaidDisk_t *spareDiskPtr = NULL;\n\tRF_RaidReconDesc_t *reconDesc;\n\tRF_RowCol_t srow, scol;\n\tint     numDisksDone = 0, rc;\n\n\t/* first look for a spare drive onto which to reconstruct the data */\n\t/* spare disk descriptors are stored in row 0.  This may have to\n\t * change eventually */\n\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tRF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);\n\n\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\tif (raidPtr->status[row] != rf_rs_degraded) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because status not degraded\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tsrow = row;\n\t\tscol = (-1);\n\t} else {\n\t\tsrow = 0;\n\t\tfor (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {\n\t\t\tif (raidPtr->Disks[srow][scol].status == rf_ds_spare) {\n\t\t\t\tspareDiskPtr = &raidPtr->Disks[srow][scol];\n\t\t\t\tspareDiskPtr->status = rf_ds_used_spare;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!spareDiskPtr) {\n\t\t\tRF_ERRORMSG2(\"Unable to reconstruct disk at row %d col %d because no spares are available\\n\", row, col);\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tprintf(\"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\\n\", row, col, srow, scol);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\n\treconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);\n\traidPtr->reconDesc = (void *) reconDesc;\n#if RF_RECON_STATS > 0\n\treconDesc->hsStallCount = 0;\n\treconDesc->numReconExecDelays = 0;\n\treconDesc->numReconEventWaits = 0;\n#endif\t\t\t\t/* RF_RECON_STATS > 0 */\n\treconDesc->reconExecTimerRunning = 0;\n\treconDesc->reconExecTicks = 0;\n\treconDesc->maxReconExecTicks = 0;\n\trc = rf_ContinueReconstructFailedDisk(reconDesc);\n\n\tif (!rc) {\n\t\t/* fix up the component label */\n\t\t/* Don't actually need the read here.. */\n\t\traidread_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\tc_label.serial_number = raidPtr->serial_number;\n\t\tc_label.row = row;\n\t\tc_label.column = col;\n\t\tc_label.num_rows = raidPtr->numRow;\n\t\tc_label.num_columns = raidPtr->numCol;\n\t\tc_label.clean = RF_RAID_DIRTY;\n\t\tc_label.status = rf_ds_optimal;\n\t\t\n\t\traidwrite_component_label(\n                        raidPtr->raid_cinfo[srow][scol].ci_dev,\n\t\t\traidPtr->raid_cinfo[srow][scol].ci_vp,\n\t\t\t&c_label);\n\t\t\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Failing disk r%d c%d\\n\"",
            "raidPtr->raidid",
            "frow",
            "fcol"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_FailDisk(\n    RF_Raid_t * raidPtr,\n    int frow,\n    int fcol,\n    int initRecon)\n{\n\tprintf(\"raid%d: Failing disk r%d c%d\\n\", raidPtr->raidid, frow, fcol);\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[frow][fcol].status = rf_ds_failed;\n\traidPtr->status[frow] = rf_rs_degraded;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (initRecon)\n\t\trf_ReconstructFailedDisk(raidPtr, frow, fcol);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_SetReconfiguredMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "724-744",
    "snippet": "int \nrf_SetReconfiguredMode(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tint     row;\n\tint     col;\n{\n\tif (!(raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tprintf(\"Can't set reconfigured mode in dedicated-spare array\\n\");\n\t\tRF_PANIC();\n\t}\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[row][col].status = rf_ds_dist_spared;\n\traidPtr->status[row] = rf_rs_reconfigured;\n\t/* install spare table only if declustering + distributed sparing\n\t * architecture. */\n\tif (raidPtr->Layout.map->flags & RF_BD_DECLUSTERED)\n\t\trf_InstallSpareTable(raidPtr, row, col);\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_InstallSpareTable",
          "args": [
            "raidPtr",
            "row",
            "col"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "rf_InstallSpareTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "654-678",
          "snippet": "int \nrf_InstallSpareTable(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t frow,\n    RF_RowCol_t fcol)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SparetWait_t *req;\n\tint     retcode;\n\n\tRF_Malloc(req, sizeof(*req), (RF_SparetWait_t *));\n\treq->C = raidPtr->numCol;\n\treq->G = raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol;\n\treq->fcol = fcol;\n\treq->SUsPerPU = raidPtr->Layout.SUsPerPU;\n\treq->TablesPerSpareRegion = info->TablesPerSpareRegion;\n\treq->BlocksPerTable = info->BlocksPerTable;\n\treq->TableDepthInPUs = info->TableDepthInPUs;\n\treq->SpareSpaceDepthPerRegionInSUs = info->SpareSpaceDepthPerRegionInSUs;\n\n\tretcode = rf_GetSpareTableFromDaemon(req);\n\tRF_ASSERT(!retcode);\t/* XXX -- fix this to recover gracefully --\n\t\t\t\t * XXX */\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int     rf_GetSpareTableFromDaemon(RF_SparetWait_t * req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint     rf_GetSpareTableFromDaemon(RF_SparetWait_t * req);\n\nint \nrf_InstallSpareTable(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t frow,\n    RF_RowCol_t fcol)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_SparetWait_t *req;\n\tint     retcode;\n\n\tRF_Malloc(req, sizeof(*req), (RF_SparetWait_t *));\n\treq->C = raidPtr->numCol;\n\treq->G = raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol;\n\treq->fcol = fcol;\n\treq->SUsPerPU = raidPtr->Layout.SUsPerPU;\n\treq->TablesPerSpareRegion = info->TablesPerSpareRegion;\n\treq->BlocksPerTable = info->BlocksPerTable;\n\treq->TableDepthInPUs = info->TableDepthInPUs;\n\treq->SpareSpaceDepthPerRegionInSUs = info->SpareSpaceDepthPerRegionInSUs;\n\n\tretcode = rf_GetSpareTableFromDaemon(req);\n\tRF_ASSERT(!retcode);\t/* XXX -- fix this to recover gracefully --\n\t\t\t\t * XXX */\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->mutex"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Can't set reconfigured mode in dedicated-spare array\\n\""
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_SetReconfiguredMode(raidPtr, row, col)\n\tRF_Raid_t *raidPtr;\n\tint     row;\n\tint     col;\n{\n\tif (!(raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tprintf(\"Can't set reconfigured mode in dedicated-spare array\\n\");\n\t\tRF_PANIC();\n\t}\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\traidPtr->numFailures++;\n\traidPtr->Disks[row][col].status = rf_ds_dist_spared;\n\traidPtr->status[row] = rf_rs_reconfigured;\n\t/* install spare table only if declustering + distributed sparing\n\t * architecture. */\n\tif (raidPtr->Layout.map->flags & RF_BD_DECLUSTERED)\n\t\trf_InstallSpareTable(raidPtr, row, col);\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DoAccess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "654-722",
    "snippet": "int \nrf_DoAccess(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    int async_flag,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp_in,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    RF_RaidAccessDesc_t ** paramDesc,\n    void (*cbF) (struct buf *),\n    void *cbA)\n/*\ntype should be read or write\nasync_flag should be RF_TRUE or RF_FALSE\nbp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel\n*/\n{\n\tRF_RaidAccessDesc_t *desc;\n\tcaddr_t lbufPtr = bufPtr;\n\tstruct buf *bp = (struct buf *) bp_in;\n\n\traidAddress += rf_raidSectorOffset;\n\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe driver not successfully configured.  Rejecting access.\\n\");\n\t\tIO_BUF_ERR(bp, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\n\tif (rf_accessDebug) {\n\n\t\tprintf(\"logBytes is: %d %d %d\\n\", raidPtr->raidid,\n\t\t    raidPtr->logBytesPerSector,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks));\n\t\tprintf(\"raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\\n\", raidPtr->raidid,\n\t\t    (type == RF_IO_TYPE_READ) ? \"READ\" : \"WRITE\", (int) raidAddress,\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress + numBlocks - 1),\n\t\t    (int) numBlocks,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks),\n\t\t    (long) bufPtr);\n\t}\n\tif (raidAddress + numBlocks > raidPtr->totalSectors) {\n\n\t\tprintf(\"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\\n\",\n\t\t    (u_long) raidAddress, (u_long) numBlocks, (u_long) raidPtr->totalSectors);\n\n\t\t\tIO_BUF_ERR(bp, ENOSPC);\n\t\t\treturn (ENOSPC);\n\t}\n\tdesc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,\n\t    numBlocks, lbufPtr, bp, paramDAG, paramASM,\n\t    flags, cbF, cbA, raidPtr->Layout.map->states);\n\n\tif (desc == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_ETIMER_START(desc->tracerec.tot_timer);\n\n\tdesc->async_flag = async_flag;\n\n\trf_ContinueRaidAccess(desc);\n\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ContinueRaidAccess",
          "args": [
            "desc"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ContinueRaidAccess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_states.c",
          "lines": "87-147",
          "snippet": "void \nrf_ContinueRaidAccess(RF_RaidAccessDesc_t * desc)\n{\n\tint     suspended = RF_FALSE;\n\tint     current_state_index = desc->state;\n\tRF_AccessState_t current_state = desc->states[current_state_index];\n\tint     unit = desc->raidPtr->raidid;\n\n\tdo {\n\n\t\tcurrent_state_index = desc->state;\n\t\tcurrent_state = desc->states[current_state_index];\n\n\t\tswitch (current_state) {\n\n\t\tcase rf_QuiesceState:\n\t\t\tsuspended = rf_State_Quiesce(desc);\n\t\t\tbreak;\n\t\tcase rf_IncrAccessesCountState:\n\t\t\tsuspended = rf_State_IncrAccessCount(desc);\n\t\t\tbreak;\n\t\tcase rf_MapState:\n\t\t\tsuspended = rf_State_Map(desc);\n\t\t\tbreak;\n\t\tcase rf_LockState:\n\t\t\tsuspended = rf_State_Lock(desc);\n\t\t\tbreak;\n\t\tcase rf_CreateDAGState:\n\t\t\tsuspended = rf_State_CreateDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_ExecuteDAGState:\n\t\t\tsuspended = rf_State_ExecuteDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_ProcessDAGState:\n\t\t\tsuspended = rf_State_ProcessDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_CleanupState:\n\t\t\tsuspended = rf_State_Cleanup(desc);\n\t\t\tbreak;\n\t\tcase rf_DecrAccessesCountState:\n\t\t\tsuspended = rf_State_DecrAccessCount(desc);\n\t\t\tbreak;\n\t\tcase rf_LastState:\n\t\t\tsuspended = rf_State_LastState(desc);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* after this point, we cannot dereference desc since desc may\n\t\t * have been freed. desc is only freed in LastState, so if we\n\t\t * renter this function or loop back up, desc should be valid. */\n\n\t\tif (rf_printStatesDebug) {\n\t\t\tprintf(\"raid%d: State: %-24s StateIndex: %3i desc: 0x%ld %s\\n\",\n\t\t\t       unit, StateName(current_state), \n\t\t\t       current_state_index, (long) desc,\n\t\t\t    suspended ? \"callback scheduled\" : \"looping\");\n\t\t}\n\t} while (!suspended && current_state != rf_LastState);\n\n\treturn;\n}",
          "includes": [
            "#include \"rf_kintf.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_kintf.h\"\n#include \"rf_etimer.h\"\n#include \"rf_map.h\"\n#include \"rf_engine.h\"\n#include \"rf_driver.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_states.h\"\n#include \"rf_general.h\"\n#include \"rf_aselect.h\"\n#include \"rf_desc.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/errno.h>\n\nvoid \nrf_ContinueRaidAccess(RF_RaidAccessDesc_t * desc)\n{\n\tint     suspended = RF_FALSE;\n\tint     current_state_index = desc->state;\n\tRF_AccessState_t current_state = desc->states[current_state_index];\n\tint     unit = desc->raidPtr->raidid;\n\n\tdo {\n\n\t\tcurrent_state_index = desc->state;\n\t\tcurrent_state = desc->states[current_state_index];\n\n\t\tswitch (current_state) {\n\n\t\tcase rf_QuiesceState:\n\t\t\tsuspended = rf_State_Quiesce(desc);\n\t\t\tbreak;\n\t\tcase rf_IncrAccessesCountState:\n\t\t\tsuspended = rf_State_IncrAccessCount(desc);\n\t\t\tbreak;\n\t\tcase rf_MapState:\n\t\t\tsuspended = rf_State_Map(desc);\n\t\t\tbreak;\n\t\tcase rf_LockState:\n\t\t\tsuspended = rf_State_Lock(desc);\n\t\t\tbreak;\n\t\tcase rf_CreateDAGState:\n\t\t\tsuspended = rf_State_CreateDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_ExecuteDAGState:\n\t\t\tsuspended = rf_State_ExecuteDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_ProcessDAGState:\n\t\t\tsuspended = rf_State_ProcessDAG(desc);\n\t\t\tbreak;\n\t\tcase rf_CleanupState:\n\t\t\tsuspended = rf_State_Cleanup(desc);\n\t\t\tbreak;\n\t\tcase rf_DecrAccessesCountState:\n\t\t\tsuspended = rf_State_DecrAccessCount(desc);\n\t\t\tbreak;\n\t\tcase rf_LastState:\n\t\t\tsuspended = rf_State_LastState(desc);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* after this point, we cannot dereference desc since desc may\n\t\t * have been freed. desc is only freed in LastState, so if we\n\t\t * renter this function or loop back up, desc should be valid. */\n\n\t\tif (rf_printStatesDebug) {\n\t\t\tprintf(\"raid%d: State: %-24s StateIndex: %3i desc: 0x%ld %s\\n\",\n\t\t\t       unit, StateName(current_state), \n\t\t\t       current_state_index, (long) desc,\n\t\t\t    suspended ? \"callback scheduled\" : \"looping\");\n\t\t}\n\t} while (!suspended && current_state != rf_LastState);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "desc->tracerec.tot_timer"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocRaidAccDesc",
          "args": [
            "raidPtr",
            "type",
            "raidAddress",
            "numBlocks",
            "lbufPtr",
            "bp",
            "paramDAG",
            "paramASM",
            "flags",
            "cbF",
            "cbA",
            "raidPtr->Layout.map->states"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocRaidAccDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "579-631",
          "snippet": "RF_RaidAccessDesc_t *\nrf_AllocRaidAccDesc(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    void (*cbF) (struct buf *),\n    void *cbA,\n    RF_AccessState_t * states)\n{\n\tRF_RaidAccessDesc_t *desc;\n\n\tRF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next, (RF_RaidAccessDesc_t *), init_rad);\n\tif (raidPtr->waitShutdown) {\n\t\t/*\n\t         * Actually, we're shutting the array down. Free the desc\n\t         * and return NULL.\n\t         */\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\tRF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next, clean_rad);\n\t\treturn (NULL);\n\t}\n\traidPtr->nAccOutstanding++;\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\tdesc->raidPtr = (void *) raidPtr;\n\tdesc->type = type;\n\tdesc->raidAddress = raidAddress;\n\tdesc->numBlocks = numBlocks;\n\tdesc->bufPtr = bufPtr;\n\tdesc->bp = bp;\n\tdesc->paramDAG = paramDAG;\n\tdesc->paramASM = paramASM;\n\tdesc->flags = flags;\n\tdesc->states = states;\n\tdesc->state = 0;\n\n\tdesc->status = 0;\n\tbzero((char *) &desc->tracerec, sizeof(RF_AccTraceEntry_t));\n\tdesc->callbackFunc = (void (*) (RF_CBParam_t)) cbF;\t/* XXX */\n\tdesc->callbackArg = cbA;\n\tdesc->next = NULL;\n\tdesc->head = desc;\n\tdesc->numPending = 0;\n\tdesc->cleanupList = NULL;\n\trf_MakeAllocList(desc->cleanupList);\n\treturn (desc);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_rad_freelist;",
            "static int init_rad(RF_RaidAccessDesc_t *);",
            "static void clean_rad(RF_RaidAccessDesc_t *);",
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nRF_RaidAccessDesc_t *\nrf_AllocRaidAccDesc(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    void (*cbF) (struct buf *),\n    void *cbA,\n    RF_AccessState_t * states)\n{\n\tRF_RaidAccessDesc_t *desc;\n\n\tRF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next, (RF_RaidAccessDesc_t *), init_rad);\n\tif (raidPtr->waitShutdown) {\n\t\t/*\n\t         * Actually, we're shutting the array down. Free the desc\n\t         * and return NULL.\n\t         */\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\tRF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next, clean_rad);\n\t\treturn (NULL);\n\t}\n\traidPtr->nAccOutstanding++;\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\tdesc->raidPtr = (void *) raidPtr;\n\tdesc->type = type;\n\tdesc->raidAddress = raidAddress;\n\tdesc->numBlocks = numBlocks;\n\tdesc->bufPtr = bufPtr;\n\tdesc->bp = bp;\n\tdesc->paramDAG = paramDAG;\n\tdesc->paramASM = paramASM;\n\tdesc->flags = flags;\n\tdesc->states = states;\n\tdesc->state = 0;\n\n\tdesc->status = 0;\n\tbzero((char *) &desc->tracerec, sizeof(RF_AccTraceEntry_t));\n\tdesc->callbackFunc = (void (*) (RF_CBParam_t)) cbF;\t/* XXX */\n\tdesc->callbackArg = cbA;\n\tdesc->next = NULL;\n\tdesc->head = desc;\n\tdesc->numPending = 0;\n\tdesc->cleanupList = NULL;\n\trf_MakeAllocList(desc->cleanupList);\n\treturn (desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IO_BUF_ERR",
          "args": [
            "bp",
            "ENOSPC"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\\n\"",
            "(u_long) raidAddress",
            "(u_long) numBlocks",
            "(u_long) raidPtr->totalSectors"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numBlocks"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeID",
          "args": [
            "&raidPtr->Layout",
            "raidAddress + numBlocks - 1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeID",
          "args": [
            "&raidPtr->Layout",
            "raidAddress"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numBlocks"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IO_BUF_ERR",
          "args": [
            "bp",
            "EINVAL"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"RAIDframe driver not successfully configured.  Rejecting access.\\n\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_DoAccess(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    int async_flag,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp_in,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    RF_RaidAccessDesc_t ** paramDesc,\n    void (*cbF) (struct buf *),\n    void *cbA)\n/*\ntype should be read or write\nasync_flag should be RF_TRUE or RF_FALSE\nbp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel\n*/\n{\n\tRF_RaidAccessDesc_t *desc;\n\tcaddr_t lbufPtr = bufPtr;\n\tstruct buf *bp = (struct buf *) bp_in;\n\n\traidAddress += rf_raidSectorOffset;\n\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe driver not successfully configured.  Rejecting access.\\n\");\n\t\tIO_BUF_ERR(bp, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\n\tif (rf_accessDebug) {\n\n\t\tprintf(\"logBytes is: %d %d %d\\n\", raidPtr->raidid,\n\t\t    raidPtr->logBytesPerSector,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks));\n\t\tprintf(\"raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\\n\", raidPtr->raidid,\n\t\t    (type == RF_IO_TYPE_READ) ? \"READ\" : \"WRITE\", (int) raidAddress,\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),\n\t\t    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress + numBlocks - 1),\n\t\t    (int) numBlocks,\n\t\t    (int) rf_RaidAddressToByte(raidPtr, numBlocks),\n\t\t    (long) bufPtr);\n\t}\n\tif (raidAddress + numBlocks > raidPtr->totalSectors) {\n\n\t\tprintf(\"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\\n\",\n\t\t    (u_long) raidAddress, (u_long) numBlocks, (u_long) raidPtr->totalSectors);\n\n\t\t\tIO_BUF_ERR(bp, ENOSPC);\n\t\t\treturn (ENOSPC);\n\t}\n\tdesc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,\n\t    numBlocks, lbufPtr, bp, paramDAG, paramASM,\n\t    flags, cbF, cbA, raidPtr->Layout.map->states);\n\n\tif (desc == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\tRF_ETIMER_START(desc->tracerec.tot_timer);\n\n\tdesc->async_flag = async_flag;\n\n\trf_ContinueRaidAccess(desc);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_FreeRaidAccDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "633-647",
    "snippet": "void \nrf_FreeRaidAccDesc(RF_RaidAccessDesc_t * desc)\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\n\tRF_ASSERT(desc);\n\n\trf_FreeAllocList(desc->cleanupList);\n\tRF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, clean_rad);\n\traidPtr->nAccOutstanding--;\n\tif (raidPtr->waitShutdown) {\n\t\tRF_SIGNAL_COND(raidPtr->outstandingCond);\n\t}\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_rad_freelist;",
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_UNLOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_SIGNAL_COND",
          "args": [
            "raidPtr->outstandingCond"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_CLEAN_NOUNLOCK",
          "args": [
            "rf_rad_freelist",
            "desc",
            "next",
            "clean_rad"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_FreeAllocList",
          "args": [
            "desc->cleanupList"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAllocList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_alloclist.c",
          "lines": "139-164",
          "snippet": "void \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_AL_FREELIST_MAX 256"
          ],
          "globals_used": [
            "static RF_AllocListElem_t *al_free_list = NULL;",
            "static int al_free_list_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_AL_FREELIST_MAX 256\n\nstatic RF_AllocListElem_t *al_free_list = NULL;\nstatic int al_free_list_count;\n\nvoid \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "desc"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_FreeRaidAccDesc(RF_RaidAccessDesc_t * desc)\n{\n\tRF_Raid_t *raidPtr = desc->raidPtr;\n\n\tRF_ASSERT(desc);\n\n\trf_FreeAllocList(desc->cleanupList);\n\tRF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, clean_rad);\n\traidPtr->nAccOutstanding--;\n\tif (raidPtr->waitShutdown) {\n\t\tRF_SIGNAL_COND(raidPtr->outstandingCond);\n\t}\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n}"
  },
  {
    "function_name": "rf_AllocRaidAccDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "579-631",
    "snippet": "RF_RaidAccessDesc_t *\nrf_AllocRaidAccDesc(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    void (*cbF) (struct buf *),\n    void *cbA,\n    RF_AccessState_t * states)\n{\n\tRF_RaidAccessDesc_t *desc;\n\n\tRF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next, (RF_RaidAccessDesc_t *), init_rad);\n\tif (raidPtr->waitShutdown) {\n\t\t/*\n\t         * Actually, we're shutting the array down. Free the desc\n\t         * and return NULL.\n\t         */\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\tRF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next, clean_rad);\n\t\treturn (NULL);\n\t}\n\traidPtr->nAccOutstanding++;\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\tdesc->raidPtr = (void *) raidPtr;\n\tdesc->type = type;\n\tdesc->raidAddress = raidAddress;\n\tdesc->numBlocks = numBlocks;\n\tdesc->bufPtr = bufPtr;\n\tdesc->bp = bp;\n\tdesc->paramDAG = paramDAG;\n\tdesc->paramASM = paramASM;\n\tdesc->flags = flags;\n\tdesc->states = states;\n\tdesc->state = 0;\n\n\tdesc->status = 0;\n\tbzero((char *) &desc->tracerec, sizeof(RF_AccTraceEntry_t));\n\tdesc->callbackFunc = (void (*) (RF_CBParam_t)) cbF;\t/* XXX */\n\tdesc->callbackArg = cbA;\n\tdesc->next = NULL;\n\tdesc->head = desc;\n\tdesc->numPending = 0;\n\tdesc->cleanupList = NULL;\n\trf_MakeAllocList(desc->cleanupList);\n\treturn (desc);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_rad_freelist;",
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_MakeAllocList",
          "args": [
            "desc->cleanupList"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &desc->tracerec",
            "sizeof(RF_AccTraceEntry_t)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_UNLOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE_CLEAN",
          "args": [
            "rf_rad_freelist",
            "desc",
            "next",
            "clean_rad"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_UNLOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_GET_INIT_NOUNLOCK",
          "args": [
            "rf_rad_freelist",
            "desc",
            "next",
            "(RF_RaidAccessDesc_t *), init_rad"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nRF_RaidAccessDesc_t *\nrf_AllocRaidAccDesc(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_RaidAddr_t raidAddress,\n    RF_SectorCount_t numBlocks,\n    caddr_t bufPtr,\n    void *bp,\n    RF_DagHeader_t ** paramDAG,\n    RF_AccessStripeMapHeader_t ** paramASM,\n    RF_RaidAccessFlags_t flags,\n    void (*cbF) (struct buf *),\n    void *cbA,\n    RF_AccessState_t * states)\n{\n\tRF_RaidAccessDesc_t *desc;\n\n\tRF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next, (RF_RaidAccessDesc_t *), init_rad);\n\tif (raidPtr->waitShutdown) {\n\t\t/*\n\t         * Actually, we're shutting the array down. Free the desc\n\t         * and return NULL.\n\t         */\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\tRF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next, clean_rad);\n\t\treturn (NULL);\n\t}\n\traidPtr->nAccOutstanding++;\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\tdesc->raidPtr = (void *) raidPtr;\n\tdesc->type = type;\n\tdesc->raidAddress = raidAddress;\n\tdesc->numBlocks = numBlocks;\n\tdesc->bufPtr = bufPtr;\n\tdesc->bp = bp;\n\tdesc->paramDAG = paramDAG;\n\tdesc->paramASM = paramASM;\n\tdesc->flags = flags;\n\tdesc->states = states;\n\tdesc->state = 0;\n\n\tdesc->status = 0;\n\tbzero((char *) &desc->tracerec, sizeof(RF_AccTraceEntry_t));\n\tdesc->callbackFunc = (void (*) (RF_CBParam_t)) cbF;\t/* XXX */\n\tdesc->callbackArg = cbA;\n\tdesc->next = NULL;\n\tdesc->head = desc;\n\tdesc->numPending = 0;\n\tdesc->cleanupList = NULL;\n\trf_MakeAllocList(desc->cleanupList);\n\treturn (desc);\n}"
  },
  {
    "function_name": "rf_ConfigureRDFreeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "556-577",
    "snippet": "static int \nrf_ConfigureRDFreeList(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_rad_freelist, RF_MAX_FREE_RAD,\n\t    RF_RAD_INC, sizeof(RF_RaidAccessDesc_t));\n\tif (rf_rad_freelist == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownRDFreeList, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownRDFreeList(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT(rf_rad_freelist, RF_RAD_INITIAL, next,\n\t    (RF_RaidAccessDesc_t *), init_rad);\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define RF_RAD_INITIAL   32",
      "#define RF_RAD_INC       16",
      "#define RF_MAX_FREE_RAD 128"
    ],
    "globals_used": [
      "static RF_FreeList_t *rf_rad_freelist;",
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);",
      "static void rf_ShutdownRDFreeList(void *);",
      "static int rf_ConfigureRDFreeList(RF_ShutdownList_t **);",
      "RF_DECLARE_STATIC_MUTEX(configureMutex)\t/* used to lock the configuration\n\t\t\t\t\t * stuff */\nstatic RF_ShutdownList_t",
      "static int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME_INIT",
          "args": [
            "rf_rad_freelist",
            "RF_RAD_INITIAL",
            "next",
            "(RF_RaidAccessDesc_t *), init_rad"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownRDFreeList",
          "args": [
            "NULL"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownRDFreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "549-554",
          "snippet": "static void \nrf_ShutdownRDFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next, (RF_RaidAccessDesc_t *), clean_rad);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_rad_freelist;",
            "static int init_rad(RF_RaidAccessDesc_t *);",
            "static void clean_rad(RF_RaidAccessDesc_t *);",
            "static void rf_ShutdownRDFreeList(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nstatic void rf_ShutdownRDFreeList(void *);\n\nstatic void \nrf_ShutdownRDFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next, (RF_RaidAccessDesc_t *), clean_rad);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownRDFreeList",
            "NULL"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_rad_freelist",
            "RF_MAX_FREE_RAD",
            "RF_RAD_INC",
            "sizeof(RF_RaidAccessDesc_t)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define RF_RAD_INITIAL   32\n#define RF_RAD_INC       16\n#define RF_MAX_FREE_RAD 128\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nstatic void rf_ShutdownRDFreeList(void *);\nstatic int rf_ConfigureRDFreeList(RF_ShutdownList_t **);\nRF_DECLARE_STATIC_MUTEX(configureMutex)\t/* used to lock the configuration\n\t\t\t\t\t * stuff */\nstatic RF_ShutdownList_t;\nstatic int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);\n\nstatic int \nrf_ConfigureRDFreeList(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_rad_freelist, RF_MAX_FREE_RAD,\n\t    RF_RAD_INC, sizeof(RF_RaidAccessDesc_t));\n\tif (rf_rad_freelist == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownRDFreeList, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownRDFreeList(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME_INIT(rf_rad_freelist, RF_RAD_INITIAL, next,\n\t    (RF_RaidAccessDesc_t *), init_rad);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownRDFreeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "549-554",
    "snippet": "static void \nrf_ShutdownRDFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next, (RF_RaidAccessDesc_t *), clean_rad);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_rad_freelist;",
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);",
      "static void rf_ShutdownRDFreeList(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY_CLEAN",
          "args": [
            "rf_rad_freelist",
            "next",
            "(RF_RaidAccessDesc_t *), clean_rad"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\nstatic void rf_ShutdownRDFreeList(void *);\n\nstatic void \nrf_ShutdownRDFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next, (RF_RaidAccessDesc_t *), clean_rad);\n}"
  },
  {
    "function_name": "clean_rad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "541-547",
    "snippet": "static void \nclean_rad(desc)\n\tRF_RaidAccessDesc_t *desc;\n{\n\trf_mutex_destroy(&desc->mutex);\n\trf_cond_destroy(&desc->cond);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&desc->cond"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&desc->mutex"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\n\nstatic void \nclean_rad(desc)\n\tRF_RaidAccessDesc_t *desc;\n{\n\trf_mutex_destroy(&desc->mutex);\n\trf_cond_destroy(&desc->cond);\n}"
  },
  {
    "function_name": "init_rad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "519-539",
    "snippet": "static int \ninit_rad(desc)\n\tRF_RaidAccessDesc_t *desc;\n{\n\tint     rc;\n\n\trc = rf_mutex_init(&desc->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_cond_init(&desc->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_mutex_destroy(&desc->mutex);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int init_rad(RF_RaidAccessDesc_t *);",
      "static void clean_rad(RF_RaidAccessDesc_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&desc->mutex"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init cond file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_init",
          "args": [
            "&desc->cond"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rf_cond_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "188-201",
          "snippet": "int \nrf_cond_init(c)\nRF_DECLARE_COND(*c)\n{\n\t*c = 0;\t\t\t/* no reason */\n\treturn (0);\n}\n\nint \nrf_cond_destroy(c)\nRF_DECLARE_COND(*c)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_cond_init(c)\nRF_DECLARE_COND(*c)\n{\n\t*c = 0;\t\t\t/* no reason */\n\treturn (0);\n}\n\nint \nrf_cond_destroy(c)\nRF_DECLARE_COND(*c)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&desc->mutex"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int init_rad(RF_RaidAccessDesc_t *);\nstatic void clean_rad(RF_RaidAccessDesc_t *);\n\nstatic int \ninit_rad(desc)\n\tRF_RaidAccessDesc_t *desc;\n{\n\tint     rc;\n\n\trc = rf_mutex_init(&desc->mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_cond_init(&desc->cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_mutex_destroy(&desc->mutex);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_Configure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "368-517",
    "snippet": "int \nrf_Configure(raidPtr, cfgPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RowCol_t row, col;\n\tint     i, rc;\n\tint     unit;\n\n\tif (raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe configuration not shut down.  Aborting configure.\\n\");\n\t\treturn (EINVAL);\n\t}\n\tRF_LOCK_MUTEX(configureMutex);\n\tconfigureCount++;\n\tif (isconfigged == 0) {\n\t\trc = rf_create_managed_mutex(&globalShutdown, &rf_printf_mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\trf_ShutdownList(&globalShutdown);\n\t\t\treturn (rc);\n\t\t}\n\t\t/* initialize globals */\n\t\tprintf(\"RAIDFRAME: protectedSectors is %ld\\n\", rf_protectedSectors);\n\n\t\trf_clear_debug_print_buffer();\n\n\t\tDO_INIT_CONFIGURE(rf_ConfigureAllocList);\n\t\t/*\n\t         * Yes, this does make debugging general to the whole system instead\n\t         * of being array specific. Bummer, drag.\n\t         */\n\t\trf_ConfigureDebug(cfgPtr);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDebugMem);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureAccessTrace);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMapModule);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureReconEvent);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureCallback);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMemChunk);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureRDFreeList);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureNWayXor);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureStripeLockFreeList);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMCPair);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDAGs);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDAGFuncs);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDebugPrint);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureReconstruction);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureCopyback);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDiskQueueSystem);\n\t\tisconfigged = 1;\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n\n\t/*\n         * Null out the entire raid descriptor to avoid problems when we reconfig.\n         * This also clears the valid bit.\n         */\n\t/* XXX this clearing should be moved UP to outside of here.... that,\n\t * or rf_Configure() needs to take more arguments... XXX */\n\tunit = raidPtr->raidid;\n\tbzero((char *) raidPtr, sizeof(RF_Raid_t));\n\traidPtr->raidid = unit;\n\tDO_RAID_MUTEX(&raidPtr->mutex);\n\t/* set up the cleanup list.  Do this after ConfigureDebug so that\n\t * value of memDebug will be set */\n\n\trf_MakeAllocList(raidPtr->cleanupList);\n\tif (raidPtr->cleanupList == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(&raidPtr->shutdownList,\n\t    (void (*) (void *)) rf_FreeAllocList,\n\t    raidPtr->cleanupList);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\tDO_RAID_FAIL();\n\t\treturn (rc);\n\t}\n\traidPtr->numRow = cfgPtr->numRow;\n\traidPtr->numCol = cfgPtr->numCol;\n\traidPtr->numSpare = cfgPtr->numSpare;\n\n\t/* XXX we don't even pretend to support more than one row in the\n\t * kernel... */\n\tif (raidPtr->numRow != 1) {\n\t\tRF_ERRORMSG(\"Only one row supported in kernel.\\n\");\n\t\tDO_RAID_FAIL();\n\t\treturn (EINVAL);\n\t}\n\tRF_CallocAndAdd(raidPtr->status, raidPtr->numRow, sizeof(RF_RowStatus_t),\n\t    (RF_RowStatus_t *), raidPtr->cleanupList);\n\tif (raidPtr->status == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\tRF_CallocAndAdd(raidPtr->reconControl, raidPtr->numRow,\n\t    sizeof(RF_ReconCtrl_t *), (RF_ReconCtrl_t **), raidPtr->cleanupList);\n\tif (raidPtr->reconControl == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->numRow; i++) {\n\t\traidPtr->status[i] = rf_rs_optimal;\n\t\traidPtr->reconControl[i] = NULL;\n\t}\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureEngine);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureStripeLocks);\n\n\tDO_RAID_COND(&raidPtr->outstandingCond);\n\n\traidPtr->nAccOutstanding = 0;\n\traidPtr->waitShutdown = 0;\n\n\tDO_RAID_MUTEX(&raidPtr->access_suspend_mutex);\n\tDO_RAID_COND(&raidPtr->quiescent_cond);\n\n\tDO_RAID_COND(&raidPtr->waitForReconCond);\n\n\tDO_RAID_MUTEX(&raidPtr->recon_done_proc_mutex);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);\n\t/* do this after ConfigureDisks & ConfigureSpareDisks to be sure dev\n\t * no. is set */\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureDiskQueues);\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureLayout);\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigurePSStatus);\n\n\tfor (row = 0; row < raidPtr->numRow; row++) {\n\t\tfor (col = 0; col < raidPtr->numCol; col++) {\n\t\t\t/*\n\t\t         * XXX better distribution\n\t\t         */\n\t\t\traidPtr->hist_diskreq[row][col] = 0;\n\t\t}\n\t}\n\n\tif (rf_keepAccTotals) {\n\t\traidPtr->keep_acc_totals = 1;\n\t}\n\trf_StartUserStats(raidPtr);\n\n\traidPtr->valid = 1;\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_ConfigureDebug(RF_Config_t * cfgPtr);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );",
      "static int configureCount = 0;",
      "static int isconfigged = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_StartUserStats",
          "args": [
            "raidPtr"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "rf_StartUserStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "949-956",
          "snippet": "void \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid \nrf_StartUserStats(RF_Raid_t * raidPtr)\n{\n\tRF_GETTIME(raidPtr->userstats.start);\n\traidPtr->userstats.sum_io_us = 0;\n\traidPtr->userstats.num_ios = 0;\n\traidPtr->userstats.num_sect_moved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigurePSStatus"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureLayout"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDiskQueues"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureSpareDisks"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDisks"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_MUTEX",
          "args": [
            "&raidPtr->recon_done_proc_mutex"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_COND",
          "args": [
            "&raidPtr->waitForReconCond"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_COND",
          "args": [
            "&raidPtr->quiescent_cond"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_MUTEX",
          "args": [
            "&raidPtr->access_suspend_mutex"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_COND",
          "args": [
            "&raidPtr->outstandingCond"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureStripeLocks"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureEngine"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_FAIL",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "raidPtr->reconControl",
            "raidPtr->numRow",
            "sizeof(RF_ReconCtrl_t *)",
            "(RF_ReconCtrl_t **), raidPtr->cleanupList"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_FAIL",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "raidPtr->status",
            "raidPtr->numRow",
            "sizeof(RF_RowStatus_t)",
            "(RF_RowStatus_t *), raidPtr->cleanupList"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_FAIL",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Only one row supported in kernel.\\n\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_FAIL",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "&raidPtr->shutdownList",
            "(void (*) (void *)) rf_FreeAllocList",
            "raidPtr->cleanupList"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_FAIL",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeAllocList",
          "args": [
            "raidPtr->cleanupList"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_RAID_MUTEX",
          "args": [
            "&raidPtr->mutex"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) raidPtr",
            "sizeof(RF_Raid_t)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDiskQueueSystem"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureCopyback"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureReconstruction"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDebugPrint"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDAGFuncs"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDAGs"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureMCPair"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureStripeLockFreeList"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureNWayXor"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureRDFreeList"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureMemChunk"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureCallback"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureReconEvent"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureMapModule"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureAccessTrace"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureDebugMem"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ConfigureDebug",
          "args": [
            "cfgPtr"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ConfigureDebug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "861-882",
          "snippet": "static void \nrf_ConfigureDebug(cfgPtr)\n\tRF_Config_t *cfgPtr;\n{\n\tchar   *val_p, *name_p, *white_p;\n\tlong    val;\n\tint     i;\n\n\trf_ResetDebugOptions();\n\tfor (i = 0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {\n\t\tname_p = rf_find_non_white(&cfgPtr->debugVars[i][0]);\n\t\twhite_p = rf_find_white(name_p);\t/* skip to start of 2nd\n\t\t\t\t\t\t\t * word */\n\t\tval_p = rf_find_non_white(white_p);\n\t\tif (*val_p == '0' && *(val_p + 1) == 'x')\n\t\t\tval = rf_htoi(val_p + 2);\n\t\telse\n\t\t\tval = rf_atoi(val_p);\n\t\t*white_p = '\\0';\n\t\tset_debug_option(name_p, val);\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_ConfigureDebug(RF_Config_t * cfgPtr);",
            "static void set_debug_option(char *name, long val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_ConfigureDebug(RF_Config_t * cfgPtr);\nstatic void set_debug_option(char *name, long val);\n\nstatic void \nrf_ConfigureDebug(cfgPtr)\n\tRF_Config_t *cfgPtr;\n{\n\tchar   *val_p, *name_p, *white_p;\n\tlong    val;\n\tint     i;\n\n\trf_ResetDebugOptions();\n\tfor (i = 0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {\n\t\tname_p = rf_find_non_white(&cfgPtr->debugVars[i][0]);\n\t\twhite_p = rf_find_white(name_p);\t/* skip to start of 2nd\n\t\t\t\t\t\t\t * word */\n\t\tval_p = rf_find_non_white(white_p);\n\t\tif (*val_p == '0' && *(val_p + 1) == 'x')\n\t\t\tval = rf_htoi(val_p + 2);\n\t\telse\n\t\t\tval = rf_atoi(val_p);\n\t\t*white_p = '\\0';\n\t\tset_debug_option(name_p, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_INIT_CONFIGURE",
          "args": [
            "rf_ConfigureAllocList"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_clear_debug_print_buffer",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "rf_clear_debug_print_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "72-80",
          "snippet": "void \nrf_clear_debug_print_buffer()\n{\n\tint     i;\n\n\tfor (i = 0; i < BUFSIZE; i++)\n\t\trf_debugprint_buf[i].cstring = NULL;\n\trf_debugprint_index = 0;\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFSIZE  (1<<BUFSHIFT)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFSIZE  (1<<BUFSHIFT)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_clear_debug_print_buffer()\n{\n\tint     i;\n\n\tfor (i = 0; i < BUFSIZE; i++)\n\t\trf_debugprint_buf[i].cstring = NULL;\n\trf_debugprint_index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RAIDFRAME: protectedSectors is %ld\\n\"",
            "rf_protectedSectors"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ShutdownList",
          "args": [
            "&globalShutdown"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_shutdown.c",
          "lines": "75-99",
          "snippet": "int \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_mutex",
          "args": [
            "&globalShutdown",
            "&rf_printf_mutex"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "69-90",
          "snippet": "int \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mutex_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void mutex_destroyer(void *);\n\nint \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"RAIDframe configuration not shut down.  Aborting configure.\\n\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_ConfigureDebug(RF_Config_t * cfgPtr);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\nstatic int configureCount = 0;\nstatic int isconfigged = 0;\n\nint \nrf_Configure(raidPtr, cfgPtr)\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RowCol_t row, col;\n\tint     i, rc;\n\tint     unit;\n\n\tif (raidPtr->valid) {\n\t\tRF_ERRORMSG(\"RAIDframe configuration not shut down.  Aborting configure.\\n\");\n\t\treturn (EINVAL);\n\t}\n\tRF_LOCK_MUTEX(configureMutex);\n\tconfigureCount++;\n\tif (isconfigged == 0) {\n\t\trc = rf_create_managed_mutex(&globalShutdown, &rf_printf_mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\trf_ShutdownList(&globalShutdown);\n\t\t\treturn (rc);\n\t\t}\n\t\t/* initialize globals */\n\t\tprintf(\"RAIDFRAME: protectedSectors is %ld\\n\", rf_protectedSectors);\n\n\t\trf_clear_debug_print_buffer();\n\n\t\tDO_INIT_CONFIGURE(rf_ConfigureAllocList);\n\t\t/*\n\t         * Yes, this does make debugging general to the whole system instead\n\t         * of being array specific. Bummer, drag.\n\t         */\n\t\trf_ConfigureDebug(cfgPtr);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDebugMem);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureAccessTrace);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMapModule);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureReconEvent);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureCallback);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMemChunk);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureRDFreeList);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureNWayXor);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureStripeLockFreeList);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureMCPair);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDAGs);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDAGFuncs);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDebugPrint);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureReconstruction);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureCopyback);\n\t\tDO_INIT_CONFIGURE(rf_ConfigureDiskQueueSystem);\n\t\tisconfigged = 1;\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n\n\t/*\n         * Null out the entire raid descriptor to avoid problems when we reconfig.\n         * This also clears the valid bit.\n         */\n\t/* XXX this clearing should be moved UP to outside of here.... that,\n\t * or rf_Configure() needs to take more arguments... XXX */\n\tunit = raidPtr->raidid;\n\tbzero((char *) raidPtr, sizeof(RF_Raid_t));\n\traidPtr->raidid = unit;\n\tDO_RAID_MUTEX(&raidPtr->mutex);\n\t/* set up the cleanup list.  Do this after ConfigureDebug so that\n\t * value of memDebug will be set */\n\n\trf_MakeAllocList(raidPtr->cleanupList);\n\tif (raidPtr->cleanupList == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_ShutdownCreate(&raidPtr->shutdownList,\n\t    (void (*) (void *)) rf_FreeAllocList,\n\t    raidPtr->cleanupList);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\tDO_RAID_FAIL();\n\t\treturn (rc);\n\t}\n\traidPtr->numRow = cfgPtr->numRow;\n\traidPtr->numCol = cfgPtr->numCol;\n\traidPtr->numSpare = cfgPtr->numSpare;\n\n\t/* XXX we don't even pretend to support more than one row in the\n\t * kernel... */\n\tif (raidPtr->numRow != 1) {\n\t\tRF_ERRORMSG(\"Only one row supported in kernel.\\n\");\n\t\tDO_RAID_FAIL();\n\t\treturn (EINVAL);\n\t}\n\tRF_CallocAndAdd(raidPtr->status, raidPtr->numRow, sizeof(RF_RowStatus_t),\n\t    (RF_RowStatus_t *), raidPtr->cleanupList);\n\tif (raidPtr->status == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\tRF_CallocAndAdd(raidPtr->reconControl, raidPtr->numRow,\n\t    sizeof(RF_ReconCtrl_t *), (RF_ReconCtrl_t **), raidPtr->cleanupList);\n\tif (raidPtr->reconControl == NULL) {\n\t\tDO_RAID_FAIL();\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->numRow; i++) {\n\t\traidPtr->status[i] = rf_rs_optimal;\n\t\traidPtr->reconControl[i] = NULL;\n\t}\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureEngine);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureStripeLocks);\n\n\tDO_RAID_COND(&raidPtr->outstandingCond);\n\n\traidPtr->nAccOutstanding = 0;\n\traidPtr->waitShutdown = 0;\n\n\tDO_RAID_MUTEX(&raidPtr->access_suspend_mutex);\n\tDO_RAID_COND(&raidPtr->quiescent_cond);\n\n\tDO_RAID_COND(&raidPtr->waitForReconCond);\n\n\tDO_RAID_MUTEX(&raidPtr->recon_done_proc_mutex);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);\n\t/* do this after ConfigureDisks & ConfigureSpareDisks to be sure dev\n\t * no. is set */\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureDiskQueues);\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigureLayout);\n\n\tDO_RAID_INIT_CONFIGURE(rf_ConfigurePSStatus);\n\n\tfor (row = 0; row < raidPtr->numRow; row++) {\n\t\tfor (col = 0; col < raidPtr->numCol; col++) {\n\t\t\t/*\n\t\t         * XXX better distribution\n\t\t         */\n\t\t\traidPtr->hist_diskreq[row][col] = 0;\n\t\t}\n\t}\n\n\tif (rf_keepAccTotals) {\n\t\traidPtr->keep_acc_totals = 1;\n\t}\n\trf_StartUserStats(raidPtr);\n\n\traidPtr->valid = 1;\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_UnconfigureVnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "284-320",
    "snippet": "void\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vnode was NULL\\n\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp",
            "FREAD | FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp",
            "0",
            "p"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "raidPtr->raid_cinfo[r][c].ci_vp",
            "FREAD | FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "raidPtr->raid_cinfo[r][c].ci_vp",
            "0",
            "p"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_Shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "244-282",
    "snippet": "int \nrf_Shutdown(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\\n\");\n\t\treturn (EINVAL);\n\t}\n\t/*\n         * wait for outstanding IOs to land\n         * As described in rf_raid.h, we use the rad_freelist lock\n         * to protect the per-array info about outstanding descs\n         * since we need to do freelist locking anyway, and this\n         * cuts down on the amount of serialization we've got going\n         * on.\n         */\n\tRF_FREELIST_DO_LOCK(rf_rad_freelist);\n\tif (raidPtr->waitShutdown) {\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\treturn (EBUSY);\n\t}\n\traidPtr->waitShutdown = 1;\n\twhile (raidPtr->nAccOutstanding) {\n\t\tRF_WAIT_COND(raidPtr->outstandingCond, RF_FREELIST_MUTEX_OF(rf_rad_freelist));\n\t}\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\traidPtr->valid = 0;\n\n\trf_update_component_labels(raidPtr);\n\n\trf_UnconfigureVnodes(raidPtr);\n\n\trf_ShutdownList(&raidPtr->shutdownList);\n\n\trf_UnconfigureArray();\n\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_rad_freelist;",
      "static void rf_UnconfigureArray(void);",
      "void rf_UnconfigureVnodes( RF_Raid_t * );"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_UnconfigureArray",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnconfigureArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "217-240",
          "snippet": "static void \nrf_UnconfigureArray()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (--configureCount == 0) {\t/* if no active configurations, shut\n\t\t\t\t\t * everything down */\n\t\tisconfigged = 0;\n\n\t\trc = rf_ShutdownList(&globalShutdown);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: unable to do global shutdown, rc=%d\\n\", rc);\n\t\t}\n\n\t\t/*\n\t         * We must wait until now, because the AllocList module\n\t         * uses the DebugMem module.\n\t         */\n\t\tif (rf_memDebug)\n\t\t\trf_print_unfreed();\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_UnconfigureArray(void);",
            "static int configureCount = 0;",
            "static int isconfigged = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_UnconfigureArray(void);\nstatic int configureCount = 0;\nstatic int isconfigged = 0;\n\nstatic void \nrf_UnconfigureArray()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (--configureCount == 0) {\t/* if no active configurations, shut\n\t\t\t\t\t * everything down */\n\t\tisconfigged = 0;\n\n\t\trc = rf_ShutdownList(&globalShutdown);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: unable to do global shutdown, rc=%d\\n\", rc);\n\t\t}\n\n\t\t/*\n\t         * We must wait until now, because the AllocList module\n\t         * uses the DebugMem module.\n\t         */\n\t\tif (rf_memDebug)\n\t\t\trf_print_unfreed();\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ShutdownList",
          "args": [
            "&raidPtr->shutdownList"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_shutdown.c",
          "lines": "75-99",
          "snippet": "int \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_UnconfigureVnodes",
          "args": [
            "raidPtr"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rf_UnconfigureVnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
          "lines": "284-320",
          "snippet": "void\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_kintf.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_nwayxor.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_callback.h\"",
            "#include \"rf_revent.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_states.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_aselect.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rf_UnconfigureVnodes( RF_Raid_t * );"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nvoid\nrf_UnconfigureVnodes( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tint r,c; \n\tstruct proc *p;\n\n\t/* We take this opportunity to close the vnodes like we should.. */\n\n\tp = raidPtr->engine_thread;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tprintf(\"Closing vnode for row: %d col: %d\\n\", r, c);\n\t\t\tif (raidPtr->raid_cinfo[r][c].ci_vp) {\n\t\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);\n \t\t\t\t(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,\n \t\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp = NULL;\n\t\t\t} else {\n\t\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (r = 0; r < raidPtr->numSpare; r++) {\n\t\tprintf(\"Closing vnode for spare: %d\\n\", r);\n\t\tif (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {\n\t\t\tVOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);\n\t\t\t(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,\n\t\t\t    FREAD | FWRITE, p->p_ucred, p);\n\t\t\traidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;\n\t\t} else {\n\t\t\tprintf(\"vnode was NULL\\n\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_update_component_labels",
          "args": [
            "raidPtr"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rf_update_component_labels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_netbsdkintf.c",
          "lines": "2115-2230",
          "snippet": "void\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}",
          "includes": [
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_dagflags.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_copyback.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"raid.h\"",
            "#include <sys/user.h>",
            "#include <sys/buf.h>",
            "#include <sys/lock.h>",
            "#include <sys/conf.h>",
            "#include <sys/disklabel.h>",
            "#include <machine/types.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/vnode.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/device.h>",
            "#include <sys/disk.h>",
            "#include <sys/queue.h>",
            "#include <sys/pool.h>",
            "#include <sys/param.h>",
            "#include <sys/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_threadstuff.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_driver.h\"\n#include \"rf_options.h\"\n#include \"rf_kintf.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_dagflags.h\"\n#include \"rf_dag.h\"\n#include \"rf_copyback.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"raid.h\"\n#include <sys/user.h>\n#include <sys/buf.h>\n#include <sys/lock.h>\n#include <sys/conf.h>\n#include <sys/disklabel.h>\n#include <machine/types.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/vnode.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/device.h>\n#include <sys/disk.h>\n#include <sys/queue.h>\n#include <sys/pool.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n\nvoid\nrf_update_component_labels( raidPtr )\n\tRF_Raid_t *raidPtr;\n{\n\tRF_ComponentLabel_t c_label;\n\tint sparecol;\n\tint r,c;\n\tint i,j;\n\tint srow, scol;\n\n\tsrow = -1;\n\tscol = -1;\n\n\t/* XXX should do extra checks to make sure things really are clean, \n\t   rather than blindly setting the clean bit... */\n\n\traidPtr->mod_counter++;\n\n\tfor (r = 0; r < raidPtr->numRow; r++) {\n\t\tfor (c = 0; c < raidPtr->numCol; c++) {\n\t\t\tif (raidPtr->Disks[r][c].status == rf_ds_optimal) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = rf_ds_optimal;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t} \n\t\t\t/* else we don't touch it.. */\n#if 0\n\t\t\telse if (raidPtr->Disks[r][c].status !=\n\t\t\t\t   rf_ds_failed) {\n\t\t\t\traidread_component_label(\n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\t/* make sure status is noted */\n\t\t\t\tc_label.status = \n\t\t\t\t\traidPtr->Disks[r][c].status;\n\t\t\t\traidwrite_component_label( \n\t\t\t\t\traidPtr->Disks[r][c].dev,\n\t\t\t\t\traidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t&c_label);\n\t\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\t\traidmarkclean( \n\t\t\t\t\t      raidPtr->Disks[r][c].dev, \n\t\t\t\t\t      raidPtr->raid_cinfo[r][c].ci_vp,\n\t\t\t\t\t      raidPtr->mod_counter);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} \n\t}\n\n\tfor( c = 0; c < raidPtr->numSpare ; c++) {\n\t\tsparecol = raidPtr->numCol + c;\n\t\tif (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {\n\t\t\t/* \n\t\t\t   \n\t\t\t   we claim this disk is \"optimal\" if it's \n\t\t\t   rf_ds_used_spare, as that means it should be \n\t\t\t   directly substitutable for the disk it replaced. \n\t\t\t   We note that too...\n\n\t\t\t */\n\n\t\t\tfor(i=0;i<raidPtr->numRow;i++) {\n\t\t\t\tfor(j=0;j<raidPtr->numCol;j++) {\n\t\t\t\t\tif ((raidPtr->Disks[i][j].spareRow == \n\t\t\t\t\t     0) &&\n\t\t\t\t\t    (raidPtr->Disks[i][j].spareCol ==\n\t\t\t\t\t     sparecol)) {\n\t\t\t\t\t\tsrow = i;\n\t\t\t\t\t\tscol = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\traidread_component_label( \n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\t/* make sure status is noted */\n\t\t\tc_label.version = RF_COMPONENT_LABEL_VERSION; \n\t\t\tc_label.mod_counter = raidPtr->mod_counter;\n\t\t\tc_label.serial_number = raidPtr->serial_number;\n\t\t\tc_label.row = srow;\n\t\t\tc_label.column = scol;\n\t\t\tc_label.num_rows = raidPtr->numRow;\n\t\t\tc_label.num_columns = raidPtr->numCol;\n\t\t\tc_label.clean = RF_RAID_DIRTY; /* changed in a bit*/\n\t\t\tc_label.status = rf_ds_optimal;\n\t\t\traidwrite_component_label(\n\t\t\t\t      raidPtr->Disks[0][sparecol].dev,\n\t\t\t\t      raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t      &c_label);\n\t\t\tif (raidPtr->parity_good == RF_RAID_CLEAN) {\n\t\t\t\traidmarkclean( raidPtr->Disks[0][sparecol].dev,\n\t\t\t              raidPtr->raid_cinfo[0][sparecol].ci_vp,\n\t\t\t\t\t       raidPtr->mod_counter);\n\t\t\t}\n\t\t}\n\t}\n\t/* \tprintf(\"Component labels updated\\n\"); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_UNLOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "raidPtr->outstandingCond",
            "RF_FREELIST_MUTEX_OF(rf_rad_freelist)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_MUTEX_OF",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_UNLOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_DO_LOCK",
          "args": [
            "rf_rad_freelist"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic RF_FreeList_t *rf_rad_freelist;\nstatic void rf_UnconfigureArray(void);\nvoid rf_UnconfigureVnodes( RF_Raid_t * );\n\nint \nrf_Shutdown(raidPtr)\n\tRF_Raid_t *raidPtr;\n{\n\tif (!raidPtr->valid) {\n\t\tRF_ERRORMSG(\"Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\\n\");\n\t\treturn (EINVAL);\n\t}\n\t/*\n         * wait for outstanding IOs to land\n         * As described in rf_raid.h, we use the rad_freelist lock\n         * to protect the per-array info about outstanding descs\n         * since we need to do freelist locking anyway, and this\n         * cuts down on the amount of serialization we've got going\n         * on.\n         */\n\tRF_FREELIST_DO_LOCK(rf_rad_freelist);\n\tif (raidPtr->waitShutdown) {\n\t\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\t\treturn (EBUSY);\n\t}\n\traidPtr->waitShutdown = 1;\n\twhile (raidPtr->nAccOutstanding) {\n\t\tRF_WAIT_COND(raidPtr->outstandingCond, RF_FREELIST_MUTEX_OF(rf_rad_freelist));\n\t}\n\tRF_FREELIST_DO_UNLOCK(rf_rad_freelist);\n\n\traidPtr->valid = 0;\n\n\trf_update_component_labels(raidPtr);\n\n\trf_UnconfigureVnodes(raidPtr);\n\n\trf_ShutdownList(&raidPtr->shutdownList);\n\n\trf_UnconfigureArray();\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_UnconfigureArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "217-240",
    "snippet": "static void \nrf_UnconfigureArray()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (--configureCount == 0) {\t/* if no active configurations, shut\n\t\t\t\t\t * everything down */\n\t\tisconfigged = 0;\n\n\t\trc = rf_ShutdownList(&globalShutdown);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: unable to do global shutdown, rc=%d\\n\", rc);\n\t\t}\n\n\t\t/*\n\t         * We must wait until now, because the AllocList module\n\t         * uses the DebugMem module.\n\t         */\n\t\tif (rf_memDebug)\n\t\t\trf_print_unfreed();\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_UnconfigureArray(void);",
      "static int configureCount = 0;",
      "static int isconfigged = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_print_unfreed",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "rf_print_unfreed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "101-120",
          "snippet": "void \nrf_print_unfreed()\n{\n\tint     i, foundone = 0;\n\tstruct mh_struct *p;\n\n\tfor (i = 0; i < RF_MH_TABLESIZE; i++) {\n\t\tfor (p = mh_table[i]; p; p = p->next)\n\t\t\tif (p->allocated) {\n\t\t\t\tif (!foundone)\n\t\t\t\t\tprintf(\"\\n\\nThere are unfreed memory locations at program shutdown:\\n\");\n\t\t\t\tfoundone = 1;\n\t\t\t\tprintf(\"Addr 0x%lx Size %d line %d file %s\\n\",\n\t\t\t\t    (long) p->address, p->size, p->line, p->filen);\n\t\t\t}\n\t}\n\tif (tot_mem_in_use) {\n\t\tprintf(\"%ld total bytes in use\\n\", tot_mem_in_use);\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_MH_TABLESIZE 1000"
          ],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static struct mh_struct *mh_table[RF_MH_TABLESIZE];",
            "static void memory_hash_insert(void *addr, int size, int line, char *filen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_MH_TABLESIZE 1000\n\nstatic long tot_mem_in_use = 0;\nstatic struct mh_struct *mh_table[RF_MH_TABLESIZE];\nstatic void memory_hash_insert(void *addr, int size, int line, char *filen);\n\nvoid \nrf_print_unfreed()\n{\n\tint     i, foundone = 0;\n\tstruct mh_struct *p;\n\n\tfor (i = 0; i < RF_MH_TABLESIZE; i++) {\n\t\tfor (p = mh_table[i]; p; p = p->next)\n\t\t\tif (p->allocated) {\n\t\t\t\tif (!foundone)\n\t\t\t\t\tprintf(\"\\n\\nThere are unfreed memory locations at program shutdown:\\n\");\n\t\t\t\tfoundone = 1;\n\t\t\t\tprintf(\"Addr 0x%lx Size %d line %d file %s\\n\",\n\t\t\t\t    (long) p->address, p->size, p->line, p->filen);\n\t\t\t}\n\t}\n\tif (tot_mem_in_use) {\n\t\tprintf(\"%ld total bytes in use\\n\", tot_mem_in_use);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"RAIDFRAME: unable to do global shutdown, rc=%d\\n\"",
            "rc"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownList",
          "args": [
            "&globalShutdown"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_shutdown.c",
          "lines": "75-99",
          "snippet": "int \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_ShutdownList(RF_ShutdownList_t ** list)\n{\n\tRF_ShutdownList_t *r, *next;\n\tchar   *file;\n\tint     line;\n\n\tfor (r = *list; r; r = next) {\n\t\tnext = r->next;\n\t\tfile = r->file;\n\t\tline = r->line;\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"call shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\tr->cleanup(r->arg);\n\n\t\tif (rf_shutdownDebug) {\n\t\t\tprintf(\"completed shutdown, created %s:%d\\n\", file, line);\n\t\t}\n\t\trf_FreeShutdownEnt(r);\n\t}\n\t*list = NULL;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void rf_UnconfigureArray(void);\nstatic int configureCount = 0;\nstatic int isconfigged = 0;\n\nstatic void \nrf_UnconfigureArray()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (--configureCount == 0) {\t/* if no active configurations, shut\n\t\t\t\t\t * everything down */\n\t\tisconfigged = 0;\n\n\t\trc = rf_ShutdownList(&globalShutdown);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: unable to do global shutdown, rc=%d\\n\", rc);\n\t\t}\n\n\t\t/*\n\t         * We must wait until now, because the AllocList module\n\t         * uses the DebugMem module.\n\t         */\n\t\tif (rf_memDebug)\n\t\t\trf_print_unfreed();\n\t}\n\tRF_UNLOCK_MUTEX(configureMutex);\n}"
  },
  {
    "function_name": "rf_UnbootRaidframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "194-213",
    "snippet": "int \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int raidframe_booted = 0;",
      "static int configureCount = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to destroy mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&configureMutex"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "configureMutex"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int raidframe_booted = 0;\nstatic int configureCount = 0;\n\nint \nrf_UnbootRaidframe()\n{\n\tint     rc;\n\n\tRF_LOCK_MUTEX(configureMutex);\n\tif (configureCount) {\n\t\tRF_UNLOCK_MUTEX(configureMutex);\n\t\treturn (EBUSY);\n\t}\n\traidframe_booted = 0;\n\tRF_UNLOCK_MUTEX(configureMutex);\n\trc = rf_mutex_destroy(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to destroy mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_BootRaidframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_driver.c",
    "lines": "168-187",
    "snippet": "int\nrf_BootRaidframe()\n{\n\tint     rc;\n\n\tif (raidframe_booted)\n\t\treturn (EBUSY);\n\traidframe_booted = 1;\n\n\trc = rf_mutex_init(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\tconfigureCount = 0;\n\tisconfigged = 0;\n\tglobalShutdown = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include <sys/buf.h>",
      "#include \"rf_kintf.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_copyback.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_nwayxor.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_callback.h\"",
      "#include \"rf_revent.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_states.h\"",
      "#include \"rf_desc.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_aselect.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int raidframe_booted = 0;",
      "static int configureCount = 0;",
      "static int isconfigged = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&configureMutex"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_kintf.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_options.h\"\n#include \"rf_driver.h\"\n#include \"rf_copyback.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_nwayxor.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_engine.h\"\n#include \"rf_callback.h\"\n#include \"rf_revent.h\"\n#include \"rf_map.h\"\n#include \"rf_decluster.h\"\n#include \"rf_freelist.h\"\n#include \"rf_states.h\"\n#include \"rf_desc.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_utils.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_aselect.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n#include \"rf_archs.h\"\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int raidframe_booted = 0;\nstatic int configureCount = 0;\nstatic int isconfigged = 0;\n\nint\nrf_BootRaidframe()\n{\n\tint     rc;\n\n\tif (raidframe_booted)\n\t\treturn (EBUSY);\n\traidframe_booted = 1;\n\n\trc = rf_mutex_init(&configureMutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\tRF_PANIC();\n\t}\n\tconfigureCount = 0;\n\tisconfigged = 0;\n\tglobalShutdown = NULL;\n\treturn (0);\n}"
  }
]