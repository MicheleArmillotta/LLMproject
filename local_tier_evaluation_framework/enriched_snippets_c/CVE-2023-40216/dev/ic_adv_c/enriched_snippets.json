[
  {
    "function_name": "adv_narrow_isr_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "963-1060",
    "snippet": "static void\nadv_narrow_isr_callback(sc, qdonep)\n\tASC_SOFTC      *sc;\n\tASC_QDONE_INFO *qdonep;\n{\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb = (ADV_CCB *) qdonep->d2.ccb_ptr;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_sense_data *s1, *s2;\n\n\n#ifdef ASC_DEBUG\n\tprintf(\" - ccb=0x%lx, id=%d, lun=%d, cmd=%d, \",\n\t\t\t(unsigned long)ccb,\n\t\t\txs->sc_link->scsipi_scsi.target,\n\t\t\txs->sc_link->scsipi_scsi.lun, xs->cmd->opcode);\n#endif\n\tuntimeout(adv_timeout, ccb);\n\n\t/*\n         * If we were a data transfer, unload the map that described\n         * the data buffer.\n         */\n\tif (xs->datalen) {\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t\t\tBUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(dmat, ccb->dmamap_xfer);\n\t}\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\t/*\n         * 'qdonep' contains the command's ending status.\n         */\n#ifdef ASC_DEBUG\n\tprintf(\"d_s=%d, h_s=%d\", qdonep->d3.done_stat, qdonep->d3.host_stat);\n#endif\n\tswitch (qdonep->d3.done_stat) {\n\tcase ASC_QD_NO_ERROR:\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase ASC_QHSTA_NO_ERROR:\n\t\t\txs->error = XS_NOERROR;\n\t\t\txs->resid = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* QHSTA error occurred */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n                 * If an INQUIRY command completed successfully, then call\n                 * the AscInquiryHandling() function to patch bugged boards.\n                 */\n\t\tif ((xs->cmd->opcode == SCSICMD_Inquiry) &&\n\t\t    (xs->sc_link->lun == 0) &&\n\t\t    (xs->datalen - qdonep->remain_bytes) >= 8) {\n\t\t\tAscInquiryHandling(sc,\n\t\t\t\t      xs->sc_link->target & 0x7,\n\t\t\t\t\t   (ASC_SCSI_INQUIRY *) xs->data);\n\t\t}\n\t\tbreak;\n\n\tcase ASC_QD_WITH_ERROR:\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase ASC_QHSTA_NO_ERROR:\n\t\t\tif (qdonep->d3.scsi_stat == SS_CHK_CONDITION) {\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t} else {\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* QHSTA error occurred */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ASC_QD_ABORTED_BY_HOST:\n\tdefault:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n\n\tadv_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_free_ccb",
      "static void adv_narrow_isr_callback",
      "static void adv_timeout",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;",
      "bus_dma_tag_t   dmat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "adv_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "257-277",
          "snippet": "static void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_free_ccb",
            "static void adv_reset_ccb",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_free_ccb;\nstatic void adv_reset_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscInquiryHandling",
          "args": [
            "sc",
            "xs->sc_link->target & 0x7",
            "(ASC_SCSI_INQUIRY *) xs->data"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "AscInquiryHandling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "3284-3328",
          "snippet": "void\nAscInquiryHandling(sc, tid_no, inq)\n\tASC_SOFTC      *sc;\n\tu_int8_t        tid_no;\n\tASC_SCSI_INQUIRY *inq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);\n\tASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;\n\n\n\torig_init_sdtr = sc->init_sdtr;\n\torig_use_tagged_qng = sc->use_tagged_qng;\n\n\tsc->init_sdtr &= ~tid_bit;\n\tsc->can_tagged_qng &= ~tid_bit;\n\tsc->use_tagged_qng &= ~tid_bit;\n\n\tif (inq->byte3.rsp_data_fmt >= 2 || inq->byte2.ansi_apr_ver >= 2) {\n\t\tif ((sc->sdtr_enable & tid_bit) && inq->byte7.Sync)\n\t\t\tsc->init_sdtr |= tid_bit;\n\n\t\tif ((sc->cmd_qng_enabled & tid_bit) && inq->byte7.CmdQue)\n\t\t\tif (AscTagQueuingSafe(inq)) {\n\t\t\t\tsc->use_tagged_qng |= tid_bit;\n\t\t\t\tsc->can_tagged_qng |= tid_bit;\n\t\t\t}\n\t}\n\tif (orig_use_tagged_qng != sc->use_tagged_qng) {\n\t\tAscWriteLramByte(iot, ioh, ASCV_DISC_ENABLE_B,\n\t\t\t\t sc->disc_enable);\n\t\tAscWriteLramByte(iot, ioh, ASCV_USE_TAGGED_QNG_B,\n\t\t\t\t sc->use_tagged_qng);\n\t\tAscWriteLramByte(iot, ioh, ASCV_CAN_TAGGED_QNG_B,\n\t\t\t\t sc->can_tagged_qng);\n\n\t\tsc->max_dvc_qng[tid_no] =\n\t\t\tsc->max_tag_qng[tid_no];\n\t\tAscWriteLramByte(iot, ioh, ASCV_MAX_DVC_QNG_BEG + tid_no,\n\t\t\t\t sc->max_dvc_qng[tid_no]);\n\t}\n\tif (orig_init_sdtr != sc->init_sdtr)\n\t\tAscAsyncFix(sc, tid_no, inq);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void AscWriteLramByte",
            "static int AscTagQueuingSafe",
            "static void AscAsyncFix"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void AscWriteLramByte;\nstatic int AscTagQueuingSafe;\nstatic void AscAsyncFix;\n\nvoid\nAscInquiryHandling(sc, tid_no, inq)\n\tASC_SOFTC      *sc;\n\tu_int8_t        tid_no;\n\tASC_SCSI_INQUIRY *inq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);\n\tASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;\n\n\n\torig_init_sdtr = sc->init_sdtr;\n\torig_use_tagged_qng = sc->use_tagged_qng;\n\n\tsc->init_sdtr &= ~tid_bit;\n\tsc->can_tagged_qng &= ~tid_bit;\n\tsc->use_tagged_qng &= ~tid_bit;\n\n\tif (inq->byte3.rsp_data_fmt >= 2 || inq->byte2.ansi_apr_ver >= 2) {\n\t\tif ((sc->sdtr_enable & tid_bit) && inq->byte7.Sync)\n\t\t\tsc->init_sdtr |= tid_bit;\n\n\t\tif ((sc->cmd_qng_enabled & tid_bit) && inq->byte7.CmdQue)\n\t\t\tif (AscTagQueuingSafe(inq)) {\n\t\t\t\tsc->use_tagged_qng |= tid_bit;\n\t\t\t\tsc->can_tagged_qng |= tid_bit;\n\t\t\t}\n\t}\n\tif (orig_use_tagged_qng != sc->use_tagged_qng) {\n\t\tAscWriteLramByte(iot, ioh, ASCV_DISC_ENABLE_B,\n\t\t\t\t sc->disc_enable);\n\t\tAscWriteLramByte(iot, ioh, ASCV_USE_TAGGED_QNG_B,\n\t\t\t\t sc->use_tagged_qng);\n\t\tAscWriteLramByte(iot, ioh, ASCV_CAN_TAGGED_QNG_B,\n\t\t\t\t sc->can_tagged_qng);\n\n\t\tsc->max_dvc_qng[tid_no] =\n\t\t\tsc->max_tag_qng[tid_no];\n\t\tAscWriteLramByte(iot, ioh, ASCV_MAX_DVC_QNG_BEG + tid_no,\n\t\t\t\t sc->max_dvc_qng[tid_no]);\n\t}\n\tif (orig_init_sdtr != sc->init_sdtr)\n\t\tAscAsyncFix(sc, tid_no, inq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"d_s=%d, h_s=%d\"",
            "qdonep->d3.done_stat",
            "qdonep->d3.host_stat"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "dmat",
            "ccb->dmamap_xfer"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t\t\tBUS_DMASYNC_POSTWRITE"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "adv_timeout",
            "ccb"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_free_ccb;\nstatic void adv_narrow_isr_callback;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\nbus_dma_tag_t   dmat;\n\nstatic void\nadv_narrow_isr_callback(sc, qdonep)\n\tASC_SOFTC      *sc;\n\tASC_QDONE_INFO *qdonep;\n{\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb = (ADV_CCB *) qdonep->d2.ccb_ptr;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_sense_data *s1, *s2;\n\n\n#ifdef ASC_DEBUG\n\tprintf(\" - ccb=0x%lx, id=%d, lun=%d, cmd=%d, \",\n\t\t\t(unsigned long)ccb,\n\t\t\txs->sc_link->scsipi_scsi.target,\n\t\t\txs->sc_link->scsipi_scsi.lun, xs->cmd->opcode);\n#endif\n\tuntimeout(adv_timeout, ccb);\n\n\t/*\n         * If we were a data transfer, unload the map that described\n         * the data buffer.\n         */\n\tif (xs->datalen) {\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t\t\tBUS_DMASYNC_POSTWRITE);\n\t\tbus_dmamap_unload(dmat, ccb->dmamap_xfer);\n\t}\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\t/*\n         * 'qdonep' contains the command's ending status.\n         */\n#ifdef ASC_DEBUG\n\tprintf(\"d_s=%d, h_s=%d\", qdonep->d3.done_stat, qdonep->d3.host_stat);\n#endif\n\tswitch (qdonep->d3.done_stat) {\n\tcase ASC_QD_NO_ERROR:\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase ASC_QHSTA_NO_ERROR:\n\t\t\txs->error = XS_NOERROR;\n\t\t\txs->resid = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* QHSTA error occurred */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n                 * If an INQUIRY command completed successfully, then call\n                 * the AscInquiryHandling() function to patch bugged boards.\n                 */\n\t\tif ((xs->cmd->opcode == SCSICMD_Inquiry) &&\n\t\t    (xs->sc_link->lun == 0) &&\n\t\t    (xs->datalen - qdonep->remain_bytes) >= 8) {\n\t\t\tAscInquiryHandling(sc,\n\t\t\t\t      xs->sc_link->target & 0x7,\n\t\t\t\t\t   (ASC_SCSI_INQUIRY *) xs->data);\n\t\t}\n\t\tbreak;\n\n\tcase ASC_QD_WITH_ERROR:\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase ASC_QHSTA_NO_ERROR:\n\t\t\tif (qdonep->d3.scsi_stat == SS_CHK_CONDITION) {\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t} else {\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* QHSTA error occurred */\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ASC_QD_ABORTED_BY_HOST:\n\tdefault:\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\n\n\tadv_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "adv_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "934-950",
    "snippet": "static void\nadv_watchdog(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\ts = splbio();\n\n\tccb->flags &= ~CCB_WATCHDOG;\n\tadv_start_ccbs(sc);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_start_ccbs",
      "static void adv_watchdog",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "adv_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "367-388",
          "snippet": "static void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */"
          ],
          "globals_used": [
            "static void adv_start_ccbs",
            "static void adv_timeout",
            "static void adv_watchdog",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */\n\nstatic void adv_start_ccbs;\nstatic void adv_timeout;\nstatic void adv_watchdog;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_start_ccbs;\nstatic void adv_watchdog;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_watchdog(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\ts = splbio();\n\n\tccb->flags &= ~CCB_WATCHDOG;\n\tadv_start_ccbs(sc);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "adv_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "893-931",
    "snippet": "static void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */"
    ],
    "globals_used": [
      "static void adv_queue_ccb",
      "static void adv_timeout",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "adv_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "355-364",
          "snippet": "static void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_queue_ccb",
            "static void adv_start_ccbs",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_queue_ccb;\nstatic void adv_start_ccbs;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscAbortCCB",
          "args": [
            "sc",
            "(u_int32_t) ccb"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "AscAbortCCB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "3030-3058",
          "snippet": "int\nAscAbortCCB(sc, ccb)\n\tASC_SOFTC      *sc;\n\tu_int32_t       ccb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             retval;\n\tASC_SCSI_BIT_ID_TYPE saved_unit_not_ready;\n\n\n\tretval = -1;\n\tsaved_unit_not_ready = sc->unit_not_ready;\n\tsc->unit_not_ready = 0xFF;\n\tAscWaitISRDone(sc);\n\tif (AscStopQueueExe(iot, ioh) == 1) {\n\t\tif (AscRiscHaltedAbortCCB(sc, ccb) == 1) {\n\t\t\tretval = 1;\n\t\t\tAscCleanUpBusyQueue(iot, ioh);\n\t\t\tAscStartQueueExe(iot, ioh);\n\t\t} else {\n\t\t\tretval = 0;\n\t\t\tAscStartQueueExe(iot, ioh);\n\t\t}\n\t}\n\tsc->unit_not_ready = saved_unit_not_ready;\n\n\treturn (retval);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int AscWaitISRDone",
            "static int AscStopQueueExe",
            "static void AscStartQueueExe",
            "static void AscCleanUpBusyQueue",
            "static int AscRiscHaltedAbortCCB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int AscWaitISRDone;\nstatic int AscStopQueueExe;\nstatic void AscStartQueueExe;\nstatic void AscCleanUpBusyQueue;\nstatic int AscRiscHaltedAbortCCB;\n\nint\nAscAbortCCB(sc, ccb)\n\tASC_SOFTC      *sc;\n\tu_int32_t       ccb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             retval;\n\tASC_SCSI_BIT_ID_TYPE saved_unit_not_ready;\n\n\n\tretval = -1;\n\tsaved_unit_not_ready = sc->unit_not_ready;\n\tsc->unit_not_ready = 0xFF;\n\tAscWaitISRDone(sc);\n\tif (AscStopQueueExe(iot, ioh) == 1) {\n\t\tif (AscRiscHaltedAbortCCB(sc, ccb) == 1) {\n\t\t\tretval = 1;\n\t\t\tAscCleanUpBusyQueue(iot, ioh);\n\t\t\tAscStartQueueExe(iot, ioh);\n\t\t} else {\n\t\t\tretval = 0;\n\t\t\tAscStartQueueExe(iot, ioh);\n\t\t}\n\t}\n\tsc->unit_not_ready = saved_unit_not_ready;\n\n\treturn (retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscResetBus",
          "args": [
            "sc"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "AscResetBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "3219-3255",
          "snippet": "int\nAscResetBus(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             retval;\n\tint             i;\n\n\n\tsc->unit_not_ready = 0xFF;\n\tretval = ASC_NOERROR;\n\n\tAscWaitISRDone(sc);\n\tAscStopQueueExe(iot, ioh);\n\tsc->sdtr_done = 0;\n\tAscResetChipAndScsiBus(iot, ioh);\n\tDvcSleepMilliSecond((u_long) ((u_int16_t) sc->scsi_reset_wait * 1000));\n\tAscReInitLram(sc);\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->cur_dvc_qng[i] = 0;\n\t\tif (sc->pci_fix_asyn_xfer & (ASC_SCSI_BIT_ID_TYPE) (0x01 << i))\n\t\t\tAscSetChipSynRegAtID(iot, ioh, i, ASYN_SDTR_DATA_FIX_PCI_REV_AB);\n\t}\n\n\tASC_SET_PC_ADDR(iot, ioh, ASC_MCODE_START_ADDR);\n\tif (ASC_GET_PC_ADDR(iot, ioh) != ASC_MCODE_START_ADDR)\n\t\tretval = ASC_ERROR;\n\n\tif (AscStartChip(iot, ioh) == 0)\n\t\tretval = ASC_ERROR;\n\n\tAscStartQueueExe(iot, ioh);\n\tsc->unit_not_ready = 0;\n\tsc->queue_full_or_busy = 0;\n\treturn (retval);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int AscResetChipAndScsiBus",
            "static int AscStartChip",
            "static int AscSetChipSynRegAtID",
            "static int AscWaitISRDone",
            "static int AscStopQueueExe",
            "static void AscStartQueueExe",
            "static void DvcSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int AscResetChipAndScsiBus;\nstatic int AscStartChip;\nstatic int AscSetChipSynRegAtID;\nstatic int AscWaitISRDone;\nstatic int AscStopQueueExe;\nstatic void AscStartQueueExe;\nstatic void DvcSleepMilliSecond;\n\nint\nAscResetBus(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             retval;\n\tint             i;\n\n\n\tsc->unit_not_ready = 0xFF;\n\tretval = ASC_NOERROR;\n\n\tAscWaitISRDone(sc);\n\tAscStopQueueExe(iot, ioh);\n\tsc->sdtr_done = 0;\n\tAscResetChipAndScsiBus(iot, ioh);\n\tDvcSleepMilliSecond((u_long) ((u_int16_t) sc->scsi_reset_wait * 1000));\n\tAscReInitLram(sc);\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->cur_dvc_qng[i] = 0;\n\t\tif (sc->pci_fix_asyn_xfer & (ASC_SCSI_BIT_ID_TYPE) (0x01 << i))\n\t\t\tAscSetChipSynRegAtID(iot, ioh, i, ASYN_SDTR_DATA_FIX_PCI_REV_AB);\n\t}\n\n\tASC_SET_PC_ADDR(iot, ioh, ASC_MCODE_START_ADDR);\n\tif (ASC_GET_PC_ADDR(iot, ioh) != ASC_MCODE_START_ADDR)\n\t\tretval = ASC_ERROR;\n\n\tif (AscStartChip(iot, ioh) == 0)\n\t\tretval = ASC_ERROR;\n\n\tAscStartQueueExe(iot, ioh);\n\tsc->unit_not_ready = 0;\n\tsc->queue_full_or_busy = 0;\n\treturn (retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */\n\nstatic void adv_queue_ccb;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "adv_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "874-890",
    "snippet": "static int\nadv_poll(sc, xs, count)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadv_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adv_poll",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adv_intr",
          "args": [
            "sc"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "adv_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "834-868",
          "snippet": "int\nadv_intr(arg)\n\tvoid           *arg;\n{\n\tASC_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n#ifdef ASC_DEBUG\n\tint int_pend = FALSE;\n\n\tif(ASC_IS_INT_PENDING(sc->sc_iot, sc->sc_ioh))\n\t{\n\t\tint_pend = TRUE;\n\t\tprintf(\"ISR - \");\n\t}\n#endif\n\tAscISR(sc);\n#ifdef ASC_DEBUG\n\tif(int_pend)\n\t\tprintf(\"\\n\");\n#endif\n\n\t/*\n         * If there are queue entries in the software queue, try to\n         * run the first one.  We should be more or less guaranteed\n         * to succeed, since we just freed a CCB.\n         *\n         * NOTE: adv_scsi_cmd() relies on our calling it with\n         * the first entry in the queue.\n         */\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t(void) adv_scsi_cmd(xs);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adv_scsi_cmd",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_scsi_cmd;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nint\nadv_intr(arg)\n\tvoid           *arg;\n{\n\tASC_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n#ifdef ASC_DEBUG\n\tint int_pend = FALSE;\n\n\tif(ASC_IS_INT_PENDING(sc->sc_iot, sc->sc_ioh))\n\t{\n\t\tint_pend = TRUE;\n\t\tprintf(\"ISR - \");\n\t}\n#endif\n\tAscISR(sc);\n#ifdef ASC_DEBUG\n\tif(int_pend)\n\t\tprintf(\"\\n\");\n#endif\n\n\t/*\n         * If there are queue entries in the software queue, try to\n         * run the first one.  We should be more or less guaranteed\n         * to succeed, since we just freed a CCB.\n         *\n         * NOTE: adv_scsi_cmd() relies on our calling it with\n         * the first entry in the queue.\n         */\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t(void) adv_scsi_cmd(xs);\n\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_poll;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic int\nadv_poll(sc, xs, count)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadv_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "adv_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "834-868",
    "snippet": "int\nadv_intr(arg)\n\tvoid           *arg;\n{\n\tASC_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n#ifdef ASC_DEBUG\n\tint int_pend = FALSE;\n\n\tif(ASC_IS_INT_PENDING(sc->sc_iot, sc->sc_ioh))\n\t{\n\t\tint_pend = TRUE;\n\t\tprintf(\"ISR - \");\n\t}\n#endif\n\tAscISR(sc);\n#ifdef ASC_DEBUG\n\tif(int_pend)\n\t\tprintf(\"\\n\");\n#endif\n\n\t/*\n         * If there are queue entries in the software queue, try to\n         * run the first one.  We should be more or less guaranteed\n         * to succeed, since we just freed a CCB.\n         *\n         * NOTE: adv_scsi_cmd() relies on our calling it with\n         * the first entry in the queue.\n         */\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t(void) adv_scsi_cmd(xs);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adv_scsi_cmd",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adv_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "adv_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "633-831",
          "snippet": "static int\nadv_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb;\n\tint             s, flags, error, nsegs;\n\tint             fromqueue = 1, dontqueue = 0;\n\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adv_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adv_dequeue(sc);\n\t\tfromqueue = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadv_enqueue(sc, xs, 0);\n\t\t\txs = adv_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif ((ccb = adv_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadv_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n         * Build up the request\n         */\n\tmemset(&ccb->scsiq, 0, sizeof(ASC_SCSI_Q));\n\n\tccb->scsiq.q2.ccb_ptr = (ulong) ccb;\n\n\tccb->scsiq.cdbptr = &xs->cmd->opcode;\n\tccb->scsiq.q2.cdb_len = xs->cmdlen;\n\tccb->scsiq.q1.target_id = ASC_TID_TO_TARGET_ID(sc_link->target);\n\tccb->scsiq.q1.target_lun = sc_link->lun;\n\tccb->scsiq.q2.target_ix = ASC_TIDLUN_TO_IX(sc_link->target,\n\t\t\t\t\t\t   sc_link->lun);\n\tccb->scsiq.q1.sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADV_CCB_OFF(ccb) + offsetof(struct adv_ccb, scsi_sense);\n\tccb->scsiq.q1.sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n         * If  there  are  any  outstanding  requests  for  the  current target,\n         * then  every  255th request  send an  ORDERED request.  This heuristic\n         * tries  to  retain  the  benefit  of request  sorting while preventing\n         * request starvation. 255 is the max number of tags or pending commands\n         * a device may have outstanding.\n         */\n\tsc->reqcnt[sc_link->target]++;\n\tif ((sc->reqcnt[sc_link->target] > 0) &&\n\t    (sc->reqcnt[sc_link->target] % 255) == 0) {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_ORDERED;\n\t} else {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_SIMPLE;\n\t}\n\n\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\t  ccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t\t\t    (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t\t\t(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ASC_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadv_free_ccb(sc, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t      (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\n\n\t\tmemset(&ccb->sghead, 0, sizeof(ASC_SG_HEAD));\n\n\t\tfor (nsegs = 0; nsegs < ccb->dmamap_xfer->dm_nsegs; nsegs++) {\n\n\t\t\tccb->sghead.sg_list[nsegs].addr =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_addr;\n\t\t\tccb->sghead.sg_list[nsegs].bytes =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_len;\n\t\t}\n\n\t\tccb->sghead.entry_cnt = ccb->scsiq.q1.sg_queue_cnt =\n\t\t\tccb->dmamap_xfer->dm_nsegs;\n\n\t\tccb->scsiq.q1.cntl |= ASC_QC_SG_HEAD;\n\t\tccb->scsiq.sg_head = &ccb->sghead;\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t}\n\n#ifdef ASC_DEBUG\n\tprintf(\"id = %d, lun = %d, cmd = %d, ccb = 0x%lX \\n\",\n\t\t\tsc_link->scsipi_scsi.target,\n\t\t\tsc_link->scsipi_scsi.lun, xs->cmd->opcode,\n\t\t\t(unsigned long)ccb);\n#endif\n\ts = splbio();\n\tadv_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n         * Usually return SUCCESSFULLY QUEUED\n         */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n         * If we can't use interrupts, poll on completion\n         */\n\tif (adv_poll(sc, xs, ccb->timeout)) {\n\t\tadv_timeout(ccb);\n\t\tif (adv_poll(sc, xs, ccb->timeout))\n\t\t\tadv_timeout(ccb);\n\t}\n\treturn (COMPLETE);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_enqueue",
            "static struct scsi_xfer *adv_dequeue",
            "static void adv_free_ccb",
            "static ADV_CCB *adv_get_ccb",
            "static void adv_queue_ccb",
            "static int adv_scsi_cmd",
            "static int adv_poll",
            "static void adv_timeout",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;",
            "bus_dma_tag_t   dmat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_enqueue;\nstatic struct scsi_xfer *adv_dequeue;\nstatic void adv_free_ccb;\nstatic ADV_CCB *adv_get_ccb;\nstatic void adv_queue_ccb;\nstatic int adv_scsi_cmd;\nstatic int adv_poll;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\nbus_dma_tag_t   dmat;\n\nstatic int\nadv_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb;\n\tint             s, flags, error, nsegs;\n\tint             fromqueue = 1, dontqueue = 0;\n\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adv_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adv_dequeue(sc);\n\t\tfromqueue = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadv_enqueue(sc, xs, 0);\n\t\t\txs = adv_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif ((ccb = adv_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadv_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n         * Build up the request\n         */\n\tmemset(&ccb->scsiq, 0, sizeof(ASC_SCSI_Q));\n\n\tccb->scsiq.q2.ccb_ptr = (ulong) ccb;\n\n\tccb->scsiq.cdbptr = &xs->cmd->opcode;\n\tccb->scsiq.q2.cdb_len = xs->cmdlen;\n\tccb->scsiq.q1.target_id = ASC_TID_TO_TARGET_ID(sc_link->target);\n\tccb->scsiq.q1.target_lun = sc_link->lun;\n\tccb->scsiq.q2.target_ix = ASC_TIDLUN_TO_IX(sc_link->target,\n\t\t\t\t\t\t   sc_link->lun);\n\tccb->scsiq.q1.sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADV_CCB_OFF(ccb) + offsetof(struct adv_ccb, scsi_sense);\n\tccb->scsiq.q1.sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n         * If  there  are  any  outstanding  requests  for  the  current target,\n         * then  every  255th request  send an  ORDERED request.  This heuristic\n         * tries  to  retain  the  benefit  of request  sorting while preventing\n         * request starvation. 255 is the max number of tags or pending commands\n         * a device may have outstanding.\n         */\n\tsc->reqcnt[sc_link->target]++;\n\tif ((sc->reqcnt[sc_link->target] > 0) &&\n\t    (sc->reqcnt[sc_link->target] % 255) == 0) {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_ORDERED;\n\t} else {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_SIMPLE;\n\t}\n\n\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\t  ccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t\t\t    (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t\t\t(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ASC_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadv_free_ccb(sc, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t      (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\n\n\t\tmemset(&ccb->sghead, 0, sizeof(ASC_SG_HEAD));\n\n\t\tfor (nsegs = 0; nsegs < ccb->dmamap_xfer->dm_nsegs; nsegs++) {\n\n\t\t\tccb->sghead.sg_list[nsegs].addr =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_addr;\n\t\t\tccb->sghead.sg_list[nsegs].bytes =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_len;\n\t\t}\n\n\t\tccb->sghead.entry_cnt = ccb->scsiq.q1.sg_queue_cnt =\n\t\t\tccb->dmamap_xfer->dm_nsegs;\n\n\t\tccb->scsiq.q1.cntl |= ASC_QC_SG_HEAD;\n\t\tccb->scsiq.sg_head = &ccb->sghead;\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t}\n\n#ifdef ASC_DEBUG\n\tprintf(\"id = %d, lun = %d, cmd = %d, ccb = 0x%lX \\n\",\n\t\t\tsc_link->scsipi_scsi.target,\n\t\t\tsc_link->scsipi_scsi.lun, xs->cmd->opcode,\n\t\t\t(unsigned long)ccb);\n#endif\n\ts = splbio();\n\tadv_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n         * Usually return SUCCESSFULLY QUEUED\n         */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n         * If we can't use interrupts, poll on completion\n         */\n\tif (adv_poll(sc, xs, ccb->timeout)) {\n\t\tadv_timeout(ccb);\n\t\tif (adv_poll(sc, xs, ccb->timeout))\n\t\t\tadv_timeout(ccb);\n\t}\n\treturn (COMPLETE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscISR",
          "args": [
            "sc"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "AscISR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "1625-1695",
          "snippet": "int\nAscISR(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t       chipstat;\n\tu_int16_t       saved_ram_addr;\n\tu_int8_t        ctrl_reg;\n\tu_int8_t        saved_ctrl_reg;\n\tint             int_pending;\n\tint             status;\n\tu_int8_t        host_flag;\n\n\n\tint_pending = FALSE;\n\n\tctrl_reg = ASC_GET_CHIP_CONTROL(iot, ioh);\n\tsaved_ctrl_reg = ctrl_reg & (~(ASC_CC_SCSI_RESET | ASC_CC_CHIP_RESET |\n\t\t\t   ASC_CC_SINGLE_STEP | ASC_CC_DIAG | ASC_CC_TEST));\n\tchipstat = ASC_GET_CHIP_STATUS(iot, ioh);\n\tif (chipstat & ASC_CSW_SCSI_RESET_LATCH) {\n\t\tif (!(sc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {\n\t\t\tint_pending = TRUE;\n\t\t\tsc->sdtr_done = 0;\n\t\t\tsaved_ctrl_reg &= (u_int8_t) (~ASC_CC_HALT);\n\n\t\t\twhile (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_SCSI_RESET_ACTIVE);\n\n\t\t\tASC_SET_CHIP_CONTROL(iot, ioh, (ASC_CC_CHIP_RESET | ASC_CC_HALT));\n\t\t\tASC_SET_CHIP_CONTROL(iot, ioh, ASC_CC_HALT);\n\t\t\tASC_SET_CHIP_STATUS(iot, ioh, ASC_CIW_CLR_SCSI_RESET_INT);\n\t\t\tASC_SET_CHIP_STATUS(iot, ioh, 0);\n\t\t\tchipstat = ASC_GET_CHIP_STATUS(iot, ioh);\n\t\t}\n\t}\n\tsaved_ram_addr = ASC_GET_CHIP_LRAM_ADDR(iot, ioh);\n\thost_flag = AscReadLramByte(iot, ioh, ASCV_HOST_FLAG_B) &\n\t\t(u_int8_t) (~ASC_HOST_FLAG_IN_ISR);\n\tAscWriteLramByte(iot, ioh, ASCV_HOST_FLAG_B,\n\t\t\t (host_flag | ASC_HOST_FLAG_IN_ISR));\n\n\tif ((chipstat & ASC_CSW_INT_PENDING) || (int_pending)) {\n\t\tAscAckInterrupt(iot, ioh);\n\t\tint_pending = TRUE;\n\n\t\tif ((chipstat & ASC_CSW_HALTED) &&\n\t\t    (ctrl_reg & ASC_CC_SINGLE_STEP)) {\n\t\t\tAscIsrChipHalted(sc);\n\t\t\tsaved_ctrl_reg &= ~ASC_CC_HALT;\n\t\t} else {\n\t\t\tif (sc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) {\n\t\t\t\twhile (((status = AscIsrQDone(sc)) & 0x01) != 0);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif ((status = AscIsrQDone(sc)) == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while (status == 0x11);\n\t\t\t}\n\n\t\t\tif (status & 0x80)\n\t\t\t\tint_pending = -1;\n\t\t}\n\t}\n\tAscWriteLramByte(iot, ioh, ASCV_HOST_FLAG_B, host_flag);\n\tASC_SET_CHIP_LRAM_ADDR(iot, ioh, saved_ram_addr);\n\tASC_SET_CHIP_CONTROL(iot, ioh, saved_ctrl_reg);\n\n\treturn (1);\n\t/* return(int_pending); */\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int8_t AscReadLramByte",
            "static void AscWriteLramByte",
            "static void AscIsrChipHalted",
            "static int AscIsrQDone",
            "static void AscAckInterrupt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int8_t AscReadLramByte;\nstatic void AscWriteLramByte;\nstatic void AscIsrChipHalted;\nstatic int AscIsrQDone;\nstatic void AscAckInterrupt;\n\nint\nAscISR(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t       chipstat;\n\tu_int16_t       saved_ram_addr;\n\tu_int8_t        ctrl_reg;\n\tu_int8_t        saved_ctrl_reg;\n\tint             int_pending;\n\tint             status;\n\tu_int8_t        host_flag;\n\n\n\tint_pending = FALSE;\n\n\tctrl_reg = ASC_GET_CHIP_CONTROL(iot, ioh);\n\tsaved_ctrl_reg = ctrl_reg & (~(ASC_CC_SCSI_RESET | ASC_CC_CHIP_RESET |\n\t\t\t   ASC_CC_SINGLE_STEP | ASC_CC_DIAG | ASC_CC_TEST));\n\tchipstat = ASC_GET_CHIP_STATUS(iot, ioh);\n\tif (chipstat & ASC_CSW_SCSI_RESET_LATCH) {\n\t\tif (!(sc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {\n\t\t\tint_pending = TRUE;\n\t\t\tsc->sdtr_done = 0;\n\t\t\tsaved_ctrl_reg &= (u_int8_t) (~ASC_CC_HALT);\n\n\t\t\twhile (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_SCSI_RESET_ACTIVE);\n\n\t\t\tASC_SET_CHIP_CONTROL(iot, ioh, (ASC_CC_CHIP_RESET | ASC_CC_HALT));\n\t\t\tASC_SET_CHIP_CONTROL(iot, ioh, ASC_CC_HALT);\n\t\t\tASC_SET_CHIP_STATUS(iot, ioh, ASC_CIW_CLR_SCSI_RESET_INT);\n\t\t\tASC_SET_CHIP_STATUS(iot, ioh, 0);\n\t\t\tchipstat = ASC_GET_CHIP_STATUS(iot, ioh);\n\t\t}\n\t}\n\tsaved_ram_addr = ASC_GET_CHIP_LRAM_ADDR(iot, ioh);\n\thost_flag = AscReadLramByte(iot, ioh, ASCV_HOST_FLAG_B) &\n\t\t(u_int8_t) (~ASC_HOST_FLAG_IN_ISR);\n\tAscWriteLramByte(iot, ioh, ASCV_HOST_FLAG_B,\n\t\t\t (host_flag | ASC_HOST_FLAG_IN_ISR));\n\n\tif ((chipstat & ASC_CSW_INT_PENDING) || (int_pending)) {\n\t\tAscAckInterrupt(iot, ioh);\n\t\tint_pending = TRUE;\n\n\t\tif ((chipstat & ASC_CSW_HALTED) &&\n\t\t    (ctrl_reg & ASC_CC_SINGLE_STEP)) {\n\t\t\tAscIsrChipHalted(sc);\n\t\t\tsaved_ctrl_reg &= ~ASC_CC_HALT;\n\t\t} else {\n\t\t\tif (sc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) {\n\t\t\t\twhile (((status = AscIsrQDone(sc)) & 0x01) != 0);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif ((status = AscIsrQDone(sc)) == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while (status == 0x11);\n\t\t\t}\n\n\t\t\tif (status & 0x80)\n\t\t\t\tint_pending = -1;\n\t\t}\n\t}\n\tAscWriteLramByte(iot, ioh, ASCV_HOST_FLAG_B, host_flag);\n\tASC_SET_CHIP_LRAM_ADDR(iot, ioh, saved_ram_addr);\n\tASC_SET_CHIP_CONTROL(iot, ioh, saved_ctrl_reg);\n\n\treturn (1);\n\t/* return(int_pending); */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASC_IS_INT_PENDING",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_scsi_cmd;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nint\nadv_intr(arg)\n\tvoid           *arg;\n{\n\tASC_SOFTC      *sc = arg;\n\tstruct scsi_xfer *xs;\n\n#ifdef ASC_DEBUG\n\tint int_pend = FALSE;\n\n\tif(ASC_IS_INT_PENDING(sc->sc_iot, sc->sc_ioh))\n\t{\n\t\tint_pend = TRUE;\n\t\tprintf(\"ISR - \");\n\t}\n#endif\n\tAscISR(sc);\n#ifdef ASC_DEBUG\n\tif(int_pend)\n\t\tprintf(\"\\n\");\n#endif\n\n\t/*\n         * If there are queue entries in the software queue, try to\n         * run the first one.  We should be more or less guaranteed\n         * to succeed, since we just freed a CCB.\n         *\n         * NOTE: adv_scsi_cmd() relies on our calling it with\n         * the first entry in the queue.\n         */\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n\t\t(void) adv_scsi_cmd(xs);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "adv_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "633-831",
    "snippet": "static int\nadv_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb;\n\tint             s, flags, error, nsegs;\n\tint             fromqueue = 1, dontqueue = 0;\n\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adv_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adv_dequeue(sc);\n\t\tfromqueue = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadv_enqueue(sc, xs, 0);\n\t\t\txs = adv_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif ((ccb = adv_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadv_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n         * Build up the request\n         */\n\tmemset(&ccb->scsiq, 0, sizeof(ASC_SCSI_Q));\n\n\tccb->scsiq.q2.ccb_ptr = (ulong) ccb;\n\n\tccb->scsiq.cdbptr = &xs->cmd->opcode;\n\tccb->scsiq.q2.cdb_len = xs->cmdlen;\n\tccb->scsiq.q1.target_id = ASC_TID_TO_TARGET_ID(sc_link->target);\n\tccb->scsiq.q1.target_lun = sc_link->lun;\n\tccb->scsiq.q2.target_ix = ASC_TIDLUN_TO_IX(sc_link->target,\n\t\t\t\t\t\t   sc_link->lun);\n\tccb->scsiq.q1.sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADV_CCB_OFF(ccb) + offsetof(struct adv_ccb, scsi_sense);\n\tccb->scsiq.q1.sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n         * If  there  are  any  outstanding  requests  for  the  current target,\n         * then  every  255th request  send an  ORDERED request.  This heuristic\n         * tries  to  retain  the  benefit  of request  sorting while preventing\n         * request starvation. 255 is the max number of tags or pending commands\n         * a device may have outstanding.\n         */\n\tsc->reqcnt[sc_link->target]++;\n\tif ((sc->reqcnt[sc_link->target] > 0) &&\n\t    (sc->reqcnt[sc_link->target] % 255) == 0) {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_ORDERED;\n\t} else {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_SIMPLE;\n\t}\n\n\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\t  ccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t\t\t    (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t\t\t(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ASC_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadv_free_ccb(sc, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t      (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\n\n\t\tmemset(&ccb->sghead, 0, sizeof(ASC_SG_HEAD));\n\n\t\tfor (nsegs = 0; nsegs < ccb->dmamap_xfer->dm_nsegs; nsegs++) {\n\n\t\t\tccb->sghead.sg_list[nsegs].addr =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_addr;\n\t\t\tccb->sghead.sg_list[nsegs].bytes =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_len;\n\t\t}\n\n\t\tccb->sghead.entry_cnt = ccb->scsiq.q1.sg_queue_cnt =\n\t\t\tccb->dmamap_xfer->dm_nsegs;\n\n\t\tccb->scsiq.q1.cntl |= ASC_QC_SG_HEAD;\n\t\tccb->scsiq.sg_head = &ccb->sghead;\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t}\n\n#ifdef ASC_DEBUG\n\tprintf(\"id = %d, lun = %d, cmd = %d, ccb = 0x%lX \\n\",\n\t\t\tsc_link->scsipi_scsi.target,\n\t\t\tsc_link->scsipi_scsi.lun, xs->cmd->opcode,\n\t\t\t(unsigned long)ccb);\n#endif\n\ts = splbio();\n\tadv_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n         * Usually return SUCCESSFULLY QUEUED\n         */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n         * If we can't use interrupts, poll on completion\n         */\n\tif (adv_poll(sc, xs, ccb->timeout)) {\n\t\tadv_timeout(ccb);\n\t\tif (adv_poll(sc, xs, ccb->timeout))\n\t\t\tadv_timeout(ccb);\n\t}\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_enqueue",
      "static struct scsi_xfer *adv_dequeue",
      "static void adv_free_ccb",
      "static ADV_CCB *adv_get_ccb",
      "static void adv_queue_ccb",
      "static int adv_scsi_cmd",
      "static int adv_poll",
      "static void adv_timeout",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;",
      "bus_dma_tag_t   dmat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adv_timeout",
          "args": [
            "ccb"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "adv_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "893-931",
          "snippet": "static void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "static void adv_queue_ccb",
            "static void adv_timeout",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */\n\nstatic void adv_queue_ccb;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adv_poll",
          "args": [
            "sc",
            "xs",
            "ccb->timeout"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "adv_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "874-890",
          "snippet": "static int\nadv_poll(sc, xs, count)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadv_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adv_poll",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_poll;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic int\nadv_poll(sc, xs, count)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             count;\n{\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\tadv_intr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn (0);\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "adv_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "355-364",
          "snippet": "static void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_queue_ccb",
            "static void adv_start_ccbs",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_queue_ccb;\nstatic void adv_start_ccbs;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"id = %d, lun = %d, cmd = %d, ccb = 0x%lX \\n\"",
            "sc_link->scsipi_scsi.target",
            "sc_link->scsipi_scsi.lun",
            "xs->cmd->opcode",
            "(unsigned long)ccb"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ccb->sghead",
            "0",
            "sizeof(ASC_SG_HEAD)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t\t\tBUS_DMASYNC_PREWRITE"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "adv_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "257-277",
          "snippet": "static void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_free_ccb",
            "static void adv_reset_ccb",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_free_ccb;\nstatic void adv_reset_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "xs->data",
            "xs->datalen",
            "NULL",
            "(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load_uio",
          "args": [
            "dmat",
            "ccb->dmamap_xfer",
            "(struct uio *) xs->data",
            "(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADV_CCB_OFF",
          "args": [
            "ccb"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TIDLUN_TO_IX",
          "args": [
            "sc_link->target",
            "sc_link->lun"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_TID_TO_TARGET_ID",
          "args": [
            "sc_link->target"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ccb->scsiq",
            "0",
            "sizeof(ASC_SCSI_Q)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_enqueue",
          "args": [
            "sc",
            "xs",
            "fromqueue"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "adv_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "140-155",
          "snippet": "static void\nadv_enqueue(sc, xs, infront)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_enqueue",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_enqueue;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_enqueue(sc, xs, infront)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_get_ccb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_dequeue",
          "args": [
            "sc"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_dequeue",
          "args": [
            "sc"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_enqueue;\nstatic struct scsi_xfer *adv_dequeue;\nstatic void adv_free_ccb;\nstatic ADV_CCB *adv_get_ccb;\nstatic void adv_queue_ccb;\nstatic int adv_scsi_cmd;\nstatic int adv_poll;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\nbus_dma_tag_t   dmat;\n\nstatic int\nadv_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tbus_dma_tag_t   dmat = sc->sc_dmat;\n\tADV_CCB        *ccb;\n\tint             s, flags, error, nsegs;\n\tint             fromqueue = 1, dontqueue = 0;\n\n\n\ts = splbio();\t\t/* protect the queue */\n\n\t/*\n         * If we're running the queue from adv_done(), we've been\n         * called with the first queue entry as our argument.\n         */\n\tif (xs == sc->sc_queue.lh_first) {\n\t\txs = adv_dequeue(sc);\n\t\tfromqueue = 1;\n\t} else {\n\n\t\t/* Polled requests can't be queued for later. */\n\t\tdontqueue = xs->flags & SCSI_POLL;\n\n\t\t/*\n                 * If there are jobs in the queue, run them first.\n                 */\n\t\tif (sc->sc_queue.lh_first != NULL) {\n\t\t\t/*\n                         * If we can't queue, we have to abort, since\n                         * we have to preserve order.\n                         */\n\t\t\tif (dontqueue) {\n\t\t\t\tsplx(s);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\treturn (TRY_AGAIN_LATER);\n\t\t\t}\n\t\t\t/*\n                         * Swap with the first queue entry.\n                         */\n\t\t\tadv_enqueue(sc, xs, 0);\n\t\t\txs = adv_dequeue(sc);\n\t\t\tfromqueue = 1;\n\t\t}\n\t}\n\n\n\t/*\n         * get a ccb to use. If the transfer\n         * is from a buf (possibly from interrupt time)\n         * then we can't allow it to sleep\n         */\n\n\tflags = xs->flags;\n\tif ((ccb = adv_get_ccb(sc, flags)) == NULL) {\n\t\t/*\n                 * If we can't queue, we lose.\n                 */\n\t\tif (dontqueue) {\n\t\t\tsplx(s);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\t/*\n                 * Stuff ourselves into the queue, in front\n                 * if we came off in the first place.\n                 */\n\t\tadv_enqueue(sc, xs, fromqueue);\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tsplx(s);\t\t/* done playing with the queue */\n\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n         * Build up the request\n         */\n\tmemset(&ccb->scsiq, 0, sizeof(ASC_SCSI_Q));\n\n\tccb->scsiq.q2.ccb_ptr = (ulong) ccb;\n\n\tccb->scsiq.cdbptr = &xs->cmd->opcode;\n\tccb->scsiq.q2.cdb_len = xs->cmdlen;\n\tccb->scsiq.q1.target_id = ASC_TID_TO_TARGET_ID(sc_link->target);\n\tccb->scsiq.q1.target_lun = sc_link->lun;\n\tccb->scsiq.q2.target_ix = ASC_TIDLUN_TO_IX(sc_link->target,\n\t\t\t\t\t\t   sc_link->lun);\n\tccb->scsiq.q1.sense_addr = sc->sc_dmamap_control->dm_segs[0].ds_addr +\n\t\tADV_CCB_OFF(ccb) + offsetof(struct adv_ccb, scsi_sense);\n\tccb->scsiq.q1.sense_len = sizeof(struct scsi_sense_data);\n\n\t/*\n         * If  there  are  any  outstanding  requests  for  the  current target,\n         * then  every  255th request  send an  ORDERED request.  This heuristic\n         * tries  to  retain  the  benefit  of request  sorting while preventing\n         * request starvation. 255 is the max number of tags or pending commands\n         * a device may have outstanding.\n         */\n\tsc->reqcnt[sc_link->target]++;\n\tif ((sc->reqcnt[sc_link->target] > 0) &&\n\t    (sc->reqcnt[sc_link->target] % 255) == 0) {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_ORDERED;\n\t} else {\n\t\tccb->scsiq.q2.tag_code = M2_QTAG_MSG_SIMPLE;\n\t}\n\n\n\tif (xs->datalen) {\n\t\t/*\n                 * Map the DMA transfer.\n                 */\n#ifdef TFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\terror = bus_dmamap_load_uio(dmat,\n\t\t\t\t  ccb->dmamap_xfer, (struct uio *) xs->data,\n\t\t\t\t\t\t    (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t} else\n#endif\t\t\t\t/* TFS */\n\t\t{\n\t\t\terror = bus_dmamap_load(dmat,\n\t\t\t      ccb->dmamap_xfer, xs->data, xs->datalen, NULL,\n\t\t\t\t\t\t(flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\t\t}\n\n\t\tif (error) {\n\t\t\tif (error == EFBIG) {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, more than %d dma\"\n\t\t\t\t       \" segments\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, ASC_MAX_SG_LIST);\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: adv_scsi_cmd, error %d loading\"\n\t\t\t\t       \" dma map\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\t}\n\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tadv_free_ccb(sc, ccb);\n\t\t\treturn (COMPLETE);\n\t\t}\n\t\tbus_dmamap_sync(dmat, ccb->dmamap_xfer,\n\t\t\t      (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :\n\t\t\t\tBUS_DMASYNC_PREWRITE);\n\n\n\t\tmemset(&ccb->sghead, 0, sizeof(ASC_SG_HEAD));\n\n\t\tfor (nsegs = 0; nsegs < ccb->dmamap_xfer->dm_nsegs; nsegs++) {\n\n\t\t\tccb->sghead.sg_list[nsegs].addr =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_addr;\n\t\t\tccb->sghead.sg_list[nsegs].bytes =\n\t\t\t\tccb->dmamap_xfer->dm_segs[nsegs].ds_len;\n\t\t}\n\n\t\tccb->sghead.entry_cnt = ccb->scsiq.q1.sg_queue_cnt =\n\t\t\tccb->dmamap_xfer->dm_nsegs;\n\n\t\tccb->scsiq.q1.cntl |= ASC_QC_SG_HEAD;\n\t\tccb->scsiq.sg_head = &ccb->sghead;\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t} else {\n\t\t/*\n                 * No data xfer, use non S/G values.\n                 */\n\t\tccb->scsiq.q1.data_addr = 0;\n\t\tccb->scsiq.q1.data_cnt = 0;\n\t}\n\n#ifdef ASC_DEBUG\n\tprintf(\"id = %d, lun = %d, cmd = %d, ccb = 0x%lX \\n\",\n\t\t\tsc_link->scsipi_scsi.target,\n\t\t\tsc_link->scsipi_scsi.lun, xs->cmd->opcode,\n\t\t\t(unsigned long)ccb);\n#endif\n\ts = splbio();\n\tadv_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n         * Usually return SUCCESSFULLY QUEUED\n         */\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/*\n         * If we can't use interrupts, poll on completion\n         */\n\tif (adv_poll(sc, xs, ccb->timeout)) {\n\t\tadv_timeout(ccb);\n\t\tif (adv_poll(sc, xs, ccb->timeout))\n\t\t\tadv_timeout(ccb);\n\t}\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "advminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "618-626",
    "snippet": "static void\nadvminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void advminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "advminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "618-626",
          "snippet": "static void\nadvminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void advminphys;\n\nstatic void\nadvminphys(bp)\n\tstruct buf     *bp;\n{\n\n\tif (bp->b_bcount > ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE))\n\t\tbp->b_bcount = ((ASC_MAX_SG_LIST - 1) * PAGE_SIZE);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "adv_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "545-615",
    "snippet": "void\nadv_attach(sc)\n\tASC_SOFTC      *sc;\n{\n\tint             i, error;\n\n\t/*\n         * Initialize board RISC chip and enable interrupts.\n         */\n\tswitch (AscInitDriver(sc)) {\n\tcase 0:\n\t\t/* AllOK */\n\t\tbreak;\n\n\tcase 1:\n\t\tpanic(\"%s: bad signature\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase 2:\n\t\tpanic(\"%s: unable to load MicroCode\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase 3:\n\t\tpanic(\"%s: unable to initialize MicroCode\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"%s: unable to initialize board RISC chip\",\n\t\t      sc->sc_dev.dv_xname);\n\t}\n\n\n\t/*\n         * fill in the prototype scsi_link.\n         */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->chip_scsi_id;\n\tsc->sc_link.adapter = &adv_switch;\n\tsc->sc_link.device = &adv_dev;\n\tsc->sc_link.openings = 4;\n\tsc->sc_link.adapter_buswidth = 7;\n\n\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\tLIST_INIT(&sc->sc_queue);\n\n\n\t/*\n         * Allocate the Control Blocks.\n         */\n\terror = adv_alloc_ccbs(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\t/*\n         * Create and initialize the Control Blocks.\n         */\n\ti = adv_create_ccbs(sc, sc->sc_control->ccbs, ADV_MAX_CCB);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create control blocks\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADV_MAX_CCB) {\n\t\tprintf(\"%s: WARNING: only %d of %d control blocks created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADV_MAX_CCB);\n\t}\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adv_alloc_ccbs",
      "static int adv_create_ccbs",
      "struct scsi_adapter adv_switch =\n{\n\tadv_scsi_cmd,\t\t/* called to start/enqueue a SCSI command */\n\tadvminphys,\t\t/* to limit the transfer to max device can do */\n\t0,\t\t\t/* IT SEEMS IT IS NOT USED YET */\n\t0,\t\t\t/* as above... */\n};",
      "struct scsi_device adv_dev =\n{\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING: only %d of %d control blocks created\\n\"",
            "sc->sc_dev.dv_xname",
            "i",
            "ADV_MAX_CCB"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adv_create_ccbs",
          "args": [
            "sc",
            "sc->sc_control->ccbs",
            "ADV_MAX_CCB"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "adv_create_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "230-251",
          "snippet": "static int\nadv_create_ccbs(sc, ccbstore, count)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccbstore;\n\tint             count;\n{\n\tADV_CCB        *ccb;\n\tint             i, error;\n\n\tbzero(ccbstore, sizeof(ADV_CCB) * count);\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adv_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adv_create_ccbs",
            "static int adv_init_ccb",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_create_ccbs;\nstatic int adv_init_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_create_ccbs(sc, ccbstore, count)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccbstore;\n\tint             count;\n{\n\tADV_CCB        *ccb;\n\tint             i, error;\n\n\tbzero(ccbstore, sizeof(ADV_CCB) * count);\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adv_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adv_alloc_ccbs",
          "args": [
            "sc"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "adv_alloc_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "182-223",
          "snippet": "static int\nadv_alloc_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control blocks.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adv_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   1, sizeof(struct adv_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adv_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int adv_alloc_ccbs",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_alloc_ccbs;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_alloc_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control blocks.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adv_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   1, sizeof(struct adv_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adv_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->sc_queue"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_waiting_ccb"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: unable to initialize board RISC chip\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: unable to initialize MicroCode\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: unable to load MicroCode\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: bad signature\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AscInitDriver",
          "args": [
            "sc"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "AscInitDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "585-611",
          "snippet": "int\nAscInitDriver(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int32_t       chksum;\n\n\n\tif (!AscFindSignature(iot, ioh))\n\t\treturn (1);\n\n\tAscDisableInterrupt(iot, ioh);\n\n\tAscInitLram(sc);\n\tchksum = AscLoadMicroCode(iot, ioh, 0, (u_int16_t *) asc_mcode,\n\t\t\t\t  asc_mcode_size);\n\tif (chksum != asc_mcode_chksum)\n\t\treturn (2);\n\n\tif (AscInitMicroCodeVar(sc) == 0)\n\t\treturn (3);\n\n\tAscEnableInterrupt(iot, ioh);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int32_t AscLoadMicroCode",
            "static void AscInitLram",
            "static u_int16_t AscInitMicroCodeVar",
            "static void AscDisableInterrupt",
            "static void AscEnableInterrupt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int32_t AscLoadMicroCode;\nstatic void AscInitLram;\nstatic u_int16_t AscInitMicroCodeVar;\nstatic void AscDisableInterrupt;\nstatic void AscEnableInterrupt;\n\nint\nAscInitDriver(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int32_t       chksum;\n\n\n\tif (!AscFindSignature(iot, ioh))\n\t\treturn (1);\n\n\tAscDisableInterrupt(iot, ioh);\n\n\tAscInitLram(sc);\n\tchksum = AscLoadMicroCode(iot, ioh, 0, (u_int16_t *) asc_mcode,\n\t\t\t\t  asc_mcode_size);\n\tif (chksum != asc_mcode_chksum)\n\t\treturn (2);\n\n\tif (AscInitMicroCodeVar(sc) == 0)\n\t\treturn (3);\n\n\tAscEnableInterrupt(iot, ioh);\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_alloc_ccbs;\nstatic int adv_create_ccbs;\nstruct scsi_adapter adv_switch =\n{\n\tadv_scsi_cmd,\t\t/* called to start/enqueue a SCSI command */\n\tadvminphys,\t\t/* to limit the transfer to max device can do */\n\t0,\t\t\t/* IT SEEMS IT IS NOT USED YET */\n\t0,\t\t\t/* as above... */\n};\nstruct scsi_device adv_dev =\n{\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nvoid\nadv_attach(sc)\n\tASC_SOFTC      *sc;\n{\n\tint             i, error;\n\n\t/*\n         * Initialize board RISC chip and enable interrupts.\n         */\n\tswitch (AscInitDriver(sc)) {\n\tcase 0:\n\t\t/* AllOK */\n\t\tbreak;\n\n\tcase 1:\n\t\tpanic(\"%s: bad signature\", sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase 2:\n\t\tpanic(\"%s: unable to load MicroCode\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tcase 3:\n\t\tpanic(\"%s: unable to initialize MicroCode\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tbreak;\n\n\tdefault:\n\t\tpanic(\"%s: unable to initialize board RISC chip\",\n\t\t      sc->sc_dev.dv_xname);\n\t}\n\n\n\t/*\n         * fill in the prototype scsi_link.\n         */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->chip_scsi_id;\n\tsc->sc_link.adapter = &adv_switch;\n\tsc->sc_link.device = &adv_dev;\n\tsc->sc_link.openings = 4;\n\tsc->sc_link.adapter_buswidth = 7;\n\n\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\tLIST_INIT(&sc->sc_queue);\n\n\n\t/*\n         * Allocate the Control Blocks.\n         */\n\terror = adv_alloc_ccbs(sc);\n\tif (error)\n\t\treturn; /* (error) */ ;\n\n\t/*\n         * Create and initialize the Control Blocks.\n         */\n\ti = adv_create_ccbs(sc, sc->sc_control->ccbs, ADV_MAX_CCB);\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create control blocks\\n\",\n\t\t       sc->sc_dev.dv_xname);\n\t\treturn; /* (ENOMEM) */ ;\n\t} else if (i != ADV_MAX_CCB) {\n\t\tprintf(\"%s: WARNING: only %d of %d control blocks created\\n\",\n\t\t       sc->sc_dev.dv_xname, i, ADV_MAX_CCB);\n\t}\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n}"
  },
  {
    "function_name": "adv_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "462-542",
    "snippet": "int\nadv_init(sc)\n\tASC_SOFTC      *sc;\n{\n\tint             warn;\n\n\tif (!AscFindSignature(sc->sc_iot, sc->sc_ioh))\n\t\tpanic(\"adv_init: adv_find_signature failed\");\n\n\t/*\n         * Read the board configuration\n         */\n\tAscInitASC_SOFTC(sc);\n\twarn = AscInitFromEEP(sc);\n\tif (warn) {\n\t\tprintf(\"%s -get: \", sc->sc_dev.dv_xname);\n\t\tswitch (warn) {\n\t\tcase -1:\n\t\t\tprintf(\"Chip is not halted\\n\");\n\t\t\tbreak;\n\n\t\tcase -2:\n\t\t\tprintf(\"Couldn't get MicroCode Start\"\n\t\t\t       \" address\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\t\tprintf(\"I/O port address modified\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_AUTO_CONFIG:\n\t\t\tprintf(\"I/O port increment switch enabled\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\t\tprintf(\"EEPROM checksum error\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_IRQ_MODIFIED:\n\t\t\tprintf(\"IRQ modified\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\t\tprintf(\"tag queuing enabled w/o disconnects\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"unknown warning %d\\n\", warn);\n\t\t}\n\t}\n\tif (sc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)\n\t\tsc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;\n\n\t/*\n         * Modify the board configuration\n         */\n\twarn = AscInitFromASC_SOFTC(sc);\n\tif (warn) {\n\t\tprintf(\"%s -set: \", sc->sc_dev.dv_xname);\n\t\tswitch (warn) {\n\t\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\t\tprintf(\"tag queuing enabled w/o disconnects\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_AUTO_CONFIG:\n\t\t\tprintf(\"I/O port increment switch enabled\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"unknown warning %d\\n\", warn);\n\t\t}\n\t}\n\tsc->isr_callback = (ulong) adv_narrow_isr_callback;\n\n\tif (!(sc->overrun_buf = adv_alloc_overrunbuf(sc->sc_dev.dv_xname,\n\t\t\t\t\t\t     sc->sc_dmat))) {\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int8_t *adv_alloc_overrunbuf",
      "static void adv_narrow_isr_callback",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adv_alloc_overrunbuf",
          "args": [
            "sc->sc_dev.dv_xname",
            "sc->sc_dmat"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unknown warning %d\\n\"",
            "warn"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscInitFromASC_SOFTC",
          "args": [
            "sc"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "AscInitFromASC_SOFTC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "523-576",
          "snippet": "u_int16_t\nAscInitFromASC_SOFTC(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t       cfg_msw;\n\tu_int16_t       warn_code;\n\tu_int16_t       pci_device_id = sc->pci_device_id;\n\n\n\twarn_code = 0;\n\tcfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t}\n\tif ((sc->cmd_qng_enabled & sc->disc_enable) != sc->cmd_qng_enabled) {\n\t\tsc->disc_enable = sc->cmd_qng_enabled;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t}\n\tif ((sc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {\n\t\tAscSetChipIRQ(iot, ioh, sc->irq_no, sc->bus_type);\n\t}\n\tif (sc->bus_type & ASC_IS_PCI) {\n\t\tcfg_msw &= 0xFFC0;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\n\t\tif ((sc->bus_type & ASC_IS_PCI_ULTRA) != ASC_IS_PCI_ULTRA) {\n\t\t\tif ((pci_device_id == ASC_PCI_DEVICE_ID_REV_A) ||\n\t\t\t    (pci_device_id == ASC_PCI_DEVICE_ID_REV_B)) {\n\t\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;\n\t\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t\t}\n\t\t}\n\t} else if (sc->bus_type == ASC_IS_ISAPNP) {\n\t\tif (AscGetChipVersion(iot, ioh, sc->bus_type) ==\n\t\t    ASC_CHIP_VER_ASYN_BUG) {\n\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t}\n\t}\n\tAscSetChipScsiID(iot, ioh, sc->chip_scsi_id);\n\n\tif (sc->bus_type & ASC_IS_ISA) {\n\t\tAscSetIsaDmaChannel(iot, ioh, sc->isa_dma_channel);\n\t\tAscSetIsaDmaSpeed(iot, ioh, sc->isa_dma_speed);\n\t}\n\treturn (warn_code);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int8_t AscSetChipScsiID",
            "static u_int8_t AscGetChipVersion",
            "static u_int8_t AscSetChipIRQ",
            "static u_int16_t AscSetIsaDmaChannel",
            "static u_int8_t AscSetIsaDmaSpeed"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int8_t AscSetChipScsiID;\nstatic u_int8_t AscGetChipVersion;\nstatic u_int8_t AscSetChipIRQ;\nstatic u_int16_t AscSetIsaDmaChannel;\nstatic u_int8_t AscSetIsaDmaSpeed;\n\nu_int16_t\nAscInitFromASC_SOFTC(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tu_int16_t       cfg_msw;\n\tu_int16_t       warn_code;\n\tu_int16_t       pci_device_id = sc->pci_device_id;\n\n\n\twarn_code = 0;\n\tcfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t}\n\tif ((sc->cmd_qng_enabled & sc->disc_enable) != sc->cmd_qng_enabled) {\n\t\tsc->disc_enable = sc->cmd_qng_enabled;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t}\n\tif ((sc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {\n\t\tAscSetChipIRQ(iot, ioh, sc->irq_no, sc->bus_type);\n\t}\n\tif (sc->bus_type & ASC_IS_PCI) {\n\t\tcfg_msw &= 0xFFC0;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\n\t\tif ((sc->bus_type & ASC_IS_PCI_ULTRA) != ASC_IS_PCI_ULTRA) {\n\t\t\tif ((pci_device_id == ASC_PCI_DEVICE_ID_REV_A) ||\n\t\t\t    (pci_device_id == ASC_PCI_DEVICE_ID_REV_B)) {\n\t\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;\n\t\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t\t}\n\t\t}\n\t} else if (sc->bus_type == ASC_IS_ISAPNP) {\n\t\tif (AscGetChipVersion(iot, ioh, sc->bus_type) ==\n\t\t    ASC_CHIP_VER_ASYN_BUG) {\n\t\t\tsc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t}\n\t}\n\tAscSetChipScsiID(iot, ioh, sc->chip_scsi_id);\n\n\tif (sc->bus_type & ASC_IS_ISA) {\n\t\tAscSetIsaDmaChannel(iot, ioh, sc->isa_dma_channel);\n\t\tAscSetIsaDmaSpeed(iot, ioh, sc->isa_dma_speed);\n\t}\n\treturn (warn_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscInitFromEEP",
          "args": [
            "sc"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "AscInitFromEEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "353-520",
          "snippet": "u_int16_t\nAscInitFromEEP(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASCEEP_CONFIG   eep_config_buf;\n\tASCEEP_CONFIG  *eep_config;\n\tu_int16_t       chksum;\n\tu_int16_t       warn_code;\n\tu_int16_t       cfg_msw, cfg_lsw;\n\tint             i;\n\tint             write_eep = 0;\n\n\n\twarn_code = 0;\n\tAscWriteLramWord(iot, ioh, ASCV_HALTCODE_W, 0x00FE);\n\tAscStopQueueExe(iot, ioh);\n\tif ((AscStopChip(iot, ioh) == FALSE) ||\n\t    (AscGetChipScsiCtrl(iot, ioh) != 0)) {\n\t\tAscResetChipAndScsiBus(iot, ioh);\n\t\tDvcSleepMilliSecond(sc->scsi_reset_wait * 1000);\n\t}\n\tif (AscIsChipHalted(iot, ioh) == FALSE)\n\t\treturn (-1);\n\n\tASC_SET_PC_ADDR(iot, ioh, ASC_MCODE_START_ADDR);\n\tif (ASC_GET_PC_ADDR(iot, ioh) != ASC_MCODE_START_ADDR)\n\t\treturn (-2);\n\n\teep_config = &eep_config_buf;\n\tcfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\tcfg_lsw = ASC_GET_CHIP_CFG_LSW(iot, ioh);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t}\n\tchksum = AscGetEEPConfig(iot, ioh, eep_config, sc->bus_type);\n#ifdef ASC_DEBUG\n\tAscPrintEEPConfig(eep_config, chksum);\n#endif\n\tif (chksum == 0)\n\t\tchksum = 0xAA55;\n\n\tif (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t\tif (sc->chip_version == 3) {\n\t\t\tif (eep_config->cfg_lsw != cfg_lsw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_lsw = ASC_GET_CHIP_CFG_LSW(iot, ioh);\n\t\t\t}\n\t\t\tif (eep_config->cfg_msw != cfg_msw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\t\t\t}\n\t\t}\n\t}\n\teep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\teep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;\n\n\tif (chksum != eep_config->chksum) {\n\t\tif (AscGetChipVersion(iot, ioh, sc->bus_type) ==\n\t\t    ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\teep_config->init_sdtr = 0xFF;\n\t\t\teep_config->disc_enable = 0xFF;\n\t\t\teep_config->start_motor = 0xFF;\n\t\t\teep_config->use_cmd_qng = 0;\n\t\t\teep_config->max_total_qng = 0xF0;\n\t\t\teep_config->max_tag_qng = 0x20;\n\t\t\teep_config->cntl = 0xBFFF;\n\t\t\teep_config->chip_scsi_id = 7;\n\t\t\teep_config->no_scam = 0;\n\t\t\teep_config->adapter_info[0] = 0;\n\t\t\teep_config->adapter_info[1] = 0;\n\t\t\teep_config->adapter_info[2] = 0;\n\t\t\teep_config->adapter_info[3] = 0;\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t\teep_config->adapter_info[5] = 0;\n\t\t\t/* Indicate EEPROM-less board. */\n\t\t\teep_config->adapter_info[4] = 0xBB;\n#else\n\t\t\teep_config->adapter_info[4] = 0;\n\t\t\t/* Indicate EEPROM-less board. */\n\t\t\teep_config->adapter_info[5] = 0xBB;\n#endif\n\t\t} else {\n\t\t\twrite_eep = 1;\n\t\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\t\t}\n\t}\n\tsc->sdtr_enable = eep_config->init_sdtr;\n\tsc->disc_enable = eep_config->disc_enable;\n\tsc->cmd_qng_enabled = eep_config->use_cmd_qng;\n\tsc->isa_dma_speed = eep_config->isa_dma_speed;\n\tsc->start_motor = eep_config->start_motor;\n\tsc->dvc_cntl = eep_config->cntl;\n#if BYTE_ORDER == BIG_ENDIAN\n\tsc->adapter_info[0] = eep_config->adapter_info[1];\n\tsc->adapter_info[1] = eep_config->adapter_info[0];\n\tsc->adapter_info[2] = eep_config->adapter_info[3];\n\tsc->adapter_info[3] = eep_config->adapter_info[2];\n\tsc->adapter_info[4] = eep_config->adapter_info[5];\n\tsc->adapter_info[5] = eep_config->adapter_info[4];\n#else\n\tsc->adapter_info[0] = eep_config->adapter_info[0];\n\tsc->adapter_info[1] = eep_config->adapter_info[1];\n\tsc->adapter_info[2] = eep_config->adapter_info[2];\n\tsc->adapter_info[3] = eep_config->adapter_info[3];\n\tsc->adapter_info[4] = eep_config->adapter_info[4];\n\tsc->adapter_info[5] = eep_config->adapter_info[5];\n#endif\n\n\tif (!AscTestExternalLram(iot, ioh)) {\n\t\tif (((sc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA)) {\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;\n\t\t} else {\n\t\t\teep_config->cfg_msw |= 0x0800;\n\t\t\tcfg_msw |= 0x0800;\n\t\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;\n\t\t}\n\t}\n\tif (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG)\n\t\teep_config->max_total_qng = ASC_MIN_TOTAL_QNG;\n\n\tif (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG)\n\t\teep_config->max_total_qng = ASC_MAX_TOTAL_QNG;\n\n\tif (eep_config->max_tag_qng > eep_config->max_total_qng)\n\t\teep_config->max_tag_qng = eep_config->max_total_qng;\n\n\tif (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC)\n\t\teep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;\n\n\tsc->max_total_qng = eep_config->max_total_qng;\n\tif ((eep_config->use_cmd_qng & eep_config->disc_enable) !=\n\t    eep_config->use_cmd_qng) {\n\t\teep_config->disc_enable = eep_config->use_cmd_qng;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (sc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA))\n\t\tsc->irq_no = AscGetChipIRQ(iot, ioh, sc->bus_type);\n\n\teep_config->chip_scsi_id &= ASC_MAX_TID;\n\tsc->chip_scsi_id = eep_config->chip_scsi_id;\n\tif (((sc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&\n\t    !(sc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {\n\t\tsc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;\n\t}\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->max_tag_qng[i] = eep_config->max_tag_qng;\n\t\tsc->sdtr_period_offset[i] = ASC_DEF_SDTR_OFFSET |\n\t\t\t(sc->host_init_sdtr_index << 4);\n\t}\n\n\teep_config->cfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\tif (write_eep) {\n\t\tAscSetEEPConfig(iot, ioh, eep_config, sc->bus_type);\n#ifdef ASC_DEBUG\n\t\tAscPrintEEPConfig(eep_config, 0);\n#endif\n\t}\n\n\treturn (warn_code);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int AscResetChipAndScsiBus",
            "static int AscStopChip",
            "static u_int8_t AscGetChipScsiCtrl",
            "static u_int8_t AscGetChipVersion",
            "static int AscIsChipHalted",
            "static void AscWriteLramWord",
            "static int AscTestExternalLram",
            "static u_int16_t AscGetEEPConfig",
            "static int AscSetEEPConfig",
            "static u_int8_t AscGetChipIRQ",
            "static int AscStopQueueExe",
            "static void DvcSleepMilliSecond"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int AscResetChipAndScsiBus;\nstatic int AscStopChip;\nstatic u_int8_t AscGetChipScsiCtrl;\nstatic u_int8_t AscGetChipVersion;\nstatic int AscIsChipHalted;\nstatic void AscWriteLramWord;\nstatic int AscTestExternalLram;\nstatic u_int16_t AscGetEEPConfig;\nstatic int AscSetEEPConfig;\nstatic u_int8_t AscGetChipIRQ;\nstatic int AscStopQueueExe;\nstatic void DvcSleepMilliSecond;\n\nu_int16_t\nAscInitFromEEP(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASCEEP_CONFIG   eep_config_buf;\n\tASCEEP_CONFIG  *eep_config;\n\tu_int16_t       chksum;\n\tu_int16_t       warn_code;\n\tu_int16_t       cfg_msw, cfg_lsw;\n\tint             i;\n\tint             write_eep = 0;\n\n\n\twarn_code = 0;\n\tAscWriteLramWord(iot, ioh, ASCV_HALTCODE_W, 0x00FE);\n\tAscStopQueueExe(iot, ioh);\n\tif ((AscStopChip(iot, ioh) == FALSE) ||\n\t    (AscGetChipScsiCtrl(iot, ioh) != 0)) {\n\t\tAscResetChipAndScsiBus(iot, ioh);\n\t\tDvcSleepMilliSecond(sc->scsi_reset_wait * 1000);\n\t}\n\tif (AscIsChipHalted(iot, ioh) == FALSE)\n\t\treturn (-1);\n\n\tASC_SET_PC_ADDR(iot, ioh, ASC_MCODE_START_ADDR);\n\tif (ASC_GET_PC_ADDR(iot, ioh) != ASC_MCODE_START_ADDR)\n\t\treturn (-2);\n\n\teep_config = &eep_config_buf;\n\tcfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\tcfg_lsw = ASC_GET_CHIP_CFG_LSW(iot, ioh);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t}\n\tchksum = AscGetEEPConfig(iot, ioh, eep_config, sc->bus_type);\n#ifdef ASC_DEBUG\n\tAscPrintEEPConfig(eep_config, chksum);\n#endif\n\tif (chksum == 0)\n\t\tchksum = 0xAA55;\n\n\tif (ASC_GET_CHIP_STATUS(iot, ioh) & ASC_CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t\tif (sc->chip_version == 3) {\n\t\t\tif (eep_config->cfg_lsw != cfg_lsw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_lsw = ASC_GET_CHIP_CFG_LSW(iot, ioh);\n\t\t\t}\n\t\t\tif (eep_config->cfg_msw != cfg_msw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\t\t\t}\n\t\t}\n\t}\n\teep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\teep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;\n\n\tif (chksum != eep_config->chksum) {\n\t\tif (AscGetChipVersion(iot, ioh, sc->bus_type) ==\n\t\t    ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\teep_config->init_sdtr = 0xFF;\n\t\t\teep_config->disc_enable = 0xFF;\n\t\t\teep_config->start_motor = 0xFF;\n\t\t\teep_config->use_cmd_qng = 0;\n\t\t\teep_config->max_total_qng = 0xF0;\n\t\t\teep_config->max_tag_qng = 0x20;\n\t\t\teep_config->cntl = 0xBFFF;\n\t\t\teep_config->chip_scsi_id = 7;\n\t\t\teep_config->no_scam = 0;\n\t\t\teep_config->adapter_info[0] = 0;\n\t\t\teep_config->adapter_info[1] = 0;\n\t\t\teep_config->adapter_info[2] = 0;\n\t\t\teep_config->adapter_info[3] = 0;\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t\teep_config->adapter_info[5] = 0;\n\t\t\t/* Indicate EEPROM-less board. */\n\t\t\teep_config->adapter_info[4] = 0xBB;\n#else\n\t\t\teep_config->adapter_info[4] = 0;\n\t\t\t/* Indicate EEPROM-less board. */\n\t\t\teep_config->adapter_info[5] = 0xBB;\n#endif\n\t\t} else {\n\t\t\twrite_eep = 1;\n\t\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\t\t}\n\t}\n\tsc->sdtr_enable = eep_config->init_sdtr;\n\tsc->disc_enable = eep_config->disc_enable;\n\tsc->cmd_qng_enabled = eep_config->use_cmd_qng;\n\tsc->isa_dma_speed = eep_config->isa_dma_speed;\n\tsc->start_motor = eep_config->start_motor;\n\tsc->dvc_cntl = eep_config->cntl;\n#if BYTE_ORDER == BIG_ENDIAN\n\tsc->adapter_info[0] = eep_config->adapter_info[1];\n\tsc->adapter_info[1] = eep_config->adapter_info[0];\n\tsc->adapter_info[2] = eep_config->adapter_info[3];\n\tsc->adapter_info[3] = eep_config->adapter_info[2];\n\tsc->adapter_info[4] = eep_config->adapter_info[5];\n\tsc->adapter_info[5] = eep_config->adapter_info[4];\n#else\n\tsc->adapter_info[0] = eep_config->adapter_info[0];\n\tsc->adapter_info[1] = eep_config->adapter_info[1];\n\tsc->adapter_info[2] = eep_config->adapter_info[2];\n\tsc->adapter_info[3] = eep_config->adapter_info[3];\n\tsc->adapter_info[4] = eep_config->adapter_info[4];\n\tsc->adapter_info[5] = eep_config->adapter_info[5];\n#endif\n\n\tif (!AscTestExternalLram(iot, ioh)) {\n\t\tif (((sc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA)) {\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;\n\t\t} else {\n\t\t\teep_config->cfg_msw |= 0x0800;\n\t\t\tcfg_msw |= 0x0800;\n\t\t\tASC_SET_CHIP_CFG_MSW(iot, ioh, cfg_msw);\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;\n\t\t}\n\t}\n\tif (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG)\n\t\teep_config->max_total_qng = ASC_MIN_TOTAL_QNG;\n\n\tif (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG)\n\t\teep_config->max_total_qng = ASC_MAX_TOTAL_QNG;\n\n\tif (eep_config->max_tag_qng > eep_config->max_total_qng)\n\t\teep_config->max_tag_qng = eep_config->max_total_qng;\n\n\tif (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC)\n\t\teep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;\n\n\tsc->max_total_qng = eep_config->max_total_qng;\n\tif ((eep_config->use_cmd_qng & eep_config->disc_enable) !=\n\t    eep_config->use_cmd_qng) {\n\t\teep_config->disc_enable = eep_config->use_cmd_qng;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (sc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA))\n\t\tsc->irq_no = AscGetChipIRQ(iot, ioh, sc->bus_type);\n\n\teep_config->chip_scsi_id &= ASC_MAX_TID;\n\tsc->chip_scsi_id = eep_config->chip_scsi_id;\n\tif (((sc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&\n\t    !(sc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {\n\t\tsc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;\n\t}\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->max_tag_qng[i] = eep_config->max_tag_qng;\n\t\tsc->sdtr_period_offset[i] = ASC_DEF_SDTR_OFFSET |\n\t\t\t(sc->host_init_sdtr_index << 4);\n\t}\n\n\teep_config->cfg_msw = ASC_GET_CHIP_CFG_MSW(iot, ioh);\n\tif (write_eep) {\n\t\tAscSetEEPConfig(iot, ioh, eep_config, sc->bus_type);\n#ifdef ASC_DEBUG\n\t\tAscPrintEEPConfig(eep_config, 0);\n#endif\n\t}\n\n\treturn (warn_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AscInitASC_SOFTC",
          "args": [
            "sc"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "AscInitASC_SOFTC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "253-346",
          "snippet": "void\nAscInitASC_SOFTC(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             i;\n\tu_int8_t        chip_version;\n\n\n\tASC_SET_CHIP_CONTROL(iot, ioh, ASC_CC_HALT);\n\tASC_SET_CHIP_STATUS(iot, ioh, 0);\n\n\tsc->bug_fix_cntl = 0;\n\tsc->pci_fix_asyn_xfer = 0;\n\tsc->pci_fix_asyn_xfer_always = 0;\n\tsc->sdtr_done = 0;\n\tsc->cur_total_qng = 0;\n\tsc->last_q_shortage = 0;\n\tsc->use_tagged_qng = 0;\n\tsc->unit_not_ready = 0;\n\tsc->queue_full_or_busy = 0;\n\tsc->host_init_sdtr_index = 0;\n\tsc->can_tagged_qng = 0;\n\tsc->cmd_qng_enabled = 0;\n\tsc->dvc_cntl = ASC_DEF_DVC_CNTL;\n\tsc->init_sdtr = 0;\n\tsc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;\n\tsc->scsi_reset_wait = 3;\n\tsc->start_motor = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->max_dma_count = AscGetMaxDmaCount(sc->bus_type);\n\tsc->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->disc_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;\n\tsc->lib_serial_no = ASC_LIB_SERIAL_NUMBER;\n\tsc->lib_version = (ASC_LIB_VERSION_MAJOR << 8) | ASC_LIB_VERSION_MINOR;\n\tchip_version = AscGetChipVersion(iot, ioh, sc->bus_type);\n\tsc->chip_version = chip_version;\n\tif ((sc->bus_type & ASC_IS_PCI) &&\n\t    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {\n\t\tsc->bus_type = ASC_IS_PCI_ULTRA;\n\t\tsc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;\n\t\tsc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;\n\t\tsc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;\n\t\tsc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;\n\t\tsc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;\n\t\tsc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;\n\t\tsc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;\n\t\tsc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;\n\t\tsc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;\n\t\tsc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;\n\t\tsc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;\n\t\tsc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;\n\t\tsc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;\n\t\tsc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;\n\t\tsc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;\n\t\tsc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;\n\t\tsc->max_sdtr_index = 15;\n\t\tif (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)\n\t\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t       (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t\telse if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050)\n\t\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));\n\t} else {\n\t\tsc->sdtr_period_tbl[0] = SYN_XFER_NS_0;\n\t\tsc->sdtr_period_tbl[1] = SYN_XFER_NS_1;\n\t\tsc->sdtr_period_tbl[2] = SYN_XFER_NS_2;\n\t\tsc->sdtr_period_tbl[3] = SYN_XFER_NS_3;\n\t\tsc->sdtr_period_tbl[4] = SYN_XFER_NS_4;\n\t\tsc->sdtr_period_tbl[5] = SYN_XFER_NS_5;\n\t\tsc->sdtr_period_tbl[6] = SYN_XFER_NS_6;\n\t\tsc->sdtr_period_tbl[7] = SYN_XFER_NS_7;\n\t\tsc->max_sdtr_index = 7;\n\t}\n\n\tif (sc->bus_type == ASC_IS_PCI)\n\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t      (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\n\tsc->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;\n\tif (AscGetChipBusType(iot, ioh) == ASC_IS_ISAPNP) {\n\t\tASC_SET_CHIP_IFC(iot, ioh, ASC_IFC_INIT_DEFAULT);\n\t\tsc->bus_type = ASC_IS_ISAPNP;\n\t}\n\tif ((sc->bus_type & ASC_IS_ISA) != 0)\n\t\tsc->isa_dma_channel = AscGetIsaDmaChannel(iot, ioh);\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->cur_dvc_qng[i] = 0;\n\t\tsc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;\n\t\tsc->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;\n\t}\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t AscGetChipBusType",
            "static u_int8_t AscGetChipVersion",
            "static u_int32_t AscGetMaxDmaCount",
            "static u_int16_t AscGetIsaDmaChannel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int16_t AscGetChipBusType;\nstatic u_int8_t AscGetChipVersion;\nstatic u_int32_t AscGetMaxDmaCount;\nstatic u_int16_t AscGetIsaDmaChannel;\n\nvoid\nAscInitASC_SOFTC(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint             i;\n\tu_int8_t        chip_version;\n\n\n\tASC_SET_CHIP_CONTROL(iot, ioh, ASC_CC_HALT);\n\tASC_SET_CHIP_STATUS(iot, ioh, 0);\n\n\tsc->bug_fix_cntl = 0;\n\tsc->pci_fix_asyn_xfer = 0;\n\tsc->pci_fix_asyn_xfer_always = 0;\n\tsc->sdtr_done = 0;\n\tsc->cur_total_qng = 0;\n\tsc->last_q_shortage = 0;\n\tsc->use_tagged_qng = 0;\n\tsc->unit_not_ready = 0;\n\tsc->queue_full_or_busy = 0;\n\tsc->host_init_sdtr_index = 0;\n\tsc->can_tagged_qng = 0;\n\tsc->cmd_qng_enabled = 0;\n\tsc->dvc_cntl = ASC_DEF_DVC_CNTL;\n\tsc->init_sdtr = 0;\n\tsc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;\n\tsc->scsi_reset_wait = 3;\n\tsc->start_motor = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->max_dma_count = AscGetMaxDmaCount(sc->bus_type);\n\tsc->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->disc_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tsc->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;\n\tsc->lib_serial_no = ASC_LIB_SERIAL_NUMBER;\n\tsc->lib_version = (ASC_LIB_VERSION_MAJOR << 8) | ASC_LIB_VERSION_MINOR;\n\tchip_version = AscGetChipVersion(iot, ioh, sc->bus_type);\n\tsc->chip_version = chip_version;\n\tif ((sc->bus_type & ASC_IS_PCI) &&\n\t    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {\n\t\tsc->bus_type = ASC_IS_PCI_ULTRA;\n\t\tsc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;\n\t\tsc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;\n\t\tsc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;\n\t\tsc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;\n\t\tsc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;\n\t\tsc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;\n\t\tsc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;\n\t\tsc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;\n\t\tsc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;\n\t\tsc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;\n\t\tsc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;\n\t\tsc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;\n\t\tsc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;\n\t\tsc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;\n\t\tsc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;\n\t\tsc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;\n\t\tsc->max_sdtr_index = 15;\n\t\tif (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)\n\t\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t       (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t\telse if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050)\n\t\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));\n\t} else {\n\t\tsc->sdtr_period_tbl[0] = SYN_XFER_NS_0;\n\t\tsc->sdtr_period_tbl[1] = SYN_XFER_NS_1;\n\t\tsc->sdtr_period_tbl[2] = SYN_XFER_NS_2;\n\t\tsc->sdtr_period_tbl[3] = SYN_XFER_NS_3;\n\t\tsc->sdtr_period_tbl[4] = SYN_XFER_NS_4;\n\t\tsc->sdtr_period_tbl[5] = SYN_XFER_NS_5;\n\t\tsc->sdtr_period_tbl[6] = SYN_XFER_NS_6;\n\t\tsc->sdtr_period_tbl[7] = SYN_XFER_NS_7;\n\t\tsc->max_sdtr_index = 7;\n\t}\n\n\tif (sc->bus_type == ASC_IS_PCI)\n\t\tASC_SET_EXTRA_CONTROL(iot, ioh,\n\t\t\t\t      (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\n\tsc->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;\n\tif (AscGetChipBusType(iot, ioh) == ASC_IS_ISAPNP) {\n\t\tASC_SET_CHIP_IFC(iot, ioh, ASC_IFC_INIT_DEFAULT);\n\t\tsc->bus_type = ASC_IS_ISAPNP;\n\t}\n\tif ((sc->bus_type & ASC_IS_ISA) != 0)\n\t\tsc->isa_dma_channel = AscGetIsaDmaChannel(iot, ioh);\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tsc->cur_dvc_qng[i] = 0;\n\t\tsc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;\n\t\tsc->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"adv_init: adv_find_signature failed\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AscFindSignature",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "AscFindSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "614-628",
          "snippet": "int\nAscFindSignature(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tu_int16_t       sig_word;\n\n\tif (ASC_GET_CHIP_SIGNATURE_BYTE(iot, ioh) == ASC_1000_ID1B) {\n\t\tsig_word = ASC_GET_CHIP_SIGNATURE_WORD(iot, ioh);\n\t\tif (sig_word == ASC_1000_ID0W ||\n\t\t    sig_word == ASC_1000_ID0W_FIX)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nAscFindSignature(iot, ioh)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n{\n\tu_int16_t       sig_word;\n\n\tif (ASC_GET_CHIP_SIGNATURE_BYTE(iot, ioh) == ASC_1000_ID1B) {\n\t\tsig_word = ASC_GET_CHIP_SIGNATURE_WORD(iot, ioh);\n\t\tif (sig_word == ASC_1000_ID0W ||\n\t\t    sig_word == ASC_1000_ID0W_FIX)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int8_t *adv_alloc_overrunbuf;\nstatic void adv_narrow_isr_callback;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nint\nadv_init(sc)\n\tASC_SOFTC      *sc;\n{\n\tint             warn;\n\n\tif (!AscFindSignature(sc->sc_iot, sc->sc_ioh))\n\t\tpanic(\"adv_init: adv_find_signature failed\");\n\n\t/*\n         * Read the board configuration\n         */\n\tAscInitASC_SOFTC(sc);\n\twarn = AscInitFromEEP(sc);\n\tif (warn) {\n\t\tprintf(\"%s -get: \", sc->sc_dev.dv_xname);\n\t\tswitch (warn) {\n\t\tcase -1:\n\t\t\tprintf(\"Chip is not halted\\n\");\n\t\t\tbreak;\n\n\t\tcase -2:\n\t\t\tprintf(\"Couldn't get MicroCode Start\"\n\t\t\t       \" address\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\t\tprintf(\"I/O port address modified\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_AUTO_CONFIG:\n\t\t\tprintf(\"I/O port increment switch enabled\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\t\tprintf(\"EEPROM checksum error\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_IRQ_MODIFIED:\n\t\t\tprintf(\"IRQ modified\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\t\tprintf(\"tag queuing enabled w/o disconnects\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"unknown warning %d\\n\", warn);\n\t\t}\n\t}\n\tif (sc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)\n\t\tsc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;\n\n\t/*\n         * Modify the board configuration\n         */\n\twarn = AscInitFromASC_SOFTC(sc);\n\tif (warn) {\n\t\tprintf(\"%s -set: \", sc->sc_dev.dv_xname);\n\t\tswitch (warn) {\n\t\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\t\tprintf(\"tag queuing enabled w/o disconnects\\n\");\n\t\t\tbreak;\n\n\t\tcase ASC_WARN_AUTO_CONFIG:\n\t\t\tprintf(\"I/O port increment switch enabled\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"unknown warning %d\\n\", warn);\n\t\t}\n\t}\n\tsc->isr_callback = (ulong) adv_narrow_isr_callback;\n\n\tif (!(sc->overrun_buf = adv_alloc_overrunbuf(sc->sc_dev.dv_xname,\n\t\t\t\t\t\t     sc->sc_dmat))) {\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "adv_start_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "367-388",
    "snippet": "static void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */"
    ],
    "globals_used": [
      "static void adv_start_ccbs",
      "static void adv_timeout",
      "static void adv_watchdog",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
      "int             flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "adv_timeout",
            "ccb",
            "(ccb->timeout * hz) / 1000"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "adv_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "893-931",
          "snippet": "static void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "static void adv_queue_ccb",
            "static void adv_timeout",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_ABORT_TIMEOUT       2000\t/* time to wait for abort (mSec) */\n\nstatic void adv_queue_ccb;\nstatic void adv_timeout;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_timeout(arg)\n\tvoid           *arg;\n{\n\tADV_CCB        *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tASC_SOFTC      *sc = sc_link->adapter_softc;\n\tint             s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n         * If it has been through before, then a previous abort has failed,\n         * don't try abort again, reset the bus instead.\n         */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN. Resetting Bus\\n\");\n\t\t/* Lets try resetting the bus! */\n\t\tif (AscResetBus(sc) == ASC_ERROR) {\n\t\t\tccb->timeout = sc->scsi_reset_wait;\n\t\t\tadv_queue_ccb(sc, ccb);\n\t\t}\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tAscAbortCCB(sc, (u_int32_t) ccb);\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = ADV_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tadv_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AscExeScsiQueue",
          "args": [
            "sc",
            "&ccb->scsiq"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "AscExeScsiQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/advlib.c",
          "lines": "2471-2619",
          "snippet": "int\nAscExeScsiQueue(sc, scsiq)\n\tASC_SOFTC      *sc;\n\tASC_SCSI_Q     *scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASC_SG_HEAD    *sg_head = scsiq->sg_head;\n\tint             retval;\n\tint             n_q_required;\n\tint             disable_syn_offset_one_fix;\n\tint             i;\n\tu_int32_t       addr;\n\tu_int16_t       sg_entry_cnt = 0;\n\tu_int16_t       sg_entry_cnt_minus_one = 0;\n\tu_int8_t        target_ix;\n\tu_int8_t        tid_no;\n\tu_int8_t        sdtr_data;\n\tu_int8_t        extra_bytes;\n\tu_int8_t        scsi_cmd;\n\tu_int32_t       data_cnt;\n\n\n\tscsiq->q1.q_no = 0;\n\tif ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)\n\t\tscsiq->q1.extra_bytes = 0;\n\n\tretval = ASC_BUSY;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tn_q_required = 1;\n\n\tif (scsiq->cdbptr[0] == SCSICMD_RequestSense)\n\t\tif ((sc->init_sdtr & scsiq->q1.target_id) != 0) {\n\t\t\tsc->sdtr_done &= ~scsiq->q1.target_id;\n\t\t\tsdtr_data = ASC_GET_MCODE_INIT_SDTR_AT_ID(iot, ioh, tid_no);\n\t\t\tAscMsgOutSDTR(sc, sc->sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t  (sc->max_sdtr_index - 1)],\n\t\t\t\t      sdtr_data & ASC_SYN_MAX_OFFSET);\n\t\t\tscsiq->q1.cntl |= (ASC_QC_MSG_OUT | ASC_QC_URGENT);\n\t\t}\n\t/*\n\t * if there is just one segment into S/G list then\n\t * map it as it was a single request, filling\n\t * data_addr and data_cnt of ASC_SCSIQ structure.\n\t */\n\tif ((scsiq->q1.cntl & ASC_QC_SG_HEAD) != 0) {\n\t\tsg_entry_cnt = sg_head->entry_cnt;\n\n\t\tif (sg_entry_cnt < 1)\n\t\t\tpanic(\"AscExeScsiQueue: Queue with QC_SG_HEAD set but %d segs.\",\n\t\t\t      sg_entry_cnt);\n\n\t\tif (sg_entry_cnt > ASC_MAX_SG_LIST)\n\t\t\tpanic(\"AscExeScsiQueue: Queue with too many segs.\");\n\n\t\tif (sg_entry_cnt == 1) {\n\t\t\tscsiq->q1.data_addr = sg_head->sg_list[0].addr;\n\t\t\tscsiq->q1.data_cnt = sg_head->sg_list[0].bytes;\n\t\t\tscsiq->q1.cntl &= ~(ASC_QC_SG_HEAD | ASC_QC_SG_SWAP_QUEUE);\n\t\t}\n\t\tsg_entry_cnt_minus_one = sg_entry_cnt - 1;\n\t}\n\tscsi_cmd = scsiq->cdbptr[0];\n\tdisable_syn_offset_one_fix = FALSE;\n\tif ((sc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&\n\t    !(sc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {\n\t\tif (scsiq->q1.cntl & ASC_QC_SG_HEAD) {\n\t\t\tdata_cnt = 0;\n\t\t\tfor (i = 0; i < sg_entry_cnt; i++)\n\t\t\t\tdata_cnt += sg_head->sg_list[i].bytes;\n\t\t} else {\n\t\t\tdata_cnt = scsiq->q1.data_cnt;\n\t\t}\n\n\t\tif (data_cnt != 0ul) {\n\t\t\tif (data_cnt < 512ul) {\n\t\t\t\tdisable_syn_offset_one_fix = TRUE;\n\t\t\t} else {\n\t\t\t\tif (scsi_cmd == SCSICMD_Inquiry ||\n\t\t\t\t    scsi_cmd == SCSICMD_RequestSense ||\n\t\t\t\t    scsi_cmd == SCSICMD_ReadCapacity ||\n\t\t\t\t    scsi_cmd == SCSICMD_ReadTOC ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSelect6 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSense6 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSelect10 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSense10) {\n\t\t\t\t\tdisable_syn_offset_one_fix = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (disable_syn_offset_one_fix) {\n\t\tscsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE;\n\t\tscsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |\n\t\t\t\t       ASC_TAG_FLAG_DISABLE_DISCONNECT);\n\t} else {\n\t\tscsiq->q2.tag_code &= 0x23;\n\t}\n\n\tif ((scsiq->q1.cntl & ASC_QC_SG_HEAD) != 0) {\n\t\tif (sc->bug_fix_cntl) {\n\t\t\tif (sc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == SCSICMD_Read6) || (scsi_cmd == SCSICMD_Read10)) {\n\t\t\t\t\taddr = sg_head->sg_list[sg_entry_cnt_minus_one].addr +\n\t\t\t\t\t\tsg_head->sg_list[sg_entry_cnt_minus_one].bytes;\n\t\t\t\t\textra_bytes = addr & 0x0003;\n\t\t\t\t\tif ((extra_bytes != 0) &&\n\t\t\t\t\t    ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)) {\n\t\t\t\t\t\tscsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\tscsiq->q1.extra_bytes = extra_bytes;\n\t\t\t\t\t\tsg_head->sg_list[sg_entry_cnt_minus_one].bytes -=\n\t\t\t\t\t\t\textra_bytes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsg_head->entry_to_copy = sg_head->entry_cnt;\n\t\tn_q_required = AscSgListToQueue(sg_entry_cnt);\n\t\tif ((AscGetNumOfFreeQueue(sc, target_ix, n_q_required) >= n_q_required)\n\t\t    || ((scsiq->q1.cntl & ASC_QC_URGENT) != 0)) {\n\t\t\tretval = AscSendScsiQueue(sc, scsiq, n_q_required);\n\t\t}\n\t} else {\n\t\tif (sc->bug_fix_cntl) {\n\t\t\tif (sc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == SCSICMD_Read6) || (scsi_cmd == SCSICMD_Read10)) {\n\t\t\t\t\taddr = scsiq->q1.data_addr + scsiq->q1.data_cnt;\n\t\t\t\t\textra_bytes = addr & 0x0003;\n\t\t\t\t\tif ((extra_bytes != 0) &&\n\t\t\t\t\t    ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)) {\n\t\t\t\t\t\tif ((scsiq->q1.data_cnt & 0x01FF) == 0) {\n\t\t\t\t\t\t\tscsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\t\tscsiq->q1.data_cnt -= extra_bytes;\n\t\t\t\t\t\t\tscsiq->q1.extra_bytes = extra_bytes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn_q_required = 1;\n\t\tif ((AscGetNumOfFreeQueue(sc, target_ix, 1) >= 1) ||\n\t\t    ((scsiq->q1.cntl & ASC_QC_URGENT) != 0)) {\n\t\t\tretval = AscSendScsiQueue(sc, scsiq, n_q_required);\n\t\t}\n\t}\n\n\treturn (retval);\n}",
          "includes": [
            "#include <dev/ic/advmcode.h>",
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/queue.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int8_t AscMsgOutSDTR",
            "static int AscSendScsiQueue",
            "static int AscSgListToQueue",
            "static u_int AscGetNumOfFreeQueue"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advmcode.h>\n#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/queue.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic u_int8_t AscMsgOutSDTR;\nstatic int AscSendScsiQueue;\nstatic int AscSgListToQueue;\nstatic u_int AscGetNumOfFreeQueue;\n\nint\nAscExeScsiQueue(sc, scsiq)\n\tASC_SOFTC      *sc;\n\tASC_SCSI_Q     *scsiq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tASC_SG_HEAD    *sg_head = scsiq->sg_head;\n\tint             retval;\n\tint             n_q_required;\n\tint             disable_syn_offset_one_fix;\n\tint             i;\n\tu_int32_t       addr;\n\tu_int16_t       sg_entry_cnt = 0;\n\tu_int16_t       sg_entry_cnt_minus_one = 0;\n\tu_int8_t        target_ix;\n\tu_int8_t        tid_no;\n\tu_int8_t        sdtr_data;\n\tu_int8_t        extra_bytes;\n\tu_int8_t        scsi_cmd;\n\tu_int32_t       data_cnt;\n\n\n\tscsiq->q1.q_no = 0;\n\tif ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)\n\t\tscsiq->q1.extra_bytes = 0;\n\n\tretval = ASC_BUSY;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tn_q_required = 1;\n\n\tif (scsiq->cdbptr[0] == SCSICMD_RequestSense)\n\t\tif ((sc->init_sdtr & scsiq->q1.target_id) != 0) {\n\t\t\tsc->sdtr_done &= ~scsiq->q1.target_id;\n\t\t\tsdtr_data = ASC_GET_MCODE_INIT_SDTR_AT_ID(iot, ioh, tid_no);\n\t\t\tAscMsgOutSDTR(sc, sc->sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t  (sc->max_sdtr_index - 1)],\n\t\t\t\t      sdtr_data & ASC_SYN_MAX_OFFSET);\n\t\t\tscsiq->q1.cntl |= (ASC_QC_MSG_OUT | ASC_QC_URGENT);\n\t\t}\n\t/*\n\t * if there is just one segment into S/G list then\n\t * map it as it was a single request, filling\n\t * data_addr and data_cnt of ASC_SCSIQ structure.\n\t */\n\tif ((scsiq->q1.cntl & ASC_QC_SG_HEAD) != 0) {\n\t\tsg_entry_cnt = sg_head->entry_cnt;\n\n\t\tif (sg_entry_cnt < 1)\n\t\t\tpanic(\"AscExeScsiQueue: Queue with QC_SG_HEAD set but %d segs.\",\n\t\t\t      sg_entry_cnt);\n\n\t\tif (sg_entry_cnt > ASC_MAX_SG_LIST)\n\t\t\tpanic(\"AscExeScsiQueue: Queue with too many segs.\");\n\n\t\tif (sg_entry_cnt == 1) {\n\t\t\tscsiq->q1.data_addr = sg_head->sg_list[0].addr;\n\t\t\tscsiq->q1.data_cnt = sg_head->sg_list[0].bytes;\n\t\t\tscsiq->q1.cntl &= ~(ASC_QC_SG_HEAD | ASC_QC_SG_SWAP_QUEUE);\n\t\t}\n\t\tsg_entry_cnt_minus_one = sg_entry_cnt - 1;\n\t}\n\tscsi_cmd = scsiq->cdbptr[0];\n\tdisable_syn_offset_one_fix = FALSE;\n\tif ((sc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&\n\t    !(sc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {\n\t\tif (scsiq->q1.cntl & ASC_QC_SG_HEAD) {\n\t\t\tdata_cnt = 0;\n\t\t\tfor (i = 0; i < sg_entry_cnt; i++)\n\t\t\t\tdata_cnt += sg_head->sg_list[i].bytes;\n\t\t} else {\n\t\t\tdata_cnt = scsiq->q1.data_cnt;\n\t\t}\n\n\t\tif (data_cnt != 0ul) {\n\t\t\tif (data_cnt < 512ul) {\n\t\t\t\tdisable_syn_offset_one_fix = TRUE;\n\t\t\t} else {\n\t\t\t\tif (scsi_cmd == SCSICMD_Inquiry ||\n\t\t\t\t    scsi_cmd == SCSICMD_RequestSense ||\n\t\t\t\t    scsi_cmd == SCSICMD_ReadCapacity ||\n\t\t\t\t    scsi_cmd == SCSICMD_ReadTOC ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSelect6 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSense6 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSelect10 ||\n\t\t\t\t    scsi_cmd == SCSICMD_ModeSense10) {\n\t\t\t\t\tdisable_syn_offset_one_fix = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (disable_syn_offset_one_fix) {\n\t\tscsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE;\n\t\tscsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |\n\t\t\t\t       ASC_TAG_FLAG_DISABLE_DISCONNECT);\n\t} else {\n\t\tscsiq->q2.tag_code &= 0x23;\n\t}\n\n\tif ((scsiq->q1.cntl & ASC_QC_SG_HEAD) != 0) {\n\t\tif (sc->bug_fix_cntl) {\n\t\t\tif (sc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == SCSICMD_Read6) || (scsi_cmd == SCSICMD_Read10)) {\n\t\t\t\t\taddr = sg_head->sg_list[sg_entry_cnt_minus_one].addr +\n\t\t\t\t\t\tsg_head->sg_list[sg_entry_cnt_minus_one].bytes;\n\t\t\t\t\textra_bytes = addr & 0x0003;\n\t\t\t\t\tif ((extra_bytes != 0) &&\n\t\t\t\t\t    ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)) {\n\t\t\t\t\t\tscsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\tscsiq->q1.extra_bytes = extra_bytes;\n\t\t\t\t\t\tsg_head->sg_list[sg_entry_cnt_minus_one].bytes -=\n\t\t\t\t\t\t\textra_bytes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsg_head->entry_to_copy = sg_head->entry_cnt;\n\t\tn_q_required = AscSgListToQueue(sg_entry_cnt);\n\t\tif ((AscGetNumOfFreeQueue(sc, target_ix, n_q_required) >= n_q_required)\n\t\t    || ((scsiq->q1.cntl & ASC_QC_URGENT) != 0)) {\n\t\t\tretval = AscSendScsiQueue(sc, scsiq, n_q_required);\n\t\t}\n\t} else {\n\t\tif (sc->bug_fix_cntl) {\n\t\t\tif (sc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == SCSICMD_Read6) || (scsi_cmd == SCSICMD_Read10)) {\n\t\t\t\t\taddr = scsiq->q1.data_addr + scsiq->q1.data_cnt;\n\t\t\t\t\textra_bytes = addr & 0x0003;\n\t\t\t\t\tif ((extra_bytes != 0) &&\n\t\t\t\t\t    ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0)) {\n\t\t\t\t\t\tif ((scsiq->q1.data_cnt & 0x01FF) == 0) {\n\t\t\t\t\t\t\tscsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\t\tscsiq->q1.data_cnt -= extra_bytes;\n\t\t\t\t\t\t\tscsiq->q1.extra_bytes = extra_bytes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn_q_required = 1;\n\t\tif ((AscGetNumOfFreeQueue(sc, target_ix, 1) >= 1) ||\n\t\t    ((scsiq->q1.cntl & ASC_QC_URGENT) != 0)) {\n\t\t\tretval = AscSendScsiQueue(sc, scsiq, n_q_required);\n\t\t}\n\t}\n\n\treturn (retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "adv_watchdog",
            "ccb"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */\n\nstatic void adv_start_ccbs;\nstatic void adv_timeout;\nstatic void adv_watchdog;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}"
  },
  {
    "function_name": "adv_queue_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "355-364",
    "snippet": "static void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_queue_ccb",
      "static void adv_start_ccbs",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adv_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "adv_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "367-388",
          "snippet": "static void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */"
          ],
          "globals_used": [
            "static void adv_start_ccbs",
            "static void adv_timeout",
            "static void adv_watchdog",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ADV_WATCH_TIMEOUT       1000\t/* time to wait for watchdog (mSec) */\n\nstatic void adv_start_ccbs;\nstatic void adv_timeout;\nstatic void adv_watchdog;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\nint             flags;\n\nstatic void\nadv_start_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tADV_CCB        *ccb;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (ccb->flags & CCB_WATCHDOG)\n\t\t\tuntimeout(adv_watchdog, ccb);\n\n\t\tif (AscExeScsiQueue(sc, &ccb->scsiq) == ASC_BUSY) {\n\t\t\tccb->flags |= CCB_WATCHDOG;\n\t\t\ttimeout(adv_watchdog, ccb,\n\t\t\t\t(ADV_WATCH_TIMEOUT * hz) / 1000);\n\t\t\tbreak;\n\t\t}\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(adv_timeout, ccb, (ccb->timeout * hz) / 1000);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_queue_ccb;\nstatic void adv_start_ccbs;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_queue_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\n\tadv_start_ccbs(sc);\n}"
  },
  {
    "function_name": "adv_init_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "289-310",
    "snippet": "static int\nadv_init_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ASC_MAX_SG_LIST, (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tadv_reset_ccb(ccb);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_reset_ccb",
      "static int adv_init_ccb",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adv_reset_ccb",
          "args": [
            "ccb"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "adv_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "280-286",
          "snippet": "static void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_reset_ccb",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_reset_ccb;\nint             flags;\n\nstatic void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create DMA map, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "(ASC_MAX_SG_LIST - 1) * PAGE_SIZE",
            "ASC_MAX_SG_LIST",
            "(ASC_MAX_SG_LIST - 1) * PAGE_SIZE",
            "0",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&ccb->dmamap_xfer"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_reset_ccb;\nstatic int adv_init_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_init_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ASC_MAX_SG_LIST, (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tadv_reset_ccb(ccb);\n\treturn (0);\n}"
  },
  {
    "function_name": "adv_reset_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "280-286",
    "snippet": "static void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_reset_ccb",
      "int             flags;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_reset_ccb;\nint             flags;\n\nstatic void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
  },
  {
    "function_name": "adv_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "257-277",
    "snippet": "static void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_free_ccb",
      "static void adv_reset_ccb",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adv_reset_ccb",
          "args": [
            "ccb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "adv_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "280-286",
          "snippet": "static void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_reset_ccb",
            "int             flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_reset_ccb;\nint             flags;\n\nstatic void\nadv_reset_ccb(ccb)\n\tADV_CCB        *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_free_ccb;\nstatic void adv_reset_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_free_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             s;\n\n\ts = splbio();\n\n\tadv_reset_ccb(ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n         * If there were none, wake anybody waiting for one to come free,\n         * starting with queued entries.\n         */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "adv_create_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "230-251",
    "snippet": "static int\nadv_create_ccbs(sc, ccbstore, count)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccbstore;\n\tint             count;\n{\n\tADV_CCB        *ccb;\n\tint             i, error;\n\n\tbzero(ccbstore, sizeof(ADV_CCB) * count);\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adv_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adv_create_ccbs",
      "static int adv_init_ccb",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to initialize ccb, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "adv_init_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "adv_init_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
          "lines": "289-310",
          "snippet": "static int\nadv_init_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ASC_MAX_SG_LIST, (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tadv_reset_ccb(ccb);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/advlib.h>",
            "#include <dev/ic/adv.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void adv_reset_ccb",
            "static int adv_init_ccb",
            "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
            "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_reset_ccb;\nstatic int adv_init_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_init_ccb(sc, ccb)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccb;\n{\n\tint             error;\n\n\t/*\n         * Create the DMA map for this CCB.\n         */\n\terror = bus_dmamap_create(sc->sc_dmat,\n\t\t\t\t  (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t\t ASC_MAX_SG_LIST, (ASC_MAX_SG_LIST - 1) * PAGE_SIZE,\n\t\t   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->dmamap_xfer);\n\tif (error) {\n\t\tprintf(\"%s: unable to create DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tadv_reset_ccb(ccb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ccbstore",
            "sizeof(ADV_CCB) * count"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_create_ccbs;\nstatic int adv_init_ccb;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_create_ccbs(sc, ccbstore, count)\n\tASC_SOFTC      *sc;\n\tADV_CCB        *ccbstore;\n\tint             count;\n{\n\tADV_CCB        *ccb;\n\tint             i, error;\n\n\tbzero(ccbstore, sizeof(ADV_CCB) * count);\n\tfor (i = 0; i < count; i++) {\n\t\tccb = &ccbstore[i];\n\t\tif ((error = adv_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to initialize ccb, error = %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, error);\n\t\t\treturn (i);\n\t\t}\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, chain);\n\t}\n\n\treturn (i);\n}"
  },
  {
    "function_name": "adv_alloc_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "182-223",
    "snippet": "static int\nadv_alloc_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control blocks.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adv_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   1, sizeof(struct adv_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adv_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int adv_alloc_ccbs",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to load control DMA map, error = %d\\n\"",
            "sc->sc_dev.dv_xname",
            "error"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_control",
            "sc->sc_control",
            "sizeof(struct adv_control)",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "sizeof(struct adv_control)",
            "1",
            "sizeof(struct adv_control)",
            "0",
            "BUS_DMA_NOWAIT",
            "&sc->sc_dmamap_control"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "sizeof(struct adv_control)",
            "(caddr_t *) & sc->sc_control",
            "BUS_DMA_NOWAIT | BUS_DMA_COHERENT"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "sizeof(struct adv_control)",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int adv_alloc_ccbs;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic int\nadv_alloc_ccbs(sc)\n\tASC_SOFTC      *sc;\n{\n\tbus_dma_segment_t seg;\n\tint             error, rseg;\n\n\t/*\n         * Allocate the control blocks.\n         */\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   NBPG, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate control structures,\"\n\t\t       \" error = %d\\n\", sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg,\n\t\t   sizeof(struct adv_control), (caddr_t *) & sc->sc_control,\n\t\t\t\t BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map control structures, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\t/*\n         * Create and load the DMA map used for the control blocks.\n         */\n\tif ((error = bus_dmamap_create(sc->sc_dmat, sizeof(struct adv_control),\n\t\t\t   1, sizeof(struct adv_control), 0, BUS_DMA_NOWAIT,\n\t\t\t\t       &sc->sc_dmamap_control)) != 0) {\n\t\tprintf(\"%s: unable to create control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_control,\n\t\t\t   sc->sc_control, sizeof(struct adv_control), NULL,\n\t\t\t\t     BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load control DMA map, error = %d\\n\",\n\t\t       sc->sc_dev.dv_xname, error);\n\t\treturn (error);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "adv_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/adv.c",
    "lines": "140-155",
    "snippet": "static void\nadv_enqueue(sc, xs, infront)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}",
    "includes": [
      "#include <dev/ic/advlib.h>",
      "#include <dev/ic/adv.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void adv_enqueue",
      "static struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;",
      "static ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_AFTER",
          "args": [
            "sc->sc_queuelast",
            "xs",
            "free_list"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_queue",
            "xs",
            "free_list"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/advlib.h>\n#include <dev/ic/adv.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void adv_enqueue;\nstatic struct scsi_xfer *\nadv_dequeue(sc)\n\tASC_SOFTC      *sc;\nstatic ADV_CCB *\nadv_get_ccb(sc, flags)\n\tASC_SOFTC      *sc;\n\nstatic void\nadv_enqueue(sc, xs, infront)\n\tASC_SOFTC      *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}"
  }
]