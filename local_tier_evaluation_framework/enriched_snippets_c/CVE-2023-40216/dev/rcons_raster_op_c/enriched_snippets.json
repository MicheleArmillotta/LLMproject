[
  {
    "function_name": "raster_blit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
    "lines": "973-1160",
    "snippet": "static int\nraster_blit( src, srclin1, srcleftignore, srcrightignore, srclongs, dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op )\n    struct raster* src;\n    u_int32_t* srclin1;\n    int srcleftignore, srcrightignore, srclongs;\n    struct raster* dst;\n    u_int32_t* dstlin1;\n    int dstleftignore, dstrightignore, dstlongs;\n    int h, op;\n    {\n    u_int32_t* srclin2;\n    u_int32_t* dstlin2;\n    int srclininc, dstlininc;\n    u_int32_t* srclin;\n    u_int32_t* dstlin;\n    register int prevleftshift, currrightshift;\n    int longinc;\n    register u_int32_t* srclong;\n    register u_int32_t* dstlong;\n    register u_int32_t* dstlong2;\n    register u_int32_t dl, lm, nlm, rm, nrm;\n\n    prevleftshift = ( srcleftignore - dstleftignore ) & 31;\n\n    srclin2 = srclin1 + h * src->linelongs;\n    dstlin2 = dstlin1 + h * dst->linelongs;\n    srclininc = src->linelongs;\n    dstlininc = dst->linelongs;\n    longinc = 1;\n\n    /* Check for overlaps. */\n    if ( ( dstlin1 >= srclin1 && dstlin1 < srclin1 + srclongs ) ||\n\t ( srclin1 >= dstlin1 && srclin1 < dstlin1 + dstlongs ) )\n\t{\n\t/* Horizontal overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    longinc = -1;\n\t    srclin1 += srclongs - 1;\n\t    srclin2 += srclongs - 1;\n\t    dstlin1 += dstlongs - 1;\n\t    }\n\t}\n    else if ( ( dstlin1 >= srclin1 && dstlin1 < srclin2 ) ||\n\t      ( srclin1 >= dstlin1 && srclin1 < dstlin2 ) )\n\t{\n\t/* Vertical overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    srclin2 = srclin1 - srclininc;\n\t    srclin1 += ( h - 1 ) * srclininc;\n\t    dstlin1 += ( h - 1 ) * dstlininc;\n\t    srclininc = -srclininc;\n\t    dstlininc = -dstlininc;\n\t    }\n\t}\n    srclin = srclin1;\n    dstlin = dstlin1;\n\n    if ( prevleftshift == 0 )\n\t{\n\t/* The bits line up, no shifting necessary. */\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It all fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tROP_SRCDST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*s*/   *srclin,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tsrclin += srclininc;\n\t\tdstlin += dstlininc;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    /* Multiple longwords. */\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\t    if ( longinc == 1 )\n\t\t{\n\t\t/* Left to right. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong + dstlongs;\n\t\t    if ( dstrightignore != 0 )\n\t\t\t--dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t++srclong;\n\t\t\t++dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     ++srclong;\n\t\t\t\t++dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\t/* Right to left. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong - dstlongs;\n\t\t    if ( dstleftignore != 0 )\n\t\t\t++dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t--srclong;\n\t\t\t--dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     --srclong;\n\t\t\t\t--dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    }",
    "includes": [
      "#include \"raster.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int raster_blit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*s*/*srclong",
            "/*d*/dl",
            "/*pst*/*dstlong = ( *dstlong & lm ) | ( dl & nlm );"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/while ( dstlong != dstlong2 ){",
            "/*s*/*srclong",
            "/*d*/*dstlong",
            "/*pst*/--srclong"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while",
          "args": [
            "dstlong != dstlong2"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*s*/*srclong",
            "/*d*/dl",
            "/*pst*/*dstlong = ( dl & nrm ) | ( *dstlong & rm );"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*s*/*srclong",
            "/*d*/dl",
            "/*pst*/*dstlong = ( dl & nrm ) | ( *dstlong & rm );"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/while ( dstlong != dstlong2 ){",
            "/*s*/*srclong",
            "/*d*/*dstlong",
            "/*pst*/++srclong"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while",
          "args": [
            "dstlong != dstlong2"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*s*/*srclong",
            "/*d*/dl",
            "/*pst*/*dstlong = ( *dstlong & lm ) | ( dl & nlm );"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlin;",
            "/*s*/*srclin",
            "/*d*/dl",
            "/*pst*/*dstlin = ( *dstlin & lm ) | ( dl & nlm );"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int raster_blit;\n\nstatic int\nraster_blit( src, srclin1, srcleftignore, srcrightignore, srclongs, dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op )\n    struct raster* src;\n    u_int32_t* srclin1;\n    int srcleftignore, srcrightignore, srclongs;\n    struct raster* dst;\n    u_int32_t* dstlin1;\n    int dstleftignore, dstrightignore, dstlongs;\n    int h, op;\n    {\n    u_int32_t* srclin2;\n    u_int32_t* dstlin2;\n    int srclininc, dstlininc;\n    u_int32_t* srclin;\n    u_int32_t* dstlin;\n    register int prevleftshift, currrightshift;\n    int longinc;\n    register u_int32_t* srclong;\n    register u_int32_t* dstlong;\n    register u_int32_t* dstlong2;\n    register u_int32_t dl, lm, nlm, rm, nrm;\n\n    prevleftshift = ( srcleftignore - dstleftignore ) & 31;\n\n    srclin2 = srclin1 + h * src->linelongs;\n    dstlin2 = dstlin1 + h * dst->linelongs;\n    srclininc = src->linelongs;\n    dstlininc = dst->linelongs;\n    longinc = 1;\n\n    /* Check for overlaps. */\n    if ( ( dstlin1 >= srclin1 && dstlin1 < srclin1 + srclongs ) ||\n\t ( srclin1 >= dstlin1 && srclin1 < dstlin1 + dstlongs ) )\n\t{\n\t/* Horizontal overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    longinc = -1;\n\t    srclin1 += srclongs - 1;\n\t    srclin2 += srclongs - 1;\n\t    dstlin1 += dstlongs - 1;\n\t    }\n\t}\n    else if ( ( dstlin1 >= srclin1 && dstlin1 < srclin2 ) ||\n\t      ( srclin1 >= dstlin1 && srclin1 < dstlin2 ) )\n\t{\n\t/* Vertical overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    srclin2 = srclin1 - srclininc;\n\t    srclin1 += ( h - 1 ) * srclininc;\n\t    dstlin1 += ( h - 1 ) * dstlininc;\n\t    srclininc = -srclininc;\n\t    dstlininc = -dstlininc;\n\t    }\n\t}\n    srclin = srclin1;\n    dstlin = dstlin1;\n\n    if ( prevleftshift == 0 )\n\t{\n\t/* The bits line up, no shifting necessary. */\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It all fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tROP_SRCDST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*s*/   *srclin,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tsrclin += srclininc;\n\t\tdstlin += dstlininc;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    /* Multiple longwords. */\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\t    if ( longinc == 1 )\n\t\t{\n\t\t/* Left to right. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong + dstlongs;\n\t\t    if ( dstrightignore != 0 )\n\t\t\t--dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t++srclong;\n\t\t\t++dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     ++srclong;\n\t\t\t\t++dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\t/* Right to left. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong - dstlongs;\n\t\t    if ( dstleftignore != 0 )\n\t\t\t++dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t--srclong;\n\t\t\t--dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     --srclong;\n\t\t\t\t--dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    }"
  },
  {
    "function_name": "raster_op_nosrc_noclip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
    "lines": "759-860",
    "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
    "includes": [
      "#include \"raster.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ROP_DST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*d*/dl",
            "/*pst*/*dstlong = ( dl & nrm ) | ( *dstlong & rm );"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_DST",
          "args": [
            "/*op*/op",
            "/*pre*/while ( dstlong != dstlong2 ){",
            "/*d*/*dstlong",
            "/*pst*/++dstlong"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while",
          "args": [
            "dstlong != dstlong2"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_DST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlong;",
            "/*d*/dl",
            "/*pst*/*dstlong = ( *dstlong & lm ) | ( dl & nlm );"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_DST",
          "args": [
            "/*op*/op",
            "/*pre*/dl = *dstlin;",
            "/*d*/dl",
            "/*pst*/*dstlin = ( *dstlin & lm ) | ( dl & nlm );"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char*) dstlin1",
            "h * dst->linelongs * sizeof(u_int32_t)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "dst",
            "dx",
            "dy"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_GETOP",
          "args": [
            "rop"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
  },
  {
    "function_name": "raster_op_noclip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
    "lines": "595-754",
    "snippet": "int\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }",
    "includes": [
      "#include \"raster.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int raster_blit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_blit",
          "args": [
            "src",
            "srclin1",
            "srcleftignore",
            "srcrightignore",
            "srclongs",
            "dst",
            "dstlin1",
            "dstleftignore",
            "dstrightignore",
            "dstlongs",
            "h",
            "op"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "raster_blit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "973-1160",
          "snippet": "static int\nraster_blit( src, srclin1, srcleftignore, srcrightignore, srclongs, dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op )\n    struct raster* src;\n    u_int32_t* srclin1;\n    int srcleftignore, srcrightignore, srclongs;\n    struct raster* dst;\n    u_int32_t* dstlin1;\n    int dstleftignore, dstrightignore, dstlongs;\n    int h, op;\n    {\n    u_int32_t* srclin2;\n    u_int32_t* dstlin2;\n    int srclininc, dstlininc;\n    u_int32_t* srclin;\n    u_int32_t* dstlin;\n    register int prevleftshift, currrightshift;\n    int longinc;\n    register u_int32_t* srclong;\n    register u_int32_t* dstlong;\n    register u_int32_t* dstlong2;\n    register u_int32_t dl, lm, nlm, rm, nrm;\n\n    prevleftshift = ( srcleftignore - dstleftignore ) & 31;\n\n    srclin2 = srclin1 + h * src->linelongs;\n    dstlin2 = dstlin1 + h * dst->linelongs;\n    srclininc = src->linelongs;\n    dstlininc = dst->linelongs;\n    longinc = 1;\n\n    /* Check for overlaps. */\n    if ( ( dstlin1 >= srclin1 && dstlin1 < srclin1 + srclongs ) ||\n\t ( srclin1 >= dstlin1 && srclin1 < dstlin1 + dstlongs ) )\n\t{\n\t/* Horizontal overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    longinc = -1;\n\t    srclin1 += srclongs - 1;\n\t    srclin2 += srclongs - 1;\n\t    dstlin1 += dstlongs - 1;\n\t    }\n\t}\n    else if ( ( dstlin1 >= srclin1 && dstlin1 < srclin2 ) ||\n\t      ( srclin1 >= dstlin1 && srclin1 < dstlin2 ) )\n\t{\n\t/* Vertical overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    srclin2 = srclin1 - srclininc;\n\t    srclin1 += ( h - 1 ) * srclininc;\n\t    dstlin1 += ( h - 1 ) * dstlininc;\n\t    srclininc = -srclininc;\n\t    dstlininc = -dstlininc;\n\t    }\n\t}\n    srclin = srclin1;\n    dstlin = dstlin1;\n\n    if ( prevleftshift == 0 )\n\t{\n\t/* The bits line up, no shifting necessary. */\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It all fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tROP_SRCDST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*s*/   *srclin,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tsrclin += srclininc;\n\t\tdstlin += dstlininc;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    /* Multiple longwords. */\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\t    if ( longinc == 1 )\n\t\t{\n\t\t/* Left to right. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong + dstlongs;\n\t\t    if ( dstrightignore != 0 )\n\t\t\t--dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t++srclong;\n\t\t\t++dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     ++srclong;\n\t\t\t\t++dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\t/* Right to left. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong - dstlongs;\n\t\t    if ( dstleftignore != 0 )\n\t\t\t++dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t--srclong;\n\t\t\t--dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     --srclong;\n\t\t\t\t--dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    }",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raster_blit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int raster_blit;\n\nstatic int\nraster_blit( src, srclin1, srcleftignore, srcrightignore, srclongs, dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op )\n    struct raster* src;\n    u_int32_t* srclin1;\n    int srcleftignore, srcrightignore, srclongs;\n    struct raster* dst;\n    u_int32_t* dstlin1;\n    int dstleftignore, dstrightignore, dstlongs;\n    int h, op;\n    {\n    u_int32_t* srclin2;\n    u_int32_t* dstlin2;\n    int srclininc, dstlininc;\n    u_int32_t* srclin;\n    u_int32_t* dstlin;\n    register int prevleftshift, currrightshift;\n    int longinc;\n    register u_int32_t* srclong;\n    register u_int32_t* dstlong;\n    register u_int32_t* dstlong2;\n    register u_int32_t dl, lm, nlm, rm, nrm;\n\n    prevleftshift = ( srcleftignore - dstleftignore ) & 31;\n\n    srclin2 = srclin1 + h * src->linelongs;\n    dstlin2 = dstlin1 + h * dst->linelongs;\n    srclininc = src->linelongs;\n    dstlininc = dst->linelongs;\n    longinc = 1;\n\n    /* Check for overlaps. */\n    if ( ( dstlin1 >= srclin1 && dstlin1 < srclin1 + srclongs ) ||\n\t ( srclin1 >= dstlin1 && srclin1 < dstlin1 + dstlongs ) )\n\t{\n\t/* Horizontal overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    longinc = -1;\n\t    srclin1 += srclongs - 1;\n\t    srclin2 += srclongs - 1;\n\t    dstlin1 += dstlongs - 1;\n\t    }\n\t}\n    else if ( ( dstlin1 >= srclin1 && dstlin1 < srclin2 ) ||\n\t      ( srclin1 >= dstlin1 && srclin1 < dstlin2 ) )\n\t{\n\t/* Vertical overlap.  Should we reverse? */\n\tif ( srclin1 < dstlin1 )\n\t    {\n\t    srclin2 = srclin1 - srclininc;\n\t    srclin1 += ( h - 1 ) * srclininc;\n\t    dstlin1 += ( h - 1 ) * dstlininc;\n\t    srclininc = -srclininc;\n\t    dstlininc = -dstlininc;\n\t    }\n\t}\n    srclin = srclin1;\n    dstlin = dstlin1;\n\n    if ( prevleftshift == 0 )\n\t{\n\t/* The bits line up, no shifting necessary. */\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It all fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tROP_SRCDST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*s*/   *srclin,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tsrclin += srclininc;\n\t\tdstlin += dstlininc;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    /* Multiple longwords. */\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\t    if ( longinc == 1 )\n\t\t{\n\t\t/* Left to right. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong + dstlongs;\n\t\t    if ( dstrightignore != 0 )\n\t\t\t--dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t++srclong;\n\t\t\t++dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     ++srclong;\n\t\t\t\t++dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    else\n\t\t{\n\t\t/* Right to left. */\n\t\twhile ( srclin != srclin2 )\n\t\t    {\n\t\t    srclong = srclin;\n\t\t    dstlong = dstlin;\n\t\t    dstlong2 = dstlong - dstlongs;\n\t\t    if ( dstleftignore != 0 )\n\t\t\t++dstlong2;\n\n\t\t    /* Leading edge. */\n\t\t    if ( dstrightignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t\t--srclong;\n\t\t\t--dstlong;\n\t\t\t}\n\n\t\t    /* Main rop. */\n\t\t    ROP_SRCDST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ while ( dstlong != dstlong2 )\n\t\t\t\t{,\n\t\t    /*s*/       *srclong,\n\t\t    /*d*/       *dstlong,\n\t\t    /*pst*/     --srclong;\n\t\t\t\t--dstlong;\n\t\t\t\t} )\n\n\t\t    /* Trailing edge. */\n\t\t    if ( dstleftignore != 0 )\n\t\t\t{\n\t\t\tROP_SRCDST(\n\t\t\t/*op*/  op,\n\t\t\t/*pre*/ dl = *dstlong;,\n\t\t\t/*s*/   *srclong,\n\t\t\t/*d*/   dl,\n\t\t\t/*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t\t}\n\n\t\t    srclin += srclininc;\n\t\t    dstlin += dstlininc;\n\t\t    }\n\t\t}\n\t    }"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(char*) srclin1",
            "(char*) dstlin1",
            "h * src->linelongs * sizeof(u_int32_t)"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "dst",
            "dx",
            "dy"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "src",
            "sx",
            "sy"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROP_SRCDSTCOLOR",
          "args": [
            "/*op*/op",
            "/*pre*/while ( i > 0 ){\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    }"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while",
          "args": [
            "i > 0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "dst",
            "dx",
            "dy"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "src",
            "sx",
            "sy"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_GETCOLOR",
          "args": [
            "rop"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "dst",
            "dx",
            "dy"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_ADDR",
          "args": [
            "src",
            "sx",
            "sy"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAS_GETOP",
          "args": [
            "rop"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int raster_blit;\n\nint\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }"
  },
  {
    "function_name": "raster_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
    "lines": "510-590",
    "snippet": "int\nraster_op( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    if ( dst == (struct raster*) 0 )\n\treturn -1;\t\t\t/* no destination */\n\n    if ( needsrc[RAS_GETOP( rop )] )\n\t{\n\t/* Two-operand blit. */\n\tif ( src == (struct raster*) 0 )\n\t    return -1;\t\t\t/* no source */\n\n\t/* Clip against source. */\n\tif ( sx < 0 )\n\t    {\n\t    w += sx;\n\t    sx = 0;\n\t    }\n\tif ( sy < 0 )\n\t    {\n\t    h += sy;\n\t    sy = 0;\n\t    }\n\tif ( sx + w > src->width )\n\t    w = src->width - sx;\n\tif ( sy + h > src->height )\n\t    h = src->height - sy;\n\n\t/* Clip against dest. */\n\tif ( dx < 0 )\n\t    {\n\t    w += dx;\n\t    sx -= dx;\n\t    dx = 0;\n\t    }\n\tif ( dy < 0 )\n\t    {\n\t    h += dy;\n\t    sy -= dy;\n\t    dy = 0;\n\t    }\n\tif ( dx + w > dst->width )\n\t    w = dst->width - dx;\n\tif ( dy + h > dst->height )\n\t    h = dst->height - dy;\n\n\tif ( w <= 0 || h <= 0 )\n\t    return 0;\t\t\t/* nothing to do */\n\n\treturn raster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy );\n\t}\n\n    /* No source necessary - one-operand blit. */\n    if ( src != (struct raster*) 0 )\n\treturn -1;\t\t\t/* unwanted source */\n\n    /* Clip against dest. */\n    if ( dx < 0 )\n\t{\n\tw += dx;\n\tdx = 0;\n\t}\n    if ( dy < 0 )\n\t{\n\th += dy;\n\tdy = 0;\n\t}\n    if ( dx + w > dst->width )\n\tw = dst->width - dx;\n    if ( dy + h > dst->height )\n\th = dst->height - dy;\n\n    if ( w <= 0 || h <= 0 )\n\treturn 0;\t\t\t/* nothing to do */\n\n    return raster_op_nosrc_noclip( dst, dx, dy, w, h, rop );\n    }",
    "includes": [
      "#include \"raster.h\"",
      "#include <dev/rcons/raster.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int needsrc[16] = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op_nosrc_noclip",
          "args": [
            "dst",
            "dx",
            "dy",
            "w",
            "h",
            "rop"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "raster_op_noclip",
          "args": [
            "dst",
            "dx",
            "dy",
            "w",
            "h",
            "rop",
            "src",
            "sx",
            "sy"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "595-754",
          "snippet": "int\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int raster_blit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int raster_blit;\n\nint\nraster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( src->depth == 1 )\n\t{\n\t/* One-bit to ? blit. */\n\tif ( dst->depth == 1 )\n\t    {\n\t    /* One to one blit. */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    int srcleftignore, srcrightignore, srclongs;\n\t    int dstleftignore, dstrightignore, dstlongs;\n\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t    /* Special-case full-width to full-width copies. */\n\t    if ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t\t src->linelongs == dst->linelongs && src->linelongs == w >> 5 )\n\t\t{\n\t\tbcopy(\n\t\t    (char*) srclin1, (char*) dstlin1,\n\t\t    h * src->linelongs * sizeof(u_int32_t) );\n\t\treturn 0;\n\t\t}\n#endif /*BCOPY_FASTER*/\n\n\t    srcleftignore = ( sx & 31 );\n\t    srclongs = ( srcleftignore + w + 31 ) >> 5;\n\t    srcrightignore = ( srclongs * 32 - w - srcleftignore ) & 31;\n\t    dstleftignore = ( dx & 31 );\n\t    dstlongs = ( dstleftignore + w + 31 ) >> 5;\n\t    dstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\t    return raster_blit(\n\t\tsrc, srclin1, srcleftignore, srcrightignore, srclongs,\n\t\tdst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t    }\n\n\telse\n\t    {\n\t    /* One to eight, using the color in the rop.  This could\n\t    ** probably be sped up by handling each four-bit source nybble\n\t    ** as a group, indexing into a 16-element runtime-constructed\n\t    ** table of longwords.\n\t    */\n\t    u_int32_t* srclin1;\n\t    u_int32_t* dstlin1;\n\t    u_int32_t* srclin2;\n\t    u_int32_t* srclin;\n\t    u_int32_t* dstlin;\n\t    register u_int32_t* srclong;\n\t    register u_int32_t* dstlong;\n\t    register u_int32_t color, dl;\n\t    register int srcbit, dstbyte, i;\n\n\t    color = RAS_GETCOLOR( rop );\n\t    if ( color == 0 )\n\t\tcolor = 255;\n\n\t    /* Make 32 bits of color so we can do the ROP without shifting. */\n\t    color |= ( color << 24 ) | ( color << 16 ) | ( color << 8 );\n\n\t    /* Don't have to worry about overlapping blits here. */\n\t    srclin1 = RAS_ADDR( src, sx, sy );\n\t    srclin2 = srclin1 + h * src->linelongs;\n\t    dstlin1 = RAS_ADDR( dst, dx, dy );\n\t    srclin = srclin1;\n\t    dstlin = dstlin1;\n\t    while ( srclin != srclin2 )\n\t\t{\n\t\tsrclong = srclin;\n\t\tsrcbit = sx & 31;\n\t\tdstlong = dstlin;\n\t\tdstbyte = dx & 3;\n\t\ti = w;\n\n\t\t/* WARNING: this code is KNOWN TO FAIL on Sun 3's / CG2's. */\n\t\tROP_SRCDSTCOLOR(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( i > 0 )\n\t\t\t    {\n\t\t\t    dl = *dstlong;,\n\t\t/*s*/       *srclong & raster_bitmask[srcbit],\n\t\t/*d*/       dl,\n\t\t/*c*/       color,\n\t\t/*pst*/     *dstlong = ( *dstlong & ~bytemask[dstbyte] ) |\n\t\t\t\t       ( dl & bytemask[dstbyte] );\n\t\t\t    if ( srcbit == 31 )\n\t\t\t\t{\n\t\t\t\tsrcbit = 0;\n\t\t\t\t++srclong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++srcbit;\n\t\t\t    if ( dstbyte == 3 )\n\t\t\t\t{\n\t\t\t\tdstbyte = 0;\n\t\t\t\t++dstlong;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t\t++dstbyte;\n\t\t\t    --i;\n\t\t\t    } )\n\n\t\tsrclin += src->linelongs;\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}\n\n    else\n\t{\n\t/* Eight to eight blit. */\n\tu_int32_t* srclin1;\n\tu_int32_t* dstlin1;\n\tint srcleftignore, srcrightignore, srclongs;\n\tint dstleftignore, dstrightignore, dstlongs;\n\n\tif ( dst->depth != 8 )\n\t    return -1;\t\t/* depth mismatch */\n\n\tsrclin1 = RAS_ADDR( src, sx, sy );\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width to full-width copies. */\n\tif ( op == RAS_SRC && src->width == w && dst->width == w &&\n\t     src->linelongs == dst->linelongs && src->linelongs == w >> 2 )\n\t    {\n\t    bcopy( (char*) srclin1, (char*) dstlin1,\n\t\t   h * src->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tsrcleftignore = ( sx & 3 ) * 8;\n\tsrclongs = ( srcleftignore + w * 8 + 31 ) >> 5;\n\tsrcrightignore = ( srclongs * 32 - w * 8 - srcleftignore ) & 31;\n\tdstleftignore = ( dx & 3 ) * 8;\n\tdstlongs = ( dstleftignore + w * 8 + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w * 8 - dstleftignore ) & 31;\n\n\treturn raster_blit(\n\t    src, srclin1, srcleftignore, srcrightignore, srclongs,\n\t    dst, dstlin1, dstleftignore, dstrightignore, dstlongs, h, op );\n\t}\n\n    return 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "RAS_GETOP",
          "args": [
            "rop"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nstatic int needsrc[16] = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0 };\n\nint\nraster_op( dst, dx, dy, w, h, rop, src, sx, sy )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    struct raster* src;\n    int sx, sy;\n    {\n    if ( dst == (struct raster*) 0 )\n\treturn -1;\t\t\t/* no destination */\n\n    if ( needsrc[RAS_GETOP( rop )] )\n\t{\n\t/* Two-operand blit. */\n\tif ( src == (struct raster*) 0 )\n\t    return -1;\t\t\t/* no source */\n\n\t/* Clip against source. */\n\tif ( sx < 0 )\n\t    {\n\t    w += sx;\n\t    sx = 0;\n\t    }\n\tif ( sy < 0 )\n\t    {\n\t    h += sy;\n\t    sy = 0;\n\t    }\n\tif ( sx + w > src->width )\n\t    w = src->width - sx;\n\tif ( sy + h > src->height )\n\t    h = src->height - sy;\n\n\t/* Clip against dest. */\n\tif ( dx < 0 )\n\t    {\n\t    w += dx;\n\t    sx -= dx;\n\t    dx = 0;\n\t    }\n\tif ( dy < 0 )\n\t    {\n\t    h += dy;\n\t    sy -= dy;\n\t    dy = 0;\n\t    }\n\tif ( dx + w > dst->width )\n\t    w = dst->width - dx;\n\tif ( dy + h > dst->height )\n\t    h = dst->height - dy;\n\n\tif ( w <= 0 || h <= 0 )\n\t    return 0;\t\t\t/* nothing to do */\n\n\treturn raster_op_noclip( dst, dx, dy, w, h, rop, src, sx, sy );\n\t}\n\n    /* No source necessary - one-operand blit. */\n    if ( src != (struct raster*) 0 )\n\treturn -1;\t\t\t/* unwanted source */\n\n    /* Clip against dest. */\n    if ( dx < 0 )\n\t{\n\tw += dx;\n\tdx = 0;\n\t}\n    if ( dy < 0 )\n\t{\n\th += dy;\n\tdy = 0;\n\t}\n    if ( dx + w > dst->width )\n\tw = dst->width - dx;\n    if ( dy + h > dst->height )\n\th = dst->height - dy;\n\n    if ( w <= 0 || h <= 0 )\n\treturn 0;\t\t\t/* nothing to do */\n\n    return raster_op_nosrc_noclip( dst, dx, dy, w, h, rop );\n    }"
  }
]