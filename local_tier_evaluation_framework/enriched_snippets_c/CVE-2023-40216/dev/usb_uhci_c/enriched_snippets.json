[
  {
    "function_name": "uhci_root_intr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3218-3227",
    "snippet": "void\nuhci_root_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub, sc->sc_intr_xfer);\n\tsc->sc_intr_xfer = NULL;\n\tDPRINTF((\"uhci_root_intr_close\\n\"));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_root_intr_close\\n\")"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "sc->sc_poll_handle",
            "uhci_poll_hub",
            "sc->sc_intr_xfer"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_root_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub, sc->sc_intr_xfer);\n\tsc->sc_intr_xfer = NULL;\n\tDPRINTF((\"uhci_root_intr_close\\n\"));\n}"
  },
  {
    "function_name": "uhci_root_intr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3198-3215",
    "snippet": "usbd_status\nuhci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tDPRINTFN(3, (\"uhci_root_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = xfer;\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_open __P((usbd_pipe_handle));",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->sc_poll_handle",
            "sc->sc_ival",
            "uhci_poll_hub",
            "xfer"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MS_TO_TICKS",
          "args": [
            "xfer->pipe->endpoint->edesc->bInterval"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci_root_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags)"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tDPRINTFN(3, (\"uhci_root_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = xfer;\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_root_intr_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3180-3195",
    "snippet": "usbd_status\nuhci_root_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * start first\n\t */\n\treturn (uhci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_root_intr_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_root_intr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "3198-3215",
          "snippet": "usbd_status\nuhci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tDPRINTFN(3, (\"uhci_root_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = xfer;\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_close __P((usbd_pipe_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_close __P((usbd_pipe_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_close __P((usbd_pipe_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_close __P((usbd_pipe_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_close __P((usbd_pipe_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_close __P((usbd_pipe_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_open __P((usbd_pipe_handle));",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_root_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\n\tDPRINTFN(3, (\"uhci_root_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tsc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = xfer;\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_root_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * start first\n\t */\n\treturn (uhci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "uhci_root_intr_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3160-3178",
    "snippet": "void\nuhci_root_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\n\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = NULL;\n\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"uhci_root_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = 0;\n\t}\n\txfer->status = USBD_CANCELLED;\n#ifdef DIAGNOSTIC\n\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_root_intr_abort: remove\\n\")"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "sc->sc_poll_handle",
            "uhci_poll_hub",
            "xfer"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_root_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\n\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub, xfer);\n\tsc->sc_intr_xfer = NULL;\n\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTF((\"uhci_root_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = 0;\n\t}\n\txfer->status = USBD_CANCELLED;\n#ifdef DIAGNOSTIC\n\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n}"
  },
  {
    "function_name": "uhci_root_ctrl_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3152-3157",
    "snippet": "void\nuhci_root_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tDPRINTF((\"uhci_root_ctrl_close\\n\"));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_root_ctrl_close\\n\")"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_root_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tDPRINTF((\"uhci_root_ctrl_close\\n\"));\n}"
  },
  {
    "function_name": "uhci_root_ctrl_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "3144-3149",
    "snippet": "void\nuhci_root_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\t/* Nothing to do, all transfers are synchronous. */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_root_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\t/* Nothing to do, all transfers are synchronous. */\n}"
  },
  {
    "function_name": "uhci_root_ctrl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2812-3141",
    "snippet": "usbd_status\nuhci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, x;\n\tint s, len, value, index, status, change, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_root_ctrl_transfer: not a request\\n\");\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(2,(\"uhci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(2,(\"uhci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(uhci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &uhci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &uhci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = uhci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = uhci_str(buf, len, \"UHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(3, (\"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_CSC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_POEDC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_OCIC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tsc->sc_isreset = 0;\n\t\t\terr = USBD_NORMAL_COMPLETION;\n\t\t\tgoto ret;\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = \n\t\t\t\t(UREAD2(sc, port) & UHCI_PORTSC_LS) >>\n\t\t\t\tUHCI_PORTSC_LS_SHIFT;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tl = min(len, USB_HUB_DESCRIPTOR_SIZE);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &uhci_hubd_piix, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len);\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tx = UREAD2(sc, port);\n\t\tstatus = change = 0;\n\t\tif (x & UHCI_PORTSC_CCS  )\n\t\t\tstatus |= UPS_CURRENT_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_CSC  ) \n\t\t\tchange |= UPS_C_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_PE   ) \n\t\t\tstatus |= UPS_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_POEDC) \n\t\t\tchange |= UPS_C_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_OCI  ) \n\t\t\tstatus |= UPS_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_OCIC ) \n\t\t\tchange |= UPS_C_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_SUSP ) \n\t\t\tstatus |= UPS_SUSPEND;\n\t\tif (x & UHCI_PORTSC_LSDA ) \n\t\t\tstatus |= UPS_LOW_SPEED;\n\t\tstatus |= UPS_PORT_POWER;\n\t\tif (sc->sc_isreset)\n\t\t\tchange |= UPS_C_PORT_RESET;\n\t\tUSETW(ps.wPortStatus, status);\n\t\tUSETW(ps.wPortChange, change);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PR);\n\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tdelay(100);\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x  | UHCI_PORTSC_PE);\n\t\t\tdelay(100);\n\t\t\tDPRINTFN(3,(\"uhci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, UREAD2(sc, port)));\n\t\t\tsc->sc_isreset = 1;\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_RESET:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;",
      "usb_device_descriptor_t uhci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};",
      "usb_config_descriptor_t uhci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};",
      "usb_interface_descriptor_t uhci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};",
      "usb_endpoint_descriptor_t uhci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | UHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8},\n\t255\n};",
      "usb_hub_descriptor_t uhci_hubd_piix = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t2,\n\t{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },\n\t50,\t\t\t/* power on to power good */\n\t0,\n\t{ 0x00 },\t\t/* both ports are removable */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 3138
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, UREAD2(sc, port))"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x  | UHCI_PORTSC_PE"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x & ~UHCI_PORTSC_PR"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "10"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_PR"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_SUSP"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_PE"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "C",
          "args": [
            "UR_SET_FEATURE",
            "UT_WRITE_CLASS_OTHER"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_printBCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "266-272",
          "snippet": "int\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_printBCD(cp, bcd)\n\tchar *cp;\n\tint bcd;\n{\n\treturn (sprintf(cp, \"%x.%02x\", bcd >> 8, bcd & 0xff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&ps",
            "l"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "sizeof ps"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "ps.wPortChange",
            "change"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "ps.wPortStatus",
            "status"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "len"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&uhci_hubd_piix",
            "l"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_OCIC"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_POEDC"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x | UHCI_PORTSC_CSC"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x & ~UHCI_PORTSC_PR"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x & ~UHCI_PORTSC_SUSP"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "port",
            "x & ~UHCI_PORTSC_PE"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "port"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value)"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "((usb_status_t *)buf)->wStatus",
            "0"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "((usb_status_t *)buf)->wStatus",
            "UDS_SELF_POWERED"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_str",
          "args": [
            "buf",
            "len",
            "\"UHCI root hub\""
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2771-2789",
          "snippet": "int\nuhci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_str __P((usb_string_descriptor_t *, int, char *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_str __P((usb_string_descriptor_t *, int, char *));\n\nint\nuhci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&uhci_endpd",
            "l"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&uhci_ifcd",
            "l"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&uhci_confd",
            "l"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&uhci_devd",
            "l"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "uhci_devd.idVendor",
            "sc->sc_id_vendor"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhci_root_ctrl_control wValue=0x%04x\\n\", value)"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wIndex"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wValue"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest)"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_root_ctrl_transfer: not a request\\n\""
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\nusb_device_descriptor_t uhci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};\nusb_config_descriptor_t uhci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};\nusb_interface_descriptor_t uhci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};\nusb_endpoint_descriptor_t uhci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | UHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8},\n\t255\n};\nusb_hub_descriptor_t uhci_hubd_piix = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t2,\n\t{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },\n\t50,\t\t\t/* power on to power good */\n\t0,\n\t{ 0x00 },\t\t/* both ports are removable */\n};\n\nusbd_status\nuhci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, x;\n\tint s, len, value, index, status, change, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_root_ctrl_transfer: not a request\\n\");\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(2,(\"uhci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(2,(\"uhci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(uhci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &uhci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &uhci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = uhci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = uhci_str(buf, len, \"UHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(3, (\"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_CSC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_POEDC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_OCIC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tsc->sc_isreset = 0;\n\t\t\terr = USBD_NORMAL_COMPLETION;\n\t\t\tgoto ret;\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = \n\t\t\t\t(UREAD2(sc, port) & UHCI_PORTSC_LS) >>\n\t\t\t\tUHCI_PORTSC_LS_SHIFT;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tl = min(len, USB_HUB_DESCRIPTOR_SIZE);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &uhci_hubd_piix, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len);\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tx = UREAD2(sc, port);\n\t\tstatus = change = 0;\n\t\tif (x & UHCI_PORTSC_CCS  )\n\t\t\tstatus |= UPS_CURRENT_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_CSC  ) \n\t\t\tchange |= UPS_C_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_PE   ) \n\t\t\tstatus |= UPS_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_POEDC) \n\t\t\tchange |= UPS_C_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_OCI  ) \n\t\t\tstatus |= UPS_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_OCIC ) \n\t\t\tchange |= UPS_C_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_SUSP ) \n\t\t\tstatus |= UPS_SUSPEND;\n\t\tif (x & UHCI_PORTSC_LSDA ) \n\t\t\tstatus |= UPS_LOW_SPEED;\n\t\tstatus |= UPS_PORT_POWER;\n\t\tif (sc->sc_isreset)\n\t\t\tchange |= UPS_C_PORT_RESET;\n\t\tUSETW(ps.wPortStatus, status);\n\t\tUSETW(ps.wPortChange, change);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PR);\n\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tdelay(100);\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x  | UHCI_PORTSC_PE);\n\t\t\tdelay(100);\n\t\t\tDPRINTFN(3,(\"uhci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, UREAD2(sc, port)));\n\t\t\tsc->sc_isreset = 1;\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_RESET:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_root_ctrl_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2794-2810",
    "snippet": "usbd_status\nuhci_root_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_root_ctrl_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_root_ctrl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2812-3141",
          "snippet": "usbd_status\nuhci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, x;\n\tint s, len, value, index, status, change, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_root_ctrl_transfer: not a request\\n\");\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(2,(\"uhci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(2,(\"uhci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(uhci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &uhci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &uhci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = uhci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = uhci_str(buf, len, \"UHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(3, (\"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_CSC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_POEDC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_OCIC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tsc->sc_isreset = 0;\n\t\t\terr = USBD_NORMAL_COMPLETION;\n\t\t\tgoto ret;\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = \n\t\t\t\t(UREAD2(sc, port) & UHCI_PORTSC_LS) >>\n\t\t\t\tUHCI_PORTSC_LS_SHIFT;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tl = min(len, USB_HUB_DESCRIPTOR_SIZE);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &uhci_hubd_piix, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len);\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tx = UREAD2(sc, port);\n\t\tstatus = change = 0;\n\t\tif (x & UHCI_PORTSC_CCS  )\n\t\t\tstatus |= UPS_CURRENT_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_CSC  ) \n\t\t\tchange |= UPS_C_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_PE   ) \n\t\t\tstatus |= UPS_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_POEDC) \n\t\t\tchange |= UPS_C_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_OCI  ) \n\t\t\tstatus |= UPS_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_OCIC ) \n\t\t\tchange |= UPS_C_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_SUSP ) \n\t\t\tstatus |= UPS_SUSPEND;\n\t\tif (x & UHCI_PORTSC_LSDA ) \n\t\t\tstatus |= UPS_LOW_SPEED;\n\t\tstatus |= UPS_PORT_POWER;\n\t\tif (sc->sc_isreset)\n\t\t\tchange |= UPS_C_PORT_RESET;\n\t\tUSETW(ps.wPortStatus, status);\n\t\tUSETW(ps.wPortChange, change);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PR);\n\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tdelay(100);\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x  | UHCI_PORTSC_PE);\n\t\t\tdelay(100);\n\t\t\tDPRINTFN(3,(\"uhci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, UREAD2(sc, port)));\n\t\t\tsc->sc_isreset = 1;\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_RESET:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;",
            "usb_device_descriptor_t uhci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};",
            "usb_config_descriptor_t uhci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};",
            "usb_interface_descriptor_t uhci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};",
            "usb_endpoint_descriptor_t uhci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | UHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8},\n\t255\n};",
            "usb_hub_descriptor_t uhci_hubd_piix = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t2,\n\t{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },\n\t50,\t\t\t/* power on to power good */\n\t0,\n\t{ 0x00 },\t\t/* both ports are removable */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\nusb_device_descriptor_t uhci_devd = {\n\tUSB_DEVICE_DESCRIPTOR_SIZE,\n\tUDESC_DEVICE,\t\t/* type */\n\t{0x00, 0x01},\t\t/* USB version */\n\tUDCLASS_HUB,\t\t/* class */\n\tUDSUBCLASS_HUB,\t\t/* subclass */\n\t0,\t\t\t/* protocol */\n\t64,\t\t\t/* max packet */\n\t{0},{0},{0x00,0x01},\t/* device id */\n\t1,2,0,\t\t\t/* string indicies */\n\t1\t\t\t/* # of configurations */\n};\nusb_config_descriptor_t uhci_confd = {\n\tUSB_CONFIG_DESCRIPTOR_SIZE,\n\tUDESC_CONFIG,\n\t{USB_CONFIG_DESCRIPTOR_SIZE +\n\t USB_INTERFACE_DESCRIPTOR_SIZE +\n\t USB_ENDPOINT_DESCRIPTOR_SIZE},\n\t1,\n\t1,\n\t0,\n\tUC_SELF_POWERED,\n\t0\t\t\t/* max power */\n};\nusb_interface_descriptor_t uhci_ifcd = {\n\tUSB_INTERFACE_DESCRIPTOR_SIZE,\n\tUDESC_INTERFACE,\n\t0,\n\t0,\n\t1,\n\tUICLASS_HUB,\n\tUISUBCLASS_HUB,\n\t0,\n\t0\n};\nusb_endpoint_descriptor_t uhci_endpd = {\n\tUSB_ENDPOINT_DESCRIPTOR_SIZE,\n\tUDESC_ENDPOINT,\n\tUE_DIR_IN | UHCI_INTR_ENDPT,\n\tUE_INTERRUPT,\n\t{8},\n\t255\n};\nusb_hub_descriptor_t uhci_hubd_piix = {\n\tUSB_HUB_DESCRIPTOR_SIZE,\n\tUDESC_HUB,\n\t2,\n\t{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },\n\t50,\t\t\t/* power on to power good */\n\t0,\n\t{ 0x00 },\t\t/* both ports are removable */\n};\n\nusbd_status\nuhci_root_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusb_device_request_t *req;\n\tvoid *buf = NULL;\n\tint port, x;\n\tint s, len, value, index, status, change, l, totlen = 0;\n\tusb_port_status_t ps;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_root_ctrl_transfer: not a request\\n\");\n#endif\n\treq = &xfer->request;\n\n\tDPRINTFN(2,(\"uhci_root_ctrl_control type=0x%02x request=%02x\\n\", \n\t\t    req->bmRequestType, req->bRequest));\n\n\tlen = UGETW(req->wLength);\n\tvalue = UGETW(req->wValue);\n\tindex = UGETW(req->wIndex);\n\n\tif (len != 0)\n\t\tbuf = KERNADDR(&xfer->dmabuf);\n\n#define C(x,y) ((x) | ((y) << 8))\n\tswitch(C(req->bRequest, req->bmRequestType)) {\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):\n\t\t/* \n\t\t * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops\n\t\t * for the integrated root hub.\n\t\t */\n\t\tbreak;\n\tcase C(UR_GET_CONFIG, UT_READ_DEVICE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = sc->sc_conf;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):\n\t\tDPRINTFN(2,(\"uhci_root_ctrl_control wValue=0x%04x\\n\", value));\n\t\tswitch(value >> 8) {\n\t\tcase UDESC_DEVICE:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);\n\t\t\tUSETW(uhci_devd.idVendor, sc->sc_id_vendor);\n\t\t\tmemcpy(buf, &uhci_devd, l);\n\t\t\tbreak;\n\t\tcase UDESC_CONFIG:\n\t\t\tif ((value & 0xff) != 0) {\n\t\t\t\terr = USBD_IOERROR;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t\ttotlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);\n\t\t\tmemcpy(buf, &uhci_confd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_ifcd, l);\n\t\t\tbuf = (char *)buf + l;\n\t\t\tlen -= l;\n\t\t\tl = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);\n\t\t\ttotlen += l;\n\t\t\tmemcpy(buf, &uhci_endpd, l);\n\t\t\tbreak;\n\t\tcase UDESC_STRING:\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t\tswitch (value & 0xff) {\n\t\t\tcase 1: /* Vendor */\n\t\t\t\ttotlen = uhci_str(buf, len, sc->sc_vendor);\n\t\t\t\tbreak;\n\t\t\tcase 2: /* Product */\n\t\t\t\ttotlen = uhci_str(buf, len, \"UHCI root hub\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_INTERFACE, UT_READ_INTERFACE):\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = 0;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_DEVICE):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_INTERFACE):\n\tcase C(UR_GET_STATUS, UT_READ_ENDPOINT):\n\t\tif (len > 1) {\n\t\t\tUSETW(((usb_status_t *)buf)->wStatus, 0);\n\t\t\ttotlen = 2;\n\t\t}\n\t\tbreak;\n\tcase C(UR_SET_ADDRESS, UT_WRITE_DEVICE):\n\t\tif (value >= USB_MAX_DEVICES) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_addr = value;\n\t\tbreak;\n\tcase C(UR_SET_CONFIG, UT_WRITE_DEVICE):\n\t\tif (value != 0 && value != 1) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tsc->sc_conf = value;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_DEVICE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_INTERFACE):\n\tcase C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):\n\t\tbreak;\n\tcase C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):\n\t\tbreak;\n\t/* Hub requests */\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tDPRINTFN(3, (\"uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE \"\n\t\t\t     \"port=%d feature=%d\\n\",\n\t\t\t     index, value));\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_CSC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_POEDC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_OCIC);\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_RESET:\n\t\t\tsc->sc_isreset = 0;\n\t\t\terr = USBD_NORMAL_COMPLETION;\n\t\t\tgoto ret;\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len > 0) {\n\t\t\t*(u_int8_t *)buf = \n\t\t\t\t(UREAD2(sc, port) & UHCI_PORTSC_LS) >>\n\t\t\t\tUHCI_PORTSC_LS_SHIFT;\n\t\t\ttotlen = 1;\n\t\t}\n\t\tbreak;\n\tcase C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):\n\t\tif (value != 0) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tl = min(len, USB_HUB_DESCRIPTOR_SIZE);\n\t\ttotlen = l;\n\t\tmemcpy(buf, &uhci_hubd_piix, l);\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tmemset(buf, 0, len);\n\t\ttotlen = len;\n\t\tbreak;\n\tcase C(UR_GET_STATUS, UT_READ_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 4) {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tx = UREAD2(sc, port);\n\t\tstatus = change = 0;\n\t\tif (x & UHCI_PORTSC_CCS  )\n\t\t\tstatus |= UPS_CURRENT_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_CSC  ) \n\t\t\tchange |= UPS_C_CONNECT_STATUS;\n\t\tif (x & UHCI_PORTSC_PE   ) \n\t\t\tstatus |= UPS_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_POEDC) \n\t\t\tchange |= UPS_C_PORT_ENABLED;\n\t\tif (x & UHCI_PORTSC_OCI  ) \n\t\t\tstatus |= UPS_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_OCIC ) \n\t\t\tchange |= UPS_C_OVERCURRENT_INDICATOR;\n\t\tif (x & UHCI_PORTSC_SUSP ) \n\t\t\tstatus |= UPS_SUSPEND;\n\t\tif (x & UHCI_PORTSC_LSDA ) \n\t\t\tstatus |= UPS_LOW_SPEED;\n\t\tstatus |= UPS_PORT_POWER;\n\t\tif (sc->sc_isreset)\n\t\t\tchange |= UPS_C_PORT_RESET;\n\t\tUSETW(ps.wPortStatus, status);\n\t\tUSETW(ps.wPortChange, change);\n\t\tl = min(len, sizeof ps);\n\t\tmemcpy(buf, &ps, l);\n\t\ttotlen = l;\n\t\tbreak;\n\tcase C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):\n\t\tbreak;\n\tcase C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):\n\t\tif (index == 1)\n\t\t\tport = UHCI_PORTSC1;\n\t\telse if (index == 2)\n\t\t\tport = UHCI_PORTSC2;\n\t\telse {\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tswitch(value) {\n\t\tcase UHF_PORT_ENABLE:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PE);\n\t\t\tbreak;\n\t\tcase UHF_PORT_SUSPEND:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase UHF_PORT_RESET:\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x | UHCI_PORTSC_PR);\n\t\t\tusb_delay_ms(&sc->sc_bus, 10);\n\t\t\tUWRITE2(sc, port, x & ~UHCI_PORTSC_PR);\n\t\t\tdelay(100);\n\t\t\tx = UREAD2(sc, port);\n\t\t\tUWRITE2(sc, port, x  | UHCI_PORTSC_PE);\n\t\t\tdelay(100);\n\t\t\tDPRINTFN(3,(\"uhci port %d reset, status = 0x%04x\\n\",\n\t\t\t\t    index, UREAD2(sc, port)));\n\t\t\tsc->sc_isreset = 1;\n\t\t\tbreak;\n\t\tcase UHF_C_PORT_CONNECTION:\n\t\tcase UHF_C_PORT_ENABLE:\n\t\tcase UHF_C_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_CONNECTION:\n\t\tcase UHF_PORT_OVER_CURRENT:\n\t\tcase UHF_PORT_POWER:\n\t\tcase UHF_PORT_LOW_SPEED:\n\t\tcase UHF_C_PORT_SUSPEND:\n\t\tcase UHF_C_PORT_RESET:\n\t\tdefault:\n\t\t\terr = USBD_IOERROR;\n\t\t\tgoto ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = USBD_IOERROR;\n\t\tgoto ret;\n\t}\n\txfer->actlen = totlen;\n\terr = USBD_NORMAL_COMPLETION;\n ret:\n\txfer->status = err;\n\ts = splusb();\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_root_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "uhci_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2771-2789",
    "snippet": "int\nuhci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_str __P((usb_string_descriptor_t *, int, char *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "USETW2",
          "args": [
            "p->bString[i]",
            "0",
            "s[i]"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_str __P((usb_string_descriptor_t *, int, char *));\n\nint\nuhci_str(p, l, s)\n\tusb_string_descriptor_t *p;\n\tint l;\n\tchar *s;\n{\n\tint i;\n\n\tif (l == 0)\n\t\treturn (0);\n\tp->bLength = 2 * strlen(s) + 2;\n\tif (l == 1)\n\t\treturn (1);\n\tp->bDescriptorType = UDESC_STRING;\n\tl -= 2;\n\tfor (i = 0; s[i] && l > 1; i++, l -= 2)\n\t\tUSETW2(p->bString[i], 0, s[i]);\n\treturn (2*i+2);\n}"
  },
  {
    "function_name": "uhci_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2632-2709",
    "snippet": "usbd_status\nuhci_open(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;\n\tusbd_status err;\n\tint ival;\n\n\tDPRINTFN(1, (\"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, pipe->device->address, \n\t\t     ed->bEndpointAddress, sc->sc_addr));\n\n\tupipe->aborting = 0;\n\tupipe->nexttoggle = 0;\n\n\tif (pipe->device->address == sc->sc_addr) {\n\t\tswitch (ed->bEndpointAddress) {\n\t\tcase USB_CONTROL_ENDPOINT:\n\t\t\tpipe->methods = &uhci_root_ctrl_methods;\n\t\t\tbreak;\n\t\tcase UE_DIR_IN | UHCI_INTR_ENDPT:\n\t\t\tpipe->methods = &uhci_root_intr_methods;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (USBD_INVAL);\n\t\t}\n\t} else {\n\t\tswitch (ed->bmAttributes & UE_XFERTYPE) {\n\t\tcase UE_CONTROL:\n\t\t\tpipe->methods = &uhci_device_ctrl_methods;\n\t\t\tupipe->u.ctl.sqh = uhci_alloc_sqh(sc);\n\t\t\tif (upipe->u.ctl.sqh == NULL)\n\t\t\t\tgoto bad;\n\t\t\tupipe->u.ctl.setup = uhci_alloc_std(sc);\n\t\t\tif (upipe->u.ctl.setup == NULL) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tupipe->u.ctl.stat = uhci_alloc_std(sc);\n\t\t\tif (upipe->u.ctl.stat == NULL) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.setup);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\terr = usb_allocmem(&sc->sc_bus, \n\t\t\t\t  sizeof(usb_device_request_t), \n\t\t\t\t  0, &upipe->u.ctl.reqdma);\n\t\t\tif (err) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.setup);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.stat);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UE_INTERRUPT:\n\t\t\tpipe->methods = &uhci_device_intr_methods;\n\t\t\tival = pipe->interval;\n\t\t\tif (ival == USBD_DEFAULT_INTERVAL)\n\t\t\t\tival = ed->bInterval;\n\t\t\treturn (uhci_device_setintr(sc, upipe, ival));\n\t\tcase UE_ISOCHRONOUS:\n\t\t\tpipe->methods = &uhci_device_isoc_methods;\n\t\t\treturn (uhci_setup_isoc(pipe));\n\t\tcase UE_BULK:\n\t\t\tpipe->methods = &uhci_device_bulk_methods;\n\t\t\tupipe->u.bulk.sqh = uhci_alloc_sqh(sc);\n\t\t\tif (upipe->u.bulk.sqh == NULL)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\treturn (USBD_NOMEM);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UHCI_INTR_ENDPT 1"
    ],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "uhci_open __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "struct usbd_pipe_methods uhci_root_ctrl_methods = {\t\n\tuhci_root_ctrl_transfer,\n\tuhci_root_ctrl_start,\n\tuhci_root_ctrl_abort,\n\tuhci_root_ctrl_close,\n\tuhci_noop,\n\tuhci_root_ctrl_done,\n};",
      "struct usbd_pipe_methods uhci_root_intr_methods = {\t\n\tuhci_root_intr_transfer,\n\tuhci_root_intr_start,\n\tuhci_root_intr_abort,\n\tuhci_root_intr_close,\n\tuhci_noop,\n\tuhci_root_intr_done,\n};",
      "struct usbd_pipe_methods uhci_device_ctrl_methods = {\n\tuhci_device_ctrl_transfer,\n\tuhci_device_ctrl_start,\n\tuhci_device_ctrl_abort,\n\tuhci_device_ctrl_close,\n\tuhci_noop,\n\tuhci_device_ctrl_done,\n};",
      "struct usbd_pipe_methods uhci_device_intr_methods = {\n\tuhci_device_intr_transfer,\n\tuhci_device_intr_start,\n\tuhci_device_intr_abort,\n\tuhci_device_intr_close,\n\tuhci_device_clear_toggle,\n\tuhci_device_intr_done,\n};",
      "struct usbd_pipe_methods uhci_device_bulk_methods = {\n\tuhci_device_bulk_transfer,\n\tuhci_device_bulk_start,\n\tuhci_device_bulk_abort,\n\tuhci_device_bulk_close,\n\tuhci_device_clear_toggle,\n\tuhci_device_bulk_done,\n};",
      "struct usbd_pipe_methods uhci_device_isoc_methods = {\n\tuhci_device_isoc_transfer,\n\tuhci_device_isoc_start,\n\tuhci_device_isoc_abort,\n\tuhci_device_isoc_close,\n\tuhci_noop,\n\tuhci_device_isoc_done,\n};",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_setup_isoc",
          "args": [
            "pipe"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_setup_isoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2342-2396",
          "snippet": "usbd_status\nuhci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tint rd = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tuhci_soft_td_t *std, *vstd;\n\tu_int32_t token;\n\tstruct iso *iso;\n\tint i, s;\n\n\tiso = &upipe->u.iso;\n\tiso->stds = malloc(UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *),\n\t\t\t   M_USBHC, M_WAITOK);\n\n\ttoken = rd ? UHCI_TD_IN (0, endpt, addr, 0) :\n\t\t     UHCI_TD_OUT(0, endpt, addr, 0);\n\n\t/* Allocate the TDs and mark as inactive; */\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tif (std == 0)\n\t\t\tgoto bad;\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(token);\n\t\tiso->stds[i] = std;\n\t}\n\n\t/* Insert TDs into schedule. */\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tvstd = sc->sc_vframes[i].htd;\n\t\tstd->link = vstd->link;\n\t\tstd->td.td_link = vstd->td.td_link;\n\t\tvstd->link.std = std;\n\t\tvstd->td.td_link = htole32(std->physaddr);\n\t}\n\tsplx(s);\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\twhile (--i >= 0)\n\t\tuhci_free_std(sc, iso->stds[i]);\n\tfree(iso->stds, M_USBHC);\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_ctrl_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_intr_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_bulk_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_isoc_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_root_ctrl_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_root_intr_close __P((usbd_pipe_handle));",
            "Static usbd_status",
            "uhci_open __P((usbd_pipe_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nuhci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tint rd = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tuhci_soft_td_t *std, *vstd;\n\tu_int32_t token;\n\tstruct iso *iso;\n\tint i, s;\n\n\tiso = &upipe->u.iso;\n\tiso->stds = malloc(UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *),\n\t\t\t   M_USBHC, M_WAITOK);\n\n\ttoken = rd ? UHCI_TD_IN (0, endpt, addr, 0) :\n\t\t     UHCI_TD_OUT(0, endpt, addr, 0);\n\n\t/* Allocate the TDs and mark as inactive; */\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tif (std == 0)\n\t\t\tgoto bad;\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(token);\n\t\tiso->stds[i] = std;\n\t}\n\n\t/* Insert TDs into schedule. */\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tvstd = sc->sc_vframes[i].htd;\n\t\tstd->link = vstd->link;\n\t\tstd->td.td_link = vstd->td.td_link;\n\t\tvstd->link.std = std;\n\t\tvstd->td.td_link = htole32(std->physaddr);\n\t}\n\tsplx(s);\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\twhile (--i >= 0)\n\t\tuhci_free_std(sc, iso->stds[i]);\n\tfree(iso->stds, M_USBHC);\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_device_setintr",
          "args": [
            "sc",
            "upipe",
            "ival"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_setintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2573-2629",
          "snippet": "usbd_status\nuhci_device_setintr(sc, upipe, ival)\n\tuhci_softc_t *sc;\n\tstruct uhci_pipe *upipe;\n\tint ival;\n{\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll, s;\n\tu_int bestbw, bw, bestoffs, offs;\n\n\tDPRINTFN(2, (\"uhci_setintr: pipe=%p\\n\", upipe));\n\tif (ival == 0) {\n\t\tprintf(\"uhci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (ival > UHCI_VFRAMELIST_COUNT)\n\t\tival = UHCI_VFRAMELIST_COUNT;\n\tnpoll = (UHCI_VFRAMELIST_COUNT + ival - 1) / ival;\n\tDPRINTFN(2, (\"uhci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\tupipe->u.intr.npoll = npoll;\n\tupipe->u.intr.qhs = \n\t\tmalloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_WAITOK);\n\n\t/* \n\t * Figure out which offset in the schedule that has most\n\t * bandwidth left over.\n\t */\n#define MOD(i) ((i) & (UHCI_VFRAMELIST_COUNT-1))\n\tfor (bestoffs = offs = 0, bestbw = ~0; offs < ival; offs++) {\n\t\tfor (bw = i = 0; i < npoll; i++)\n\t\t\tbw += sc->sc_vframes[MOD(i * ival + offs)].bandwidth;\n\t\tif (bw < bestbw) {\n\t\t\tbestbw = bw;\n\t\t\tbestoffs = offs;\n\t\t}\n\t}\n\tDPRINTFN(1, (\"uhci_setintr: bw=%d offs=%d\\n\", bestbw, bestoffs));\n\n\tfor(i = 0; i < npoll; i++) {\n\t\tupipe->u.intr.qhs[i] = sqh = uhci_alloc_sqh(sc);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsqh->pos = MOD(i * ival + bestoffs);\n\t}\n#undef MOD\n\n\ts = splusb();\n\t/* Enter QHs into the controller data structures. */\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_add_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\tDPRINTFN(5, (\"uhci_setintr: returns %p\\n\", upipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static usbd_status",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static usbd_status",
            "uhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_setintr(sc, upipe, ival)\n\tuhci_softc_t *sc;\n\tstruct uhci_pipe *upipe;\n\tint ival;\n{\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll, s;\n\tu_int bestbw, bw, bestoffs, offs;\n\n\tDPRINTFN(2, (\"uhci_setintr: pipe=%p\\n\", upipe));\n\tif (ival == 0) {\n\t\tprintf(\"uhci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (ival > UHCI_VFRAMELIST_COUNT)\n\t\tival = UHCI_VFRAMELIST_COUNT;\n\tnpoll = (UHCI_VFRAMELIST_COUNT + ival - 1) / ival;\n\tDPRINTFN(2, (\"uhci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\tupipe->u.intr.npoll = npoll;\n\tupipe->u.intr.qhs = \n\t\tmalloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_WAITOK);\n\n\t/* \n\t * Figure out which offset in the schedule that has most\n\t * bandwidth left over.\n\t */\n#define MOD(i) ((i) & (UHCI_VFRAMELIST_COUNT-1))\n\tfor (bestoffs = offs = 0, bestbw = ~0; offs < ival; offs++) {\n\t\tfor (bw = i = 0; i < npoll; i++)\n\t\t\tbw += sc->sc_vframes[MOD(i * ival + offs)].bandwidth;\n\t\tif (bw < bestbw) {\n\t\t\tbestbw = bw;\n\t\t\tbestoffs = offs;\n\t\t}\n\t}\n\tDPRINTFN(1, (\"uhci_setintr: bw=%d offs=%d\\n\", bestbw, bestoffs));\n\n\tfor(i = 0; i < npoll; i++) {\n\t\tupipe->u.intr.qhs[i] = sqh = uhci_alloc_sqh(sc);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsqh->pos = MOD(i * ival + bestoffs);\n\t}\n#undef MOD\n\n\ts = splusb();\n\t/* Enter QHs into the controller data structures. */\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_add_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\tDPRINTFN(5, (\"uhci_setintr: returns %p\\n\", upipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_free_std",
          "args": [
            "sc",
            "upipe->u.ctl.stat"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_free_sqh",
          "args": [
            "sc",
            "upipe->u.ctl.sqh"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_sqh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1495-1502",
          "snippet": "void\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "sizeof(usb_device_request_t)",
            "0",
            "&upipe->u.ctl.reqdma"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, pipe->device->address, \n\t\t     ed->bEndpointAddress, sc->sc_addr)"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UHCI_INTR_ENDPT 1\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nuhci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nstruct usbd_pipe_methods uhci_root_ctrl_methods = {\t\n\tuhci_root_ctrl_transfer,\n\tuhci_root_ctrl_start,\n\tuhci_root_ctrl_abort,\n\tuhci_root_ctrl_close,\n\tuhci_noop,\n\tuhci_root_ctrl_done,\n};\nstruct usbd_pipe_methods uhci_root_intr_methods = {\t\n\tuhci_root_intr_transfer,\n\tuhci_root_intr_start,\n\tuhci_root_intr_abort,\n\tuhci_root_intr_close,\n\tuhci_noop,\n\tuhci_root_intr_done,\n};\nstruct usbd_pipe_methods uhci_device_ctrl_methods = {\n\tuhci_device_ctrl_transfer,\n\tuhci_device_ctrl_start,\n\tuhci_device_ctrl_abort,\n\tuhci_device_ctrl_close,\n\tuhci_noop,\n\tuhci_device_ctrl_done,\n};\nstruct usbd_pipe_methods uhci_device_intr_methods = {\n\tuhci_device_intr_transfer,\n\tuhci_device_intr_start,\n\tuhci_device_intr_abort,\n\tuhci_device_intr_close,\n\tuhci_device_clear_toggle,\n\tuhci_device_intr_done,\n};\nstruct usbd_pipe_methods uhci_device_bulk_methods = {\n\tuhci_device_bulk_transfer,\n\tuhci_device_bulk_start,\n\tuhci_device_bulk_abort,\n\tuhci_device_bulk_close,\n\tuhci_device_clear_toggle,\n\tuhci_device_bulk_done,\n};\nstruct usbd_pipe_methods uhci_device_isoc_methods = {\n\tuhci_device_isoc_transfer,\n\tuhci_device_isoc_start,\n\tuhci_device_isoc_abort,\n\tuhci_device_isoc_close,\n\tuhci_noop,\n\tuhci_device_isoc_done,\n};\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_open(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;\n\tusbd_status err;\n\tint ival;\n\n\tDPRINTFN(1, (\"uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\\n\",\n\t\t     pipe, pipe->device->address, \n\t\t     ed->bEndpointAddress, sc->sc_addr));\n\n\tupipe->aborting = 0;\n\tupipe->nexttoggle = 0;\n\n\tif (pipe->device->address == sc->sc_addr) {\n\t\tswitch (ed->bEndpointAddress) {\n\t\tcase USB_CONTROL_ENDPOINT:\n\t\t\tpipe->methods = &uhci_root_ctrl_methods;\n\t\t\tbreak;\n\t\tcase UE_DIR_IN | UHCI_INTR_ENDPT:\n\t\t\tpipe->methods = &uhci_root_intr_methods;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (USBD_INVAL);\n\t\t}\n\t} else {\n\t\tswitch (ed->bmAttributes & UE_XFERTYPE) {\n\t\tcase UE_CONTROL:\n\t\t\tpipe->methods = &uhci_device_ctrl_methods;\n\t\t\tupipe->u.ctl.sqh = uhci_alloc_sqh(sc);\n\t\t\tif (upipe->u.ctl.sqh == NULL)\n\t\t\t\tgoto bad;\n\t\t\tupipe->u.ctl.setup = uhci_alloc_std(sc);\n\t\t\tif (upipe->u.ctl.setup == NULL) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tupipe->u.ctl.stat = uhci_alloc_std(sc);\n\t\t\tif (upipe->u.ctl.stat == NULL) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.setup);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\terr = usb_allocmem(&sc->sc_bus, \n\t\t\t\t  sizeof(usb_device_request_t), \n\t\t\t\t  0, &upipe->u.ctl.reqdma);\n\t\t\tif (err) {\n\t\t\t\tuhci_free_sqh(sc, upipe->u.ctl.sqh);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.setup);\n\t\t\t\tuhci_free_std(sc, upipe->u.ctl.stat);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UE_INTERRUPT:\n\t\t\tpipe->methods = &uhci_device_intr_methods;\n\t\t\tival = pipe->interval;\n\t\t\tif (ival == USBD_DEFAULT_INTERVAL)\n\t\t\t\tival = ed->bInterval;\n\t\t\treturn (uhci_device_setintr(sc, upipe, ival));\n\t\tcase UE_ISOCHRONOUS:\n\t\t\tpipe->methods = &uhci_device_isoc_methods;\n\t\t\treturn (uhci_setup_isoc(pipe));\n\t\tcase UE_BULK:\n\t\t\tpipe->methods = &uhci_device_bulk_methods;\n\t\t\tupipe->u.bulk.sqh = uhci_alloc_sqh(sc);\n\t\t\tif (upipe->u.bulk.sqh == NULL)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\treturn (USBD_NOMEM);\n}"
  },
  {
    "function_name": "uhci_device_setintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2573-2629",
    "snippet": "usbd_status\nuhci_device_setintr(sc, upipe, ival)\n\tuhci_softc_t *sc;\n\tstruct uhci_pipe *upipe;\n\tint ival;\n{\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll, s;\n\tu_int bestbw, bw, bestoffs, offs;\n\n\tDPRINTFN(2, (\"uhci_setintr: pipe=%p\\n\", upipe));\n\tif (ival == 0) {\n\t\tprintf(\"uhci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (ival > UHCI_VFRAMELIST_COUNT)\n\t\tival = UHCI_VFRAMELIST_COUNT;\n\tnpoll = (UHCI_VFRAMELIST_COUNT + ival - 1) / ival;\n\tDPRINTFN(2, (\"uhci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\tupipe->u.intr.npoll = npoll;\n\tupipe->u.intr.qhs = \n\t\tmalloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_WAITOK);\n\n\t/* \n\t * Figure out which offset in the schedule that has most\n\t * bandwidth left over.\n\t */\n#define MOD(i) ((i) & (UHCI_VFRAMELIST_COUNT-1))\n\tfor (bestoffs = offs = 0, bestbw = ~0; offs < ival; offs++) {\n\t\tfor (bw = i = 0; i < npoll; i++)\n\t\t\tbw += sc->sc_vframes[MOD(i * ival + offs)].bandwidth;\n\t\tif (bw < bestbw) {\n\t\t\tbestbw = bw;\n\t\t\tbestoffs = offs;\n\t\t}\n\t}\n\tDPRINTFN(1, (\"uhci_setintr: bw=%d offs=%d\\n\", bestbw, bestoffs));\n\n\tfor(i = 0; i < npoll; i++) {\n\t\tupipe->u.intr.qhs[i] = sqh = uhci_alloc_sqh(sc);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsqh->pos = MOD(i * ival + bestoffs);\n\t}\n#undef MOD\n\n\ts = splusb();\n\t/* Enter QHs into the controller data structures. */\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_add_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\tDPRINTFN(5, (\"uhci_setintr: returns %p\\n\", upipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "Static usbd_status",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static usbd_status",
      "uhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_setintr: returns %p\\n\", upipe)"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_intr",
          "args": [
            "sc",
            "upipe->u.intr.qhs[i]"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_add_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2535-2552",
          "snippet": "void\nuhci_add_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *eqh;\n\n\tDPRINTFN(4, (\"uhci_add_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\teqh = vf->eqh;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tvf->eqh = sqh;\n\tvf->bandwidth++;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *eqh;\n\n\tDPRINTFN(4, (\"uhci_add_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\teqh = vf->eqh;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tvf->eqh = sqh;\n\tvf->bandwidth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD",
          "args": [
            "i * ival + bestoffs"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_setintr: bw=%d offs=%d\\n\", bestbw, bestoffs)"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD",
          "args": [
            "i * ival + offs"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "npoll * sizeof(uhci_soft_qh_t *)",
            "M_USBHC",
            "M_WAITOK"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhci_setintr: ival=%d npoll=%d\\n\", ival, npoll)"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_setintr: 0 interval\\n\""
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhci_setintr: pipe=%p\\n\", upipe)"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_setintr __P((uhci_softc_t *sc, \n\t\t\t    struct uhci_pipe *pipe, int ival));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_setintr(sc, upipe, ival)\n\tuhci_softc_t *sc;\n\tstruct uhci_pipe *upipe;\n\tint ival;\n{\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll, s;\n\tu_int bestbw, bw, bestoffs, offs;\n\n\tDPRINTFN(2, (\"uhci_setintr: pipe=%p\\n\", upipe));\n\tif (ival == 0) {\n\t\tprintf(\"uhci_setintr: 0 interval\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\n\tif (ival > UHCI_VFRAMELIST_COUNT)\n\t\tival = UHCI_VFRAMELIST_COUNT;\n\tnpoll = (UHCI_VFRAMELIST_COUNT + ival - 1) / ival;\n\tDPRINTFN(2, (\"uhci_setintr: ival=%d npoll=%d\\n\", ival, npoll));\n\n\tupipe->u.intr.npoll = npoll;\n\tupipe->u.intr.qhs = \n\t\tmalloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_WAITOK);\n\n\t/* \n\t * Figure out which offset in the schedule that has most\n\t * bandwidth left over.\n\t */\n#define MOD(i) ((i) & (UHCI_VFRAMELIST_COUNT-1))\n\tfor (bestoffs = offs = 0, bestbw = ~0; offs < ival; offs++) {\n\t\tfor (bw = i = 0; i < npoll; i++)\n\t\t\tbw += sc->sc_vframes[MOD(i * ival + offs)].bandwidth;\n\t\tif (bw < bestbw) {\n\t\t\tbestbw = bw;\n\t\t\tbestoffs = offs;\n\t\t}\n\t}\n\tDPRINTFN(1, (\"uhci_setintr: bw=%d offs=%d\\n\", bestbw, bestoffs));\n\n\tfor(i = 0; i < npoll; i++) {\n\t\tupipe->u.intr.qhs[i] = sqh = uhci_alloc_sqh(sc);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsqh->pos = MOD(i * ival + bestoffs);\n\t}\n#undef MOD\n\n\ts = splusb();\n\t/* Enter QHs into the controller data structures. */\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_add_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\tDPRINTFN(5, (\"uhci_setintr: returns %p\\n\", upipe));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uhci_remove_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2555-2571",
    "snippet": "void\nuhci_remove_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *pqh;\n\n\tDPRINTFN(4, (\"uhci_remove_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\tpqh = uhci_find_prev_qh(vf->hqh, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (vf->eqh == sqh)\n\t\tvf->eqh = pqh;\n\tvf->bandwidth--;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_find_prev_qh",
          "args": [
            "vf->hqh",
            "sqh"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_find_prev_qh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "350-365",
          "snippet": "Static __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static uhci_soft_qh_t",
            "Static void",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static void",
            "Static void",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic uhci_soft_qh_t;\nStatic void;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic void;\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic void;\nStatic void;\nStatic __inline__ uhci_soft_qh_t;\n\nStatic __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"uhci_remove_intr: n=%d sqh=%p\\n\", sqh->pos, sqh)"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *pqh;\n\n\tDPRINTFN(4, (\"uhci_remove_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\tpqh = uhci_find_prev_qh(vf->hqh, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (vf->eqh == sqh)\n\t\tvf->eqh = pqh;\n\tvf->bandwidth--;\n}"
  },
  {
    "function_name": "uhci_add_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2535-2552",
    "snippet": "void\nuhci_add_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *eqh;\n\n\tDPRINTFN(4, (\"uhci_add_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\teqh = vf->eqh;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tvf->eqh = sqh;\n\tvf->bandwidth++;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"uhci_add_intr: n=%d sqh=%p\\n\", sqh->pos, sqh)"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *eqh;\n\n\tDPRINTFN(4, (\"uhci_add_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\teqh = vf->eqh;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tvf->eqh = sqh;\n\tvf->bandwidth++;\n}"
  },
  {
    "function_name": "uhci_device_bulk_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2517-2532",
    "snippet": "void\nuhci_device_bulk_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n\n\tuhci_remove_bulk(sc, upipe->u.bulk.sqh);\n\n\tuhci_free_std_chain(sc, ii->stdstart, 0);\n\n\tDPRINTFN(5, (\"uhci_bulk_done: length=%d\\n\", xfer->actlen));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_bulk_done: length=%d\\n\", xfer->actlen)"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_free_std_chain",
          "args": [
            "sc",
            "ii->stdstart",
            "0"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_remove_bulk",
          "args": [
            "sc",
            "upipe->u.bulk.sqh"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_remove_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1009-1024",
          "snippet": "void\nuhci_remove_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_bulk: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_bulk_end == sqh)\n\t\tsc->sc_bulk_end = pqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_bulk: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_bulk_end == sqh)\n\t\tsc->sc_bulk_end = pqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_del_intr_info",
          "args": [
            "ii"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_bulk_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n\n\tuhci_remove_bulk(sc, upipe->u.bulk.sqh);\n\n\tuhci_free_std_chain(sc, ii->stdstart, 0);\n\n\tDPRINTFN(5, (\"uhci_bulk_done: length=%d\\n\", xfer->actlen));\n}"
  },
  {
    "function_name": "uhci_device_ctrl_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2493-2514",
    "snippet": "void\nuhci_device_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_ctrl_done: not a request\\n\");\n#endif\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n\n\tuhci_remove_ctrl(sc, upipe->u.ctl.sqh);\n\n\tif (upipe->u.ctl.length != 0)\n\t\tuhci_free_std_chain(sc, ii->stdstart->link.std, ii->stdend);\n\n\tDPRINTFN(5, (\"uhci_ctrl_done: length=%d\\n\", xfer->actlen));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_ctrl_done: length=%d\\n\", xfer->actlen)"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_free_std_chain",
          "args": [
            "sc",
            "ii->stdstart->link.std",
            "ii->stdend"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_remove_ctrl",
          "args": [
            "sc",
            "upipe->u.ctl.sqh"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_remove_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "972-987",
          "snippet": "void\nuhci_remove_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_ctrl: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_ctl_end == sqh)\n\t\tsc->sc_ctl_end = pqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_ctrl: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_ctl_end == sqh)\n\t\tsc->sc_ctl_end = pqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_del_intr_info",
          "args": [
            "ii"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_ctrl_done: not a request\\n\""
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_ctrl_done: not a request\\n\");\n#endif\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n\n\tuhci_remove_ctrl(sc, upipe->u.ctl.sqh);\n\n\tif (upipe->u.ctl.length != 0)\n\t\tuhci_free_std_chain(sc, ii->stdstart->link.std, ii->stdend);\n\n\tDPRINTFN(5, (\"uhci_ctrl_done: length=%d\\n\", xfer->actlen));\n}"
  },
  {
    "function_name": "uhci_device_intr_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2432-2490",
    "snippet": "void\nuhci_device_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll;\n\n\tDPRINTFN(5, (\"uhci_intr_done: length=%d\\n\", xfer->actlen));\n\n\tnpoll = upipe->u.intr.npoll;\n\tfor(i = 0; i < npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t}\n\tuhci_free_std_chain(sc, ii->stdstart, 0);\n\n\t/* XXX Wasteful. */\n\tif (xfer->pipe->repeat) {\n\t\tuhci_soft_td_t *data, *dataend;\n\n\t\tDPRINTFN(5,(\"uhci_device_intr_done: requeing\\n\"));\n\n\t\t/* This alloc cannot fail since we freed the chain above. */\n\t\tuhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t     &xfer->dmabuf, &data, &dataend);\n\t\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 10) {\n\t\t\tDPRINTF((\"uhci_device_intr_done: data(1)\\n\"));\n\t\t\tuhci_dump_tds(data);\n\t\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t\t}\n#endif\n\n\t\tii->stdstart = data;\n\t\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\t\tif (!ii->isdone) {\n\t\t\tprintf(\"uhci_device_intr_done: not done, ii=%p\\n\", ii);\n\t\t}\n\t\tii->isdone = 0;\n#endif\n\t\tfor (i = 0; i < npoll; i++) {\n\t\t\tsqh = upipe->u.intr.qhs[i];\n\t\t\tsqh->elink = data;\n\t\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t\t}\n\t\txfer->status = USBD_IN_PROGRESS;\n\t\t/* The ii is already on the examined list, just leave it. */\n\t} else {\n\t\tDPRINTFN(5,(\"uhci_device_intr_done: removing\\n\"));\n\t\tuhci_del_intr_info(ii);\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_del_intr_info",
          "args": [
            "ii"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_intr_done: removing\\n\")"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "data->physaddr"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_intr_done: not done, ii=%p\\n\"",
            "ii"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_qh",
          "args": [
            "upipe->u.intr.qhs[0]"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_qhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "795-825",
          "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "data"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_intr_done: data(1)\\n\")"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_IOC"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std_chain",
          "args": [
            "upipe",
            "sc",
            "xfer->length",
            "1",
            "xfer->flags",
            "&xfer->dmabuf",
            "&data",
            "&dataend"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_intr_done: requeing\\n\")"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_free_std_chain",
          "args": [
            "sc",
            "ii->stdstart",
            "0"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_intr_done: length=%d\\n\", xfer->actlen)"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_softc_t *sc = ii->sc;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_qh_t *sqh;\n\tint i, npoll;\n\n\tDPRINTFN(5, (\"uhci_intr_done: length=%d\\n\", xfer->actlen));\n\n\tnpoll = upipe->u.intr.npoll;\n\tfor(i = 0; i < npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t}\n\tuhci_free_std_chain(sc, ii->stdstart, 0);\n\n\t/* XXX Wasteful. */\n\tif (xfer->pipe->repeat) {\n\t\tuhci_soft_td_t *data, *dataend;\n\n\t\tDPRINTFN(5,(\"uhci_device_intr_done: requeing\\n\"));\n\n\t\t/* This alloc cannot fail since we freed the chain above. */\n\t\tuhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t     &xfer->dmabuf, &data, &dataend);\n\t\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 10) {\n\t\t\tDPRINTF((\"uhci_device_intr_done: data(1)\\n\"));\n\t\t\tuhci_dump_tds(data);\n\t\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t\t}\n#endif\n\n\t\tii->stdstart = data;\n\t\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\t\tif (!ii->isdone) {\n\t\t\tprintf(\"uhci_device_intr_done: not done, ii=%p\\n\", ii);\n\t\t}\n\t\tii->isdone = 0;\n#endif\n\t\tfor (i = 0; i < npoll; i++) {\n\t\t\tsqh = upipe->u.intr.qhs[i];\n\t\t\tsqh->elink = data;\n\t\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t\t}\n\t\txfer->status = USBD_IN_PROGRESS;\n\t\t/* The ii is already on the examined list, just leave it. */\n\t} else {\n\t\tDPRINTFN(5,(\"uhci_device_intr_done: removing\\n\"));\n\t\tuhci_del_intr_info(ii);\n\t}\n}"
  },
  {
    "function_name": "uhci_device_isoc_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2398-2430",
    "snippet": "void\nuhci_device_isoc_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\n\tDPRINTFN(4, (\"uhci_isoc_done: length=%d\\n\", xfer->actlen));\n\n\tif (ii->xfer != xfer)\n\t\t/* Not on interrupt list, ignore it. */\n\t\treturn;\n\n#ifdef DIAGNOSTIC\n\tif (xfer->busy_free != XFER_BUSY) {\n\t\tprintf(\"uhci_device_isoc_done: xfer=%p not busy 0x%08x\\n\",\n\t\t       xfer, xfer->busy_free);\n\t\treturn;\n\t}\n\n        if (ii->stdend == NULL) {\n                printf(\"uhci_device_isoc_done: xfer=%p stdend==NULL\\n\", xfer);\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_ii(ii);\n#endif\n\t\treturn;\n\t}\n#endif\n\n\t/* Turn off the interrupt since it is active even if the TD is not. */\n\tii->stdend->td.td_status &= htole32(~UHCI_TD_IOC);\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_del_intr_info",
          "args": [
            "ii"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~UHCI_TD_IOC"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_ii",
          "args": [
            "ii"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_iis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "887-896",
          "snippet": "void\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_isoc_done: xfer=%p stdend==NULL\\n\"",
            "xfer"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"uhci_isoc_done: length=%d\\n\", xfer->actlen)"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_device_isoc_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\n\tDPRINTFN(4, (\"uhci_isoc_done: length=%d\\n\", xfer->actlen));\n\n\tif (ii->xfer != xfer)\n\t\t/* Not on interrupt list, ignore it. */\n\t\treturn;\n\n#ifdef DIAGNOSTIC\n\tif (xfer->busy_free != XFER_BUSY) {\n\t\tprintf(\"uhci_device_isoc_done: xfer=%p not busy 0x%08x\\n\",\n\t\t       xfer, xfer->busy_free);\n\t\treturn;\n\t}\n\n        if (ii->stdend == NULL) {\n                printf(\"uhci_device_isoc_done: xfer=%p stdend==NULL\\n\", xfer);\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_ii(ii);\n#endif\n\t\treturn;\n\t}\n#endif\n\n\t/* Turn off the interrupt since it is active even if the TD is not. */\n\tii->stdend->td.td_status &= htole32(~UHCI_TD_IOC);\n\n\tuhci_del_intr_info(ii);\t/* remove from active list */\n}"
  },
  {
    "function_name": "uhci_setup_isoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2342-2396",
    "snippet": "usbd_status\nuhci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tint rd = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tuhci_soft_td_t *std, *vstd;\n\tu_int32_t token;\n\tstruct iso *iso;\n\tint i, s;\n\n\tiso = &upipe->u.iso;\n\tiso->stds = malloc(UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *),\n\t\t\t   M_USBHC, M_WAITOK);\n\n\ttoken = rd ? UHCI_TD_IN (0, endpt, addr, 0) :\n\t\t     UHCI_TD_OUT(0, endpt, addr, 0);\n\n\t/* Allocate the TDs and mark as inactive; */\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tif (std == 0)\n\t\t\tgoto bad;\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(token);\n\t\tiso->stds[i] = std;\n\t}\n\n\t/* Insert TDs into schedule. */\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tvstd = sc->sc_vframes[i].htd;\n\t\tstd->link = vstd->link;\n\t\tstd->td.td_link = vstd->td.td_link;\n\t\tvstd->link.std = std;\n\t\tvstd->td.td_link = htole32(std->physaddr);\n\t}\n\tsplx(s);\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\twhile (--i >= 0)\n\t\tuhci_free_std(sc, iso->stds[i]);\n\tfree(iso->stds, M_USBHC);\n\treturn (USBD_NOMEM);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "Static usbd_status",
      "uhci_open __P((usbd_pipe_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iso->stds",
            "M_USBHC"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "std->physaddr"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "token"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_IOS"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UHCI_TD_OUT",
          "args": [
            "0",
            "endpt",
            "addr",
            "0"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_IN",
          "args": [
            "0",
            "endpt",
            "addr",
            "0"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *)",
            "M_USBHC",
            "M_WAITOK"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_bulk_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_isoc_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_root_intr_close __P((usbd_pipe_handle));\nStatic usbd_status;\nuhci_open __P((usbd_pipe_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_setup_isoc(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tint rd = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tuhci_soft_td_t *std, *vstd;\n\tu_int32_t token;\n\tstruct iso *iso;\n\tint i, s;\n\n\tiso = &upipe->u.iso;\n\tiso->stds = malloc(UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *),\n\t\t\t   M_USBHC, M_WAITOK);\n\n\ttoken = rd ? UHCI_TD_IN (0, endpt, addr, 0) :\n\t\t     UHCI_TD_OUT(0, endpt, addr, 0);\n\n\t/* Allocate the TDs and mark as inactive; */\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tif (std == 0)\n\t\t\tgoto bad;\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(token);\n\t\tiso->stds[i] = std;\n\t}\n\n\t/* Insert TDs into schedule. */\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tvstd = sc->sc_vframes[i].htd;\n\t\tstd->link = vstd->link;\n\t\tstd->td.td_link = vstd->td.td_link;\n\t\tvstd->link.std = std;\n\t\tvstd->td.td_link = htole32(std->physaddr);\n\t}\n\tsplx(s);\n\n\tiso->next = -1;\n\tiso->inuse = 0;\n\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad:\n\twhile (--i >= 0)\n\t\tuhci_free_std(sc, iso->stds[i]);\n\tfree(iso->stds, M_USBHC);\n\treturn (USBD_NOMEM);\n}"
  },
  {
    "function_name": "uhci_device_isoc_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2297-2340",
    "snippet": "void\nuhci_device_isoc_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_soft_td_t *std, *vstd;\n\tstruct iso *iso;\n\tint i, s;\n\n\t/*\n\t * Make sure all TDs are marked as inactive.\n\t * Wait for completion.\n\t * Unschedule.\n\t * Deallocate.\n\t */\n\tiso = &upipe->u.iso;\n\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++)\n\t\tiso->stds[i]->td.td_status &= htole32(~UHCI_TD_ACTIVE);\n\tusb_delay_ms(&sc->sc_bus, 2); /* wait for completion */\n\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tfor (vstd = sc->sc_vframes[i].htd;\n\t\t     vstd != NULL && vstd->link.std != std;\n\t\t     vstd = vstd->link.std)\n\t\t\t;\n\t\tif (vstd == NULL) {\n\t\t\t/*panic*/\n\t\t\tprintf(\"uhci_device_isoc_close: %p not found\\n\", std);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tvstd->link = std->link;\n\t\tvstd->td.td_link = std->td.td_link;\n\t\tuhci_free_std(sc, std);\n\t}\n\tsplx(s);\n\n\tfree(iso->stds, M_USBHC);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iso->stds",
            "M_USBHC"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_isoc_close: %p not found\\n\"",
            "std"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "2"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~UHCI_TD_ACTIVE"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_isoc_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_soft_td_t *std, *vstd;\n\tstruct iso *iso;\n\tint i, s;\n\n\t/*\n\t * Make sure all TDs are marked as inactive.\n\t * Wait for completion.\n\t * Unschedule.\n\t * Deallocate.\n\t */\n\tiso = &upipe->u.iso;\n\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++)\n\t\tiso->stds[i]->td.td_status &= htole32(~UHCI_TD_ACTIVE);\n\tusb_delay_ms(&sc->sc_bus, 2); /* wait for completion */\n\n\ts = splusb();\n\tfor (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = iso->stds[i];\n\t\tfor (vstd = sc->sc_vframes[i].htd;\n\t\t     vstd != NULL && vstd->link.std != std;\n\t\t     vstd = vstd->link.std)\n\t\t\t;\n\t\tif (vstd == NULL) {\n\t\t\t/*panic*/\n\t\t\tprintf(\"uhci_device_isoc_close: %p not found\\n\", std);\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tvstd->link = std->link;\n\t\tvstd->td.td_link = std->td.td_link;\n\t\tuhci_free_std(sc, std);\n\t}\n\tsplx(s);\n\n\tfree(iso->stds, M_USBHC);\n}"
  },
  {
    "function_name": "uhci_device_isoc_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2250-2295",
    "snippet": "void\nuhci_device_isoc_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\tuhci_soft_td_t *std;\n\tint i, n, s, nframes, maxlen, len;\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Give xfer the requested abort code. */\n\txfer->status = USBD_CANCELLED;\n\n\t/* make hardware ignore it, */\n\tnframes = xfer->nframes;\n\tn = UXFER(xfer)->curframe;\n\tmaxlen = 0;\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = stds[n];\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\t\tlen = UHCI_TD_GET_MAXLEN(std->td.td_token);\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\tn = 0;\n\t}\n\n\t/* and wait until we are sure the hardware has finished. */\n\tdelay(maxlen);\n\n#ifdef DIAGNOSTIC\n\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\t/* Run callback and remove from interrupt list. */\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "maxlen"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_MAXLEN",
          "args": [
            "std->td.td_token"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~(UHCI_TD_ACTIVE | UHCI_TD_IOC)"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_device_isoc_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\tuhci_soft_td_t *std;\n\tint i, n, s, nframes, maxlen, len;\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Give xfer the requested abort code. */\n\txfer->status = USBD_CANCELLED;\n\n\t/* make hardware ignore it, */\n\tnframes = xfer->nframes;\n\tn = UXFER(xfer)->curframe;\n\tmaxlen = 0;\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = stds[n];\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\t\tlen = UHCI_TD_GET_MAXLEN(std->td.td_token);\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\tn = 0;\n\t}\n\n\t/* and wait until we are sure the hardware has finished. */\n\tdelay(maxlen);\n\n#ifdef DIAGNOSTIC\n\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\t/* Run callback and remove from interrupt list. */\n\tusb_transfer_complete(xfer);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "uhci_device_isoc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2199-2248",
    "snippet": "usbd_status\nuhci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *end;\n\tint s, i;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* Find the last TD */\n\ti = UXFER(xfer)->curframe + xfer->nframes;\n\tif (i >= UHCI_VFRAMELIST_COUNT)\n\t\ti -= UHCI_VFRAMELIST_COUNT;\n\tend = upipe->u.iso.stds[i];\n\n#ifdef DIAGNOSTIC\n\tif (end == NULL) {\n\t\tprintf(\"uhci_device_isoc_start: end == NULL\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\ts = splusb();\n\t\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = end;\n\tii->stdend = end;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone)\n\t\tprintf(\"uhci_device_isoc_start: not done, ii=%p\\n\", ii);\n\tii->isdone = 0;\n#endif\n\tuhci_add_intr_info(sc, ii);\n\t\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_intr_info",
          "args": [
            "sc",
            "ii"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_isoc_start: not done, ii=%p\\n\"",
            "ii"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_isoc_start: xfer=%p\\n\", xfer)"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *end;\n\tint s, i;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* Find the last TD */\n\ti = UXFER(xfer)->curframe + xfer->nframes;\n\tif (i >= UHCI_VFRAMELIST_COUNT)\n\t\ti -= UHCI_VFRAMELIST_COUNT;\n\tend = upipe->u.iso.stds[i];\n\n#ifdef DIAGNOSTIC\n\tif (end == NULL) {\n\t\tprintf(\"uhci_device_isoc_start: end == NULL\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\ts = splusb();\n\t\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = end;\n\tii->stdend = end;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone)\n\t\tprintf(\"uhci_device_isoc_start: not done, ii=%p\\n\", ii);\n\tii->isdone = 0;\n#endif\n\tuhci_add_intr_info(sc, ii);\n\t\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_device_isoc_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2128-2197",
    "snippet": "void\nuhci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tstruct iso *iso = &upipe->u.iso;\n\tuhci_soft_td_t *std;\t\n\tu_int32_t buf, len, status;\n\tint s, i, next, nframes;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (xfer->status == USBD_IN_PROGRESS) {\n\t\t/* This request has already been entered into the frame list */\n\t\tprintf(\"uhci_device_isoc_enter: xfer=%p in frame list\\n\", xfer);\n\t\t/* XXX */\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (iso->inuse >= UHCI_VFRAMELIST_COUNT)\n\t\tprintf(\"uhci_device_isoc_enter: overflow!\\n\");\n#endif\n\n\tnext = iso->next;\n\tif (next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tnext = (UREAD2(sc, UHCI_FRNUM) + 3) % UHCI_VFRAMELIST_COUNT;\n\t\tDPRINTFN(2,(\"uhci_device_isoc_enter: start next=%d\\n\", next));\n\t}\n\n\txfer->status = USBD_IN_PROGRESS;\n\tUXFER(xfer)->curframe = next;\n\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |\n\t\t\t\t     UHCI_TD_ACTIVE |\n\t\t\t\t     UHCI_TD_IOS);\n\tnframes = xfer->nframes;\n\ts = splusb();\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = iso->stds[next];\n\t\tif (++next >= UHCI_VFRAMELIST_COUNT)\n\t\t\tnext = 0;\n\t\tlen = xfer->frlengths[i];\n\t\tstd->td.td_buffer = htole32(buf);\n\t\tif (i == nframes - 1)\n\t\t\tstatus |= UHCI_TD_IOC;\n\t\tstd->td.td_status = htole32(status);\n\t\tstd->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);\n\t\tstd->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 5) {\n\t\t\tDPRINTFN(5,(\"uhci_device_isoc_enter: TD %d\\n\", i));\n\t\t\tuhci_dump_td(std);\n\t\t}\n#endif\n\t\tbuf += len;\n\t}\n\tiso->next = next;\n\tiso->inuse += xfer->nframes;\n\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_td",
          "args": [
            "std"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_isoc_enter: TD %d\\n\", i)"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_SET_MAXLEN(len)"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SET_MAXLEN",
          "args": [
            "len"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~UHCI_TD_MAXLEN_MASK"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "status"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "buf"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_ZERO_ACTLEN",
          "args": [
            "UHCI_TD_SET_ERRCNT(0) |\n\t\t\t\t     UHCI_TD_ACTIVE |\n\t\t\t\t     UHCI_TD_IOS"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SET_ERRCNT",
          "args": [
            "0"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uhci_device_isoc_enter: start next=%d\\n\", next)"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_FRNUM"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_isoc_enter: overflow!\\n\""
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes)"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tstruct iso *iso = &upipe->u.iso;\n\tuhci_soft_td_t *std;\t\n\tu_int32_t buf, len, status;\n\tint s, i, next, nframes;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (xfer->status == USBD_IN_PROGRESS) {\n\t\t/* This request has already been entered into the frame list */\n\t\tprintf(\"uhci_device_isoc_enter: xfer=%p in frame list\\n\", xfer);\n\t\t/* XXX */\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (iso->inuse >= UHCI_VFRAMELIST_COUNT)\n\t\tprintf(\"uhci_device_isoc_enter: overflow!\\n\");\n#endif\n\n\tnext = iso->next;\n\tif (next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tnext = (UREAD2(sc, UHCI_FRNUM) + 3) % UHCI_VFRAMELIST_COUNT;\n\t\tDPRINTFN(2,(\"uhci_device_isoc_enter: start next=%d\\n\", next));\n\t}\n\n\txfer->status = USBD_IN_PROGRESS;\n\tUXFER(xfer)->curframe = next;\n\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |\n\t\t\t\t     UHCI_TD_ACTIVE |\n\t\t\t\t     UHCI_TD_IOS);\n\tnframes = xfer->nframes;\n\ts = splusb();\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = iso->stds[next];\n\t\tif (++next >= UHCI_VFRAMELIST_COUNT)\n\t\t\tnext = 0;\n\t\tlen = xfer->frlengths[i];\n\t\tstd->td.td_buffer = htole32(buf);\n\t\tif (i == nframes - 1)\n\t\t\tstatus |= UHCI_TD_IOC;\n\t\tstd->td.td_status = htole32(status);\n\t\tstd->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);\n\t\tstd->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 5) {\n\t\t\tDPRINTFN(5,(\"uhci_device_isoc_enter: TD %d\\n\", i));\n\t\t\tuhci_dump_td(std);\n\t\t}\n#endif\n\t\tbuf += len;\n\t}\n\tiso->next = next;\n\tiso->inuse += xfer->nframes;\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "uhci_device_isoc_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "2101-2126",
    "snippet": "usbd_status\nuhci_device_isoc_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_transfer: xfer=%p\\n\", xfer));\n\n\t/* Put it on our queue, */\n\terr = usb_insert_transfer(xfer);\n\n\t/* bail out on error, */\n\tif (err && err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\n\t/* XXX should check inuse here */\n\n\t/* insert into schedule, */\n\tuhci_device_isoc_enter(xfer);\n\n\t/* and start if the pipe wasn't running */\n\tif (!err)\n\t\tuhci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));\n\n\treturn (err);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_device_isoc_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_isoc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2199-2248",
          "snippet": "usbd_status\nuhci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *end;\n\tint s, i;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* Find the last TD */\n\ti = UXFER(xfer)->curframe + xfer->nframes;\n\tif (i >= UHCI_VFRAMELIST_COUNT)\n\t\ti -= UHCI_VFRAMELIST_COUNT;\n\tend = upipe->u.iso.stds[i];\n\n#ifdef DIAGNOSTIC\n\tif (end == NULL) {\n\t\tprintf(\"uhci_device_isoc_start: end == NULL\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\ts = splusb();\n\t\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = end;\n\tii->stdend = end;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone)\n\t\tprintf(\"uhci_device_isoc_start: not done, ii=%p\\n\", ii);\n\tii->isdone = 0;\n#endif\n\tuhci_add_intr_info(sc, ii);\n\t\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_isoc_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *end;\n\tint s, i;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_start: xfer=%p\\n\", xfer));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->status != USBD_IN_PROGRESS)\n\t\tprintf(\"uhci_device_isoc_start: not in progress %p\\n\", xfer);\n#endif\n\n\t/* Find the last TD */\n\ti = UXFER(xfer)->curframe + xfer->nframes;\n\tif (i >= UHCI_VFRAMELIST_COUNT)\n\t\ti -= UHCI_VFRAMELIST_COUNT;\n\tend = upipe->u.iso.stds[i];\n\n#ifdef DIAGNOSTIC\n\tif (end == NULL) {\n\t\tprintf(\"uhci_device_isoc_start: end == NULL\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\ts = splusb();\n\t\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = end;\n\tii->stdend = end;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone)\n\t\tprintf(\"uhci_device_isoc_start: not done, ii=%p\\n\", ii);\n\tii->isdone = 0;\n#endif\n\tuhci_add_intr_info(sc, ii);\n\t\n\tsplx(s);\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_device_isoc_enter",
          "args": [
            "xfer"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_isoc_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2128-2197",
          "snippet": "void\nuhci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tstruct iso *iso = &upipe->u.iso;\n\tuhci_soft_td_t *std;\t\n\tu_int32_t buf, len, status;\n\tint s, i, next, nframes;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (xfer->status == USBD_IN_PROGRESS) {\n\t\t/* This request has already been entered into the frame list */\n\t\tprintf(\"uhci_device_isoc_enter: xfer=%p in frame list\\n\", xfer);\n\t\t/* XXX */\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (iso->inuse >= UHCI_VFRAMELIST_COUNT)\n\t\tprintf(\"uhci_device_isoc_enter: overflow!\\n\");\n#endif\n\n\tnext = iso->next;\n\tif (next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tnext = (UREAD2(sc, UHCI_FRNUM) + 3) % UHCI_VFRAMELIST_COUNT;\n\t\tDPRINTFN(2,(\"uhci_device_isoc_enter: start next=%d\\n\", next));\n\t}\n\n\txfer->status = USBD_IN_PROGRESS;\n\tUXFER(xfer)->curframe = next;\n\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |\n\t\t\t\t     UHCI_TD_ACTIVE |\n\t\t\t\t     UHCI_TD_IOS);\n\tnframes = xfer->nframes;\n\ts = splusb();\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = iso->stds[next];\n\t\tif (++next >= UHCI_VFRAMELIST_COUNT)\n\t\t\tnext = 0;\n\t\tlen = xfer->frlengths[i];\n\t\tstd->td.td_buffer = htole32(buf);\n\t\tif (i == nframes - 1)\n\t\t\tstatus |= UHCI_TD_IOC;\n\t\tstd->td.td_status = htole32(status);\n\t\tstd->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);\n\t\tstd->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 5) {\n\t\t\tDPRINTFN(5,(\"uhci_device_isoc_enter: TD %d\\n\", i));\n\t\t\tuhci_dump_td(std);\n\t\t}\n#endif\n\t\tbuf += len;\n\t}\n\tiso->next = next;\n\tiso->inuse += xfer->nframes;\n\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_isoc_enter(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tstruct iso *iso = &upipe->u.iso;\n\tuhci_soft_td_t *std;\t\n\tu_int32_t buf, len, status;\n\tint s, i, next, nframes;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_enter: used=%d next=%d xfer=%p \"\n\t\t    \"nframes=%d\\n\",\n\t\t    iso->inuse, iso->next, xfer, xfer->nframes));\n\n\tif (sc->sc_dying)\n\t\treturn;\n\n\tif (xfer->status == USBD_IN_PROGRESS) {\n\t\t/* This request has already been entered into the frame list */\n\t\tprintf(\"uhci_device_isoc_enter: xfer=%p in frame list\\n\", xfer);\n\t\t/* XXX */\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (iso->inuse >= UHCI_VFRAMELIST_COUNT)\n\t\tprintf(\"uhci_device_isoc_enter: overflow!\\n\");\n#endif\n\n\tnext = iso->next;\n\tif (next == -1) {\n\t\t/* Not in use yet, schedule it a few frames ahead. */\n\t\tnext = (UREAD2(sc, UHCI_FRNUM) + 3) % UHCI_VFRAMELIST_COUNT;\n\t\tDPRINTFN(2,(\"uhci_device_isoc_enter: start next=%d\\n\", next));\n\t}\n\n\txfer->status = USBD_IN_PROGRESS;\n\tUXFER(xfer)->curframe = next;\n\n\tbuf = DMAADDR(&xfer->dmabuf);\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |\n\t\t\t\t     UHCI_TD_ACTIVE |\n\t\t\t\t     UHCI_TD_IOS);\n\tnframes = xfer->nframes;\n\ts = splusb();\n\tfor (i = 0; i < nframes; i++) {\n\t\tstd = iso->stds[next];\n\t\tif (++next >= UHCI_VFRAMELIST_COUNT)\n\t\t\tnext = 0;\n\t\tlen = xfer->frlengths[i];\n\t\tstd->td.td_buffer = htole32(buf);\n\t\tif (i == nframes - 1)\n\t\t\tstatus |= UHCI_TD_IOC;\n\t\tstd->td.td_status = htole32(status);\n\t\tstd->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);\n\t\tstd->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 5) {\n\t\t\tDPRINTFN(5,(\"uhci_device_isoc_enter: TD %d\\n\", i));\n\t\t\tuhci_dump_td(std);\n\t\t}\n#endif\n\t\tbuf += len;\n\t}\n\tiso->next = next;\n\tiso->inuse += xfer->nframes;\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_device_isoc_transfer: xfer=%p\\n\", xfer)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_device_isoc_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"uhci_device_isoc_transfer: xfer=%p\\n\", xfer));\n\n\t/* Put it on our queue, */\n\terr = usb_insert_transfer(xfer);\n\n\t/* bail out on error, */\n\tif (err && err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\n\t/* XXX should check inuse here */\n\n\t/* insert into schedule, */\n\tuhci_device_isoc_enter(xfer);\n\n\t/* and start if the pipe wasn't running */\n\tif (!err)\n\t\tuhci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));\n\n\treturn (err);\n}"
  },
  {
    "function_name": "uhci_device_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1974-2099",
    "snippet": "usbd_status\nuhci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *setup, *data, *stat, *next, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tint len;\n\tu_int32_t ls;\n\tusbd_status err;\n\tint isread;\n\tint s;\n\n\tDPRINTFN(3,(\"uhci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), UGETW(req->wLength),\n\t\t    addr, endpt));\n\n\tls = dev->lowspeed ? UHCI_TD_LS : 0;\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tsetup = upipe->u.ctl.setup;\n\tstat = upipe->u.ctl.stat;\n\tsqh = upipe->u.ctl.sqh;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tupipe->nexttoggle = 1;\n\t\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tnext = data;\n\t\tdataend->link.std = stat;\n\t\tdataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF);\n\t} else {\n\t\tnext = stat;\n\t}\n\tupipe->u.ctl.length = len;\n\n\tmemcpy(KERNADDR(&upipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->link.std = next;\n\tsetup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF);\n\tsetup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |\n\t\tUHCI_TD_ACTIVE);\n\tsetup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));\n\tsetup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));\n\n\tstat->link.std = NULL;\n\tstat->td.td_link = htole32(UHCI_PTR_T);\n\tstat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | \n\t\tUHCI_TD_ACTIVE | UHCI_TD_IOC);\n\tstat->td.td_token = \n\t\thtole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :\n\t\t                 UHCI_TD_IN (0, endpt, addr, 1));\n\tstat->td.td_buffer = htole32(0);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_request: before transfer\\n\"));\n\t\tuhci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = setup;\n\tii->stdend = stat;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_request: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = setup;\n\tsqh->qh.qh_elink = htole32(setup->physaddr);\n\n\ts = splusb();\n\tuhci_add_ctrl(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 12) {\n\t\tuhci_soft_td_t *std;\n\t\tuhci_soft_qh_t *xqh;\n\t\tuhci_soft_qh_t *sxqh;\n\t\tint maxqh = 0;\n\t\tuhci_physaddr_t link;\n\t\tDPRINTF((\"uhci_enter_ctl_q: follow from [0]\\n\"));\n\t\tfor (std = sc->sc_vframes[0].htd, link = 0;\n\t\t     (link & UHCI_PTR_Q) == 0;\n\t\t     std = std->link.std) {\n\t\t\tlink = le32toh(std->td.td_link);\n\t\t\tuhci_dump_td(std);\n\t\t}\n\t\tsxqh = (uhci_soft_qh_t *)std;\n\t\tuhci_dump_qh(sxqh);\n\t\tfor (xqh = sxqh;\n\t\t     xqh != NULL;\n\t\t     xqh = (maxqh++ == 5 || xqh->hlink==sxqh || \n                            xqh->hlink==xqh ? NULL : xqh->hlink)) {\n\t\t\tuhci_dump_qh(xqh);\n\t\t}\n\t\tDPRINTF((\"Enqueued QH:\\n\"));\n\t\tuhci_dump_qh(sqh);\n\t\tuhci_dump_tds(sqh->elink);\n\t}\n#endif\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "xfer->timeout_handle",
            "MS_TO_TICKS(xfer->timeout)",
            "uhci_timeout",
            "ii"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MS_TO_TICKS",
          "args": [
            "xfer->timeout"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "sqh->elink"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_qh",
          "args": [
            "sqh"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_qhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "795-825",
          "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"Enqueued QH:\\n\")"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_link"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_enter_ctl_q: follow from [0]\\n\")"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_intr_info",
          "args": [
            "sc",
            "ii"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_ctrl",
          "args": [
            "sc",
            "sqh"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_add_ctrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "953-969",
          "snippet": "void\nuhci_add_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_ctrl: sqh=%p\\n\", sqh));\n\teqh = sc->sc_ctl_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_ctl_end = sqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_ctrl: sqh=%p\\n\", sqh));\n\teqh = sc->sc_ctl_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_ctl_end = sqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "setup->physaddr"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_request: not done, ii=%p\\n\"",
            "ii"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_request: before transfer\\n\")"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "isread ? UHCI_TD_OUT(0, endpt, addr, 1) :\n\t\t                 UHCI_TD_IN (0, endpt, addr, 1)"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_IN",
          "args": [
            "0",
            "endpt",
            "addr",
            "1"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_OUT",
          "args": [
            "0",
            "endpt",
            "addr",
            "1"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_SET_ERRCNT(3) | ls | \n\t\tUHCI_TD_ACTIVE | UHCI_TD_IOC"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SET_ERRCNT",
          "args": [
            "3"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "DMAADDR(&upipe->u.ctl.reqdma)"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&upipe->u.ctl.reqdma"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_SETUP(sizeof *req, endpt, addr)"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SETUP",
          "args": [
            "sizeof *req",
            "endpt",
            "addr"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_SET_ERRCNT(3) | ls |\n\t\tUHCI_TD_ACTIVE"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SET_ERRCNT",
          "args": [
            "3"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "next->physaddr | UHCI_PTR_VF"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "KERNADDR(&upipe->u.ctl.reqdma)",
            "req",
            "sizeof *req"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&upipe->u.ctl.reqdma"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "stat->physaddr | UHCI_PTR_VF"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std_chain",
          "args": [
            "upipe",
            "sc",
            "len",
            "isread",
            "xfer->flags",
            "&xfer->dmabuf",
            "&data",
            "&dataend"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), UGETW(req->wLength),\n\t\t    addr, endpt)"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wLength"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wIndex"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "req->wValue"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *setup, *data, *stat, *next, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tint len;\n\tu_int32_t ls;\n\tusbd_status err;\n\tint isread;\n\tint s;\n\n\tDPRINTFN(3,(\"uhci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), UGETW(req->wLength),\n\t\t    addr, endpt));\n\n\tls = dev->lowspeed ? UHCI_TD_LS : 0;\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tsetup = upipe->u.ctl.setup;\n\tstat = upipe->u.ctl.stat;\n\tsqh = upipe->u.ctl.sqh;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tupipe->nexttoggle = 1;\n\t\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tnext = data;\n\t\tdataend->link.std = stat;\n\t\tdataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF);\n\t} else {\n\t\tnext = stat;\n\t}\n\tupipe->u.ctl.length = len;\n\n\tmemcpy(KERNADDR(&upipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->link.std = next;\n\tsetup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF);\n\tsetup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |\n\t\tUHCI_TD_ACTIVE);\n\tsetup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));\n\tsetup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));\n\n\tstat->link.std = NULL;\n\tstat->td.td_link = htole32(UHCI_PTR_T);\n\tstat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | \n\t\tUHCI_TD_ACTIVE | UHCI_TD_IOC);\n\tstat->td.td_token = \n\t\thtole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :\n\t\t                 UHCI_TD_IN (0, endpt, addr, 1));\n\tstat->td.td_buffer = htole32(0);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_request: before transfer\\n\"));\n\t\tuhci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = setup;\n\tii->stdend = stat;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_request: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = setup;\n\tsqh->qh.qh_elink = htole32(setup->physaddr);\n\n\ts = splusb();\n\tuhci_add_ctrl(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 12) {\n\t\tuhci_soft_td_t *std;\n\t\tuhci_soft_qh_t *xqh;\n\t\tuhci_soft_qh_t *sxqh;\n\t\tint maxqh = 0;\n\t\tuhci_physaddr_t link;\n\t\tDPRINTF((\"uhci_enter_ctl_q: follow from [0]\\n\"));\n\t\tfor (std = sc->sc_vframes[0].htd, link = 0;\n\t\t     (link & UHCI_PTR_Q) == 0;\n\t\t     std = std->link.std) {\n\t\t\tlink = le32toh(std->td.td_link);\n\t\t\tuhci_dump_td(std);\n\t\t}\n\t\tsxqh = (uhci_soft_qh_t *)std;\n\t\tuhci_dump_qh(sxqh);\n\t\tfor (xqh = sxqh;\n\t\t     xqh != NULL;\n\t\t     xqh = (maxqh++ == 5 || xqh->hlink==sxqh || \n                            xqh->hlink==xqh ? NULL : xqh->hlink)) {\n\t\t\tuhci_dump_qh(xqh);\n\t\t}\n\t\tDPRINTF((\"Enqueued QH:\\n\"));\n\t\tuhci_dump_qh(sqh);\n\t\tuhci_dump_tds(sqh->elink);\n\t}\n#endif\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uhci_device_intr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1945-1972",
    "snippet": "void\nuhci_device_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tint i, npoll;\n\tint s;\n\n\t/* Unlink descriptors from controller data structures. */\n\tnpoll = upipe->u.intr.npoll;\n\ts = splusb();\n\tfor (i = 0; i < npoll; i++)\n\t\tuhci_remove_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\t/* \n\t * We now have to wait for any activity on the physical\n\t * descriptors to stop.\n\t */\n\tusb_delay_ms(&sc->sc_bus, 2);\n\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_free_sqh(sc, upipe->u.intr.qhs[i]);\n\tfree(upipe->u.intr.qhs, M_USBHC);\n\n\t/* XXX free other resources */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "upipe->u.intr.qhs",
            "M_USBHC"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_free_sqh",
          "args": [
            "sc",
            "upipe->u.intr.qhs[i]"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_sqh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1495-1502",
          "snippet": "void\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "2"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_remove_intr",
          "args": [
            "sc",
            "upipe->u.intr.qhs[i]"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_remove_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "2555-2571",
          "snippet": "void\nuhci_remove_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *pqh;\n\n\tDPRINTFN(4, (\"uhci_remove_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\tpqh = uhci_find_prev_qh(vf->hqh, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (vf->eqh == sqh)\n\t\tvf->eqh = pqh;\n\tvf->bandwidth--;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_intr(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tstruct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];\n\tuhci_soft_qh_t *pqh;\n\n\tDPRINTFN(4, (\"uhci_remove_intr: n=%d sqh=%p\\n\", sqh->pos, sqh));\n\n\tpqh = uhci_find_prev_qh(vf->hqh, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (vf->eqh == sqh)\n\t\tvf->eqh = pqh;\n\tvf->bandwidth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_intr_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tint i, npoll;\n\tint s;\n\n\t/* Unlink descriptors from controller data structures. */\n\tnpoll = upipe->u.intr.npoll;\n\ts = splusb();\n\tfor (i = 0; i < npoll; i++)\n\t\tuhci_remove_intr(sc, upipe->u.intr.qhs[i]);\n\tsplx(s);\n\n\t/* \n\t * We now have to wait for any activity on the physical\n\t * descriptors to stop.\n\t */\n\tusb_delay_ms(&sc->sc_bus, 2);\n\n\tfor(i = 0; i < npoll; i++)\n\t\tuhci_free_sqh(sc, upipe->u.intr.qhs[i]);\n\tfree(upipe->u.intr.qhs, M_USBHC);\n\n\t/* XXX free other resources */\n}"
  },
  {
    "function_name": "uhci_device_intr_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1932-1942",
    "snippet": "void\nuhci_device_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(1,(\"uhci_device_intr_abort: xfer=%p\\n\", xfer));\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTFN(1,(\"uhci_device_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = 0;\n\t}\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_abort_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1727-1769",
          "snippet": "void\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\n\nvoid\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_device_intr_abort: remove\\n\")"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_device_intr_abort: xfer=%p\\n\", xfer)"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_device_intr_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(1,(\"uhci_device_intr_abort: xfer=%p\\n\", xfer));\n\tif (xfer->pipe->intrxfer == xfer) {\n\t\tDPRINTFN(1,(\"uhci_device_intr_abort: remove\\n\"));\n\t\txfer->pipe->intrxfer = 0;\n\t}\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "uhci_device_ctrl_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1925-1929",
    "snippet": "void\nuhci_device_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_device_ctrl_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n}"
  },
  {
    "function_name": "uhci_device_ctrl_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1916-1922",
    "snippet": "void\nuhci_device_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"uhci_device_ctrl_abort:\\n\"));\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_abort_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1727-1769",
          "snippet": "void\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\n\nvoid\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_ctrl_abort:\\n\")"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_device_ctrl_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"uhci_device_ctrl_abort:\\n\"));\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "uhci_device_intr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1843-1913",
    "snippet": "usbd_status\nuhci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3,(\"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t    xfer, xfer->length, xfer->flags));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_intr_transfer: a request\\n\");\n#endif\n\n\terr = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\ts = splusb();\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_intr_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tDPRINTFN(10,(\"uhci_device_intr_transfer: qhs[0]=%p\\n\", \n\t\t     upipe->u.intr.qhs[0]));\n\tfor (i = 0; i < upipe->u.intr.npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = data;\n\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t}\n\tuhci_add_intr_info(sc, ii);\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_dump_qh",
          "args": [
            "upipe->u.intr.qhs[0]"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_qhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "795-825",
          "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "data"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_intr_transfer: data(2)\\n\")"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_intr_info",
          "args": [
            "sc",
            "ii"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "data->physaddr"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_device_intr_transfer: qhs[0]=%p\\n\", \n\t\t     upipe->u.intr.qhs[0])"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_intr_transfer: not done, ii=%p\\n\"",
            "ii"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_intr_transfer: data(1)\\n\")"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_IOC"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std_chain",
          "args": [
            "upipe",
            "sc",
            "xfer->length",
            "1",
            "xfer->flags",
            "&xfer->dmabuf",
            "&data",
            "&dataend"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_device_intr_transfer: a request\\n\""
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t    xfer, xfer->length, xfer->flags)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3,(\"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t    xfer, xfer->length, xfer->flags));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_intr_transfer: a request\\n\");\n#endif\n\n\terr = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\ts = splusb();\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_intr_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tDPRINTFN(10,(\"uhci_device_intr_transfer: qhs[0]=%p\\n\", \n\t\t     upipe->u.intr.qhs[0]));\n\tfor (i = 0; i < upipe->u.intr.npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = data;\n\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t}\n\tuhci_add_intr_info(sc, ii);\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_device_intr_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1825-1841",
    "snippet": "usbd_status\nuhci_device_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_device_intr_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_intr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1843-1913",
          "snippet": "usbd_status\nuhci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3,(\"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t    xfer, xfer->length, xfer->flags));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_intr_transfer: a request\\n\");\n#endif\n\n\terr = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\ts = splusb();\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_intr_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tDPRINTFN(10,(\"uhci_device_intr_transfer: qhs[0]=%p\\n\", \n\t\t     upipe->u.intr.qhs[0]));\n\tfor (i = 0; i < upipe->u.intr.npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = data;\n\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t}\n\tuhci_add_intr_info(sc, ii);\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_intr_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n\tDPRINTFN(3,(\"uhci_device_intr_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t    xfer, xfer->length, xfer->flags));\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_intr_transfer: a request\\n\");\n#endif\n\n\terr = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\ts = splusb();\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_intr_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tDPRINTFN(10,(\"uhci_device_intr_transfer: qhs[0]=%p\\n\", \n\t\t     upipe->u.intr.qhs[0]));\n\tfor (i = 0; i < upipe->u.intr.npoll; i++) {\n\t\tsqh = upipe->u.intr.qhs[i];\n\t\tsqh->elink = data;\n\t\tsqh->qh.qh_elink = htole32(data->physaddr);\n\t}\n\tuhci_add_intr_info(sc, ii);\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_intr_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t\tuhci_dump_qh(upipe->u.intr.qhs[0]);\n\t}\n#endif\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_device_intr_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "uhci_device_ctrl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1801-1823",
    "snippet": "usbd_status\nuhci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_device_ctrl_transfer: not a request\\n\");\n#endif\n\n\terr = uhci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_waitintr",
          "args": [
            "sc",
            "xfer"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_waitintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1314-1346",
          "snippet": "void\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_device_request",
          "args": [
            "xfer"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1974-2099",
          "snippet": "usbd_status\nuhci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *setup, *data, *stat, *next, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tint len;\n\tu_int32_t ls;\n\tusbd_status err;\n\tint isread;\n\tint s;\n\n\tDPRINTFN(3,(\"uhci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), UGETW(req->wLength),\n\t\t    addr, endpt));\n\n\tls = dev->lowspeed ? UHCI_TD_LS : 0;\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tsetup = upipe->u.ctl.setup;\n\tstat = upipe->u.ctl.stat;\n\tsqh = upipe->u.ctl.sqh;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tupipe->nexttoggle = 1;\n\t\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tnext = data;\n\t\tdataend->link.std = stat;\n\t\tdataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF);\n\t} else {\n\t\tnext = stat;\n\t}\n\tupipe->u.ctl.length = len;\n\n\tmemcpy(KERNADDR(&upipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->link.std = next;\n\tsetup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF);\n\tsetup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |\n\t\tUHCI_TD_ACTIVE);\n\tsetup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));\n\tsetup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));\n\n\tstat->link.std = NULL;\n\tstat->td.td_link = htole32(UHCI_PTR_T);\n\tstat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | \n\t\tUHCI_TD_ACTIVE | UHCI_TD_IOC);\n\tstat->td.td_token = \n\t\thtole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :\n\t\t                 UHCI_TD_IN (0, endpt, addr, 1));\n\tstat->td.td_buffer = htole32(0);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_request: before transfer\\n\"));\n\t\tuhci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = setup;\n\tii->stdend = stat;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_request: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = setup;\n\tsqh->qh.qh_elink = htole32(setup->physaddr);\n\n\ts = splusb();\n\tuhci_add_ctrl(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 12) {\n\t\tuhci_soft_td_t *std;\n\t\tuhci_soft_qh_t *xqh;\n\t\tuhci_soft_qh_t *sxqh;\n\t\tint maxqh = 0;\n\t\tuhci_physaddr_t link;\n\t\tDPRINTF((\"uhci_enter_ctl_q: follow from [0]\\n\"));\n\t\tfor (std = sc->sc_vframes[0].htd, link = 0;\n\t\t     (link & UHCI_PTR_Q) == 0;\n\t\t     std = std->link.std) {\n\t\t\tlink = le32toh(std->td.td_link);\n\t\t\tuhci_dump_td(std);\n\t\t}\n\t\tsxqh = (uhci_soft_qh_t *)std;\n\t\tuhci_dump_qh(sxqh);\n\t\tfor (xqh = sxqh;\n\t\t     xqh != NULL;\n\t\t     xqh = (maxqh++ == 5 || xqh->hlink==sxqh || \n                            xqh->hlink==xqh ? NULL : xqh->hlink)) {\n\t\t\tuhci_dump_qh(xqh);\n\t\t}\n\t\tDPRINTF((\"Enqueued QH:\\n\"));\n\t\tuhci_dump_qh(sqh);\n\t\tuhci_dump_tds(sqh->elink);\n\t}\n#endif\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_request(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusb_device_request_t *req = &xfer->request;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tint addr = dev->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *setup, *data, *stat, *next, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tint len;\n\tu_int32_t ls;\n\tusbd_status err;\n\tint isread;\n\tint s;\n\n\tDPRINTFN(3,(\"uhci_device_control type=0x%02x, request=0x%02x, \"\n\t\t    \"wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\\n\",\n\t\t    req->bmRequestType, req->bRequest, UGETW(req->wValue),\n\t\t    UGETW(req->wIndex), UGETW(req->wLength),\n\t\t    addr, endpt));\n\n\tls = dev->lowspeed ? UHCI_TD_LS : 0;\n\tisread = req->bmRequestType & UT_READ;\n\tlen = UGETW(req->wLength);\n\n\tsetup = upipe->u.ctl.setup;\n\tstat = upipe->u.ctl.stat;\n\tsqh = upipe->u.ctl.sqh;\n\n\t/* Set up data transaction */\n\tif (len != 0) {\n\t\tupipe->nexttoggle = 1;\n\t\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tnext = data;\n\t\tdataend->link.std = stat;\n\t\tdataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF);\n\t} else {\n\t\tnext = stat;\n\t}\n\tupipe->u.ctl.length = len;\n\n\tmemcpy(KERNADDR(&upipe->u.ctl.reqdma), req, sizeof *req);\n\n\tsetup->link.std = next;\n\tsetup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF);\n\tsetup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |\n\t\tUHCI_TD_ACTIVE);\n\tsetup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));\n\tsetup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));\n\n\tstat->link.std = NULL;\n\tstat->td.td_link = htole32(UHCI_PTR_T);\n\tstat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | \n\t\tUHCI_TD_ACTIVE | UHCI_TD_IOC);\n\tstat->td.td_token = \n\t\thtole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :\n\t\t                 UHCI_TD_IN (0, endpt, addr, 1));\n\tstat->td.td_buffer = htole32(0);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_request: before transfer\\n\"));\n\t\tuhci_dump_tds(setup);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = setup;\n\tii->stdend = stat;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_request: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = setup;\n\tsqh->qh.qh_elink = htole32(setup->physaddr);\n\n\ts = splusb();\n\tuhci_add_ctrl(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 12) {\n\t\tuhci_soft_td_t *std;\n\t\tuhci_soft_qh_t *xqh;\n\t\tuhci_soft_qh_t *sxqh;\n\t\tint maxqh = 0;\n\t\tuhci_physaddr_t link;\n\t\tDPRINTF((\"uhci_enter_ctl_q: follow from [0]\\n\"));\n\t\tfor (std = sc->sc_vframes[0].htd, link = 0;\n\t\t     (link & UHCI_PTR_Q) == 0;\n\t\t     std = std->link.std) {\n\t\t\tlink = le32toh(std->td.td_link);\n\t\t\tuhci_dump_td(std);\n\t\t}\n\t\tsxqh = (uhci_soft_qh_t *)std;\n\t\tuhci_dump_qh(sxqh);\n\t\tfor (xqh = sxqh;\n\t\t     xqh != NULL;\n\t\t     xqh = (maxqh++ == 5 || xqh->hlink==sxqh || \n                            xqh->hlink==xqh ? NULL : xqh->hlink)) {\n\t\t\tuhci_dump_qh(xqh);\n\t\t}\n\t\tDPRINTF((\"Enqueued QH:\\n\"));\n\t\tuhci_dump_qh(sqh);\n\t\tuhci_dump_tds(sqh->elink);\n\t}\n#endif\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_device_ctrl_transfer: not a request\\n\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_device_ctrl_transfer: not a request\\n\");\n#endif\n\n\terr = uhci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_device_ctrl_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1783-1799",
    "snippet": "usbd_status\nuhci_device_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_device_ctrl_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_ctrl_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1801-1823",
          "snippet": "usbd_status\nuhci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_device_ctrl_transfer: not a request\\n\");\n#endif\n\n\terr = uhci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_ctrl_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;\n\tusbd_status err;\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (!(xfer->rqflags & URQ_REQUEST))\n\t\tpanic(\"uhci_device_ctrl_transfer: not a request\\n\");\n#endif\n\n\terr = uhci_device_request(xfer);\n\tif (err)\n\t\treturn (err);\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_device_ctrl_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "uhci_device_bulk_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1772-1781",
    "snippet": "void\nuhci_device_bulk_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\n\tuhci_free_sqh(sc, upipe->u.bulk.sqh);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_free_sqh",
          "args": [
            "sc",
            "upipe->u.bulk.sqh"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_sqh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1495-1502",
          "snippet": "void\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_device_bulk_close(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\n\tuhci_free_sqh(sc, upipe->u.bulk.sqh);\n}"
  },
  {
    "function_name": "uhci_abort_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1727-1769",
    "snippet": "void\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "Static usbd_status",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "~(UHCI_TD_ACTIVE | UHCI_TD_IOC)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "xfer->timeout_handle",
            "uhci_timeout",
            "ii"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status)"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\n\nvoid\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
  },
  {
    "function_name": "uhci_device_bulk_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1714-1720",
    "snippet": "void\nuhci_device_bulk_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"uhci_device_bulk_abort:\\n\"));\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_abort_xfer",
          "args": [
            "xfer",
            "USBD_CANCELLED"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_abort_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1727-1769",
          "snippet": "void\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\n\nvoid\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_bulk_abort:\\n\")"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_device_bulk_abort(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTF((\"uhci_device_bulk_abort:\\n\"));\n\tuhci_abort_xfer(xfer, USBD_CANCELLED);\n}"
  },
  {
    "function_name": "uhci_device_bulk_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1629-1711",
    "snippet": "usbd_status\nuhci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint len, isread, endpt;\n\tint s;\n\n\tDPRINTFN(3, (\"uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_bulk_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\tendpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsqh = upipe->u.bulk.sqh;\n\n\tupipe->u.bulk.isread = isread;\n\tupipe->u.bulk.length = len;\n\n\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 8) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_bulk_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = data;\n\tsqh->qh.qh_elink = htole32(data->physaddr);\n\n\ts = splusb();\n\tuhci_add_bulk(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\n\treturn (USBD_IN_PROGRESS);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_waitintr",
          "args": [
            "sc",
            "xfer"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_waitintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1314-1346",
          "snippet": "void\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "data"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_bulk_transfer: data(2)\\n\")"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "xfer->timeout_handle",
            "MS_TO_TICKS(xfer->timeout)",
            "uhci_timeout",
            "ii"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MS_TO_TICKS",
          "args": [
            "xfer->timeout"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_intr_info",
          "args": [
            "sc",
            "ii"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_add_bulk",
          "args": [
            "sc",
            "sqh"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_add_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "990-1006",
          "snippet": "void\nuhci_add_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_bulk: sqh=%p\\n\", sqh));\n\teqh = sc->sc_bulk_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_bulk_end = sqh;\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_bulk: sqh=%p\\n\", sqh));\n\teqh = sc->sc_bulk_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_bulk_end = sqh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "data->physaddr"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_device_bulk_transfer: not done, ii=%p\\n\"",
            "ii"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_device_bulk_transfer: data(1)\\n\")"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_IOC"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std_chain",
          "args": [
            "upipe",
            "sc",
            "len",
            "isread",
            "xfer->flags",
            "&xfer->dmabuf",
            "&data",
            "&dataend"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_device_bulk_transfer: a request\\n\""
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags)"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint len, isread, endpt;\n\tint s;\n\n\tDPRINTFN(3, (\"uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_bulk_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\tendpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsqh = upipe->u.bulk.sqh;\n\n\tupipe->u.bulk.isread = isread;\n\tupipe->u.bulk.length = len;\n\n\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 8) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_bulk_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = data;\n\tsqh->qh.qh_elink = htole32(data->physaddr);\n\n\ts = splusb();\n\tuhci_add_bulk(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\n\treturn (USBD_IN_PROGRESS);\n}"
  },
  {
    "function_name": "uhci_device_bulk_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1611-1627",
    "snippet": "usbd_status\nuhci_device_bulk_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "Static usbd_status",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_device_bulk_start",
          "args": [
            "SIMPLEQ_FIRST(&xfer->pipe->queue)"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_device_bulk_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1629-1711",
          "snippet": "usbd_status\nuhci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint len, isread, endpt;\n\tint s;\n\n\tDPRINTFN(3, (\"uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_bulk_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\tendpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsqh = upipe->u.bulk.sqh;\n\n\tupipe->u.bulk.isread = isread;\n\tupipe->u.bulk.length = len;\n\n\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 8) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_bulk_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = data;\n\tsqh->qh.qh_elink = htole32(data->physaddr);\n\n\ts = splusb();\n\tuhci_add_bulk(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\n\treturn (USBD_IN_PROGRESS);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "Static __inline__ uhci_soft_qh_t",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_device_bulk_start(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tusbd_device_handle dev = upipe->pipe.device;\n\tuhci_softc_t *sc = (uhci_softc_t *)dev->bus;\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *data, *dataend;\n\tuhci_soft_qh_t *sqh;\n\tusbd_status err;\n\tint len, isread, endpt;\n\tint s;\n\n\tDPRINTFN(3, (\"uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\\n\",\n\t\t     xfer, xfer->length, xfer->flags));\n\n\tif (sc->sc_dying)\n\t\treturn (USBD_IOERROR);\n\n#ifdef DIAGNOSTIC\n\tif (xfer->rqflags & URQ_REQUEST)\n\t\tpanic(\"uhci_device_bulk_transfer: a request\\n\");\n#endif\n\n\tlen = xfer->length;\n\tendpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\tisread = UE_GET_DIR(endpt) == UE_DIR_IN;\n\tsqh = upipe->u.bulk.sqh;\n\n\tupipe->u.bulk.isread = isread;\n\tupipe->u.bulk.length = len;\n\n\terr = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,\n\t\t\t\t   &xfer->dmabuf, &data, &dataend);\n\tif (err)\n\t\treturn (err);\n\tdataend->td.td_status |= htole32(UHCI_TD_IOC);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 8) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(1)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\t/* Set up interrupt info. */\n\tii->xfer = xfer;\n\tii->stdstart = data;\n\tii->stdend = dataend;\n#ifdef DIAGNOSTIC\n\tif (!ii->isdone) {\n\t\tprintf(\"uhci_device_bulk_transfer: not done, ii=%p\\n\", ii);\n\t}\n\tii->isdone = 0;\n#endif\n\n\tsqh->elink = data;\n\tsqh->qh.qh_elink = htole32(data->physaddr);\n\n\ts = splusb();\n\tuhci_add_bulk(sc, sqh);\n\tuhci_add_intr_info(sc, ii);\n\n\tif (xfer->timeout && !sc->sc_bus.use_polling) {\n\t\tusb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),\n\t\t\t    uhci_timeout, ii);\n\t}\n\txfer->status = USBD_IN_PROGRESS;\n\tsplx(s);\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10) {\n\t\tDPRINTF((\"uhci_device_bulk_transfer: data(2)\\n\"));\n\t\tuhci_dump_tds(data);\n\t}\n#endif\n\n\tif (sc->sc_bus.use_polling)\n\t\tuhci_waitintr(sc, xfer);\n\n\treturn (USBD_IN_PROGRESS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&xfer->pipe->queue"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_insert_transfer",
          "args": [
            "xfer"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "usb_insert_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "885-905",
          "snippet": "usbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusb_insert_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusbd_status err;\n\tint s;\n\n\tDPRINTFN(5,(\"usb_insert_transfer: pipe=%p running=%d timeout=%d\\n\", \n\t\t    pipe, pipe->running, xfer->timeout));\n\ts = splusb();\n\tSIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);\n\tif (pipe->running)\n\t\terr = USBD_IN_PROGRESS;\n\telse {\n\t\tpipe->running = 1;\n\t\terr = USBD_NORMAL_COMPLETION;\n\t}\n\tsplx(s);\n\treturn (err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nusbd_status\nuhci_device_bulk_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_status err;\n\n\t/* Insert last in queue. */\n\terr = usb_insert_transfer(xfer);\n\tif (err)\n\t\treturn (err);\n\n\t/* \n\t * Pipe isn't running (otherwise err would be USBD_INPROG),\n\t * so start it first.\n\t */\n\treturn (uhci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));\n}"
  },
  {
    "function_name": "uhci_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1605-1609",
    "snippet": "void\nuhci_noop(pipe)\n\tusbd_pipe_handle pipe;\n{\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_noop(pipe)\n\tusbd_pipe_handle pipe;\n{\n}"
  },
  {
    "function_name": "uhci_device_clear_toggle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1597-1603",
    "snippet": "void\nuhci_device_clear_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tupipe->nexttoggle = 0;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_device_clear_toggle(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)pipe;\n\tupipe->nexttoggle = 0;\n}"
  },
  {
    "function_name": "uhci_alloc_std_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1518-1595",
    "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "Static usbd_status",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static usbd_status",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "DMAADDR(dma) + i * maxp"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "dma"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog)"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_OUT",
          "args": [
            "l",
            "endpt",
            "addr",
            "tog"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_IN",
          "args": [
            "l",
            "endpt",
            "addr",
            "tog"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "status"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "lastlink|UHCI_PTR_VF"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "lastlink"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_free_std_chain",
          "args": [
            "sc",
            "lastp",
            "0"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "UHCI_TD_ZERO_ACTLEN",
          "args": [
            "UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_SET_ERRCNT",
          "args": [
            "3"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"uhci_alloc_std_chain: ntd=0\\n\")"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_alloc_std_chain: maxp=0\\n\""
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "upipe->pipe.endpoint->edesc->wMaxPacketSize"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "8",
            "(\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags)"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "endpt"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uhci_free_std_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1504-1516",
    "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_free_std",
          "args": [
            "sc",
            "std"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
  },
  {
    "function_name": "uhci_free_sqh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1495-1502",
    "snippet": "void\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_sqh(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tsqh->hlink = sc->sc_freeqhs;\n\tsc->sc_freeqhs = sqh;\n}"
  },
  {
    "function_name": "uhci_free_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1449-1464",
    "snippet": "void\nuhci_free_std(sc, std)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n{\n#ifdef DIAGNOSTIC\n#define TD_IS_FREE 0x12345678\n\tif (le32toh(std->td.td_token) == TD_IS_FREE) {\n\t\tprintf(\"uhci_free_std: freeing free TD %p\\n\", std);\n\t\treturn;\n\t}\n\tstd->td.td_token = htole32(TD_IS_FREE);\n#endif\n\tstd->link.std = sc->sc_freetds;\n\tsc->sc_freetds = std;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TD_IS_FREE 0x12345678"
    ],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "TD_IS_FREE"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_free_std: freeing free TD %p\\n\"",
            "std"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_token"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TD_IS_FREE 0x12345678\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std(sc, std)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n{\n#ifdef DIAGNOSTIC\n#define TD_IS_FREE 0x12345678\n\tif (le32toh(std->td.td_token) == TD_IS_FREE) {\n\t\tprintf(\"uhci_free_std: freeing free TD %p\\n\", std);\n\t\treturn;\n\t}\n\tstd->td.td_token = htole32(TD_IS_FREE);\n#endif\n\tstd->link.std = sc->sc_freetds;\n\tsc->sc_freetds = std;\n}"
  },
  {
    "function_name": "uhci_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1376-1408",
    "snippet": "usbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "uhci_run __P((uhci_softc_t *, int run));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cannot %s\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)",
            "run ? \"start\" : \"stop\""
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "1"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS))"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_run: setting run=%d\\n\", run)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nuhci_run __P((uhci_softc_t *, int run));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}"
  },
  {
    "function_name": "uhci_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1359-1373",
    "snippet": "void\nuhci_reset(sc)\n\tuhci_softc_t *sc;\n{\n\tint n;\n\n\tUHCICMD(sc, UHCI_CMD_HCRESET);\n\t/* The reset bit goes low when the controller is done. */\n\tfor (n = 0; n < UHCI_RESET_TIMEOUT && \n\t\t    (UREAD2(sc, UHCI_CMD) & UHCI_CMD_HCRESET); n++)\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\tif (n >= UHCI_RESET_TIMEOUT)\n\t\tprintf(\"%s: controller did not reset\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UHCI_RESET_TIMEOUT 100\t/* reset timeout */"
    ],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: controller did not reset\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "1"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "UHCI_CMD_HCRESET"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UHCI_RESET_TIMEOUT 100\t/* reset timeout */\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_reset(sc)\n\tuhci_softc_t *sc;\n{\n\tint n;\n\n\tUHCICMD(sc, UHCI_CMD_HCRESET);\n\t/* The reset bit goes low when the controller is done. */\n\tfor (n = 0; n < UHCI_RESET_TIMEOUT && \n\t\t    (UREAD2(sc, UHCI_CMD) & UHCI_CMD_HCRESET); n++)\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\tif (n >= UHCI_RESET_TIMEOUT)\n\t\tprintf(\"%s: controller did not reset\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n}"
  },
  {
    "function_name": "uhci_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1348-1356",
    "snippet": "void\nuhci_poll(bus)\n\tstruct usbd_bus *bus;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)bus;\n\n\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT)\n\t\tuhci_intr(sc);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_allocx __P((struct usbd_bus *));",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_intr",
          "args": [
            "sc"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1026-1090",
          "snippet": "int\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_allocx __P((struct usbd_bus *));\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_poll(bus)\n\tstruct usbd_bus *bus;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)bus;\n\n\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT)\n\t\tuhci_intr(sc);\n}"
  },
  {
    "function_name": "uhci_waitintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1314-1346",
    "snippet": "void\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_idone",
          "args": [
            "ii"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_idone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1177-1285",
          "snippet": "void\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"uhci_waitintr: lost intr_info\\n\""
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "ii",
            "list"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_intrhead"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_waitintr: timeout\\n\")"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_intr",
          "args": [
            "sc"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1026-1090",
          "snippet": "int\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "20",
            "(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS))"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "1"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_waitintr: timeout = %dms\\n\", timo)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_waitintr(sc, xfer)\n\tuhci_softc_t *sc;\n\tusbd_xfer_handle xfer;\n{\n\tint timo = xfer->timeout;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"uhci_waitintr: timeout = %dms\\n\", timo));\n\n\txfer->status = USBD_IN_PROGRESS;\n\tfor (; timo >= 0; timo--) {\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t\tDPRINTFN(20,(\"uhci_waitintr: 0x%04x\\n\", UREAD2(sc, UHCI_STS)));\n\t\tif (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {\n\t\t\tuhci_intr(sc);\n\t\t\tif (xfer->status != USBD_IN_PROGRESS)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Timeout */\n\tDPRINTF((\"uhci_waitintr: timeout\\n\"));\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead);\n\t     ii != NULL && ii->xfer != xfer; \n\t     ii = LIST_NEXT(ii, list))\n\t\t;\n#ifdef DIAGNOSTIC\n\tif (ii == NULL)\n\t\tpanic(\"uhci_waitintr: lost intr_info\\n\");\n#endif\n\tuhci_idone(ii);\n}"
  },
  {
    "function_name": "uhci_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1290-1306",
    "snippet": "void\nuhci_timeout(addr)\n\tvoid *addr;\n{\n\tuhci_intr_info_t *ii = addr;\n\n\tDPRINTF((\"uhci_timeout: ii=%p\\n\", ii));\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\tii->xfer->device->bus->intr_context++;\n\tuhci_abort_xfer(ii->xfer, USBD_TIMEOUT);\n\tii->xfer->device->bus->intr_context--;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_abort_xfer",
          "args": [
            "ii->xfer",
            "USBD_TIMEOUT"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_abort_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1727-1769",
          "snippet": "void\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "Static usbd_status",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "Static usbd_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nStatic usbd_status;\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic usbd_status;\n\nvoid\nuhci_abort_xfer(xfer, status)\n\tusbd_xfer_handle xfer;\n\tusbd_status status;\n{\n\tuhci_intr_info_t *ii = &UXFER(xfer)->iinfo;\n\tuhci_soft_td_t *std;\n\tint s;\n\n\tDPRINTFN(1,(\"uhci_abort_xfer: xfer=%p, status=%d\\n\", xfer, status));\n\n\ts = splusb();\n\n\t/* Transfer is already done. */\n\tif (xfer->status != USBD_NOT_STARTED && \n\t    xfer->status != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Make interrupt routine ignore it, */\n\txfer->status = status;\n\n\t/* don't timeout, */\n\tusb_uncallout(xfer->timeout_handle, uhci_timeout, ii);\n\n\t/* make hardware ignore it, */\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std)\n\t\tstd->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));\n\n\txfer->hcpriv = ii;\n\n\tsplx(s);\n\n\tdelay(1000);\n\n\ts = splusb();\n#ifdef DIAGNOSTIC\n\tii->isdone = 1;\n#endif\n\tusb_transfer_complete(xfer);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "ii->stdstart"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_timeout: ii=%p\\n\", ii)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_timeout(addr)\n\tvoid *addr;\n{\n\tuhci_intr_info_t *ii = addr;\n\n\tDPRINTF((\"uhci_timeout: ii=%p\\n\", ii));\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\tii->xfer->device->bus->intr_context++;\n\tuhci_abort_xfer(ii->xfer, USBD_TIMEOUT);\n\tii->xfer->device->bus->intr_context--;\n}"
  },
  {
    "function_name": "uhci_idone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1177-1285",
    "snippet": "void\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "(status == UHCI_TD_STALLED)*10",
            "(\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\")"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_DT",
          "args": [
            "le32toh(std->td.td_token)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_token"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ACTLEN",
          "args": [
            "status"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_PID",
          "args": [
            "le32toh(std->td.td_token)"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_token"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_status"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "ii->stdstart"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ACTLEN",
          "args": [
            "status"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_status"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"uhci_idone: isoc TD %d\\n\", i)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uhci_idone: ii=%p isoc ready\\n\", ii)"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_idone: aborted xfer=%p\\n\", xfer)"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_idone: ii=%p is done!\\n\"",
            "ii"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dump_ii",
          "args": [
            "ii"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_iis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "887-896",
          "snippet": "void\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}"
  },
  {
    "function_name": "uhci_check_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1121-1174",
    "snippet": "void\nuhci_check_intr(sc, ii)\n\tuhci_softc_t *sc;\n\tuhci_intr_info_t *ii;\n{\n\tuhci_soft_td_t *std, *lstd;\n\tu_int32_t status;\n\n\tDPRINTFN(15, (\"uhci_check_intr: ii=%p\\n\", ii));\n#ifdef DIAGNOSTIC\n\tif (ii == NULL) {\n\t\tprintf(\"uhci_check_intr: no ii? %p\\n\", ii);\n\t\treturn;\n\t}\n#endif\n\tif (ii->stdstart == NULL)\n\t\treturn;\n\tlstd = ii->stdend;\n#ifdef DIAGNOSTIC\n\tif (lstd == NULL) {\n\t\tprintf(\"uhci_check_intr: std==0\\n\");\n\t\treturn;\n\t}\n#endif\n\t/* \n\t * If the last TD is still active we need to check whether there\n\t * is a an error somewhere in the middle, or whether there was a\n\t * short packet (SPD and not ACTIVE).\n\t */\n\tif (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {\n\t\tDPRINTFN(12, (\"uhci_check_intr: active ii=%p\\n\", ii));\n\t\tfor (std = ii->stdstart; std != lstd; std = std->link.std) {\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\t/* If there's an active TD the xfer isn't done. */\n\t\t\tif (status & UHCI_TD_ACTIVE)\n\t\t\t\tbreak;\n\t\t\t/* Any kind of error makes the xfer done. */\n\t\t\tif (status & UHCI_TD_STALLED)\n\t\t\t\tgoto done;\n\t\t\t/* We want short packets, and it is short: it's done */\n\t\t\tif ((status & UHCI_TD_SPD) &&\n\t\t\t      UHCI_TD_GET_ACTLEN(status) < \n\t\t\t      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tDPRINTFN(12, (\"uhci_check_intr: ii=%p std=%p still active\\n\",\n\t\t\t      ii, ii->stdstart));\n\t\treturn;\n\t}\n done:\n\tDPRINTFN(12, (\"uhci_check_intr: ii=%p done\\n\", ii));\n\tusb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);\n\tuhci_idone(ii);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_idone",
          "args": [
            "ii"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_idone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1177-1285",
          "snippet": "void\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\n\nvoid\nuhci_idone(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_xfer_handle xfer = ii->xfer;\n\tstruct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;\n\tuhci_soft_td_t *std;\n\tu_int32_t status = 0, nstatus;\n\tint actlen;\n\n#ifdef DIAGNOSTIC\n\t{\n\t\tint s = splhigh();\n\t\tif (ii->isdone) {\n\t\t\tsplx(s);\n#ifdef UHCI_DEBUG\n\t\t\tprintf(\"uhci_idone: ii is done!\\n   \");\n\t\t\tuhci_dump_ii(ii);\n#else\n\t\t\tprintf(\"uhci_idone: ii=%p is done!\\n\", ii);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tii->isdone = 1;\n\t\tsplx(s);\n\t}\n#endif\n\n\tif (xfer->status == USBD_CANCELLED ||\n\t    xfer->status == USBD_TIMEOUT) {\n\t\tDPRINTF((\"uhci_idone: aborted xfer=%p\\n\", xfer));\n\t\treturn;\n\t}\n\n\tif (xfer->nframes != 0) {\n\t\t/* Isoc transfer, do things differently. */\n\t\tuhci_soft_td_t **stds = upipe->u.iso.stds;\n\t\tint i, n, nframes;\n\n\t\tDPRINTFN(5,(\"uhci_idone: ii=%p isoc ready\\n\", ii));\n\n\t\tnframes = xfer->nframes;\n\t\tactlen = 0;\n\t\tn = UXFER(xfer)->curframe;\n\t\tfor (i = 0; i < nframes; i++) {\n\t\t\tstd = stds[n];\n#ifdef UHCI_DEBUG\n\t\t\tif (uhcidebug > 5) {\n\t\t\t\tDPRINTFN(-1,(\"uhci_idone: isoc TD %d\\n\", i));\n\t\t\t\tuhci_dump_td(std);\n\t\t\t}\n#endif\n\t\t\tif (++n >= UHCI_VFRAMELIST_COUNT)\n\t\t\t\tn = 0;\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t\t}\n\t\tupipe->u.iso.inuse -= nframes;\n\t\txfer->actlen = actlen;\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t\tusb_transfer_complete(xfer);\n\t\treturn;\n\t}\n\n#ifdef UHCI_DEBUG\n\tDPRINTFN(10, (\"uhci_idone: ii=%p, xfer=%p, pipe=%p ready\\n\",\n\t\t      ii, xfer, upipe));\n\tif (uhcidebug > 10)\n\t\tuhci_dump_tds(ii->stdstart);\n#endif\n\n\t/* The transfer is done, compute actual length and status. */\n\tactlen = 0;\n\tfor (std = ii->stdstart; std != NULL; std = std->link.std) {\n\t\tnstatus = le32toh(std->td.td_status);\n\t\tif (nstatus & UHCI_TD_ACTIVE)\n\t\t\tbreak;\n\n\t\tstatus = nstatus;\n\t\tif (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=\n\t\t\tUHCI_TD_PID_SETUP)\n\t\t\tactlen += UHCI_TD_GET_ACTLEN(status);\n\t}\n\t/* If there are left over TDs we need to update the toggle. */\n\tif (std != NULL)\n\t\tupipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));\n\n\tstatus &= UHCI_TD_ERROR;\n\tDPRINTFN(10, (\"uhci_check_intr: actlen=%d, status=0x%x\\n\", \n\t\t      actlen, status));\n\txfer->actlen = actlen;\n\tif (status != 0) {\n\t\tDPRINTFN((status == UHCI_TD_STALLED)*10,\n\t\t\t (\"uhci_idone: error, addr=%d, endpt=0x%02x, \"\n\t\t\t  \"status 0x%b\\n\",\n\t\t\t  xfer->pipe->device->address,\n\t\t\t  xfer->pipe->endpoint->edesc->bEndpointAddress,\n\t\t\t  (int)status, \n\t\t\t  \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t\t  \"STALLED\\30ACTIVE\"));\n\t\tif (status == UHCI_TD_STALLED)\n\t\t\txfer->status = USBD_STALLED;\n\t\telse\n\t\t\txfer->status = USBD_IOERROR; /* more info XXX */\n\t} else {\n\t\txfer->status = USBD_NORMAL_COMPLETION;\n\t}\n\tusb_transfer_complete(xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "ii->xfer->timeout_handle",
            "uhci_timeout",
            "ii"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "12",
            "(\"uhci_check_intr: ii=%p done\\n\", ii)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "12",
            "(\"uhci_check_intr: ii=%p std=%p still active\\n\",\n\t\t\t      ii, ii->stdstart)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_MAXLEN",
          "args": [
            "le32toh(std->td.td_token)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_token"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ACTLEN",
          "args": [
            "status"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "std->td.td_status"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "12",
            "(\"uhci_check_intr: active ii=%p\\n\", ii)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "lstd->td.td_status"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_check_intr: std==0\\n\""
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"uhci_check_intr: ii=%p\\n\", ii)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_check_intr(sc, ii)\n\tuhci_softc_t *sc;\n\tuhci_intr_info_t *ii;\n{\n\tuhci_soft_td_t *std, *lstd;\n\tu_int32_t status;\n\n\tDPRINTFN(15, (\"uhci_check_intr: ii=%p\\n\", ii));\n#ifdef DIAGNOSTIC\n\tif (ii == NULL) {\n\t\tprintf(\"uhci_check_intr: no ii? %p\\n\", ii);\n\t\treturn;\n\t}\n#endif\n\tif (ii->stdstart == NULL)\n\t\treturn;\n\tlstd = ii->stdend;\n#ifdef DIAGNOSTIC\n\tif (lstd == NULL) {\n\t\tprintf(\"uhci_check_intr: std==0\\n\");\n\t\treturn;\n\t}\n#endif\n\t/* \n\t * If the last TD is still active we need to check whether there\n\t * is a an error somewhere in the middle, or whether there was a\n\t * short packet (SPD and not ACTIVE).\n\t */\n\tif (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {\n\t\tDPRINTFN(12, (\"uhci_check_intr: active ii=%p\\n\", ii));\n\t\tfor (std = ii->stdstart; std != lstd; std = std->link.std) {\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\t/* If there's an active TD the xfer isn't done. */\n\t\t\tif (status & UHCI_TD_ACTIVE)\n\t\t\t\tbreak;\n\t\t\t/* Any kind of error makes the xfer done. */\n\t\t\tif (status & UHCI_TD_STALLED)\n\t\t\t\tgoto done;\n\t\t\t/* We want short packets, and it is short: it's done */\n\t\t\tif ((status & UHCI_TD_SPD) &&\n\t\t\t      UHCI_TD_GET_ACTLEN(status) < \n\t\t\t      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tDPRINTFN(12, (\"uhci_check_intr: ii=%p std=%p still active\\n\",\n\t\t\t      ii, ii->stdstart));\n\t\treturn;\n\t}\n done:\n\tDPRINTFN(12, (\"uhci_check_intr: ii=%p done\\n\", ii));\n\tusb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);\n\tuhci_idone(ii);\n}"
  },
  {
    "function_name": "uhci_softintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1092-1118",
    "snippet": "void\nuhci_softintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)bus;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"%s: uhci_softintr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\tsc->sc_bus.intr_context++;\n\n\t/*\n\t * Interrupts on UHCI really suck.  When the host controller\n\t * interrupts because a transfer is completed there is no\n\t * way of knowing which transfer it was.  You can scan down\n\t * the TDs and QHs of the previous frame to limit the search,\n\t * but that assumes that the interrupt was not delayed by more\n\t * than 1 ms, which may not always be true (e.g. after debug\n\t * output on a slow console).\n\t * We scan all interrupt descriptors to see if any have\n\t * completed.\n\t */\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_check_intr(sc, ii);\n\n\tsc->sc_bus.intr_context--;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_allocx __P((struct usbd_bus *));",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_check_intr",
          "args": [
            "sc",
            "ii"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_check_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1121-1174",
          "snippet": "void\nuhci_check_intr(sc, ii)\n\tuhci_softc_t *sc;\n\tuhci_intr_info_t *ii;\n{\n\tuhci_soft_td_t *std, *lstd;\n\tu_int32_t status;\n\n\tDPRINTFN(15, (\"uhci_check_intr: ii=%p\\n\", ii));\n#ifdef DIAGNOSTIC\n\tif (ii == NULL) {\n\t\tprintf(\"uhci_check_intr: no ii? %p\\n\", ii);\n\t\treturn;\n\t}\n#endif\n\tif (ii->stdstart == NULL)\n\t\treturn;\n\tlstd = ii->stdend;\n#ifdef DIAGNOSTIC\n\tif (lstd == NULL) {\n\t\tprintf(\"uhci_check_intr: std==0\\n\");\n\t\treturn;\n\t}\n#endif\n\t/* \n\t * If the last TD is still active we need to check whether there\n\t * is a an error somewhere in the middle, or whether there was a\n\t * short packet (SPD and not ACTIVE).\n\t */\n\tif (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {\n\t\tDPRINTFN(12, (\"uhci_check_intr: active ii=%p\\n\", ii));\n\t\tfor (std = ii->stdstart; std != lstd; std = std->link.std) {\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\t/* If there's an active TD the xfer isn't done. */\n\t\t\tif (status & UHCI_TD_ACTIVE)\n\t\t\t\tbreak;\n\t\t\t/* Any kind of error makes the xfer done. */\n\t\t\tif (status & UHCI_TD_STALLED)\n\t\t\t\tgoto done;\n\t\t\t/* We want short packets, and it is short: it's done */\n\t\t\tif ((status & UHCI_TD_SPD) &&\n\t\t\t      UHCI_TD_GET_ACTLEN(status) < \n\t\t\t      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tDPRINTFN(12, (\"uhci_check_intr: ii=%p std=%p still active\\n\",\n\t\t\t      ii, ii->stdstart));\n\t\treturn;\n\t}\n done:\n\tDPRINTFN(12, (\"uhci_check_intr: ii=%p done\\n\", ii));\n\tusb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);\n\tuhci_idone(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_check_intr(sc, ii)\n\tuhci_softc_t *sc;\n\tuhci_intr_info_t *ii;\n{\n\tuhci_soft_td_t *std, *lstd;\n\tu_int32_t status;\n\n\tDPRINTFN(15, (\"uhci_check_intr: ii=%p\\n\", ii));\n#ifdef DIAGNOSTIC\n\tif (ii == NULL) {\n\t\tprintf(\"uhci_check_intr: no ii? %p\\n\", ii);\n\t\treturn;\n\t}\n#endif\n\tif (ii->stdstart == NULL)\n\t\treturn;\n\tlstd = ii->stdend;\n#ifdef DIAGNOSTIC\n\tif (lstd == NULL) {\n\t\tprintf(\"uhci_check_intr: std==0\\n\");\n\t\treturn;\n\t}\n#endif\n\t/* \n\t * If the last TD is still active we need to check whether there\n\t * is a an error somewhere in the middle, or whether there was a\n\t * short packet (SPD and not ACTIVE).\n\t */\n\tif (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {\n\t\tDPRINTFN(12, (\"uhci_check_intr: active ii=%p\\n\", ii));\n\t\tfor (std = ii->stdstart; std != lstd; std = std->link.std) {\n\t\t\tstatus = le32toh(std->td.td_status);\n\t\t\t/* If there's an active TD the xfer isn't done. */\n\t\t\tif (status & UHCI_TD_ACTIVE)\n\t\t\t\tbreak;\n\t\t\t/* Any kind of error makes the xfer done. */\n\t\t\tif (status & UHCI_TD_STALLED)\n\t\t\t\tgoto done;\n\t\t\t/* We want short packets, and it is short: it's done */\n\t\t\tif ((status & UHCI_TD_SPD) &&\n\t\t\t      UHCI_TD_GET_ACTLEN(status) < \n\t\t\t      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tDPRINTFN(12, (\"uhci_check_intr: ii=%p std=%p still active\\n\",\n\t\t\t      ii, ii->stdstart));\n\t\treturn;\n\t}\n done:\n\tDPRINTFN(12, (\"uhci_check_intr: ii=%p done\\n\", ii));\n\tusb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);\n\tuhci_idone(ii);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "ii",
            "list"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_intrhead"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: uhci_softintr\\n\", USBDEVNAME(sc->sc_bus.bdev))"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_allocx __P((struct usbd_bus *));\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_softintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tuhci_softc_t *sc = (uhci_softc_t *)bus;\n\tuhci_intr_info_t *ii;\n\n\tDPRINTFN(10,(\"%s: uhci_softintr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\tsc->sc_bus.intr_context++;\n\n\t/*\n\t * Interrupts on UHCI really suck.  When the host controller\n\t * interrupts because a transfer is completed there is no\n\t * way of knowing which transfer it was.  You can scan down\n\t * the TDs and QHs of the previous frame to limit the search,\n\t * but that assumes that the interrupt was not delayed by more\n\t * than 1 ms, which may not always be true (e.g. after debug\n\t * output on a slow console).\n\t * We scan all interrupt descriptors to see if any have\n\t * completed.\n\t */\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_check_intr(sc, ii);\n\n\tsc->sc_bus.intr_context--;\n}"
  },
  {
    "function_name": "uhci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1026-1090",
    "snippet": "int\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev))"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_schedsoftintr",
          "args": [
            "&sc->sc_bus"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "usb_schedsoftintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "702-707",
          "snippet": "void\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\n\nvoid\nusb_schedsoftintr(bus)\n\tstruct usbd_bus *bus;\n{\n\tbus->methods->soft_intr(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_STS",
            "ack"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_all",
          "args": [
            "sc"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "784-792",
          "snippet": "void\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: host controller halted\\n\"",
            "USBDEVNAME(sc->sc_bus.bdev)"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "722-737",
          "snippet": "Static void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "uhci_busreset __P((uhci_softc_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nuhci_busreset __P((uhci_softc_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nStatic void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev))"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_intr(arg)\n\tvoid *arg;\n{\n\tuhci_softc_t *sc = arg;\n\tint status;\n\tint ack;\n\n#ifdef UHCI_DEBUG\n\tif (uhcidebug > 15) {\n\t\tDPRINTF((\"%s: uhci_intr\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\t\tuhci_dumpregs(sc);\n\t}\n#endif\n\n\tstatus = UREAD2(sc, UHCI_STS);\n\tif (status == 0)\t/* The interrupt was not for us. */\n\t\treturn (0);\n\n#if defined(DIAGNOSTIC) && defined(__NetBSD__)\n\tif (sc->sc_suspend != PWR_RESUME)\n\t\tprintf(\"uhci_intr: suspended sts=0x%x\\n\", status);\n#endif\n\n\tack = 0;\n\tif (status & UHCI_STS_USBINT)\n\t\tack |= UHCI_STS_USBINT;\n\tif (status & UHCI_STS_USBEI)\n\t\tack |= UHCI_STS_USBEI;\n\tif (status & UHCI_STS_RD) {\n\t\tack |= UHCI_STS_RD;\n\t\tprintf(\"%s: resume detect\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HSE) {\n\t\tack |= UHCI_STS_HSE;\n\t\tprintf(\"%s: host system error\\n\", USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCPE) {\n\t\tack |= UHCI_STS_HCPE;\n\t\tprintf(\"%s: host controller process error\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t}\n\tif (status & UHCI_STS_HCH) {\n\t\t/* no acknowledge needed */\n\t\tprintf(\"%s: host controller halted\\n\", \n\t\t       USBDEVNAME(sc->sc_bus.bdev));\n\t\tsc->sc_dying = 1;\n#ifdef UHCI_DEBUG\n\t\tuhci_dump_all(sc);\n#endif\n\n\t}\n\n\tif (ack)\t/* acknowledge the ints */\n\t\tUWRITE2(sc, UHCI_STS, ack);\n\telse\t/* nothing to acknowledge */\n\t\treturn (0);\n\n\tsc->sc_bus.no_intrs++;\n\tusb_schedsoftintr(&sc->sc_bus);\n\n\tDPRINTFN(10, (\"%s: uhci_intr: exit\\n\", USBDEVNAME(sc->sc_bus.bdev)));\n\n\treturn (1);\n}"
  },
  {
    "function_name": "uhci_remove_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "1009-1024",
    "snippet": "void\nuhci_remove_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_bulk: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_bulk_end == sqh)\n\t\tsc->sc_bulk_end = pqh;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_find_prev_qh",
          "args": [
            "sc->sc_bulk_start",
            "sqh"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_find_prev_qh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "350-365",
          "snippet": "Static __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static uhci_soft_qh_t",
            "Static void",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static void",
            "Static void",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic uhci_soft_qh_t;\nStatic void;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic void;\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic void;\nStatic void;\nStatic __inline__ uhci_soft_qh_t;\n\nStatic __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_remove_bulk: sqh=%p\\n\", sqh)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_bulk: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_bulk_end == sqh)\n\t\tsc->sc_bulk_end = pqh;\n}"
  },
  {
    "function_name": "uhci_add_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "990-1006",
    "snippet": "void\nuhci_add_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_bulk: sqh=%p\\n\", sqh));\n\teqh = sc->sc_bulk_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_bulk_end = sqh;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_add_bulk: sqh=%p\\n\", sqh)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_bulk(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_bulk: sqh=%p\\n\", sqh));\n\teqh = sc->sc_bulk_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_bulk_end = sqh;\n}"
  },
  {
    "function_name": "uhci_remove_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "972-987",
    "snippet": "void\nuhci_remove_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_ctrl: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_ctl_end == sqh)\n\t\tsc->sc_ctl_end = pqh;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_find_prev_qh",
          "args": [
            "sc->sc_ctl_start",
            "sqh"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_find_prev_qh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "350-365",
          "snippet": "Static __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static uhci_soft_qh_t",
            "Static void",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "Static void",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static void",
            "Static void",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic uhci_soft_qh_t;\nStatic void;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic void;\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic void;\nStatic void;\nStatic __inline__ uhci_soft_qh_t;\n\nStatic __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_remove_ctrl: sqh=%p\\n\", sqh)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_remove_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *pqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_remove_ctrl: sqh=%p\\n\", sqh));\n\tpqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);\n\tpqh->hlink       = sqh->hlink;\n\tpqh->qh.qh_hlink = sqh->qh.qh_hlink;\n\tif (sc->sc_ctl_end == sqh)\n\t\tsc->sc_ctl_end = pqh;\n}"
  },
  {
    "function_name": "uhci_add_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "953-969",
    "snippet": "void\nuhci_add_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_ctrl: sqh=%p\\n\", sqh));\n\teqh = sc->sc_ctl_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_ctl_end = sqh;\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"uhci_add_ctrl: sqh=%p\\n\", sqh)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_add_ctrl(sc, sqh)\n\tuhci_softc_t *sc;\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_soft_qh_t *eqh;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(10, (\"uhci_add_ctrl: sqh=%p\\n\", sqh));\n\teqh = sc->sc_ctl_end;\n\tsqh->hlink       = eqh->hlink;\n\tsqh->qh.qh_hlink = eqh->qh.qh_hlink;\n\teqh->hlink       = sqh;\n\teqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);\n\tsc->sc_ctl_end = sqh;\n}"
  },
  {
    "function_name": "uhci_root_ctrl_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "946-950",
    "snippet": "void\nuhci_root_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_root_ctrl_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n}"
  },
  {
    "function_name": "uhci_root_intr_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "940-944",
    "snippet": "void\nuhci_root_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\n\nvoid\nuhci_root_intr_done(xfer)\n\tusbd_xfer_handle xfer;\n{\n}"
  },
  {
    "function_name": "uhci_poll_hub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "907-938",
    "snippet": "void\nuhci_poll_hub(addr)\n\tvoid *addr;\n{\n\tusbd_xfer_handle xfer = addr;\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tint s;\n\tu_char *p;\n\n\tDPRINTFN(20, (\"uhci_poll_hub\\n\"));\n\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tp[0] = 0;\n\tif (UREAD2(sc, UHCI_PORTSC1) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))\n\t\tp[0] |= 1<<1;\n\tif (UREAD2(sc, UHCI_PORTSC2) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))\n\t\tp[0] |= 1<<2;\n\tif (p[0] == 0)\n\t\t/* No change, try again in a while */\n\t\treturn;\n\n\txfer->actlen = 1;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\ts = splusb();\n\txfer->device->bus->intr_context++;\n\tusb_transfer_complete(xfer);\n\txfer->device->bus->intr_context--;\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_open __P((usbd_pipe_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "uhci_noop __P((usbd_pipe_handle pipe));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_transfer_complete",
          "args": [
            "xfer"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "usb_transfer_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "789-883",
          "snippet": "void\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nvoid\nusb_transfer_complete(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tint repeat = pipe->repeat;\n\tint polling;\n\n\tSPLUSBCHECK;\n\n\tDPRINTFN(5, (\"usb_transfer_complete: pipe=%p xfer=%p status=%d \"\n\t\t     \"actlen=%d\\n\", pipe, xfer, xfer->status, xfer->actlen));\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_transfer_cb: pipe==0, xfer=%p\\n\", xfer);\n\t\treturn;\n\t}\n#endif\n\tpolling = pipe->device->bus->use_polling;\n\t/* XXXX */\n\tif (polling)\n\t\tpipe->running = 0;\n\n\tif (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&\n\t    usbd_xfer_isread(xfer)) {\n#ifdef DIAGNOSTIC\n\t\tif (xfer->actlen > xfer->length) {\n\t\t\tprintf(\"usb_transfer_complete: actlen > len %d > %d\\n\",\n\t\t\t       xfer->actlen, xfer->length);\n\t\t\txfer->actlen = xfer->length;\n\t\t}\n#endif\n\t\tmemcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);\n\t}\n\n\t/* if we allocated the buffer in usbd_transfer() we free it here. */\n\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\tif (!repeat) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\t\t\tbus->methods->freem(bus, dmap);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!repeat) {\n\t\t/* Remove request from queue. */\n#ifdef DIAGNOSTIC\n\t\tif (xfer != SIMPLEQ_FIRST(&pipe->queue))\n\t\t\tprintf(\"usb_transfer_complete: bad dequeue %p != %p\\n\",\n\t\t\t       xfer, SIMPLEQ_FIRST(&pipe->queue));\n#endif\n\t\tSIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);\n\t}\n\tDPRINTFN(5,(\"usb_transfer_complete: repeat=%d new head=%p\\n\", \n\t\t    repeat, SIMPLEQ_FIRST(&pipe->queue)));\n\n\t/* Count completed transfers. */\n\t++pipe->device->bus->stats.requests\n\t\t[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];\n\n\txfer->done = 1;\n\tif (!xfer->status && xfer->actlen < xfer->length &&\n\t    !(xfer->flags & USBD_SHORT_XFER_OK)) {\n\t\tDPRINTFN(-1,(\"usbd_transfer_cb: short transfer %d<%d\\n\",\n\t\t\t     xfer->actlen, xfer->length));\n\t\txfer->status = USBD_SHORT_XFER;\n\t}\n\n\tif (xfer->callback)\n\t\txfer->callback(xfer, xfer->priv, xfer->status);\n\n#ifdef DIAGNOSTIC\n\tif (pipe->methods->done != NULL)\n\t\tpipe->methods->done(xfer);\n\telse\n\t\tprintf(\"usb_transfer_complete: pipe->methods->done == NULL\\n\");\n#else\n\tpipe->methods->done(xfer);\n#endif\n\n\tif ((xfer->flags & USBD_SYNCHRONOUS) && !polling)\n\t\twakeup(xfer);\n\n\tif (!repeat) {\n\t\t/* XXX should we stop the queue on all errors? */\n\t\tif ((xfer->status == USBD_CANCELLED ||\n\t\t     xfer->status == USBD_TIMEOUT) &&\n\t\t    pipe->iface != NULL)\t\t/* not control pipe */\n\t\t\tpipe->running = 0;\n\t\telse\n\t\t\tusbd_start_next(pipe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_PORTSC2"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_PORTSC1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&xfer->dmabuf"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->sc_poll_handle",
            "sc->sc_ival",
            "uhci_poll_hub",
            "xfer"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "20",
            "(\"uhci_poll_hub\\n\")"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_close __P((usbd_pipe_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_close __P((usbd_pipe_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_close __P((usbd_pipe_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_close __P((usbd_pipe_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_open __P((usbd_pipe_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_poll_hub(addr)\n\tvoid *addr;\n{\n\tusbd_xfer_handle xfer = addr;\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tuhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;\n\tint s;\n\tu_char *p;\n\n\tDPRINTFN(20, (\"uhci_poll_hub\\n\"));\n\n\tusb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);\n\n\tp = KERNADDR(&xfer->dmabuf);\n\tp[0] = 0;\n\tif (UREAD2(sc, UHCI_PORTSC1) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))\n\t\tp[0] |= 1<<1;\n\tif (UREAD2(sc, UHCI_PORTSC2) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))\n\t\tp[0] |= 1<<2;\n\tif (p[0] == 0)\n\t\t/* No change, try again in a while */\n\t\treturn;\n\n\txfer->actlen = 1;\n\txfer->status = USBD_NORMAL_COMPLETION;\n\ts = splusb();\n\txfer->device->bus->intr_context++;\n\tusb_transfer_complete(xfer);\n\txfer->device->bus->intr_context--;\n\tsplx(s);\n}"
  },
  {
    "function_name": "iidump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "899-899",
    "snippet": "void iidump() { uhci_dump_iis(thesc); }",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_dump_iis",
          "args": [
            "thesc"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_iis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "887-896",
          "snippet": "void\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
            "uhci_idone __P((uhci_intr_info_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid iidump() { uhci_dump_iis(thesc); }"
  },
  {
    "function_name": "uhci_dump_iis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "887-896",
    "snippet": "void\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "uhci_idone __P((uhci_intr_info_t *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_dump_ii",
          "args": [
            "ii"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_iis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "887-896",
          "snippet": "void\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "ii",
            "list"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_intrhead"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"intr_info list:\\n\""
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nuhci_idone __P((uhci_intr_info_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_iis(sc)\n\tstruct uhci_softc *sc;\n{\n\tuhci_intr_info_t *ii;\n\n\tprintf(\"intr_info list:\\n\");\n\tfor (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))\n\t\tuhci_dump_ii(ii);\n}"
  },
  {
    "function_name": "uhci_dump_ii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "847-884",
    "snippet": "Static void\nuhci_dump_ii(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_pipe_handle pipe;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_device_handle dev;\n\t\n#ifdef DIAGNOSTIC\n#define DONE ii->isdone\n#else\n#define DONE 0\n#endif\n        if (ii == NULL) {\n                printf(\"ii NULL\\n\");\n                return;\n        }\n        if (ii->xfer == NULL) {\n\t\tprintf(\"ii %p: done=%d xfer=NULL\\n\",\n\t\t       ii, DONE);\n                return;\n        }\n        pipe = ii->xfer->pipe;\n        if (pipe == NULL) {\n\t\tprintf(\"ii %p: done=%d xfer=%p pipe=NULL\\n\",\n\t\t       ii, DONE, ii->xfer);\n                return;\n\t}\n        ed = pipe->endpoint->edesc;\n        dev = pipe->device;\n\tprintf(\"ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\\n\", \n\t       ii, DONE, ii->xfer, dev, \n\t       UGETW(dev->ddesc.idVendor),\n\t       UGETW(dev->ddesc.idProduct),\n\t       dev->address, pipe,\n\t       ed->bEndpointAddress, ed->bmAttributes);\n#undef DONE\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DONE 0",
      "#define DONE ii->isdone"
    ],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "uhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));",
      "Static void",
      "uhci_idone __P((uhci_intr_info_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "uhci_device_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_device_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_device_bulk_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_device_isoc_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_root_ctrl_close __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_root_intr_close __P((usbd_pipe_handle));",
      "Static void",
      "uhci_open __P((usbd_pipe_handle));",
      "Static void",
      "Static void",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "Static void",
      "Static void",
      "Static void",
      "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
      "Static void",
      "uhci_noop __P((usbd_pipe_handle pipe));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\\n\"",
            "ii",
            "DONE",
            "ii->xfer",
            "dev",
            "UGETW(dev->ddesc.idVendor)",
            "UGETW(dev->ddesc.idProduct)",
            "dev->address",
            "pipe",
            "ed->bEndpointAddress",
            "ed->bmAttributes"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.idProduct"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "dev->ddesc.idVendor"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DONE 0\n#define DONE ii->isdone\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_check_intr __P((uhci_softc_t *,\n\t\t\t    uhci_intr_info_t *));\nStatic void;\nuhci_idone __P((uhci_intr_info_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_device_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nuhci_device_intr_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nuhci_device_bulk_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nuhci_device_isoc_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nuhci_root_ctrl_close __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nStatic void;\nuhci_root_intr_close __P((usbd_pipe_handle));\nStatic void;\nuhci_open __P((usbd_pipe_handle));\nStatic void;\nStatic void;\nuhci_device_request __P((usbd_xfer_handle xfer));\nStatic void;\nStatic void;\nStatic void;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nStatic void;\nuhci_noop __P((usbd_pipe_handle pipe));\n\nStatic void\nuhci_dump_ii(ii)\n\tuhci_intr_info_t *ii;\n{\n\tusbd_pipe_handle pipe;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_device_handle dev;\n\t\n#ifdef DIAGNOSTIC\n#define DONE ii->isdone\n#else\n#define DONE 0\n#endif\n        if (ii == NULL) {\n                printf(\"ii NULL\\n\");\n                return;\n        }\n        if (ii->xfer == NULL) {\n\t\tprintf(\"ii %p: done=%d xfer=NULL\\n\",\n\t\t       ii, DONE);\n                return;\n        }\n        pipe = ii->xfer->pipe;\n        if (pipe == NULL) {\n\t\tprintf(\"ii %p: done=%d xfer=%p pipe=NULL\\n\",\n\t\t       ii, DONE, ii->xfer);\n                return;\n\t}\n        ed = pipe->endpoint->edesc;\n        dev = pipe->device;\n\tprintf(\"ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\\n\", \n\t       ii, DONE, ii->xfer, dev, \n\t       UGETW(dev->ddesc.idVendor),\n\t       UGETW(dev->ddesc.idProduct),\n\t       dev->address, pipe,\n\t       ed->bEndpointAddress, ed->bmAttributes);\n#undef DONE\n}"
  },
  {
    "function_name": "uhci_dump_tds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "827-845",
    "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "td->td.td_link"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "td->td.td_link"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_td",
          "args": [
            "td"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "uhci_dump_qhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "795-825",
    "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"No TD\\n\")"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_tds",
          "args": [
            "sqh->elink"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_tds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "827-845",
          "snippet": "void\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\n\nvoid\nuhci_dump_tds(std)\n\tuhci_soft_td_t *std;\n{\n\tuhci_soft_td_t *td;\n\n\tfor(td = std; td != NULL; td = td->link.std) {\n\t\tuhci_dump_td(td);\n\n\t\t/* Check whether the link pointer in this TD marks\n\t\t * the link pointer as end of queue. This avoids\n\t\t * printing the free list in case the queue/TD has\n\t\t * already been moved there (seatbelt).\n\t\t */\n\t\tif (le32toh(td->td.td_link) & UHCI_PTR_T ||\n\t\t    le32toh(td->td.td_link) == 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sqh->qh.qh_elink"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"No QH\\n\")"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dump_qhs",
          "args": [
            "sqh->hlink"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_qhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "795-825",
          "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sqh->qh.qh_hlink"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}"
  },
  {
    "function_name": "uhci_dump_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "784-792",
    "snippet": "void\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_dump_qh",
          "args": [
            "sc->sc_ctl_start"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_qhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "795-825",
          "snippet": "void\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static __inline__ uhci_soft_qh_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qhs(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tuhci_dump_qh(sqh);\n\n\t/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards\n\t * Traverses sideways first, then down.\n\t *\n\t * QH1\n\t * QH2\n\t * No QH\n\t * TD2.1\n\t * TD2.2\n\t * TD1.1\n\t * etc.\n\t *\n\t * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.\n\t */\n\n\n\tif (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))\n\t\tuhci_dump_qhs(sqh->hlink);\n\telse\n\t\tDPRINTF((\"No QH\\n\"));\n\n\tif (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))\n\t\tuhci_dump_tds(sqh->elink);\n\telse\n\t\tDPRINTF((\"No TD\\n\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"intrs=%d\\n\"",
            "sc->sc_bus.no_intrs"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "722-737",
          "snippet": "Static void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "uhci_busreset __P((uhci_softc_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nuhci_busreset __P((uhci_softc_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nStatic void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}"
  },
  {
    "function_name": "uhci_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "777-781",
    "snippet": "void\nuhci_dump()\n{\n\tuhci_dump_all(thesc);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_dump_all",
          "args": [
            "thesc"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dump_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "784-792",
          "snippet": "void\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_dump_all(sc)\n\tuhci_softc_t *sc;\n{\n\tuhci_dumpregs(sc);\n\tprintf(\"intrs=%d\\n\", sc->sc_bus.no_intrs);\n\t/*printf(\"framelist[i].link = %08x\\n\", sc->sc_framelist[0].link);*/\n\tuhci_dump_qh(sc->sc_ctl_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nuhci_dump()\n{\n\tuhci_dump_all(thesc);\n}"
  },
  {
    "function_name": "uhci_dump_qh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "766-773",
    "snippet": "void\nuhci_dump_qh(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tDPRINTFN(-1,(\"QH(%p) at %08x: hlink=%08x elink=%08x\\n\", sqh,\n\t    (int)sqh->physaddr, le32toh(sqh->qh.qh_hlink),\n\t    le32toh(sqh->qh.qh_elink)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static __inline__ uhci_soft_qh_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"QH(%p) at %08x: hlink=%08x elink=%08x\\n\", sqh,\n\t    (int)sqh->physaddr, le32toh(sqh->qh.qh_hlink),\n\t    le32toh(sqh->qh.qh_elink))"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sqh->qh.qh_elink"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "sqh->qh.qh_hlink"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic __inline__ uhci_soft_qh_t;\n\nvoid\nuhci_dump_qh(sqh)\n\tuhci_soft_qh_t *sqh;\n{\n\tDPRINTFN(-1,(\"QH(%p) at %08x: hlink=%08x elink=%08x\\n\", sqh,\n\t    (int)sqh->physaddr, le32toh(sqh->qh.qh_hlink),\n\t    le32toh(sqh->qh.qh_elink)));\n}"
  },
  {
    "function_name": "uhci_dump_td",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "739-764",
    "snippet": "void\nuhci_dump_td(p)\n\tuhci_soft_td_t *p;\n{\n\tDPRINTFN(-1,(\"TD(%p) at %08lx = link=0x%08lx status=0x%08lx \"\n\t\t     \"token=0x%08lx buffer=0x%08lx\\n\",\n\t\t     p, (long)p->physaddr,\n\t\t     (long)le32toh(p->td.td_link),\n\t\t     (long)le32toh(p->td.td_status),\n\t\t     (long)le32toh(p->td.td_token),\n\t\t     (long)le32toh(p->td.td_buffer)));\n\tDPRINTFN(-1,(\"  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,\"\n\t\t     \"D=%d,maxlen=%d\\n\",\n\t\t     (int)le32toh(p->td.td_link),\n\t\t     \"\\20\\1T\\2Q\\3VF\",\n\t\t     (int)le32toh(p->td.td_status),\n\t\t     \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t     \"STALLED\\30ACTIVE\\31IOC\\32ISO\\33LS\\36SPD\",\n\t\t     UHCI_TD_GET_ERRCNT(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_ACTLEN(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_PID(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DEVADDR(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_ENDPT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_MAXLEN(le32toh(p->td.td_token))));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,\"\n\t\t     \"D=%d,maxlen=%d\\n\",\n\t\t     (int)le32toh(p->td.td_link),\n\t\t     \"\\20\\1T\\2Q\\3VF\",\n\t\t     (int)le32toh(p->td.td_status),\n\t\t     \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t     \"STALLED\\30ACTIVE\\31IOC\\32ISO\\33LS\\36SPD\",\n\t\t     UHCI_TD_GET_ERRCNT(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_ACTLEN(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_PID(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DEVADDR(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_ENDPT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_MAXLEN(le32toh(p->td.td_token)))"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_MAXLEN",
          "args": [
            "le32toh(p->td.td_token)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_DT",
          "args": [
            "le32toh(p->td.td_token)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ENDPT",
          "args": [
            "le32toh(p->td.td_token)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_DEVADDR",
          "args": [
            "le32toh(p->td.td_token)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_PID",
          "args": [
            "le32toh(p->td.td_token)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ACTLEN",
          "args": [
            "le32toh(p->td.td_status)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_status"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCI_TD_GET_ERRCNT",
          "args": [
            "le32toh(p->td.td_status)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_status"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_status"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_link"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"TD(%p) at %08lx = link=0x%08lx status=0x%08lx \"\n\t\t     \"token=0x%08lx buffer=0x%08lx\\n\",\n\t\t     p, (long)p->physaddr,\n\t\t     (long)le32toh(p->td.td_link),\n\t\t     (long)le32toh(p->td.td_status),\n\t\t     (long)le32toh(p->td.td_token),\n\t\t     (long)le32toh(p->td.td_buffer))"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_buffer"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_token"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_status"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "p->td.td_link"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\n\nvoid\nuhci_dump_td(p)\n\tuhci_soft_td_t *p;\n{\n\tDPRINTFN(-1,(\"TD(%p) at %08lx = link=0x%08lx status=0x%08lx \"\n\t\t     \"token=0x%08lx buffer=0x%08lx\\n\",\n\t\t     p, (long)p->physaddr,\n\t\t     (long)le32toh(p->td.td_link),\n\t\t     (long)le32toh(p->td.td_status),\n\t\t     (long)le32toh(p->td.td_token),\n\t\t     (long)le32toh(p->td.td_buffer)));\n\tDPRINTFN(-1,(\"  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,\"\n\t\t     \"D=%d,maxlen=%d\\n\",\n\t\t     (int)le32toh(p->td.td_link),\n\t\t     \"\\20\\1T\\2Q\\3VF\",\n\t\t     (int)le32toh(p->td.td_status),\n\t\t     \"\\20\\22BITSTUFF\\23CRCTO\\24NAK\\25BABBLE\\26DBUFFER\\27\"\n\t\t     \"STALLED\\30ACTIVE\\31IOC\\32ISO\\33LS\\36SPD\",\n\t\t     UHCI_TD_GET_ERRCNT(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_ACTLEN(le32toh(p->td.td_status)),\n\t\t     UHCI_TD_GET_PID(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DEVADDR(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_ENDPT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_DT(le32toh(p->td.td_token)),\n\t\t     UHCI_TD_GET_MAXLEN(le32toh(p->td.td_token))));\n}"
  },
  {
    "function_name": "uhci_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "722-737",
    "snippet": "Static void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "uhci_busreset __P((uhci_softc_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "-1",
            "(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2))"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_PORTSC2"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_PORTSC1"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD1",
          "args": [
            "sc",
            "UHCI_SOF"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD4",
          "args": [
            "sc",
            "UHCI_FLBASEADDR"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_FRNUM"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_INTR"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_STS"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_bus.bdev"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nuhci_busreset __P((uhci_softc_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nStatic void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}"
  },
  {
    "function_name": "uhci_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "652-719",
    "snippet": "void\nuhci_power(why, v)\n\tint why;\n\tvoid *v;\n{\n\tuhci_softc_t *sc = v;\n\tint cmd;\n\tint s;\n\n\ts = splusb();\n\tcmd = UREAD2(sc, UHCI_CMD);\n\n\tDPRINTF((\"uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\\n\", \n\t\t sc, why, sc->sc_suspend, cmd));\n\n\tif (why != PWR_RESUME) {\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 2)\n\t\t\tuhci_dumpregs(sc);\n#endif\n\t\tif (sc->sc_intr_xfer != NULL)\n\t\t\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub,\n\t\t\t    sc->sc_intr_xfer);\n\t\tsc->sc_bus.use_polling++;\n\t\tuhci_run(sc, 0); /* stop the controller */\n\n\t\t/* save some state if BIOS doesn't */\n\t\tsc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);\n\t\tsc->sc_saved_sof = UREAD1(sc, UHCI_SOF);\n\n\t\tUHCICMD(sc, cmd | UHCI_CMD_EGSM); /* enter global suspend */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);\n\t\tsc->sc_suspend = why;\n\t\tsc->sc_bus.use_polling--;\n\t\tDPRINTF((\"uhci_power: cmd=0x%x\\n\", UREAD2(sc, UHCI_CMD)));\n\t} else {\n#ifdef DIAGNOSTIC\n\t\tif (sc->sc_suspend == PWR_RESUME)\n\t\t\tprintf(\"uhci_power: weird, resume without suspend.\\n\");\n#endif\n\t\tsc->sc_bus.use_polling++;\n\t\tsc->sc_suspend = why;\n\t\tif (cmd & UHCI_CMD_RS)\n\t\t\tuhci_run(sc, 0); /* in case BIOS has started it */\n\n\t\t/* restore saved state */\n\t\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma));\n\t\tUWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);\n\t\tUWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);\n\n\t\tUHCICMD(sc, cmd | UHCI_CMD_FGR); /* force global resume */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\tUHCICMD(sc, cmd & ~UHCI_CMD_EGSM); /* back to normal */\n\t\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE); /* re-enable intrs */\n\t\tuhci_run(sc, 1); /* and start traffic again */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);\n\t\tsc->sc_bus.use_polling--;\n\t\tif (sc->sc_intr_xfer != NULL)\n\t\t\tusb_callout(sc->sc_poll_handle, sc->sc_ival,\n\t\t\t\t    uhci_poll_hub, sc->sc_intr_xfer);\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 2)\n\t\t\tuhci_dumpregs(sc);\n#endif\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_shutdown __P((void *v));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "722-737",
          "snippet": "Static void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "uhci_busreset __P((uhci_softc_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nuhci_busreset __P((uhci_softc_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nStatic void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->sc_poll_handle",
            "sc->sc_ival",
            "uhci_poll_hub",
            "sc->sc_intr_xfer"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "USB_RESUME_RECOVERY"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_run",
          "args": [
            "sc",
            "1"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1376-1408",
          "snippet": "usbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "uhci_run __P((uhci_softc_t *, int run));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nuhci_run __P((uhci_softc_t *, int run));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_INTR",
            "UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "cmd & ~UHCI_CMD_EGSM"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "cmd | UHCI_CMD_FGR"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE1",
          "args": [
            "sc",
            "UHCI_SOF",
            "sc->sc_saved_sof"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_FRNUM",
            "sc->sc_saved_frnum"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE4",
          "args": [
            "sc",
            "UHCI_FLBASEADDR",
            "DMAADDR(&sc->sc_dma)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&sc->sc_dma"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_power: weird, resume without suspend.\\n\""
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_power: cmd=0x%x\\n\", UREAD2(sc, UHCI_CMD))"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "cmd | UHCI_CMD_EGSM"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD1",
          "args": [
            "sc",
            "UHCI_SOF"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_FRNUM"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "sc->sc_poll_handle",
            "uhci_poll_hub",
            "sc->sc_intr_xfer"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\\n\", \n\t\t sc, why, sc->sc_suspend, cmd)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UREAD2",
          "args": [
            "sc",
            "UHCI_CMD"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_shutdown __P((void *v));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_power(why, v)\n\tint why;\n\tvoid *v;\n{\n\tuhci_softc_t *sc = v;\n\tint cmd;\n\tint s;\n\n\ts = splusb();\n\tcmd = UREAD2(sc, UHCI_CMD);\n\n\tDPRINTF((\"uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\\n\", \n\t\t sc, why, sc->sc_suspend, cmd));\n\n\tif (why != PWR_RESUME) {\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 2)\n\t\t\tuhci_dumpregs(sc);\n#endif\n\t\tif (sc->sc_intr_xfer != NULL)\n\t\t\tusb_uncallout(sc->sc_poll_handle, uhci_poll_hub,\n\t\t\t    sc->sc_intr_xfer);\n\t\tsc->sc_bus.use_polling++;\n\t\tuhci_run(sc, 0); /* stop the controller */\n\n\t\t/* save some state if BIOS doesn't */\n\t\tsc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);\n\t\tsc->sc_saved_sof = UREAD1(sc, UHCI_SOF);\n\n\t\tUHCICMD(sc, cmd | UHCI_CMD_EGSM); /* enter global suspend */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);\n\t\tsc->sc_suspend = why;\n\t\tsc->sc_bus.use_polling--;\n\t\tDPRINTF((\"uhci_power: cmd=0x%x\\n\", UREAD2(sc, UHCI_CMD)));\n\t} else {\n#ifdef DIAGNOSTIC\n\t\tif (sc->sc_suspend == PWR_RESUME)\n\t\t\tprintf(\"uhci_power: weird, resume without suspend.\\n\");\n#endif\n\t\tsc->sc_bus.use_polling++;\n\t\tsc->sc_suspend = why;\n\t\tif (cmd & UHCI_CMD_RS)\n\t\t\tuhci_run(sc, 0); /* in case BIOS has started it */\n\n\t\t/* restore saved state */\n\t\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma));\n\t\tUWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);\n\t\tUWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);\n\n\t\tUHCICMD(sc, cmd | UHCI_CMD_FGR); /* force global resume */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);\n\t\tUHCICMD(sc, cmd & ~UHCI_CMD_EGSM); /* back to normal */\n\t\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE); /* re-enable intrs */\n\t\tuhci_run(sc, 1); /* and start traffic again */\n\t\tusb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);\n\t\tsc->sc_bus.use_polling--;\n\t\tif (sc->sc_intr_xfer != NULL)\n\t\t\tusb_callout(sc->sc_poll_handle, sc->sc_ival,\n\t\t\t\t    uhci_poll_hub, sc->sc_intr_xfer);\n#ifdef UHCI_DEBUG\n\t\tif (uhcidebug > 2)\n\t\t\tuhci_dumpregs(sc);\n#endif\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "uhci_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "635-643",
    "snippet": "void\nuhci_shutdown(v)\n\tvoid *v;\n{\n\tuhci_softc_t *sc = v;\n\n\tDPRINTF((\"uhci_shutdown: stopping the HC\\n\"));\n\tuhci_run(sc, 0); /* stop the controller */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_shutdown __P((void *v));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_run",
          "args": [
            "sc",
            "0"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1376-1408",
          "snippet": "usbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "uhci_run __P((uhci_softc_t *, int run));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nuhci_run __P((uhci_softc_t *, int run));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_shutdown: stopping the HC\\n\")"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_shutdown __P((void *v));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_shutdown(v)\n\tvoid *v;\n{\n\tuhci_softc_t *sc = v;\n\n\tDPRINTF((\"uhci_shutdown: stopping the HC\\n\"));\n\tuhci_run(sc, 0); /* stop the controller */\n}"
  },
  {
    "function_name": "uhci_freex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "610-630",
    "snippet": "void\nuhci_freex(bus, xfer)\n\tstruct usbd_bus *bus;\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\n#ifdef DIAGNOSTIC\n\tif (xfer->busy_free != XFER_BUSY) {\n\t\tprintf(\"uhci_freex: xfer=%p not busy, 0x%08x\\n\", xfer,\n\t\t       xfer->busy_free);\n\t\treturn;\n\t}\n\txfer->busy_free = XFER_FREE;\n\tif (!UXFER(xfer)->iinfo.isdone) {\n\t\tprintf(\"uhci_freex: !isdone\\n\");\n\t\treturn;\n\t}\n#endif\n\tSIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_allocx __P((struct usbd_bus *));",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_xfers",
            "xfer",
            "next"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_freex: !isdone\\n\""
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_allocx __P((struct usbd_bus *));\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_freex(bus, xfer)\n\tstruct usbd_bus *bus;\n\tusbd_xfer_handle xfer;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\n#ifdef DIAGNOSTIC\n\tif (xfer->busy_free != XFER_BUSY) {\n\t\tprintf(\"uhci_freex: xfer=%p not busy, 0x%08x\\n\", xfer,\n\t\t       xfer->busy_free);\n\t\treturn;\n\t}\n\txfer->busy_free = XFER_FREE;\n\tif (!UXFER(xfer)->iinfo.isdone) {\n\t\tprintf(\"uhci_freex: !isdone\\n\");\n\t\treturn;\n\t}\n#endif\n\tSIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);\n}"
  },
  {
    "function_name": "uhci_allocx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "578-608",
    "snippet": "usbd_xfer_handle\nuhci_allocx(bus)\n\tstruct usbd_bus *bus;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\tusbd_xfer_handle xfer;\n\n\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\tif (xfer != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n#ifdef DIAGNOSTIC\n\t\tif (xfer->busy_free != XFER_FREE) {\n\t\t\tprintf(\"uhci_allocx: xfer=%p not free, 0x%08x\\n\", xfer,\n\t\t\t       xfer->busy_free);\n\t\t}\n#endif\n\t} else {\n\t\txfer = malloc(sizeof(struct uhci_xfer), M_USB, M_NOWAIT);\n\t}\n\tif (xfer != NULL) {\n\t\tmemset(xfer, 0, sizeof (struct uhci_xfer));\n\t\tUXFER(xfer)->iinfo.sc = sc;\n#ifdef DIAGNOSTIC\n\t\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\t}\n#ifdef DIAGNOSTIC\n\txfer->busy_free = XFER_BUSY;\n#endif\n\treturn (xfer);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_allocx __P((struct usbd_bus *));",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UXFER",
          "args": [
            "xfer"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xfer",
            "0",
            "sizeof (struct uhci_xfer)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct uhci_xfer)",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_allocx: xfer=%p not free, 0x%08x\\n\"",
            "xfer",
            "xfer->busy_free"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_free_xfers",
            "xfer",
            "next"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->sc_free_xfers"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_allocx __P((struct usbd_bus *));\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_xfer_handle\nuhci_allocx(bus)\n\tstruct usbd_bus *bus;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\tusbd_xfer_handle xfer;\n\n\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\tif (xfer != NULL) {\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n#ifdef DIAGNOSTIC\n\t\tif (xfer->busy_free != XFER_FREE) {\n\t\t\tprintf(\"uhci_allocx: xfer=%p not free, 0x%08x\\n\", xfer,\n\t\t\t       xfer->busy_free);\n\t\t}\n#endif\n\t} else {\n\t\txfer = malloc(sizeof(struct uhci_xfer), M_USB, M_NOWAIT);\n\t}\n\tif (xfer != NULL) {\n\t\tmemset(xfer, 0, sizeof (struct uhci_xfer));\n\t\tUXFER(xfer)->iinfo.sc = sc;\n#ifdef DIAGNOSTIC\n\t\tUXFER(xfer)->iinfo.isdone = 1;\n#endif\n\t}\n#ifdef DIAGNOSTIC\n\txfer->busy_free = XFER_BUSY;\n#endif\n\treturn (xfer);\n}"
  },
  {
    "function_name": "uhci_freem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "570-576",
    "snippet": "void\nuhci_freem(bus, dma)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n{\n\tusb_freemem(&((struct uhci_softc *)bus)->sc_bus, dma);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "uhci_allocx __P((struct usbd_bus *));",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_freemem",
          "args": [
            "&((struct uhci_softc *)bus)->sc_bus",
            "dma"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "usb_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "271-291",
          "snippet": "void\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nvoid\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nuhci_allocx __P((struct usbd_bus *));\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\n\nvoid\nuhci_freem(bus, dma)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n{\n\tusb_freemem(&((struct uhci_softc *)bus)->sc_bus, dma);\n}"
  },
  {
    "function_name": "uhci_allocm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "536-568",
    "snippet": "usbd_status\nuhci_allocm(bus, dma, size)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n\tu_int32_t size;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\tu_int32_t n;\n\n\t/* \n\t * XXX\n\t * Since we are allocating a buffer we can assume that we will\n\t * need TDs for it.  Since we don't want to alolocate those from\n\t * an interrupt context, we allocate them here and free them again.\n\t * This is no guarantee that we'll get the TDs next time...\n\t */\n\tn = size / 8;\n\tif (n > 16) {\n\t\tu_int32_t i;\n\t\tuhci_soft_td_t **stds;\n\t\tDPRINTF((\"uhci_allocm: get %d TDs\\n\", n));\n\t\tstds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP, M_NOWAIT);\n\t\tmemset(stds, 0, sizeof(uhci_soft_td_t *) * n);\n\t\tfor(i=0; i < n; i++)\n\t\t\tstds[i] = uhci_alloc_std(sc);\n\t\tfor(i=0; i < n; i++)\n\t\t\tif (stds[i] != NULL)\n\t\t\t\tuhci_free_std(sc, stds[i]);\n\t\tfree(stds, M_TEMP);\n\t}\n\n\treturn (usb_allocmem(&sc->sc_bus, size, 0, dma));\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
      "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
      "uhci_allocx __P((struct usbd_bus *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_poll __P((struct usbd_bus *));",
      "uhci_softintr __P((struct usbd_bus *));",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "size",
            "0",
            "dma"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "stds",
            "M_TEMP"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stds",
            "0",
            "sizeof(uhci_soft_td_t *) * n"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(uhci_soft_td_t *) * n",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uhci_allocm: get %d TDs\\n\", n)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nStatic usbd_status;\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nuhci_allocx __P((struct usbd_bus *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_poll __P((struct usbd_bus *));\nuhci_softintr __P((struct usbd_bus *));\nStatic usbd_status;\nStatic usbd_status;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_allocm(bus, dma, size)\n\tstruct usbd_bus *bus;\n\tusb_dma_t *dma;\n\tu_int32_t size;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)bus;\n\tu_int32_t n;\n\n\t/* \n\t * XXX\n\t * Since we are allocating a buffer we can assume that we will\n\t * need TDs for it.  Since we don't want to alolocate those from\n\t * an interrupt context, we allocate them here and free them again.\n\t * This is no guarantee that we'll get the TDs next time...\n\t */\n\tn = size / 8;\n\tif (n > 16) {\n\t\tu_int32_t i;\n\t\tuhci_soft_td_t **stds;\n\t\tDPRINTF((\"uhci_allocm: get %d TDs\\n\", n));\n\t\tstds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP, M_NOWAIT);\n\t\tmemset(stds, 0, sizeof(uhci_soft_td_t *) * n);\n\t\tfor(i=0; i < n; i++)\n\t\t\tstds[i] = uhci_alloc_std(sc);\n\t\tfor(i=0; i < n; i++)\n\t\t\tif (stds[i] != NULL)\n\t\t\t\tuhci_free_std(sc, stds[i]);\n\t\tfree(stds, M_TEMP);\n\t}\n\n\treturn (usb_allocmem(&sc->sc_bus, size, 0, dma));\n}"
  },
  {
    "function_name": "uhci_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "502-533",
    "snippet": "int\nuhci_detach(sc, flags)\n\tstruct uhci_softc *sc;\n\tint flags;\n{\n\tusbd_xfer_handle xfer;\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* Free all xfers associated with this HC. */\n\tfor (;;) {\n\t\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\t\tif (xfer == NULL)\n\t\t\tbreak;\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\t\tfree(xfer, M_USB);\n\t}\t\t\t\n\n\t/* XXX free other data structures XXX */\n\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
      "uhci_device_isoc_enter __P((usbd_xfer_handle));",
      "Static usbd_xfer_handle",
      "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
      "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_device_ctrl_start __P((usbd_xfer_handle));",
      "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_device_intr_transfer __P((usbd_xfer_handle));",
      "uhci_device_intr_start __P((usbd_xfer_handle));",
      "uhci_device_intr_abort __P((usbd_xfer_handle));",
      "uhci_device_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
      "uhci_device_bulk_start __P((usbd_xfer_handle));",
      "uhci_device_bulk_abort __P((usbd_xfer_handle));",
      "uhci_device_bulk_done  __P((usbd_xfer_handle));",
      "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
      "uhci_device_isoc_start __P((usbd_xfer_handle));",
      "uhci_device_isoc_abort __P((usbd_xfer_handle));",
      "uhci_device_isoc_done  __P((usbd_xfer_handle));",
      "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
      "uhci_root_ctrl_start __P((usbd_xfer_handle));",
      "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
      "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
      "uhci_root_intr_transfer __P((usbd_xfer_handle));",
      "uhci_root_intr_start __P((usbd_xfer_handle));",
      "uhci_root_intr_abort __P((usbd_xfer_handle));",
      "uhci_root_intr_done  __P((usbd_xfer_handle));",
      "uhci_device_request __P((usbd_xfer_handle xfer));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xfer",
            "M_USB"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&sc->sc_free_xfers",
            "xfer",
            "next"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&sc->sc_free_xfers"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_disestablish",
          "args": [
            "sc->sc_shutdownhook"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_disestablish",
          "args": [
            "sc->sc_powerhook"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "sc->sc_child",
            "flags"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_detach(sc, flags)\n\tstruct uhci_softc *sc;\n\tint flags;\n{\n\tusbd_xfer_handle xfer;\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* Free all xfers associated with this HC. */\n\tfor (;;) {\n\t\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\t\tif (xfer == NULL)\n\t\t\tbreak;\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\t\tfree(xfer, M_USB);\n\t}\t\t\t\n\n\t/* XXX free other data structures XXX */\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "uhci_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "481-500",
    "snippet": "int\nuhci_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\trv = config_deactivate(sc->sc_child);\n\t\tbreak;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "sc->sc_child"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uhci_softc *sc = (struct uhci_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_child != NULL)\n\t\t\trv = config_deactivate(sc->sc_child);\n\t\tbreak;\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "uhci_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "376-478",
    "snippet": "usbd_status\nuhci_init(sc)\n\tuhci_softc_t *sc;\n{\n\tusbd_status err;\n\tint i, j;\n\tuhci_soft_qh_t *csqh, *bsqh, *sqh;\n\tuhci_soft_td_t *std;\n\n\tDPRINTFN(1,(\"uhci_init: start\\n\"));\n\n#ifdef UHCI_DEBUG\n\tthesc = sc;\n\n\tif (uhcidebug > 2)\n\t\tuhci_dumpregs(sc);\n#endif\n\n\tuhci_run(sc, 0);\t\t\t/* stop the controller */\n\tUWRITE2(sc, UHCI_INTR, 0);\t\t/* disable interrupts */\n\n\tuhci_busreset(sc);\n\n\t/* Allocate and initialize real frame array. */\n\terr = usb_allocmem(&sc->sc_bus, \n\t\t  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),\n\t\t  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_pframes = KERNADDR(&sc->sc_dma);\n\tUWRITE2(sc, UHCI_FRNUM, 0);\t\t/* set frame number to 0 */\n\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list*/\n\n\t/* Allocate the dummy QH where bulk traffic will be queued. */\n\tbsqh = uhci_alloc_sqh(sc);\n\tif (bsqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tbsqh->qh.qh_hlink = htole32(UHCI_PTR_T);\t/* end of QH chain */\n\tbsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_bulk_start = sc->sc_bulk_end = bsqh;\n\n\t/* Allocate the dummy QH where control traffic will be queued. */\n\tcsqh = uhci_alloc_sqh(sc);\n\tif (csqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tcsqh->hlink = bsqh;\n\tcsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_Q);\n\tcsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_ctl_start = sc->sc_ctl_end = csqh;\n\n\t/* \n\t * Make all (virtual) frame list pointers point to the interrupt\n\t * queue heads and the interrupt queue heads at the control\n\t * queue head and point the physical frame list to the virtual.\n\t */\n\tfor(i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tsqh = uhci_alloc_sqh(sc);\n\t\tif (std == NULL || sqh == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tstd->link.sqh = sqh;\n\t\tstd->td.td_link = htole32(sqh->physaddr | UHCI_PTR_Q);\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(0);\n\t\tstd->td.td_buffer = htole32(0);\n\t\tsqh->hlink = csqh;\n\t\tsqh->qh.qh_hlink = htole32(csqh->physaddr | UHCI_PTR_Q);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsc->sc_vframes[i].htd = std;\n\t\tsc->sc_vframes[i].etd = std;\n\t\tsc->sc_vframes[i].hqh = sqh;\n\t\tsc->sc_vframes[i].eqh = sqh;\n\t\tfor (j = i; \n\t\t     j < UHCI_FRAMELIST_COUNT; \n\t\t     j += UHCI_VFRAMELIST_COUNT)\n\t\t\tsc->sc_pframes[j] = htole32(std->physaddr);\n\t}\n\n\tLIST_INIT(&sc->sc_intrhead);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\tusb_callout_init(sc->sc_poll_handle);\n\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &uhci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct uhci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_suspend = PWR_RESUME;\n\tsc->sc_powerhook = powerhook_establish(uhci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);\n#endif\n\n\tDPRINTFN(1,(\"uhci_init: enabling\\n\"));\n\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE);\t/* enable interrupts */\n\n\tUHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */\n\n\treturn (uhci_run(sc, 1));\t\t/* and here we go... */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "Static usbd_status",
      "Static uhci_soft_td_t",
      "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
      "Static uhci_soft_qh_t",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
      "Static usbd_status",
      "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static usbd_status",
      "Static __inline__ uhci_soft_qh_t",
      "struct usbd_bus_methods uhci_bus_methods = {\n\tuhci_open,\n\tuhci_softintr,\n\tuhci_poll,\n\tuhci_allocm,\n\tuhci_freem,\n\tuhci_allocx,\n\tuhci_freex,\n};",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uhci_run",
          "args": [
            "sc",
            "1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1376-1408",
          "snippet": "usbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "uhci_run __P((uhci_softc_t *, int run));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nuhci_run __P((uhci_softc_t *, int run));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_run(sc, run)\n\tuhci_softc_t *sc;\n\tint run;\n{\n\tint s, n, running;\n\tu_int16_t cmd;\n\n\trun = run != 0;\n\ts = splusb();\n\tDPRINTF((\"uhci_run: setting run=%d\\n\", run));\n\tcmd = UREAD2(sc, UHCI_CMD);\n\tif (run)\n\t\tcmd |= UHCI_CMD_RS;\n\telse\n\t\tcmd &= ~UHCI_CMD_RS;\n\tUHCICMD(sc, cmd);\n\tfor(n = 0; n < 10; n++) {\n\t\trunning = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);\n\t\t/* return when we've entered the state we want */\n\t\tif (run == running) {\n\t\t\tsplx(s);\n\t\t\tDPRINTF((\"uhci_run: done cmd=0x%x sts=0x%x\\n\",\n\t\t\t\t UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t\tusb_delay_ms(&sc->sc_bus, 1);\n\t}\n\tsplx(s);\n\tprintf(\"%s: cannot %s\\n\", USBDEVNAME(sc->sc_bus.bdev),\n\t       run ? \"start\" : \"stop\");\n\treturn (USBD_IOERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "UHCI_CMD_MAXP"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_INTR",
            "UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_init: enabling\\n\")"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "uhci_shutdown",
            "sc"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "uhci_power",
            "sc"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout_init",
          "args": [
            "sc->sc_poll_handle"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&sc->sc_free_xfers"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&sc->sc_intrhead"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "std->physaddr"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "csqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_TD_IOS"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "sqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_std",
          "args": [
            "sc"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_alloc_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1518-1595",
          "snippet": "usbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));",
            "Static usbd_status",
            "uhci_setup_isoc __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "uhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));",
            "uhci_freem __P((struct usbd_bus *, usb_dma_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_device_clear_toggle __P((usbd_pipe_handle pipe));",
            "uhci_noop __P((usbd_pipe_handle pipe));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_abort_xfer __P((usbd_xfer_handle,\n\t\t\t    usbd_status status));\nStatic usbd_status;\nuhci_setup_isoc __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nuhci_allocm __P((struct usbd_bus *, usb_dma_t *,\n\t\t\t    u_int32_t));\nuhci_freem __P((struct usbd_bus *, usb_dma_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_device_clear_toggle __P((usbd_pipe_handle pipe));\nuhci_noop __P((usbd_pipe_handle pipe));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)\n\tstruct uhci_pipe *upipe;\n\tuhci_softc_t *sc;\n\tint len, rd;\n\tu_int16_t flags;\n\tusb_dma_t *dma;\n\tuhci_soft_td_t **sp, **ep;\n{\n\tuhci_soft_td_t *p, *lastp;\n\tuhci_physaddr_t lastlink;\n\tint i, ntd, l, tog, maxp;\n\tu_int32_t status;\n\tint addr = upipe->pipe.device->address;\n\tint endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;\n\n\tDPRINTFN(8, (\"uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d \"\n\t\t      \"flags=0x%x\\n\", addr, UE_GET_ADDR(endpt), len, \n\t\t      upipe->pipe.device->lowspeed, flags));\n\tmaxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);\n\tif (maxp == 0) {\n\t\tprintf(\"uhci_alloc_std_chain: maxp=0\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n\tntd = (len + maxp - 1) / maxp;\n\tif ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)\n\t\tntd++;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: maxp=%d ntd=%d\\n\", maxp, ntd));\n\tif (ntd == 0) {\n\t\t*sp = *ep = 0;\n\t\tDPRINTFN(-1,(\"uhci_alloc_std_chain: ntd=0\\n\"));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\ttog = upipe->nexttoggle;\n\tif (ntd % 2 == 0)\n\t\ttog ^= 1;\n\tupipe->nexttoggle = tog ^ 1;\n\tlastp = 0;\n\tlastlink = UHCI_PTR_T;\n\tntd--;\n\tstatus = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);\n\tif (upipe->pipe.device->lowspeed)\n\t\tstatus |= UHCI_TD_LS;\n\tif (flags & USBD_SHORT_XFER_OK)\n\t\tstatus |= UHCI_TD_SPD;\n\tfor (i = ntd; i >= 0; i--) {\n\t\tp = uhci_alloc_std(sc);\n\t\tif (p == NULL) {\n\t\t\tuhci_free_std_chain(sc, lastp, 0);\n\t\t\treturn (USBD_NOMEM);\n\t\t}\n\t\tp->link.std = lastp;\n\t\tif (lastlink == UHCI_PTR_T)\n\t\t\tp->td.td_link = htole32(lastlink);\n\t\telse\n\t\t\tp->td.td_link = htole32(lastlink|UHCI_PTR_VF);\n\t\tlastp = p;\n\t\tlastlink = p->physaddr;\n\t\tp->td.td_status = htole32(status);\n\t\tif (i == ntd) {\n\t\t\t/* last TD */\n\t\t\tl = len % maxp;\n\t\t\tif (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))\n\t\t\t\tl = maxp;\n\t\t\t*ep = p;\n\t\t} else\n\t\t\tl = maxp;\n\t\tp->td.td_token = \n\t\t    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :\n\t\t\t\t UHCI_TD_OUT(l, endpt, addr, tog));\n\t\tp->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);\n\t\ttog ^= 1;\n\t}\n\t*sp = lastp;\n\tDPRINTFN(10, (\"uhci_alloc_std_chain: nexttog=%d\\n\", \n\t\t      upipe->nexttoggle));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "bsqh->physaddr | UHCI_PTR_Q"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole32",
          "args": [
            "UHCI_PTR_T"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_alloc_sqh",
          "args": [
            "sc"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE4",
          "args": [
            "sc",
            "UHCI_FLBASEADDR",
            "DMAADDR(&sc->sc_dma)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "&sc->sc_dma"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_FRNUM",
            "0"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "&sc->sc_dma"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_allocmem",
          "args": [
            "&sc->sc_bus",
            "UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t)",
            "UHCI_FRAMELIST_ALIGN",
            "&sc->sc_dma"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "usb_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "216-269",
          "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
            "#define USB_MEM_SMALL 64"
          ],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_busreset",
          "args": [
            "sc"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_busreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "367-374",
          "snippet": "void\nuhci_busreset(sc)\n\tuhci_softc_t *sc;\n{\n\tUHCICMD(sc, UHCI_CMD_GRESET);\t/* global reset */\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY); /* wait a little */\n\tUHCICMD(sc, 0);\t\t\t/* do nothing */\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_busreset(sc)\n\tuhci_softc_t *sc;\n{\n\tUHCICMD(sc, UHCI_CMD_GRESET);\t/* global reset */\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY); /* wait a little */\n\tUHCICMD(sc, 0);\t\t\t/* do nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "UWRITE2",
          "args": [
            "sc",
            "UHCI_INTR",
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_dumpregs",
          "args": [
            "sc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "722-737",
          "snippet": "Static void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "uhci_busreset __P((uhci_softc_t *));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nuhci_busreset __P((uhci_softc_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nStatic void\nuhci_dumpregs(sc)\n\tuhci_softc_t *sc;\n{\n\tDPRINTFN(-1,(\"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, \"\n\t\t     \"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\\n\",\n\t\t     USBDEVNAME(sc->sc_bus.bdev),\n\t\t     UREAD2(sc, UHCI_CMD),\n\t\t     UREAD2(sc, UHCI_STS),\n\t\t     UREAD2(sc, UHCI_INTR),\n\t\t     UREAD2(sc, UHCI_FRNUM),\n\t\t     UREAD4(sc, UHCI_FLBASEADDR),\n\t\t     UREAD1(sc, UHCI_SOF),\n\t\t     UREAD2(sc, UHCI_PORTSC1),\n\t\t     UREAD2(sc, UHCI_PORTSC2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uhci_init: start\\n\")"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nStatic __inline__ uhci_soft_qh_t;\nstruct usbd_bus_methods uhci_bus_methods = {\n\tuhci_open,\n\tuhci_softintr,\n\tuhci_poll,\n\tuhci_allocm,\n\tuhci_freem,\n\tuhci_allocx,\n\tuhci_freex,\n};\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_init(sc)\n\tuhci_softc_t *sc;\n{\n\tusbd_status err;\n\tint i, j;\n\tuhci_soft_qh_t *csqh, *bsqh, *sqh;\n\tuhci_soft_td_t *std;\n\n\tDPRINTFN(1,(\"uhci_init: start\\n\"));\n\n#ifdef UHCI_DEBUG\n\tthesc = sc;\n\n\tif (uhcidebug > 2)\n\t\tuhci_dumpregs(sc);\n#endif\n\n\tuhci_run(sc, 0);\t\t\t/* stop the controller */\n\tUWRITE2(sc, UHCI_INTR, 0);\t\t/* disable interrupts */\n\n\tuhci_busreset(sc);\n\n\t/* Allocate and initialize real frame array. */\n\terr = usb_allocmem(&sc->sc_bus, \n\t\t  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),\n\t\t  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_pframes = KERNADDR(&sc->sc_dma);\n\tUWRITE2(sc, UHCI_FRNUM, 0);\t\t/* set frame number to 0 */\n\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list*/\n\n\t/* Allocate the dummy QH where bulk traffic will be queued. */\n\tbsqh = uhci_alloc_sqh(sc);\n\tif (bsqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tbsqh->qh.qh_hlink = htole32(UHCI_PTR_T);\t/* end of QH chain */\n\tbsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_bulk_start = sc->sc_bulk_end = bsqh;\n\n\t/* Allocate the dummy QH where control traffic will be queued. */\n\tcsqh = uhci_alloc_sqh(sc);\n\tif (csqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tcsqh->hlink = bsqh;\n\tcsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_Q);\n\tcsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_ctl_start = sc->sc_ctl_end = csqh;\n\n\t/* \n\t * Make all (virtual) frame list pointers point to the interrupt\n\t * queue heads and the interrupt queue heads at the control\n\t * queue head and point the physical frame list to the virtual.\n\t */\n\tfor(i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tsqh = uhci_alloc_sqh(sc);\n\t\tif (std == NULL || sqh == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tstd->link.sqh = sqh;\n\t\tstd->td.td_link = htole32(sqh->physaddr | UHCI_PTR_Q);\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(0);\n\t\tstd->td.td_buffer = htole32(0);\n\t\tsqh->hlink = csqh;\n\t\tsqh->qh.qh_hlink = htole32(csqh->physaddr | UHCI_PTR_Q);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsc->sc_vframes[i].htd = std;\n\t\tsc->sc_vframes[i].etd = std;\n\t\tsc->sc_vframes[i].hqh = sqh;\n\t\tsc->sc_vframes[i].eqh = sqh;\n\t\tfor (j = i; \n\t\t     j < UHCI_FRAMELIST_COUNT; \n\t\t     j += UHCI_VFRAMELIST_COUNT)\n\t\t\tsc->sc_pframes[j] = htole32(std->physaddr);\n\t}\n\n\tLIST_INIT(&sc->sc_intrhead);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\tusb_callout_init(sc->sc_poll_handle);\n\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &uhci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct uhci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_suspend = PWR_RESUME;\n\tsc->sc_powerhook = powerhook_establish(uhci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);\n#endif\n\n\tDPRINTFN(1,(\"uhci_init: enabling\\n\"));\n\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE);\t/* enable interrupts */\n\n\tUHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */\n\n\treturn (uhci_run(sc, 1));\t\t/* and here we go... */\n}"
  },
  {
    "function_name": "uhci_busreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "367-374",
    "snippet": "void\nuhci_busreset(sc)\n\tuhci_softc_t *sc;\n{\n\tUHCICMD(sc, UHCI_CMD_GRESET);\t/* global reset */\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY); /* wait a little */\n\tUHCICMD(sc, 0);\t\t\t/* do nothing */\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uhci_busreset __P((uhci_softc_t *));",
      "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
      "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_delay_ms",
          "args": [
            "&sc->sc_bus",
            "USB_BUS_RESET_DELAY"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "usb_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "301-313",
          "snippet": "void\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_getnewaddr __P((usbd_bus_handle bus));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_getnewaddr __P((usbd_bus_handle bus));\n\nvoid\nusb_delay_ms(bus, ms)\n\tusbd_bus_handle bus;\n\tu_int ms;\n{\n\textern int cold;\n\n\t/* Wait at least two clock ticks so we know the time has passed. */\n\tif (bus->use_polling || cold)\n\t\tdelay((ms+1) * 1000);\n\telse\n\t\ttsleep(&ms, PRIBIO, \"usbdly\", (ms*hz+999)/1000 + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UHCICMD",
          "args": [
            "sc",
            "UHCI_CMD_GRESET"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_busreset(sc)\n\tuhci_softc_t *sc;\n{\n\tUHCICMD(sc, UHCI_CMD_GRESET);\t/* global reset */\n\tusb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY); /* wait a little */\n\tUHCICMD(sc, 0);\t\t\t/* do nothing */\n}"
  },
  {
    "function_name": "uhci_find_prev_qh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
    "lines": "350-365",
    "snippet": "Static __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}",
    "includes": [
      "#include <machine/clock.h>",
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <machine/endian.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <machine/cpu.h>",
      "#include <machine/bus_pio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/select.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static uhci_soft_qh_t",
      "Static void",
      "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "Static void",
      "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "Static void",
      "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static void",
      "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
      "Static void",
      "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
      "Static void",
      "Static void",
      "Static __inline__ uhci_soft_qh_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uhci_find_prev_qh: QH not found\\n\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32toh",
          "args": [
            "pqh->qh.qh_hlink"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic uhci_soft_qh_t;\nStatic void;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic void;\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nStatic void;\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic void;\nStatic void;\nStatic __inline__ uhci_soft_qh_t;\n\nStatic __inline__ uhci_soft_qh_t *\nuhci_find_prev_qh(pqh, sqh)\n\tuhci_soft_qh_t *pqh, *sqh;\n{\n\tDPRINTFN(15,(\"uhci_find_prev_qh: pqh=%p sqh=%p\\n\", pqh, sqh));\n\n\tfor (; pqh->hlink != sqh; pqh = pqh->hlink) {\n#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)\t\t\n\t\tif (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {\n\t\t\tprintf(\"uhci_find_prev_qh: QH not found\\n\");\n\t\t\treturn (NULL);\n\t\t}\n#endif\n\t}\n\treturn (pqh);\n}"
  }
]