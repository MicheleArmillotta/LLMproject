[
  {
    "function_name": "DAGExecutionThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "707-798",
    "snippet": "static void \nDAGExecutionThread(RF_ThreadArg_t arg)\n{\n\tRF_DagNode_t *nd, *local_nq, *term_nq, *fire_nq;\n\tRF_Raid_t *raidPtr;\n\tint     ks;\n\tint     s;\n\n\traidPtr = (RF_Raid_t *) arg;\n\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Engine thread is running\\n\", raidPtr->raidid);\n\t}\n\t/* XXX what to put here XXX */\n\n\ts = splbio();\n\n\tRF_THREADGROUP_RUNNING(&raidPtr->engine_tg);\n\n\tDO_LOCK(raidPtr);\n\twhile (!raidPtr->shutdown_engine) {\n\n\t\twhile (raidPtr->node_queue != NULL) {\n\t\t\tlocal_nq = raidPtr->node_queue;\n\t\t\tfire_nq = NULL;\n\t\t\tterm_nq = NULL;\n\t\t\traidPtr->node_queue = NULL;\n\t\t\tDO_UNLOCK(raidPtr);\n\n\t\t\t/* first, strip out the terminal nodes */\n\t\t\twhile (local_nq) {\n\t\t\t\tnd = local_nq;\n\t\t\t\tlocal_nq = local_nq->next;\n\t\t\t\tswitch (nd->dagHdr->status) {\n\t\t\t\tcase rf_enable:\n\t\t\t\tcase rf_rollForward:\n\t\t\t\t\tif (nd->numSuccedents == 0) {\n\t\t\t\t\t\t/* end of the dag, add to\n\t\t\t\t\t\t * callback list */\n\t\t\t\t\t\tnd->next = term_nq;\n\t\t\t\t\t\tterm_nq = nd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not the end, add to the\n\t\t\t\t\t\t * fire queue */\n\t\t\t\t\t\tnd->next = fire_nq;\n\t\t\t\t\t\tfire_nq = nd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase rf_rollBackward:\n\t\t\t\t\tif (nd->numAntecedents == 0) {\n\t\t\t\t\t\t/* end of the dag, add to the\n\t\t\t\t\t\t * callback list */\n\t\t\t\t\t\tnd->next = term_nq;\n\t\t\t\t\t\tterm_nq = nd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not the end, add to the\n\t\t\t\t\t\t * fire queue */\n\t\t\t\t\t\tnd->next = fire_nq;\n\t\t\t\t\t\tfire_nq = nd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* execute callback of dags which have reached the\n\t\t\t * terminal node */\n\t\t\twhile (term_nq) {\n\t\t\t\tnd = term_nq;\n\t\t\t\tterm_nq = term_nq->next;\n\t\t\t\tnd->next = NULL;\n\t\t\t\t(nd->dagHdr->cbFunc) (nd->dagHdr->cbArg);\n\t\t\t\traidPtr->dags_in_flight--;\t/* debug only */\n\t\t\t}\n\n\t\t\t/* fire remaining nodes */\n\t\t\tFireNodeList(fire_nq);\n\n\t\t\tDO_LOCK(raidPtr);\n\t\t}\n\t\twhile (!raidPtr->shutdown_engine && raidPtr->node_queue == NULL)\n\t\t\tDO_WAIT(raidPtr);\n\t}\n\tDO_UNLOCK(raidPtr);\n\n\tRF_THREADGROUP_DONE(&raidPtr->engine_tg);\n\n\tsplx(s);\n\tkthread_exit(0);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DAGExecutionThread(RF_ThreadArg_t arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_THREADGROUP_DONE",
          "args": [
            "&raidPtr->engine_tg"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_UNLOCK",
          "args": [
            "raidPtr"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_WAIT",
          "args": [
            "raidPtr"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_LOCK",
          "args": [
            "raidPtr"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FireNodeList",
          "args": [
            "fire_nq"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "FireNodeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "336-373",
          "snippet": "static void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nd->dagHdr->cbArg"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_UNLOCK",
          "args": [
            "raidPtr"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_LOCK",
          "args": [
            "raidPtr"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_THREADGROUP_RUNNING",
          "args": [
            "&raidPtr->engine_tg"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Engine thread is running\\n\"",
            "raidPtr->raidid"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void DAGExecutionThread(RF_ThreadArg_t arg);\n\nstatic void \nDAGExecutionThread(RF_ThreadArg_t arg)\n{\n\tRF_DagNode_t *nd, *local_nq, *term_nq, *fire_nq;\n\tRF_Raid_t *raidPtr;\n\tint     ks;\n\tint     s;\n\n\traidPtr = (RF_Raid_t *) arg;\n\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Engine thread is running\\n\", raidPtr->raidid);\n\t}\n\t/* XXX what to put here XXX */\n\n\ts = splbio();\n\n\tRF_THREADGROUP_RUNNING(&raidPtr->engine_tg);\n\n\tDO_LOCK(raidPtr);\n\twhile (!raidPtr->shutdown_engine) {\n\n\t\twhile (raidPtr->node_queue != NULL) {\n\t\t\tlocal_nq = raidPtr->node_queue;\n\t\t\tfire_nq = NULL;\n\t\t\tterm_nq = NULL;\n\t\t\traidPtr->node_queue = NULL;\n\t\t\tDO_UNLOCK(raidPtr);\n\n\t\t\t/* first, strip out the terminal nodes */\n\t\t\twhile (local_nq) {\n\t\t\t\tnd = local_nq;\n\t\t\t\tlocal_nq = local_nq->next;\n\t\t\t\tswitch (nd->dagHdr->status) {\n\t\t\t\tcase rf_enable:\n\t\t\t\tcase rf_rollForward:\n\t\t\t\t\tif (nd->numSuccedents == 0) {\n\t\t\t\t\t\t/* end of the dag, add to\n\t\t\t\t\t\t * callback list */\n\t\t\t\t\t\tnd->next = term_nq;\n\t\t\t\t\t\tterm_nq = nd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not the end, add to the\n\t\t\t\t\t\t * fire queue */\n\t\t\t\t\t\tnd->next = fire_nq;\n\t\t\t\t\t\tfire_nq = nd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase rf_rollBackward:\n\t\t\t\t\tif (nd->numAntecedents == 0) {\n\t\t\t\t\t\t/* end of the dag, add to the\n\t\t\t\t\t\t * callback list */\n\t\t\t\t\t\tnd->next = term_nq;\n\t\t\t\t\t\tterm_nq = nd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* not the end, add to the\n\t\t\t\t\t\t * fire queue */\n\t\t\t\t\t\tnd->next = fire_nq;\n\t\t\t\t\t\tfire_nq = nd;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tRF_PANIC();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* execute callback of dags which have reached the\n\t\t\t * terminal node */\n\t\t\twhile (term_nq) {\n\t\t\t\tnd = term_nq;\n\t\t\t\tterm_nq = term_nq->next;\n\t\t\t\tnd->next = NULL;\n\t\t\t\t(nd->dagHdr->cbFunc) (nd->dagHdr->cbArg);\n\t\t\t\traidPtr->dags_in_flight--;\t/* debug only */\n\t\t\t}\n\n\t\t\t/* fire remaining nodes */\n\t\t\tFireNodeList(fire_nq);\n\n\t\t\tDO_LOCK(raidPtr);\n\t\t}\n\t\twhile (!raidPtr->shutdown_engine && raidPtr->node_queue == NULL)\n\t\t\tDO_WAIT(raidPtr);\n\t}\n\tDO_UNLOCK(raidPtr);\n\n\tRF_THREADGROUP_DONE(&raidPtr->engine_tg);\n\n\tsplx(s);\n\tkthread_exit(0);\n}"
  },
  {
    "function_name": "rf_DispatchDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "668-695",
    "snippet": "int \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FireNodeArray",
          "args": [
            "dag->numSuccedents",
            "dag->succedents"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "FireNodeArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "293-329",
          "snippet": "static void \nFireNodeArray(\n    int numNodes,\n    RF_DagNode_t ** nodeList)\n{\n\tRF_DagStatus_t dstat;\n\tRF_DagNode_t *node;\n\tint     i, j;\n\n\t/* first, mark all nodes which are ready to be fired */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tnode = nodeList[i];\n\t\tdstat = node->dagHdr->status;\n\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\tif (NodeReady(node)) {\n\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\tif (node->commitNode)\n\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\tnode->status = rf_fired;\n\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t} else {\n\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\tnode->status = rf_recover;\n\t\t\t}\n\t\t}\n\t}\n\t/* now, fire the nodes */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tif ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))\n\t\t\tFireNode(nodeList[i]);\n\t}\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeArray(\n    int numNodes,\n    RF_DagNode_t ** nodeList)\n{\n\tRF_DagStatus_t dstat;\n\tRF_DagNode_t *node;\n\tint     i, j;\n\n\t/* first, mark all nodes which are ready to be fired */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tnode = nodeList[i];\n\t\tdstat = node->dagHdr->status;\n\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\tif (NodeReady(node)) {\n\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\tif (node->commitNode)\n\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\tnode->status = rf_fired;\n\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t} else {\n\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\tnode->status = rf_recover;\n\t\t\t}\n\t\t}\n\t}\n\t/* now, fire the nodes */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tif ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))\n\t\t\tFireNode(nodeList[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Entering DispatchDAG\\n\"",
            "raidPtr->raidid"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ValidateDAG",
          "args": [
            "dag"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ValidateDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "635-733",
          "snippet": "int \nrf_ValidateDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     i, nodecount;\n\tint    *scount, *acount;/* per-node successor and antecedent counts */\n\tRF_DagNode_t **nodes;\t/* array of ptrs to nodes in dag */\n\tint     retcode = 0;\n\tint     unvisited;\n\tint     commitNodeCount = 0;\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\tif (dag_h->numNodesCompleted != 0) {\n\t\tprintf(\"INVALID DAG: num nodes completed is %d, should be 0\\n\", dag_h->numNodesCompleted);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->status != rf_enable) {\n\t\tprintf(\"INVALID DAG: not enabled\\n\");\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numCommits != 0) {\n\t\tprintf(\"INVALID DAG: numCommits != 0 (%d)\\n\", dag_h->numCommits);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numSuccedents != 1) {\n\t\t/* currently, all dags must have only one succedent */\n\t\tprintf(\"INVALID DAG: numSuccedents !1 (%d)\\n\", dag_h->numSuccedents);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tnodecount = rf_AssignNodeNums(dag_h);\n\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tRF_Calloc(scount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(acount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(nodes, nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif ((dag_h->succedents[i]->visited == unvisited)\n\t\t    && rf_ValidateBranch(dag_h->succedents[i], scount,\n\t\t\tacount, nodes, unvisited)) {\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\t/* start at 1 to skip the header node */\n\tfor (i = 1; i < nodecount; i++) {\n\t\tif (nodes[i]->commitNode)\n\t\t\tcommitNodeCount++;\n\t\tif (nodes[i]->doFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->undoFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numAntecedents != scount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numSuccedents != acount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t}\n\n\tif (dag_h->numCommitNodes != commitNodeCount) {\n\t\tprintf(\"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\\n\",\n\t\t    dag_h->numCommitNodes, commitNodeCount);\n\t\tretcode = 1;\n\t\tgoto validate_dag_out;\n\t}\nvalidate_dag_out:\n\tRF_Free(scount, nodecount * sizeof(int));\n\tRF_Free(acount, nodecount * sizeof(int));\n\tRF_Free(nodes, nodecount * sizeof(RF_DagNode_t *));\n\tif (retcode)\n\t\trf_PrintDAGList(dag_h);\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\treturn (retcode);\n\nvalidate_dag_bad:\n\trf_PrintDAGList(dag_h);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nint \nrf_ValidateDAG(dag_h)\n\tRF_DagHeader_t *dag_h;\n{\n\tint     i, nodecount;\n\tint    *scount, *acount;/* per-node successor and antecedent counts */\n\tRF_DagNode_t **nodes;\t/* array of ptrs to nodes in dag */\n\tint     retcode = 0;\n\tint     unvisited;\n\tint     commitNodeCount = 0;\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\tif (dag_h->numNodesCompleted != 0) {\n\t\tprintf(\"INVALID DAG: num nodes completed is %d, should be 0\\n\", dag_h->numNodesCompleted);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->status != rf_enable) {\n\t\tprintf(\"INVALID DAG: not enabled\\n\");\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numCommits != 0) {\n\t\tprintf(\"INVALID DAG: numCommits != 0 (%d)\\n\", dag_h->numCommits);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tif (dag_h->numSuccedents != 1) {\n\t\t/* currently, all dags must have only one succedent */\n\t\tprintf(\"INVALID DAG: numSuccedents !1 (%d)\\n\", dag_h->numSuccedents);\n\t\tretcode = 1;\n\t\tgoto validate_dag_bad;\n\t}\n\tnodecount = rf_AssignNodeNums(dag_h);\n\n\tunvisited = dag_h->succedents[0]->visited;\n\n\tRF_Calloc(scount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(acount, nodecount, sizeof(int), (int *));\n\tRF_Calloc(nodes, nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));\n\tfor (i = 0; i < dag_h->numSuccedents; i++) {\n\t\tif ((dag_h->succedents[i]->visited == unvisited)\n\t\t    && rf_ValidateBranch(dag_h->succedents[i], scount,\n\t\t\tacount, nodes, unvisited)) {\n\t\t\tretcode = 1;\n\t\t}\n\t}\n\t/* start at 1 to skip the header node */\n\tfor (i = 1; i < nodecount; i++) {\n\t\tif (nodes[i]->commitNode)\n\t\t\tcommitNodeCount++;\n\t\tif (nodes[i]->doFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->undoFunc == NULL) {\n\t\t\tprintf(\"INVALID DAG: node %s has an undefined doFunc\\n\", nodes[i]->name);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numAntecedents != scount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t\tif (nodes[i]->numSuccedents != acount[nodes[i]->nodeNum]) {\n\t\t\tprintf(\"INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\\n\",\n\t\t\t    nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);\n\t\t\tretcode = 1;\n\t\t\tgoto validate_dag_out;\n\t\t}\n\t}\n\n\tif (dag_h->numCommitNodes != commitNodeCount) {\n\t\tprintf(\"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\\n\",\n\t\t    dag_h->numCommitNodes, commitNodeCount);\n\t\tretcode = 1;\n\t\tgoto validate_dag_out;\n\t}\nvalidate_dag_out:\n\tRF_Free(scount, nodecount * sizeof(int));\n\tRF_Free(acount, nodecount * sizeof(int));\n\tRF_Free(nodes, nodecount * sizeof(RF_DagNode_t *));\n\tif (retcode)\n\t\trf_PrintDAGList(dag_h);\n\n\tif (rf_validateVisitedDebug)\n\t\trf_ValidateVisitedBits(dag_h);\n\n\treturn (retcode);\n\nvalidate_dag_bad:\n\trf_PrintDAGList(dag_h);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "dag->tracerec->timer"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}"
  },
  {
    "function_name": "rf_FinishNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "642-653",
    "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessNode",
          "args": [
            "node",
            "context"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "589-633",
          "snippet": "static void \nProcessNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tswitch (node->status) {\n\tcase rf_good:\n\t\t/* normal case, don't need to do anything */\n\t\tbreak;\n\tcase rf_bad:\n\t\tif ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {\n\t\t\tnode->dagHdr->status = rf_rollForward;\t/* crossed commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling forward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t} else {\n\t\t\tnode->dagHdr->status = rf_rollBackward;\t/* never reached commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling backward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase rf_undone:\n\t\t/* normal rollBackward case, don't need to do anything */\n\t\tbreak;\n\tcase rf_panic:\n\t\t/* an undo node failed!!! */\n\t\tprintf(\"UNDO of a node failed!!!/n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"node finished execution with an illegal status!!!\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\t/* enqueue node's succedents (antecedents if rollBackward) for\n\t * execution */\n\tPropagateResults(node, context);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nProcessNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tswitch (node->status) {\n\tcase rf_good:\n\t\t/* normal case, don't need to do anything */\n\t\tbreak;\n\tcase rf_bad:\n\t\tif ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {\n\t\t\tnode->dagHdr->status = rf_rollForward;\t/* crossed commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling forward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t} else {\n\t\t\tnode->dagHdr->status = rf_rollBackward;\t/* never reached commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling backward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase rf_undone:\n\t\t/* normal rollBackward case, don't need to do anything */\n\t\tbreak;\n\tcase rf_panic:\n\t\t/* an undo node failed!!! */\n\t\tprintf(\"UNDO of a node failed!!!/n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"node finished execution with an illegal status!!!\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\t/* enqueue node's succedents (antecedents if rollBackward) for\n\t * execution */\n\tPropagateResults(node, context);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
  },
  {
    "function_name": "ProcessNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "589-633",
    "snippet": "static void \nProcessNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tswitch (node->status) {\n\tcase rf_good:\n\t\t/* normal case, don't need to do anything */\n\t\tbreak;\n\tcase rf_bad:\n\t\tif ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {\n\t\t\tnode->dagHdr->status = rf_rollForward;\t/* crossed commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling forward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t} else {\n\t\t\tnode->dagHdr->status = rf_rollBackward;\t/* never reached commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling backward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase rf_undone:\n\t\t/* normal rollBackward case, don't need to do anything */\n\t\tbreak;\n\tcase rf_panic:\n\t\t/* an undo node failed!!! */\n\t\tprintf(\"UNDO of a node failed!!!/n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"node finished execution with an illegal status!!!\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\t/* enqueue node's succedents (antecedents if rollBackward) for\n\t * execution */\n\tPropagateResults(node, context);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PropagateResults",
          "args": [
            "node",
            "context"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "PropagateResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "390-582",
          "snippet": "static void \nPropagateResults(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_DagNode_t *s, *a;\n\tRF_Raid_t *raidPtr;\n\tint     i, ks;\n\tRF_DagNode_t *finishlist = NULL;\t/* a list of NIL nodes to be\n\t\t\t\t\t\t * finished */\n\tRF_DagNode_t *skiplist = NULL;\t/* list of nodes with failed truedata\n\t\t\t\t\t * antecedents */\n\tRF_DagNode_t *firelist = NULL;\t/* a list of nodes to be fired */\n\tRF_DagNode_t *q = NULL, *qh = NULL, *next;\n\tint     j, skipNode;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tDO_LOCK(raidPtr);\n\n\t/* debug - validate fire counts */\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\ta = *(node->antecedents + i);\n\t\tRF_ASSERT(a->numSuccFired >= a->numSuccDone);\n\t\tRF_ASSERT(a->numSuccFired <= a->numSuccedents);\n\t\ta->numSuccDone++;\n\t}\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\t\ts = *(node->succedents + i);\n\t\t\tRF_ASSERT(s->status == rf_wait);\n\t\t\t(s->numAntDone)++;\n\t\t\tif (s->numAntDone == s->numAntecedents) {\n\t\t\t\t/* look for NIL nodes */\n\t\t\t\tif (s->doFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ts->next = finishlist;\n\t\t\t\t\tfinishlist = s;\n\t\t\t\t} else {\n\t\t\t\t\t/* look to see if the node is to be\n\t\t\t\t\t * skipped */\n\t\t\t\t\tskipNode = RF_FALSE;\n\t\t\t\t\tfor (j = 0; j < s->numAntecedents; j++)\n\t\t\t\t\t\tif ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))\n\t\t\t\t\t\t\tskipNode = RF_TRUE;\n\t\t\t\t\tif (skipNode) {\n\t\t\t\t\t\t/* this node has one or more\n\t\t\t\t\t\t * failed true data\n\t\t\t\t\t\t * dependencies, so skip it */\n\t\t\t\t\t\ts->next = skiplist;\n\t\t\t\t\t\tskiplist = s;\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* add s to list of nodes (q)\n\t\t\t\t\t\t * to execute */\n\t\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t\t/* we only have to\n\t\t\t\t\t\t\t * enqueue if we're at\n\t\t\t\t\t\t\t * intr context */\n\t\t\t\t\t\t\ts->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\t\tfirelist = s;\n\t\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\t\tRF_ASSERT(NodeReady(s));\n\t\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\t\tq->next = s;\n\t\t\t\t\t\t\t\tq = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tqh = q = s;\n\t\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\n\t\tfor (; skiplist; skiplist = next) {\n\t\t\tnext = skiplist->next;\n\t\t\tskiplist->status = rf_skipped;\n\t\t\tfor (i = 0; i < skiplist->numAntecedents; i++) {\n\t\t\t\tskiplist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (skiplist->commitNode) {\n\t\t\t\tskiplist->dagHdr->numCommits++;\n\t\t\t}\n\t\t\trf_FinishNode(skiplist, context);\n\t\t}\n\t\tfor (; finishlist; finishlist = next) {\n\t\t\t/* NIL nodes: no need to fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\tfor (i = 0; i < finishlist->numAntecedents; i++) {\n\t\t\t\tfinishlist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (finishlist->commitNode)\n\t\t\t\tfinishlist->dagHdr->numCommits++;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the terminal node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\t\tbreak;\n\n\tcase rf_rollBackward:\n\t\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\t\ta = *(node->antecedents + i);\n\t\t\tRF_ASSERT(a->status == rf_good);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccedents);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccFired);\n\n\t\t\tif (a->numSuccDone == a->numSuccFired) {\n\t\t\t\tif (a->undoFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ta->next = finishlist;\n\t\t\t\t\tfinishlist = a;\n\t\t\t\t} else {\n\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t/* we only have to enqueue if\n\t\t\t\t\t\t * we're at intr context */\n\t\t\t\t\t\ta->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\tfirelist = a;\n\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\tRF_ASSERT(NodeReady(a));\n\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\tq->next = a;\n\t\t\t\t\t\t\tq = a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqh = q = a;\n\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\t\tfor (; finishlist; finishlist = next) {\t/* NIL nodes: no need to\n\t\t\t\t\t\t\t * fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the first node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Engine found illegal DAG status in PropagateResults()\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nPropagateResults(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_DagNode_t *s, *a;\n\tRF_Raid_t *raidPtr;\n\tint     i, ks;\n\tRF_DagNode_t *finishlist = NULL;\t/* a list of NIL nodes to be\n\t\t\t\t\t\t * finished */\n\tRF_DagNode_t *skiplist = NULL;\t/* list of nodes with failed truedata\n\t\t\t\t\t * antecedents */\n\tRF_DagNode_t *firelist = NULL;\t/* a list of nodes to be fired */\n\tRF_DagNode_t *q = NULL, *qh = NULL, *next;\n\tint     j, skipNode;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tDO_LOCK(raidPtr);\n\n\t/* debug - validate fire counts */\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\ta = *(node->antecedents + i);\n\t\tRF_ASSERT(a->numSuccFired >= a->numSuccDone);\n\t\tRF_ASSERT(a->numSuccFired <= a->numSuccedents);\n\t\ta->numSuccDone++;\n\t}\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\t\ts = *(node->succedents + i);\n\t\t\tRF_ASSERT(s->status == rf_wait);\n\t\t\t(s->numAntDone)++;\n\t\t\tif (s->numAntDone == s->numAntecedents) {\n\t\t\t\t/* look for NIL nodes */\n\t\t\t\tif (s->doFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ts->next = finishlist;\n\t\t\t\t\tfinishlist = s;\n\t\t\t\t} else {\n\t\t\t\t\t/* look to see if the node is to be\n\t\t\t\t\t * skipped */\n\t\t\t\t\tskipNode = RF_FALSE;\n\t\t\t\t\tfor (j = 0; j < s->numAntecedents; j++)\n\t\t\t\t\t\tif ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))\n\t\t\t\t\t\t\tskipNode = RF_TRUE;\n\t\t\t\t\tif (skipNode) {\n\t\t\t\t\t\t/* this node has one or more\n\t\t\t\t\t\t * failed true data\n\t\t\t\t\t\t * dependencies, so skip it */\n\t\t\t\t\t\ts->next = skiplist;\n\t\t\t\t\t\tskiplist = s;\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* add s to list of nodes (q)\n\t\t\t\t\t\t * to execute */\n\t\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t\t/* we only have to\n\t\t\t\t\t\t\t * enqueue if we're at\n\t\t\t\t\t\t\t * intr context */\n\t\t\t\t\t\t\ts->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\t\tfirelist = s;\n\t\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\t\tRF_ASSERT(NodeReady(s));\n\t\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\t\tq->next = s;\n\t\t\t\t\t\t\t\tq = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tqh = q = s;\n\t\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\n\t\tfor (; skiplist; skiplist = next) {\n\t\t\tnext = skiplist->next;\n\t\t\tskiplist->status = rf_skipped;\n\t\t\tfor (i = 0; i < skiplist->numAntecedents; i++) {\n\t\t\t\tskiplist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (skiplist->commitNode) {\n\t\t\t\tskiplist->dagHdr->numCommits++;\n\t\t\t}\n\t\t\trf_FinishNode(skiplist, context);\n\t\t}\n\t\tfor (; finishlist; finishlist = next) {\n\t\t\t/* NIL nodes: no need to fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\tfor (i = 0; i < finishlist->numAntecedents; i++) {\n\t\t\t\tfinishlist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (finishlist->commitNode)\n\t\t\t\tfinishlist->dagHdr->numCommits++;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the terminal node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\t\tbreak;\n\n\tcase rf_rollBackward:\n\t\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\t\ta = *(node->antecedents + i);\n\t\t\tRF_ASSERT(a->status == rf_good);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccedents);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccFired);\n\n\t\t\tif (a->numSuccDone == a->numSuccFired) {\n\t\t\t\tif (a->undoFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ta->next = finishlist;\n\t\t\t\t\tfinishlist = a;\n\t\t\t\t} else {\n\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t/* we only have to enqueue if\n\t\t\t\t\t\t * we're at intr context */\n\t\t\t\t\t\ta->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\tfirelist = a;\n\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\tRF_ASSERT(NodeReady(a));\n\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\tq->next = a;\n\t\t\t\t\t\t\tq = a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqh = q = a;\n\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\t\tfor (; finishlist; finishlist = next) {\t/* NIL nodes: no need to\n\t\t\t\t\t\t\t * fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the first node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Engine found illegal DAG status in PropagateResults()\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"node finished execution with an illegal status!!!\\n\""
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nProcessNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tswitch (node->status) {\n\tcase rf_good:\n\t\t/* normal case, don't need to do anything */\n\t\tbreak;\n\tcase rf_bad:\n\t\tif ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {\n\t\t\tnode->dagHdr->status = rf_rollForward;\t/* crossed commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling forward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t} else {\n\t\t\tnode->dagHdr->status = rf_rollBackward;\t/* never reached commit\n\t\t\t\t\t\t\t\t * barrier */\n\t\t\tif (rf_engineDebug || 1) {\n\t\t\t\tprintf(\"raid%d: node (%s) returned fail, rolling backward\\n\", raidPtr->raidid, node->name);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase rf_undone:\n\t\t/* normal rollBackward case, don't need to do anything */\n\t\tbreak;\n\tcase rf_panic:\n\t\t/* an undo node failed!!! */\n\t\tprintf(\"UNDO of a node failed!!!/n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"node finished execution with an illegal status!!!\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\t/* enqueue node's succedents (antecedents if rollBackward) for\n\t * execution */\n\tPropagateResults(node, context);\n}"
  },
  {
    "function_name": "PropagateResults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "390-582",
    "snippet": "static void \nPropagateResults(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_DagNode_t *s, *a;\n\tRF_Raid_t *raidPtr;\n\tint     i, ks;\n\tRF_DagNode_t *finishlist = NULL;\t/* a list of NIL nodes to be\n\t\t\t\t\t\t * finished */\n\tRF_DagNode_t *skiplist = NULL;\t/* list of nodes with failed truedata\n\t\t\t\t\t * antecedents */\n\tRF_DagNode_t *firelist = NULL;\t/* a list of nodes to be fired */\n\tRF_DagNode_t *q = NULL, *qh = NULL, *next;\n\tint     j, skipNode;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tDO_LOCK(raidPtr);\n\n\t/* debug - validate fire counts */\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\ta = *(node->antecedents + i);\n\t\tRF_ASSERT(a->numSuccFired >= a->numSuccDone);\n\t\tRF_ASSERT(a->numSuccFired <= a->numSuccedents);\n\t\ta->numSuccDone++;\n\t}\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\t\ts = *(node->succedents + i);\n\t\t\tRF_ASSERT(s->status == rf_wait);\n\t\t\t(s->numAntDone)++;\n\t\t\tif (s->numAntDone == s->numAntecedents) {\n\t\t\t\t/* look for NIL nodes */\n\t\t\t\tif (s->doFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ts->next = finishlist;\n\t\t\t\t\tfinishlist = s;\n\t\t\t\t} else {\n\t\t\t\t\t/* look to see if the node is to be\n\t\t\t\t\t * skipped */\n\t\t\t\t\tskipNode = RF_FALSE;\n\t\t\t\t\tfor (j = 0; j < s->numAntecedents; j++)\n\t\t\t\t\t\tif ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))\n\t\t\t\t\t\t\tskipNode = RF_TRUE;\n\t\t\t\t\tif (skipNode) {\n\t\t\t\t\t\t/* this node has one or more\n\t\t\t\t\t\t * failed true data\n\t\t\t\t\t\t * dependencies, so skip it */\n\t\t\t\t\t\ts->next = skiplist;\n\t\t\t\t\t\tskiplist = s;\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* add s to list of nodes (q)\n\t\t\t\t\t\t * to execute */\n\t\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t\t/* we only have to\n\t\t\t\t\t\t\t * enqueue if we're at\n\t\t\t\t\t\t\t * intr context */\n\t\t\t\t\t\t\ts->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\t\tfirelist = s;\n\t\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\t\tRF_ASSERT(NodeReady(s));\n\t\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\t\tq->next = s;\n\t\t\t\t\t\t\t\tq = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tqh = q = s;\n\t\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\n\t\tfor (; skiplist; skiplist = next) {\n\t\t\tnext = skiplist->next;\n\t\t\tskiplist->status = rf_skipped;\n\t\t\tfor (i = 0; i < skiplist->numAntecedents; i++) {\n\t\t\t\tskiplist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (skiplist->commitNode) {\n\t\t\t\tskiplist->dagHdr->numCommits++;\n\t\t\t}\n\t\t\trf_FinishNode(skiplist, context);\n\t\t}\n\t\tfor (; finishlist; finishlist = next) {\n\t\t\t/* NIL nodes: no need to fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\tfor (i = 0; i < finishlist->numAntecedents; i++) {\n\t\t\t\tfinishlist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (finishlist->commitNode)\n\t\t\t\tfinishlist->dagHdr->numCommits++;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the terminal node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\t\tbreak;\n\n\tcase rf_rollBackward:\n\t\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\t\ta = *(node->antecedents + i);\n\t\t\tRF_ASSERT(a->status == rf_good);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccedents);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccFired);\n\n\t\t\tif (a->numSuccDone == a->numSuccFired) {\n\t\t\t\tif (a->undoFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ta->next = finishlist;\n\t\t\t\t\tfinishlist = a;\n\t\t\t\t} else {\n\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t/* we only have to enqueue if\n\t\t\t\t\t\t * we're at intr context */\n\t\t\t\t\t\ta->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\tfirelist = a;\n\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\tRF_ASSERT(NodeReady(a));\n\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\tq->next = a;\n\t\t\t\t\t\t\tq = a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqh = q = a;\n\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\t\tfor (; finishlist; finishlist = next) {\t/* NIL nodes: no need to\n\t\t\t\t\t\t\t * fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the first node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Engine found illegal DAG status in PropagateResults()\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Engine found illegal DAG status in PropagateResults()\\n\""
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FireNodeList",
          "args": [
            "firelist"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "FireNodeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "336-373",
          "snippet": "static void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FinishNode",
          "args": [
            "finishlist",
            "context"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FinishNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "642-653",
          "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_UNLOCK",
          "args": [
            "raidPtr"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_SIGNAL",
          "args": [
            "raidPtr"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "NodeReady(a)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NodeReady",
          "args": [
            "a"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "NodeReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "201-230",
          "snippet": "static int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "a->numSuccDone <= a->numSuccFired"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "a->numSuccDone <= a->numSuccedents"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "a->status == rf_good"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_UNLOCK",
          "args": [
            "raidPtr"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_SIGNAL",
          "args": [
            "raidPtr"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "NodeReady(s)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "s->status == rf_wait"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "a->numSuccFired <= a->numSuccedents"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "a->numSuccFired >= a->numSuccDone"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_LOCK",
          "args": [
            "raidPtr"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nPropagateResults(\n    RF_DagNode_t * node,\n    int context)\n{\n\tRF_DagNode_t *s, *a;\n\tRF_Raid_t *raidPtr;\n\tint     i, ks;\n\tRF_DagNode_t *finishlist = NULL;\t/* a list of NIL nodes to be\n\t\t\t\t\t\t * finished */\n\tRF_DagNode_t *skiplist = NULL;\t/* list of nodes with failed truedata\n\t\t\t\t\t * antecedents */\n\tRF_DagNode_t *firelist = NULL;\t/* a list of nodes to be fired */\n\tRF_DagNode_t *q = NULL, *qh = NULL, *next;\n\tint     j, skipNode;\n\n\traidPtr = node->dagHdr->raidPtr;\n\n\tDO_LOCK(raidPtr);\n\n\t/* debug - validate fire counts */\n\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\ta = *(node->antecedents + i);\n\t\tRF_ASSERT(a->numSuccFired >= a->numSuccDone);\n\t\tRF_ASSERT(a->numSuccFired <= a->numSuccedents);\n\t\ta->numSuccDone++;\n\t}\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tfor (i = 0; i < node->numSuccedents; i++) {\n\t\t\ts = *(node->succedents + i);\n\t\t\tRF_ASSERT(s->status == rf_wait);\n\t\t\t(s->numAntDone)++;\n\t\t\tif (s->numAntDone == s->numAntecedents) {\n\t\t\t\t/* look for NIL nodes */\n\t\t\t\tif (s->doFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ts->next = finishlist;\n\t\t\t\t\tfinishlist = s;\n\t\t\t\t} else {\n\t\t\t\t\t/* look to see if the node is to be\n\t\t\t\t\t * skipped */\n\t\t\t\t\tskipNode = RF_FALSE;\n\t\t\t\t\tfor (j = 0; j < s->numAntecedents; j++)\n\t\t\t\t\t\tif ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))\n\t\t\t\t\t\t\tskipNode = RF_TRUE;\n\t\t\t\t\tif (skipNode) {\n\t\t\t\t\t\t/* this node has one or more\n\t\t\t\t\t\t * failed true data\n\t\t\t\t\t\t * dependencies, so skip it */\n\t\t\t\t\t\ts->next = skiplist;\n\t\t\t\t\t\tskiplist = s;\n\t\t\t\t\t} else\n\t\t\t\t\t\t/* add s to list of nodes (q)\n\t\t\t\t\t\t * to execute */\n\t\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t\t/* we only have to\n\t\t\t\t\t\t\t * enqueue if we're at\n\t\t\t\t\t\t\t * intr context */\n\t\t\t\t\t\t\ts->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\t\tfirelist = s;\n\t\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\t\tRF_ASSERT(NodeReady(s));\n\t\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\t\tq->next = s;\n\t\t\t\t\t\t\t\tq = s;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tqh = q = s;\n\t\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\n\t\tfor (; skiplist; skiplist = next) {\n\t\t\tnext = skiplist->next;\n\t\t\tskiplist->status = rf_skipped;\n\t\t\tfor (i = 0; i < skiplist->numAntecedents; i++) {\n\t\t\t\tskiplist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (skiplist->commitNode) {\n\t\t\t\tskiplist->dagHdr->numCommits++;\n\t\t\t}\n\t\t\trf_FinishNode(skiplist, context);\n\t\t}\n\t\tfor (; finishlist; finishlist = next) {\n\t\t\t/* NIL nodes: no need to fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\tfor (i = 0; i < finishlist->numAntecedents; i++) {\n\t\t\t\tfinishlist->antecedents[i]->numSuccFired++;\n\t\t\t}\n\t\t\tif (finishlist->commitNode)\n\t\t\t\tfinishlist->dagHdr->numCommits++;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the terminal node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\t\tbreak;\n\n\tcase rf_rollBackward:\n\t\tfor (i = 0; i < node->numAntecedents; i++) {\n\t\t\ta = *(node->antecedents + i);\n\t\t\tRF_ASSERT(a->status == rf_good);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccedents);\n\t\t\tRF_ASSERT(a->numSuccDone <= a->numSuccFired);\n\n\t\t\tif (a->numSuccDone == a->numSuccFired) {\n\t\t\t\tif (a->undoFunc == rf_NullNodeFunc) {\n\t\t\t\t\t/* don't fire NIL nodes, just process\n\t\t\t\t\t * them */\n\t\t\t\t\ta->next = finishlist;\n\t\t\t\t\tfinishlist = a;\n\t\t\t\t} else {\n\t\t\t\t\tif (context != RF_INTR_CONTEXT) {\n\t\t\t\t\t\t/* we only have to enqueue if\n\t\t\t\t\t\t * we're at intr context */\n\t\t\t\t\t\ta->next = firelist;\t/* put node on a list to\n\t\t\t\t\t\t\t\t\t * be fired after we\n\t\t\t\t\t\t\t\t\t * unlock */\n\t\t\t\t\t\tfirelist = a;\n\t\t\t\t\t} else {\t/* enqueue the node for\n\t\t\t\t\t\t\t * the dag exec thread\n\t\t\t\t\t\t\t * to fire */\n\t\t\t\t\t\tRF_ASSERT(NodeReady(a));\n\t\t\t\t\t\tif (q) {\n\t\t\t\t\t\t\tq->next = a;\n\t\t\t\t\t\t\tq = a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tqh = q = a;\n\t\t\t\t\t\t\tqh->next = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (q) {\n\t\t\t/* xfer our local list of nodes to the node queue */\n\t\t\tq->next = raidPtr->node_queue;\n\t\t\traidPtr->node_queue = qh;\n\t\t\tDO_SIGNAL(raidPtr);\n\t\t}\n\t\tDO_UNLOCK(raidPtr);\n\t\tfor (; finishlist; finishlist = next) {\t/* NIL nodes: no need to\n\t\t\t\t\t\t\t * fire them */\n\t\t\tnext = finishlist->next;\n\t\t\tfinishlist->status = rf_good;\n\t\t\t/*\n\t\t         * Okay, here we're calling rf_FinishNode() on nodes that\n\t\t         * have the null function as their work proc. Such a node\n\t\t         * could be the first node in a DAG. If so, it will\n\t\t         * cause the DAG to complete, which will in turn free\n\t\t         * memory used by the DAG, which includes the node in\n\t\t         * question. Thus, we must avoid referencing the node\n\t\t         * at all after calling rf_FinishNode() on it.\n\t\t         */\n\t\t\trf_FinishNode(finishlist, context);\t/* recursive call */\n\t\t}\n\t\t/* fire all nodes in firelist */\n\t\tFireNodeList(firelist);\n\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Engine found illegal DAG status in PropagateResults()\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "FireNodeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "336-373",
    "snippet": "static void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FireNode",
          "args": [
            "node"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "FireNodeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "336-373",
          "snippet": "static void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->commitNode == RF_FALSE"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->status == rf_good"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "dstat == rf_rollBackward"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->status == rf_wait"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NodeReady",
          "args": [
            "node"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "NodeReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "201-230",
          "snippet": "static int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(node->status == rf_wait) || (node->status == rf_good)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "FireNodeArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "293-329",
    "snippet": "static void \nFireNodeArray(\n    int numNodes,\n    RF_DagNode_t ** nodeList)\n{\n\tRF_DagStatus_t dstat;\n\tRF_DagNode_t *node;\n\tint     i, j;\n\n\t/* first, mark all nodes which are ready to be fired */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tnode = nodeList[i];\n\t\tdstat = node->dagHdr->status;\n\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\tif (NodeReady(node)) {\n\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\tif (node->commitNode)\n\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\tnode->status = rf_fired;\n\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t} else {\n\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\tnode->status = rf_recover;\n\t\t\t}\n\t\t}\n\t}\n\t/* now, fire the nodes */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tif ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))\n\t\t\tFireNode(nodeList[i]);\n\t}\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FireNode",
          "args": [
            "nodeList[i]"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "FireNodeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "336-373",
          "snippet": "static void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeList(RF_DagNode_t * nodeList)\n{\n\tRF_DagNode_t *node, *next;\n\tRF_DagStatus_t dstat;\n\tint     j;\n\n\tif (nodeList) {\n\t\t/* first, mark all nodes which are ready to be fired */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tdstat = node->dagHdr->status;\n\t\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\t\tif (NodeReady(node)) {\n\t\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\t\tif (node->commitNode)\n\t\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\t\tnode->status = rf_fired;\n\t\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\t\tnode->status = rf_recover;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* now, fire the nodes */\n\t\tfor (node = nodeList; node; node = next) {\n\t\t\tnext = node->next;\n\t\t\tif ((node->status == rf_fired) || (node->status == rf_recover))\n\t\t\t\tFireNode(node);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->commitNode == RF_FALSE"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->status == rf_good"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "dstat == rf_rollBackward"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->status == rf_wait"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NodeReady",
          "args": [
            "node"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "NodeReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "201-230",
          "snippet": "static int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(node->status == rf_wait) || (node->status == rf_good)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNodeArray(\n    int numNodes,\n    RF_DagNode_t ** nodeList)\n{\n\tRF_DagStatus_t dstat;\n\tRF_DagNode_t *node;\n\tint     i, j;\n\n\t/* first, mark all nodes which are ready to be fired */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tnode = nodeList[i];\n\t\tdstat = node->dagHdr->status;\n\t\tRF_ASSERT((node->status == rf_wait) || (node->status == rf_good));\n\t\tif (NodeReady(node)) {\n\t\t\tif ((dstat == rf_enable) || (dstat == rf_rollForward)) {\n\t\t\t\tRF_ASSERT(node->status == rf_wait);\n\t\t\t\tif (node->commitNode)\n\t\t\t\t\tnode->dagHdr->numCommits++;\n\t\t\t\tnode->status = rf_fired;\n\t\t\t\tfor (j = 0; j < node->numAntecedents; j++)\n\t\t\t\t\tnode->antecedents[j]->numSuccFired++;\n\t\t\t} else {\n\t\t\t\tRF_ASSERT(dstat == rf_rollBackward);\n\t\t\t\tRF_ASSERT(node->status == rf_good);\n\t\t\t\tRF_ASSERT(node->commitNode == RF_FALSE);\t/* only one commit node\n\t\t\t\t\t\t\t\t\t\t * per graph */\n\t\t\t\tnode->status = rf_recover;\n\t\t\t}\n\t\t}\n\t}\n\t/* now, fire the nodes */\n\tfor (i = 0; i < numNodes; i++) {\n\t\tif ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))\n\t\t\tFireNode(nodeList[i]);\n\t}\n}"
  },
  {
    "function_name": "FireNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "240-285",
    "snippet": "static void \nFireNode(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\tcase rf_fired:\n\t\t/* fire the do function of a node */\n\t\tif (rf_engineDebug) {\n\t\t\tprintf(\"raid%d: Firing node 0x%lx (%s)\\n\", \n\t\t\t       node->dagHdr->raidPtr->raidid, \n\t\t\t       (unsigned long) node, node->name);\n\t\t}\n\t\tif (node->flags & RF_DAGNODE_FLAG_YIELD) {\n#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)\n\t\t\t/* thread_block(); */\n\t\t\t/* printf(\"Need to block the thread here...\\n\");  */\n\t\t\t/* XXX thread_block is actually mentioned in\n\t\t\t * /usr/include/vm/vm_extern.h */\n#else\n\t\t\tthread_block();\n#endif\n\t\t}\n\t\t(*(node->doFunc)) (node);\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* fire the undo function of a node */\n\t\tif (rf_engineDebug) {\n\t\t\tprintf(\"raid%d: Firing (undo) node 0x%lx (%s)\\n\", \n\t\t\t       node->dagHdr->raidPtr->raidid,\n\t\t\t       (unsigned long) node, node->name);\n\t\t}\n\t\tif (node->flags & RF_DAGNODE_FLAG_YIELD)\n#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)\n\t\t\t/* thread_block(); */\n\t\t\t/* printf(\"Need to block the thread here...\\n\"); */\n\t\t\t/* XXX thread_block is actually mentioned in\n\t\t\t * /usr/include/vm/vm_extern.h */\n#else\n\t\t\tthread_block();\n#endif\n\t\t(*(node->undoFunc)) (node);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_block",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Firing (undo) node 0x%lx (%s)\\n\"",
            "node->dagHdr->raidPtr->raidid",
            "(unsigned long) node",
            "node->name"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_block",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void \nFireNode(RF_DagNode_t * node)\n{\n\tswitch (node->status) {\n\tcase rf_fired:\n\t\t/* fire the do function of a node */\n\t\tif (rf_engineDebug) {\n\t\t\tprintf(\"raid%d: Firing node 0x%lx (%s)\\n\", \n\t\t\t       node->dagHdr->raidPtr->raidid, \n\t\t\t       (unsigned long) node, node->name);\n\t\t}\n\t\tif (node->flags & RF_DAGNODE_FLAG_YIELD) {\n#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)\n\t\t\t/* thread_block(); */\n\t\t\t/* printf(\"Need to block the thread here...\\n\");  */\n\t\t\t/* XXX thread_block is actually mentioned in\n\t\t\t * /usr/include/vm/vm_extern.h */\n#else\n\t\t\tthread_block();\n#endif\n\t\t}\n\t\t(*(node->doFunc)) (node);\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* fire the undo function of a node */\n\t\tif (rf_engineDebug) {\n\t\t\tprintf(\"raid%d: Firing (undo) node 0x%lx (%s)\\n\", \n\t\t\t       node->dagHdr->raidPtr->raidid,\n\t\t\t       (unsigned long) node, node->name);\n\t\t}\n\t\tif (node->flags & RF_DAGNODE_FLAG_YIELD)\n#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)\n\t\t\t/* thread_block(); */\n\t\t\t/* printf(\"Need to block the thread here...\\n\"); */\n\t\t\t/* XXX thread_block is actually mentioned in\n\t\t\t * /usr/include/vm/vm_extern.h */\n#else\n\t\t\tthread_block();\n#endif\n\t\t(*(node->undoFunc)) (node);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "NodeReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "201-230",
    "snippet": "static int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Execution engine found illegal DAG status in NodeReady\\n\""
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->numSuccFired <= node->numSuccDone"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->numSuccFired <= node->numSuccedents"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->numSuccDone <= node->numSuccedents"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic int \nNodeReady(RF_DagNode_t * node)\n{\n\tint     ready;\n\n\tswitch (node->dagHdr->status) {\n\tcase rf_enable:\n\tcase rf_rollForward:\n\t\tif ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tcase rf_rollBackward:\n\t\tRF_ASSERT(node->numSuccDone <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccedents);\n\t\tRF_ASSERT(node->numSuccFired <= node->numSuccDone);\n\t\tif ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))\n\t\t\tready = RF_TRUE;\n\t\telse\n\t\t\tready = RF_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"Execution engine found illegal DAG status in NodeReady\\n\");\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\n\treturn (ready);\n}"
  },
  {
    "function_name": "BranchDone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "158-199",
    "snippet": "static int \nBranchDone(RF_DagNode_t * node)\n{\n\tint     i;\n\n\t/* return true if forward execution is completed for a node and it's\n\t * succedents */\n\tswitch (node->status) {\n\tcase rf_wait:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_fired:\n\t\t/* node is currently executing, so we're not done */\n\t\treturn (RF_FALSE);\n\tcase rf_good:\n\t\tfor (i = 0; i < node->numSuccedents; i++)\t/* for each succedent */\n\t\t\tif (!BranchDone(node->succedents[i]))\t/* recursively check\n\t\t\t\t\t\t\t\t * branch */\n\t\t\t\treturn RF_FALSE;\n\t\treturn RF_TRUE;\t/* node and all succedent branches aren't in\n\t\t\t\t * fired state */\n\t\tbreak;\n\tcase rf_bad:\n\t\t/* succedents can't fire */\n\t\treturn (RF_TRUE);\n\tcase rf_recover:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_undone:\n\tcase rf_panic:\n\t\t/* XXX need to fix this case */\n\t\t/* for now, assume that we're done */\n\t\treturn (RF_TRUE);\n\t\tbreak;\n\tdefault:\n\t\t/* illegal node status */\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BranchDone",
          "args": [
            "node->succedents[i]"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "BranchDone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "158-199",
          "snippet": "static int \nBranchDone(RF_DagNode_t * node)\n{\n\tint     i;\n\n\t/* return true if forward execution is completed for a node and it's\n\t * succedents */\n\tswitch (node->status) {\n\tcase rf_wait:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_fired:\n\t\t/* node is currently executing, so we're not done */\n\t\treturn (RF_FALSE);\n\tcase rf_good:\n\t\tfor (i = 0; i < node->numSuccedents; i++)\t/* for each succedent */\n\t\t\tif (!BranchDone(node->succedents[i]))\t/* recursively check\n\t\t\t\t\t\t\t\t * branch */\n\t\t\t\treturn RF_FALSE;\n\t\treturn RF_TRUE;\t/* node and all succedent branches aren't in\n\t\t\t\t * fired state */\n\t\tbreak;\n\tcase rf_bad:\n\t\t/* succedents can't fire */\n\t\treturn (RF_TRUE);\n\tcase rf_recover:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_undone:\n\tcase rf_panic:\n\t\t/* XXX need to fix this case */\n\t\t/* for now, assume that we're done */\n\t\treturn (RF_TRUE);\n\t\tbreak;\n\tdefault:\n\t\t/* illegal node status */\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic int \nBranchDone(RF_DagNode_t * node)\n{\n\tint     i;\n\n\t/* return true if forward execution is completed for a node and it's\n\t * succedents */\n\tswitch (node->status) {\n\tcase rf_wait:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_fired:\n\t\t/* node is currently executing, so we're not done */\n\t\treturn (RF_FALSE);\n\tcase rf_good:\n\t\tfor (i = 0; i < node->numSuccedents; i++)\t/* for each succedent */\n\t\t\tif (!BranchDone(node->succedents[i]))\t/* recursively check\n\t\t\t\t\t\t\t\t * branch */\n\t\t\t\treturn RF_FALSE;\n\t\treturn RF_TRUE;\t/* node and all succedent branches aren't in\n\t\t\t\t * fired state */\n\t\tbreak;\n\tcase rf_bad:\n\t\t/* succedents can't fire */\n\t\treturn (RF_TRUE);\n\tcase rf_recover:\n\t\t/* should never be called in this state */\n\t\tRF_PANIC();\n\t\tbreak;\n\tcase rf_undone:\n\tcase rf_panic:\n\t\t/* XXX need to fix this case */\n\t\t/* for now, assume that we're done */\n\t\treturn (RF_TRUE);\n\t\tbreak;\n\tdefault:\n\t\t/* illegal node status */\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "rf_ConfigureEngine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "107-156",
    "snippet": "int \nrf_ConfigureEngine(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\tDO_INIT(listp, raidPtr);\n\n\traidPtr->node_queue = NULL;\n\traidPtr->dags_in_flight = 0;\n\n\trc = rf_init_managed_threadgroup(listp, &raidPtr->engine_tg);\n\tif (rc)\n\t\treturn (rc);\n\n\t/* we create the execution thread only once per system boot. no need\n\t * to check return code b/c the kernel panics if it can't create the\n\t * thread. */\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Creating engine thread\\n\", raidPtr->raidid);\n\t}\n\tif (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread, raidPtr,\"raid\")) {\n\t\tRF_ERRORMSG(\"RAIDFRAME: Unable to create engine thread\\n\");\n\t\treturn (ENOMEM);\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Created engine thread\\n\", raidPtr->raidid);\n\t}\n\tRF_THREADGROUP_STARTED(&raidPtr->engine_tg);\n\t/* XXX something is missing here... */\n#ifdef debug\n\tprintf(\"Skipping the WAIT_START!!\\n\");\n#endif\n#if 0\n\tRF_THREADGROUP_WAIT_START(&raidPtr->engine_tg);\n#endif\n\t/* engine thread is now running and waiting for work */\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Engine thread running and waiting for events\\n\", raidPtr->raidid);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownEngine, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownEngine(NULL);\n\t}\n\treturn (rc);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void rf_ShutdownEngine(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ShutdownEngine",
          "args": [
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownEngine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "96-105",
          "snippet": "static void \nrf_ShutdownEngine(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\traidPtr->shutdown_engine = 1;\n\tDO_SIGNAL(raidPtr);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DAGExecutionThread(RF_ThreadArg_t arg);",
            "static void rf_ShutdownEngine(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void DAGExecutionThread(RF_ThreadArg_t arg);\nstatic void rf_ShutdownEngine(void *);\n\nstatic void \nrf_ShutdownEngine(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\traidPtr->shutdown_engine = 1;\n\tDO_SIGNAL(raidPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownEngine",
            "raidPtr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Engine thread running and waiting for events\\n\"",
            "raidPtr->raidid"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_THREADGROUP_WAIT_START",
          "args": [
            "&raidPtr->engine_tg"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_THREADGROUP_STARTED",
          "args": [
            "&raidPtr->engine_tg"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"RAIDFRAME: Unable to create engine thread\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->engine_thread",
            "DAGExecutionThread",
            "raidPtr",
            "\"raid\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_init_managed_threadgroup",
          "args": [
            "listp",
            "&raidPtr->engine_tg"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_init_managed_threadgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "115-132",
          "snippet": "int \n_rf_init_managed_threadgroup(listp, g, file, line)\n\tRF_ShutdownList_t **listp;\n\tRF_ThreadGroup_t *g;\n\tchar   *file;\n\tint     line;\n{\n\tint     rc;\n\n\trc = _rf_create_managed_mutex(listp, &g->mutex, file, line);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_create_managed_cond(listp, &g->cond, file, line);\n\tif (rc)\n\t\treturn (rc);\n\tg->created = g->running = g->shutdown = 0;\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \n_rf_init_managed_threadgroup(listp, g, file, line)\n\tRF_ShutdownList_t **listp;\n\tRF_ThreadGroup_t *g;\n\tchar   *file;\n\tint     line;\n{\n\tint     rc;\n\n\trc = _rf_create_managed_mutex(listp, &g->mutex, file, line);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_create_managed_cond(listp, &g->cond, file, line);\n\tif (rc)\n\t\treturn (rc);\n\tg->created = g->running = g->shutdown = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_INIT",
          "args": [
            "listp",
            "raidPtr"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void rf_ShutdownEngine(void *);\n\nint \nrf_ConfigureEngine(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\tDO_INIT(listp, raidPtr);\n\n\traidPtr->node_queue = NULL;\n\traidPtr->dags_in_flight = 0;\n\n\trc = rf_init_managed_threadgroup(listp, &raidPtr->engine_tg);\n\tif (rc)\n\t\treturn (rc);\n\n\t/* we create the execution thread only once per system boot. no need\n\t * to check return code b/c the kernel panics if it can't create the\n\t * thread. */\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Creating engine thread\\n\", raidPtr->raidid);\n\t}\n\tif (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread, raidPtr,\"raid\")) {\n\t\tRF_ERRORMSG(\"RAIDFRAME: Unable to create engine thread\\n\");\n\t\treturn (ENOMEM);\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Created engine thread\\n\", raidPtr->raidid);\n\t}\n\tRF_THREADGROUP_STARTED(&raidPtr->engine_tg);\n\t/* XXX something is missing here... */\n#ifdef debug\n\tprintf(\"Skipping the WAIT_START!!\\n\");\n#endif\n#if 0\n\tRF_THREADGROUP_WAIT_START(&raidPtr->engine_tg);\n#endif\n\t/* engine thread is now running and waiting for work */\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Engine thread running and waiting for events\\n\", raidPtr->raidid);\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownEngine, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownEngine(NULL);\n\t}\n\treturn (rc);\n}"
  },
  {
    "function_name": "rf_ShutdownEngine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
    "lines": "96-105",
    "snippet": "static void \nrf_ShutdownEngine(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\traidPtr->shutdown_engine = 1;\n\tDO_SIGNAL(raidPtr);\n}",
    "includes": [
      "#include \"rf_raid.h\"",
      "#include \"rf_shutdown.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_dag.h\"",
      "#include <sys/errno.h>",
      "#include \"rf_threadstuff.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void DAGExecutionThread(RF_ThreadArg_t arg);",
      "static void rf_ShutdownEngine(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_SIGNAL",
          "args": [
            "raidPtr"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nstatic void DAGExecutionThread(RF_ThreadArg_t arg);\nstatic void rf_ShutdownEngine(void *);\n\nstatic void \nrf_ShutdownEngine(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\traidPtr->shutdown_engine = 1;\n\tDO_SIGNAL(raidPtr);\n}"
  }
]