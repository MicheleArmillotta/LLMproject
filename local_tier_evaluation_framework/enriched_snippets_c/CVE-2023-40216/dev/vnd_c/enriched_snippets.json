[
  {
    "function_name": "vndunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "1002-1012",
    "snippet": "static void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_LOCKED\t0x0080",
      "#define VNF_WANTED\t0x0040"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "static\tvoid vndunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tvoid vndunlock;\n\nstatic void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
  },
  {
    "function_name": "vndlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "984-997",
    "snippet": "static int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_LOCKED\t0x0080",
      "#define VNF_WANTED\t0x0040"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "static\tint vndlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "PRIBIO | PCATCH",
            "\"vndlck\"",
            "0"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tint vndlock;\n\nstatic int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}"
  },
  {
    "function_name": "vnddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "966-976",
    "snippet": "int\nvnddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nvnddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "vndsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "954-964",
    "snippet": "int\nvndsize(dev)\n\tdev_t dev;\n{\n\tint unit = vndunit(dev);\n\tregister struct vnd_softc *vnd = &vnd_softc[unit];\n\n\tif (unit >= numvnd || (vnd->sc_flags & VNF_INITED) == 0)\n\t\treturn(-1);\n\treturn(vnd->sc_size);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_INITED\t0x0002"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\n\nint\nvndsize(dev)\n\tdev_t dev;\n{\n\tint unit = vndunit(dev);\n\tregister struct vnd_softc *vnd = &vnd_softc[unit];\n\n\tif (unit >= numvnd || (vnd->sc_flags & VNF_INITED) == 0)\n\t\treturn(-1);\n\treturn(vnd->sc_size);\n}"
  },
  {
    "function_name": "vndclear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "933-952",
    "snippet": "void\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_INITED\t0x0002",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "void\tvndclear"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crfree",
          "args": [
            "vnd->sc_cred"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "vnd->sc_cred",
            "p"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"vndioctl: null vp\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndclear(%p): vp %p\\n\"",
            "vnd",
            "vp"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndclear;\n\nvoid\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}"
  },
  {
    "function_name": "vndshutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "923-931",
    "snippet": "void\nvndshutdown()\n{\n\tregister struct vnd_softc *vnd;\n\n\tfor (vnd = &vnd_softc[0]; vnd < &vnd_softc[numvnd]; vnd++)\n\t\tif (vnd->sc_flags & VNF_INITED)\n\t\t\tvndclear(vnd);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_INITED\t0x0002"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;",
      "void\tvndclear",
      "void\tvndshutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vndclear",
          "args": [
            "vnd"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "vndclear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "933-952",
          "snippet": "void\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_INITED\t0x0002",
            "#define VDB_FOLLOW\t0x01"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "void\tvndclear"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndclear;\n\nvoid\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\nvoid\tvndclear;\nvoid\tvndshutdown;\n\nvoid\nvndshutdown()\n{\n\tregister struct vnd_softc *vnd;\n\n\tfor (vnd = &vnd_softc[0]; vnd < &vnd_softc[numvnd]; vnd++)\n\t\tif (vnd->sc_flags & VNF_INITED)\n\t\t\tvndclear(vnd);\n}"
  },
  {
    "function_name": "vndthrottle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "905-921",
    "snippet": "void\nvndthrottle(vnd, vp)\n\tregister struct vnd_softc *vnd;\n\tstruct vnode *vp;\n{\n#ifdef NFSCLIENT\n\textern int (**nfsv2_vnodeop_p) __P((void *));\n\n\tif (vp->v_op == nfsv2_vnodeop_p)\n\t\tvnd->sc_maxactive = 2;\n\telse\n#endif\n\t\tvnd->sc_maxactive = 8;\n\n\tif (vnd->sc_maxactive < 1)\n\t\tvnd->sc_maxactive = 1;\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "__P((int));",
      "void\tvndthrottle",
      "__P((void));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\n__P((int));\nvoid\tvndthrottle;\n__P((void));\n\nvoid\nvndthrottle(vnd, vp)\n\tregister struct vnd_softc *vnd;\n\tstruct vnode *vp;\n{\n#ifdef NFSCLIENT\n\textern int (**nfsv2_vnodeop_p) __P((void *));\n\n\tif (vp->v_op == nfsv2_vnodeop_p)\n\t\tvnd->sc_maxactive = 2;\n\telse\n#endif\n\t\tvnd->sc_maxactive = 8;\n\n\tif (vnd->sc_maxactive < 1)\n\t\tvnd->sc_maxactive = 1;\n}"
  },
  {
    "function_name": "vndsetcred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "871-900",
    "snippet": "int\nvndsetcred(vnd, cred)\n\tregister struct vnd_softc *vnd;\n\tstruct ucred *cred;\n{\n\tstruct uio auio;\n\tstruct iovec aiov;\n\tchar *tmpbuf;\n\tint error;\n\tstruct proc *p = curproc;\n\n\tvnd->sc_cred = crdup(cred);\n\ttmpbuf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);\n\n\t/* XXX: Horrible kludge to establish credentials for NFS */\n\taiov.iov_base = tmpbuf;\n\taiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_offset = 0;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = aiov.iov_len;\n\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\terror = VOP_READ(vnd->sc_vp, &auio, 0, vnd->sc_cred);\n\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\n\tfree(tmpbuf, M_TEMP);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int\tvndsetcred"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmpbuf",
            "M_TEMP"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vnd->sc_vp",
            "0",
            "p"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_READ",
          "args": [
            "vnd->sc_vp",
            "&auio",
            "0",
            "vnd->sc_cred"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_lock",
          "args": [
            "vnd->sc_vp",
            "LK_RETRY | LK_EXCLUSIVE",
            "p"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "DEV_BSIZE",
            "dbtob(vnd->sc_size)"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "vnd->sc_size"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "DEV_BSIZE",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "crdup",
          "args": [
            "cred"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\nint\tvndsetcred;\n\nint\nvndsetcred(vnd, cred)\n\tregister struct vnd_softc *vnd;\n\tstruct ucred *cred;\n{\n\tstruct uio auio;\n\tstruct iovec aiov;\n\tchar *tmpbuf;\n\tint error;\n\tstruct proc *p = curproc;\n\n\tvnd->sc_cred = crdup(cred);\n\ttmpbuf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);\n\n\t/* XXX: Horrible kludge to establish credentials for NFS */\n\taiov.iov_base = tmpbuf;\n\taiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_offset = 0;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = aiov.iov_len;\n\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\terror = VOP_READ(vnd->sc_vp, &auio, 0, vnd->sc_cred);\n\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\n\tfree(tmpbuf, M_TEMP);\n\treturn (error);\n}"
  },
  {
    "function_name": "vndioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "688-863",
    "snippet": "int\nvndioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tregister struct vnd_softc *vnd;\n\tstruct vnd_ioctl *vio;\n\tstruct vattr vattr;\n\tstruct nameidata nd;\n\tint error, part, pmask, s;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndioctl(%x, %lx, %p, %x, %p): unit %d\\n\",\n\t\t    dev, cmd, addr, flag, p, unit);\n#endif\n\terror = suser(p->p_ucred, &p->p_acflag);\n\tif (error)\n\t\treturn (error);\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\n\tvnd = &vnd_softc[unit];\n\tvio = (struct vnd_ioctl *)addr;\n\tswitch (cmd) {\n\n\tcase VNDIOCSET:\n\t\tif (vnd->sc_flags & VNF_INITED)\n\t\t\treturn (EBUSY);\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Always open for read and write.\n\t\t * This is probably bogus, but it lets vn_open()\n\t\t * weed out directories, sockets, etc. so we don't\n\t\t * have to worry about them.\n\t\t */\n\t\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, vio->vnd_file, p);\n\t\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\terror = VOP_GETATTR(nd.ni_vp, &vattr, p->p_ucred, p);\n\t\tif (error) {\n\t\t\tVOP_UNLOCK(nd.ni_vp, 0, p);\n\t\t\t(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\tVOP_UNLOCK(nd.ni_vp, 0, p);\n\t\tvnd->sc_vp = nd.ni_vp;\n\t\tvnd->sc_size = btodb(vattr.va_size);\t/* note truncation */\n\t\tif ((error = vndsetcred(vnd, p->p_ucred)) != 0) {\n\t\t\t(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\tvndthrottle(vnd, vnd->sc_vp);\n\t\tvio->vnd_size = dbtob(vnd->sc_size);\n\t\tvnd->sc_flags |= VNF_INITED;\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_INIT)\n\t\t\tprintf(\"vndioctl: SET vp %p size %x\\n\",\n\t\t\t    vnd->sc_vp, vnd->sc_size);\n#endif\n\n\t\t/* Attach the disk. */\n\t\tbzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));\n\t\tsprintf(vnd->sc_dev.dv_xname, \"vnd%d\", unit);\n\t\tvnd->sc_dk.dk_driver = &vnddkdriver;\n\t\tvnd->sc_dk.dk_name = vnd->sc_dev.dv_xname;\n\t\tdisk_attach(&vnd->sc_dk);\n\t\tdk_establish(&vnd->sc_dk, &vnd->sc_dev);\n\n\t\tvndunlock(vnd);\n\n\t\tbreak;\n\n\tcase VNDIOCCLR:\n\t\tif ((vnd->sc_flags & VNF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Don't unconfigure if any other partitions are open\n\t\t * or if both the character and block flavors of this\n\t\t * partition are open.\n\t\t */\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((vnd->sc_dk.dk_openmask & ~pmask) ||\n\t\t    ((vnd->sc_dk.dk_bopenmask & pmask) &&\n\t\t    (vnd->sc_dk.dk_copenmask & pmask))) {\n\t\t\tvndunlock(vnd);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\tvndclear(vnd);\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_INIT)\n\t\t\tprintf(\"vndioctl: CLRed\\n\");\n#endif\n\n\t\t/* Detatch the disk. */\n\t\tdisk_detach(&vnd->sc_dk);\n\n\t\t/* This must be atomic. */\n\t\ts = splhigh();\n\t\tvndunlock(vnd);\n\t\tbzero(vnd, sizeof(struct vnd_softc));\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase DIOCGDINFO:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\t*(struct disklabel *)addr = *(vnd->sc_dk.dk_label);\n\t\treturn 0;\n\n\tcase DIOCGPART:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\t((struct partinfo *)addr)->disklab = vnd->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &vnd->sc_dk.dk_label->d_partitions[DISKPART(dev)];\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn error;\n\t\tvnd->sc_flags |= VNF_LABELLING;\n\n\t\terror = setdisklabel(vnd->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*vnd->sc_dk.dk_openmask : */0,\n\t\t    vnd->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(MAKEDISKDEV(major(dev),\n\t\t\t\t    DISKUNIT(dev), RAW_PART),\n\t\t\t\t    vndstrategy, vnd->sc_dk.dk_label,\n\t\t\t\t    vnd->sc_dk.dk_cpulabel);\n\t\t}\n\n\t\tvnd->sc_flags &= ~VNF_LABELLING;\n\t\tvndunlock(vnd);\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\tif (*(int *)addr)\n\t\t\tvnd->sc_flags |= VNF_WLABEL;\n\t\telse\n\t\t\tvnd->sc_flags &= ~VNF_WLABEL;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tVNF_HAVELABEL\t0x0400",
      "#define\tVNF_WLABEL\t0x0200",
      "#define\tVNF_LABELLING\t0x0100",
      "#define VNF_INITED\t0x0002",
      "#define VDB_INIT\t0x02",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;",
      "struct dkdriver vnddkdriver = { vndstrategy };",
      "void\tvndclear",
      "int\tvndsetcred",
      "void\tvndthrottle",
      "static\tint vndlock",
      "static\tvoid vndunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vndunlock",
          "args": [
            "vnd"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "vndunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "1002-1012",
          "snippet": "static void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tvoid vndunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tvoid vndunlock;\n\nstatic void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "MAKEDISKDEV(major(dev),\n\t\t\t\t    DISKUNIT(dev), RAW_PART)",
            "vndstrategy",
            "vnd->sc_dk.dk_label",
            "vnd->sc_dk.dk_cpulabel"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEDISKDEV",
          "args": [
            "major(dev)",
            "DISKUNIT(dev)",
            "RAW_PART"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "vnd->sc_dk.dk_label",
            "(struct disklabel *)addr",
            "/*vnd->sc_dk.dk_openmask : */0",
            "vnd->sc_dk.dk_cpulabel"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndlock",
          "args": [
            "vnd"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "vndlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "984-997",
          "snippet": "static int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tint vndlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tint vndlock;\n\nstatic int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "vnd",
            "sizeof(struct vnd_softc)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_detach",
          "args": [
            "&vnd->sc_dk"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndioctl: CLRed\\n\""
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndclear",
          "args": [
            "vnd"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "vndclear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "933-952",
          "snippet": "void\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_INITED\t0x0002",
            "#define VDB_FOLLOW\t0x01"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "void\tvndclear"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndclear;\n\nvoid\nvndclear(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct vnode *vp = vnd->sc_vp;\n\tstruct proc *p = curproc;\t\t/* XXX */\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclear(%p): vp %p\\n\", vnd, vp);\n#endif\n\tvnd->sc_flags &= ~VNF_INITED;\n\tif (vp == (struct vnode *)0)\n\t\tpanic(\"vndioctl: null vp\");\n\t(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);\n\tcrfree(vnd->sc_cred);\n\tvnd->sc_vp = (struct vnode *)0;\n\tvnd->sc_cred = (struct ucred *)0;\n\tvnd->sc_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dk_establish",
          "args": [
            "&vnd->sc_dk",
            "&vnd->sc_dev"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&vnd->sc_dk"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "vnd->sc_dev.dv_xname",
            "\"vnd%d\"",
            "unit"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "vnd->sc_dev.dv_xname",
            "sizeof(vnd->sc_dev.dv_xname)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "vnd->sc_size"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndthrottle",
          "args": [
            "vnd",
            "vnd->sc_vp"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "vndthrottle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "905-921",
          "snippet": "void\nvndthrottle(vnd, vp)\n\tregister struct vnd_softc *vnd;\n\tstruct vnode *vp;\n{\n#ifdef NFSCLIENT\n\textern int (**nfsv2_vnodeop_p) __P((void *));\n\n\tif (vp->v_op == nfsv2_vnodeop_p)\n\t\tvnd->sc_maxactive = 2;\n\telse\n#endif\n\t\tvnd->sc_maxactive = 8;\n\n\tif (vnd->sc_maxactive < 1)\n\t\tvnd->sc_maxactive = 1;\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "__P((int));",
            "void\tvndthrottle",
            "__P((void));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\n__P((int));\nvoid\tvndthrottle;\n__P((void));\n\nvoid\nvndthrottle(vnd, vp)\n\tregister struct vnd_softc *vnd;\n\tstruct vnode *vp;\n{\n#ifdef NFSCLIENT\n\textern int (**nfsv2_vnodeop_p) __P((void *));\n\n\tif (vp->v_op == nfsv2_vnodeop_p)\n\t\tvnd->sc_maxactive = 2;\n\telse\n#endif\n\t\tvnd->sc_maxactive = 8;\n\n\tif (vnd->sc_maxactive < 1)\n\t\tvnd->sc_maxactive = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "nd.ni_vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndsetcred",
          "args": [
            "vnd",
            "p->p_ucred"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "vndsetcred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "871-900",
          "snippet": "int\nvndsetcred(vnd, cred)\n\tregister struct vnd_softc *vnd;\n\tstruct ucred *cred;\n{\n\tstruct uio auio;\n\tstruct iovec aiov;\n\tchar *tmpbuf;\n\tint error;\n\tstruct proc *p = curproc;\n\n\tvnd->sc_cred = crdup(cred);\n\ttmpbuf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);\n\n\t/* XXX: Horrible kludge to establish credentials for NFS */\n\taiov.iov_base = tmpbuf;\n\taiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_offset = 0;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = aiov.iov_len;\n\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\terror = VOP_READ(vnd->sc_vp, &auio, 0, vnd->sc_cred);\n\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\n\tfree(tmpbuf, M_TEMP);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "int\tvndsetcred"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\nint\tvndsetcred;\n\nint\nvndsetcred(vnd, cred)\n\tregister struct vnd_softc *vnd;\n\tstruct ucred *cred;\n{\n\tstruct uio auio;\n\tstruct iovec aiov;\n\tchar *tmpbuf;\n\tint error;\n\tstruct proc *p = curproc;\n\n\tvnd->sc_cred = crdup(cred);\n\ttmpbuf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);\n\n\t/* XXX: Horrible kludge to establish credentials for NFS */\n\taiov.iov_base = tmpbuf;\n\taiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_offset = 0;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = aiov.iov_len;\n\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\terror = VOP_READ(vnd->sc_vp, &auio, 0, vnd->sc_cred);\n\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\n\tfree(tmpbuf, M_TEMP);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btodb",
          "args": [
            "vattr.va_size"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "nd.ni_vp",
            "0",
            "p"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "nd.ni_vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "nd.ni_vp",
            "0",
            "p"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "nd.ni_vp",
            "&vattr",
            "p->p_ucred",
            "p"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_open",
          "args": [
            "&nd",
            "FREAD|FWRITE",
            "0"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDINIT",
          "args": [
            "&nd",
            "LOOKUP",
            "FOLLOW",
            "UIO_USERSPACE",
            "vio->vnd_file",
            "p"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tVNF_HAVELABEL\t0x0400\n#define\tVNF_WLABEL\t0x0200\n#define\tVNF_LABELLING\t0x0100\n#define VNF_INITED\t0x0002\n#define VDB_INIT\t0x02\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\nstruct dkdriver vnddkdriver = { vndstrategy };\nvoid\tvndclear;\nint\tvndsetcred;\nvoid\tvndthrottle;\nstatic\tint vndlock;\nstatic\tvoid vndunlock;\n\nint\nvndioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tregister struct vnd_softc *vnd;\n\tstruct vnd_ioctl *vio;\n\tstruct vattr vattr;\n\tstruct nameidata nd;\n\tint error, part, pmask, s;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndioctl(%x, %lx, %p, %x, %p): unit %d\\n\",\n\t\t    dev, cmd, addr, flag, p, unit);\n#endif\n\terror = suser(p->p_ucred, &p->p_acflag);\n\tif (error)\n\t\treturn (error);\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\n\tvnd = &vnd_softc[unit];\n\tvio = (struct vnd_ioctl *)addr;\n\tswitch (cmd) {\n\n\tcase VNDIOCSET:\n\t\tif (vnd->sc_flags & VNF_INITED)\n\t\t\treturn (EBUSY);\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Always open for read and write.\n\t\t * This is probably bogus, but it lets vn_open()\n\t\t * weed out directories, sockets, etc. so we don't\n\t\t * have to worry about them.\n\t\t */\n\t\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, vio->vnd_file, p);\n\t\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\terror = VOP_GETATTR(nd.ni_vp, &vattr, p->p_ucred, p);\n\t\tif (error) {\n\t\t\tVOP_UNLOCK(nd.ni_vp, 0, p);\n\t\t\t(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\tVOP_UNLOCK(nd.ni_vp, 0, p);\n\t\tvnd->sc_vp = nd.ni_vp;\n\t\tvnd->sc_size = btodb(vattr.va_size);\t/* note truncation */\n\t\tif ((error = vndsetcred(vnd, p->p_ucred)) != 0) {\n\t\t\t(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);\n\t\t\tvndunlock(vnd);\n\t\t\treturn(error);\n\t\t}\n\t\tvndthrottle(vnd, vnd->sc_vp);\n\t\tvio->vnd_size = dbtob(vnd->sc_size);\n\t\tvnd->sc_flags |= VNF_INITED;\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_INIT)\n\t\t\tprintf(\"vndioctl: SET vp %p size %x\\n\",\n\t\t\t    vnd->sc_vp, vnd->sc_size);\n#endif\n\n\t\t/* Attach the disk. */\n\t\tbzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));\n\t\tsprintf(vnd->sc_dev.dv_xname, \"vnd%d\", unit);\n\t\tvnd->sc_dk.dk_driver = &vnddkdriver;\n\t\tvnd->sc_dk.dk_name = vnd->sc_dev.dv_xname;\n\t\tdisk_attach(&vnd->sc_dk);\n\t\tdk_establish(&vnd->sc_dk, &vnd->sc_dev);\n\n\t\tvndunlock(vnd);\n\n\t\tbreak;\n\n\tcase VNDIOCCLR:\n\t\tif ((vnd->sc_flags & VNF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Don't unconfigure if any other partitions are open\n\t\t * or if both the character and block flavors of this\n\t\t * partition are open.\n\t\t */\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((vnd->sc_dk.dk_openmask & ~pmask) ||\n\t\t    ((vnd->sc_dk.dk_bopenmask & pmask) &&\n\t\t    (vnd->sc_dk.dk_copenmask & pmask))) {\n\t\t\tvndunlock(vnd);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\tvndclear(vnd);\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_INIT)\n\t\t\tprintf(\"vndioctl: CLRed\\n\");\n#endif\n\n\t\t/* Detatch the disk. */\n\t\tdisk_detach(&vnd->sc_dk);\n\n\t\t/* This must be atomic. */\n\t\ts = splhigh();\n\t\tvndunlock(vnd);\n\t\tbzero(vnd, sizeof(struct vnd_softc));\n\t\tsplx(s);\n\t\tbreak;\n\n\tcase DIOCGDINFO:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\t*(struct disklabel *)addr = *(vnd->sc_dk.dk_label);\n\t\treturn 0;\n\n\tcase DIOCGPART:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\t((struct partinfo *)addr)->disklab = vnd->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &vnd->sc_dk.dk_label->d_partitions[DISKPART(dev)];\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((vnd->sc_flags & VNF_HAVELABEL) == 0)\n\t\t\treturn (ENOTTY);\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\tif ((error = vndlock(vnd)) != 0)\n\t\t\treturn error;\n\t\tvnd->sc_flags |= VNF_LABELLING;\n\n\t\terror = setdisklabel(vnd->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*vnd->sc_dk.dk_openmask : */0,\n\t\t    vnd->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(MAKEDISKDEV(major(dev),\n\t\t\t\t    DISKUNIT(dev), RAW_PART),\n\t\t\t\t    vndstrategy, vnd->sc_dk.dk_label,\n\t\t\t\t    vnd->sc_dk.dk_cpulabel);\n\t\t}\n\n\t\tvnd->sc_flags &= ~VNF_LABELLING;\n\t\tvndunlock(vnd);\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\tif (*(int *)addr)\n\t\t\tvnd->sc_flags |= VNF_WLABEL;\n\t\telse\n\t\t\tvnd->sc_flags &= ~VNF_WLABEL;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "vndwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "663-685",
    "snippet": "int\nvndwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndwrite(%x, %p)\\n\", dev, uio);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((sc->sc_flags & VNF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\treturn (physio(vndstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_INITED\t0x0002",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "vndstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndwrite(%x, %p)\\n\"",
            "dev",
            "uio"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\n\nint\nvndwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndwrite(%x, %p)\\n\", dev, uio);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((sc->sc_flags & VNF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\treturn (physio(vndstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "vndread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "638-660",
    "snippet": "int\nvndread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndread(%x, %p)\\n\", dev, uio);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((sc->sc_flags & VNF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\treturn (physio(vndstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_INITED\t0x0002",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "vndstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndread(%x, %p)\\n\"",
            "dev",
            "uio"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\n\nint\nvndread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndread(%x, %p)\\n\", dev, uio);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((sc->sc_flags & VNF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\treturn (physio(vndstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "vndiodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "594-635",
    "snippet": "void\nvndiodone(bp)\n\tstruct buf *bp;\n{\n\tregister struct vndbuf *vbp = (struct vndbuf *) bp;\n\tregister struct buf *pbp = vbp->vb_obp;\n\tregister struct vnd_softc *vnd = &vnd_softc[vndunit(pbp->b_dev)];\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndiodone(%d): vbp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, vbp, vbp->vb_buf.b_vp, vbp->vb_buf.b_blkno,\n\t\t    vbp->vb_buf.b_data, vbp->vb_buf.b_bcount);\n#endif\n\n\tif (vbp->vb_buf.b_error) {\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndiodone: vbp %p error %d\\n\", vbp,\n\t\t\t    vbp->vb_buf.b_error);\n#endif\n\t\tpbp->b_flags |= B_ERROR;\n\t\tpbp->b_error = biowait(&vbp->vb_buf);\n\t}\n\tpbp->b_resid -= vbp->vb_buf.b_bcount;\n\tputvndbuf(vbp);\n\tdisk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid));\n\tif (pbp->b_resid == 0) {\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndiodone: pbp %p iodone\\n\", pbp);\n#endif\n\t\tbiodone(pbp);\n\t}\n\tif (vnd->sc_tab.b_actf)\n\t\tvndstart(vnd);\n\telse\n\t\tvnd->sc_tab.b_active--;\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VDB_IO\t\t0x04"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "void\tvndstart",
      "void\tvndiodone"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndstart",
          "args": [
            "vnd"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "vndstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "567-592",
          "snippet": "void\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VDB_IO\t\t0x04"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "void\tvndstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VDB_IO\t\t0x04\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndstart;\n\nvoid\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "pbp"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndiodone: pbp %p iodone\\n\"",
            "pbp"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&vnd->sc_dk",
            "(pbp->b_bcount - pbp->b_resid)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putvndbuf",
          "args": [
            "vbp"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biowait",
          "args": [
            "&vbp->vb_buf"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "pbp->b_dev"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VDB_IO\t\t0x04\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndstart;\nvoid\tvndiodone;\n\nvoid\nvndiodone(bp)\n\tstruct buf *bp;\n{\n\tregister struct vndbuf *vbp = (struct vndbuf *) bp;\n\tregister struct buf *pbp = vbp->vb_obp;\n\tregister struct vnd_softc *vnd = &vnd_softc[vndunit(pbp->b_dev)];\n\tint s;\n\n\ts = splbio();\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndiodone(%d): vbp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, vbp, vbp->vb_buf.b_vp, vbp->vb_buf.b_blkno,\n\t\t    vbp->vb_buf.b_data, vbp->vb_buf.b_bcount);\n#endif\n\n\tif (vbp->vb_buf.b_error) {\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndiodone: vbp %p error %d\\n\", vbp,\n\t\t\t    vbp->vb_buf.b_error);\n#endif\n\t\tpbp->b_flags |= B_ERROR;\n\t\tpbp->b_error = biowait(&vbp->vb_buf);\n\t}\n\tpbp->b_resid -= vbp->vb_buf.b_bcount;\n\tputvndbuf(vbp);\n\tdisk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid));\n\tif (pbp->b_resid == 0) {\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndiodone: pbp %p iodone\\n\", pbp);\n#endif\n\t\tbiodone(pbp);\n\t}\n\tif (vnd->sc_tab.b_actf)\n\t\tvndstart(vnd);\n\telse\n\t\tvnd->sc_tab.b_active--;\n\tsplx(s);\n}"
  },
  {
    "function_name": "vndstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "567-592",
    "snippet": "void\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VDB_IO\t\t0x04"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "void\tvndstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VOP_STRATEGY",
          "args": [
            "bp"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&vnd->sc_dk"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\"",
            "vnd-vnd_softc",
            "bp",
            "bp->b_vp",
            "bp->b_blkno",
            "bp->b_data",
            "bp->b_bcount"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VDB_IO\t\t0x04\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndstart;\n\nvoid\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}"
  },
  {
    "function_name": "vndstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "360-559",
    "snippet": "void\nvndstrategy(bp)\n\tregister struct buf *bp;\n{\n\tint unit = vndunit(bp->b_dev);\n\tregister struct vnd_softc *vnd = &vnd_softc[unit];\n\tregister struct vndbuf *nbp;\n\tregister int bn, bsize;\n\tregister caddr_t addr;\n\tregister size_t resid;\n\tint sz, flags, error, s;\n\tstruct iovec aiov;\n\tstruct uio auio;\n\tstruct proc *p = curproc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndstrategy(%p): unit %d\\n\", bp, unit);\n#endif\n\tif ((vnd->sc_flags & VNF_INITED) == 0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\n\tbn = bp->b_blkno;\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\tbp->b_resid = bp->b_bcount;\n\tif (bn < 0) {\n\t\tbp->b_error = EINVAL;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tif (DISKPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, vnd->sc_dk.dk_label,\n\t    vnd->sc_dk.dk_cpulabel, 1) == 0) {\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\n\t/* No bypassing of buffer cache?  */\n\tif (vndsimple(bp->b_dev)) {\n\t\t/*\n\t\t * In order to avoid \"locking against myself\" panics, we\n\t\t * must be prepared to queue operations during another I/O\n\t\t * operation.  This situation comes up where a dirty cache\n\t\t * buffer needs to be flushed in order to provide the current\n\t\t * operation with a fresh buffer.\n\t\t *\n\t\t * XXX do we really need to protect stuff relating to this with\n\t\t * splbio?\n\t\t */\n\t\tif (vnd->sc_flags & VNF_BUSY) {\n\t\t\ts = splbio();\n\t\t\tbp->b_actf = vnd->sc_tab.b_actf;\n\t\t\tvnd->sc_tab.b_actf = bp;\n\t\t\tvnd->sc_tab.b_active++;\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Loop until all queued requests are handled.  */\n\t\tfor (;;) {\n\t\t\tint part = DISKPART(bp->b_dev);\n\t\t\tint off = vnd->sc_dk.dk_label->d_partitions[part].p_offset;\n\n\t\t\taiov.iov_base = bp->b_data;\n\t\t\tauio.uio_resid = aiov.iov_len = bp->b_bcount;\n\t\t\tauio.uio_iov = &aiov;\n\t\t\tauio.uio_iovcnt = 1;\n\t\t\tauio.uio_offset = dbtob(bp->b_blkno + off);\n\t\t\tauio.uio_segflg = UIO_SYSSPACE;\n\t\t\tauio.uio_procp = NULL;\n\n\t\t\tvn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);\n\t\t\tvnd->sc_flags |= VNF_BUSY;\n\t\t\tif (bp->b_flags & B_READ) {\n\t\t\t\tauio.uio_rw = UIO_READ;\n\t\t\t\tbp->b_error = VOP_READ(vnd->sc_vp, &auio, 0,\n\t\t\t\t    vnd->sc_cred);\n\t\t\t} else {\n\t\t\t\tauio.uio_rw = UIO_WRITE;\n\t\t\t\tbp->b_error = VOP_WRITE(vnd->sc_vp, &auio, 0,\n\t\t\t\t    vnd->sc_cred);\n\t\t\t}\n\t\t\tvnd->sc_flags &= ~VNF_BUSY;\n\t\t\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\t\t\tif (bp->b_error)\n\t\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = auio.uio_resid;\n\t\t\tbiodone(bp);\n\n\t\t\t/* If nothing more is queued, we are done.  */\n\t\t\tif (!vnd->sc_tab.b_active)\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Dequeue now since lower level strategy\n\t\t\t * routine might queue using same links.\n\t\t\t */\n\t\t\ts = splbio();\n\t\t\tbp = vnd->sc_tab.b_actf;\n\t\t\tvnd->sc_tab.b_actf = bp->b_actf;\n\t\t\tvnd->sc_tab.b_active--;\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\t/* The old-style buffercache bypassing method.  */\n\tbn += vnd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)].p_offset;\n\tbn = dbtob(bn);\n \tbsize = vnd->sc_vp->v_mount->mnt_stat.f_iosize;\n\taddr = bp->b_data;\n\tflags = bp->b_flags | B_CALL;\n\tfor (resid = bp->b_resid; resid; resid -= sz) {\n\t\tstruct vnode *vp;\n\t\tdaddr_t nbn;\n\t\tint off, s, nra;\n\n\t\tnra = 0;\n\t\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\t\terror = VOP_BMAP(vnd->sc_vp, bn / bsize, &vp, &nbn, &nra);\n\t\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\t\tif (error == 0 && (long)nbn == -1)\n\t\t\terror = EIO;\n#ifdef DEBUG\n\t\tif (!dovndcluster)\n\t\t\tnra = 0;\n#endif\n\n\t\tif ((off = bn % bsize) != 0)\n\t\t\tsz = bsize - off;\n\t\telse\n\t\t\tsz = (1 + nra) * bsize;\n\t\tif (resid < sz)\n\t\t\tsz = resid;\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndstrategy: vp %p/%p bn %x/%x sz %x\\n\",\n\t\t\t       vnd->sc_vp, vp, bn, nbn, sz);\n#endif\n\n\t\tnbp = getvndbuf();\n\t\tnbp->vb_buf.b_flags = flags;\n\t\tnbp->vb_buf.b_bcount = sz;\n\t\tnbp->vb_buf.b_bufsize = bp->b_bufsize;\n\t\tnbp->vb_buf.b_error = 0;\n\t\tif (vp->v_type == VBLK || vp->v_type == VCHR)\n\t\t\tnbp->vb_buf.b_dev = vp->v_rdev;\n\t\telse\n\t\t\tnbp->vb_buf.b_dev = NODEV;\n\t\tnbp->vb_buf.b_data = addr;\n\t\tnbp->vb_buf.b_blkno = nbn + btodb(off);\n\t\tnbp->vb_buf.b_proc = bp->b_proc;\n\t\tnbp->vb_buf.b_iodone = vndiodone;\n\t\tnbp->vb_buf.b_vp = vp;\n\t\tnbp->vb_buf.b_rcred = vnd->sc_cred;\t/* XXX crdup? */\n\t\tnbp->vb_buf.b_wcred = vnd->sc_cred;\t/* XXX crdup? */\n\t\tnbp->vb_buf.b_dirtyoff = bp->b_dirtyoff;\n\t\tnbp->vb_buf.b_dirtyend = bp->b_dirtyend;\n\t\tnbp->vb_buf.b_validoff = bp->b_validoff;\n\t\tnbp->vb_buf.b_validend = bp->b_validend;\n\t\tLIST_INIT(&nbp->vb_buf.b_dep);\n\n\t\t/* save a reference to the old buffer */\n\t\tnbp->vb_obp = bp;\n\n\t\t/*\n\t\t * If there was an error or a hole in the file...punt.\n\t\t * Note that we deal with this after the nbp allocation.\n\t\t * This ensures that we properly clean up any operations\n\t\t * that we have already fired off.\n\t\t *\n\t\t * XXX we could deal with holes here but it would be\n\t\t * a hassle (in the write case).\n\t\t */\n\t\tif (error) {\n\t\t\tnbp->vb_buf.b_error = error;\n\t\t\tnbp->vb_buf.b_flags |= B_ERROR;\n\t\t\tbp->b_resid -= (resid - sz);\n\t\t\tbiodone(&nbp->vb_buf);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Just sort by block number\n\t\t */\n\t\tnbp->vb_buf.b_cylin = nbp->vb_buf.b_blkno;\n\t\ts = splbio();\n\t\tdisksort(&vnd->sc_tab, &nbp->vb_buf);\n\t\tif (vnd->sc_tab.b_active < vnd->sc_maxactive) {\n\t\t\tvnd->sc_tab.b_active++;\n\t\t\tvndstart(vnd);\n\t\t}\n\t\tsplx(s);\n\t\tbn += sz;\n\t\taddr += sz;\n\t}\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_BUSY\t0x0800",
      "#define VNF_INITED\t0x0002",
      "#define b_cylin\tb_resid",
      "#define VDB_IO\t\t0x04",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "void\tvndstart",
      "void\tvndiodone"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndstart",
          "args": [
            "vnd"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "vndstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "567-592",
          "snippet": "void\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VDB_IO\t\t0x04"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "void\tvndstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VDB_IO\t\t0x04\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndstart;\n\nvoid\nvndstart(vnd)\n\tregister struct vnd_softc *vnd;\n{\n\tregister struct buf *bp;\n\n\t/*\n\t * Dequeue now since lower level strategy routine might\n\t * queue using same links\n\t */\n\tbp = vnd->sc_tab.b_actf;\n\tvnd->sc_tab.b_actf = bp->b_actf;\n#ifdef DEBUG\n\tif (vnddebug & VDB_IO)\n\t\tprintf(\"vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\\n\",\n\t\t    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,\n\t\t    bp->b_bcount);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&vnd->sc_dk);\n\n\tif ((bp->b_flags & B_READ) == 0)\n\t\tbp->b_vp->v_numoutput++;\n\tVOP_STRATEGY(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disksort",
          "args": [
            "&vnd->sc_tab",
            "&nbp->vb_buf"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "&nbp->vb_buf"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&nbp->vb_buf.b_dep"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btodb",
          "args": [
            "off"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getvndbuf",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndstrategy: vp %p/%p bn %x/%x sz %x\\n\"",
            "vnd->sc_vp",
            "vp",
            "bn",
            "nbn",
            "sz"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vnd->sc_vp",
            "0",
            "p"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_BMAP",
          "args": [
            "vnd->sc_vp",
            "bn / bsize",
            "&vp",
            "&nbn",
            "&nra"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_lock",
          "args": [
            "vnd->sc_vp",
            "LK_RETRY | LK_EXCLUSIVE",
            "p"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "bn"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vnd->sc_vp",
            "0",
            "p"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_WRITE",
          "args": [
            "vnd->sc_vp",
            "&auio",
            "0",
            "vnd->sc_cred"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_READ",
          "args": [
            "vnd->sc_vp",
            "&auio",
            "0",
            "vnd->sc_cred"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_lock",
          "args": [
            "vnd->sc_vp",
            "LK_EXCLUSIVE | LK_RETRY",
            "p"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "bp->b_blkno + off"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndsimple",
          "args": [
            "bp->b_dev"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "vnd->sc_dk.dk_label",
            "vnd->sc_dk.dk_cpulabel",
            "1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "bp->b_bcount",
            "DEV_BSIZE"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "bp->b_dev"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_BUSY\t0x0800\n#define VNF_INITED\t0x0002\n#define b_cylin\tb_resid\n#define VDB_IO\t\t0x04\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndstart;\nvoid\tvndiodone;\n\nvoid\nvndstrategy(bp)\n\tregister struct buf *bp;\n{\n\tint unit = vndunit(bp->b_dev);\n\tregister struct vnd_softc *vnd = &vnd_softc[unit];\n\tregister struct vndbuf *nbp;\n\tregister int bn, bsize;\n\tregister caddr_t addr;\n\tregister size_t resid;\n\tint sz, flags, error, s;\n\tstruct iovec aiov;\n\tstruct uio auio;\n\tstruct proc *p = curproc;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndstrategy(%p): unit %d\\n\", bp, unit);\n#endif\n\tif ((vnd->sc_flags & VNF_INITED) == 0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\n\tbn = bp->b_blkno;\n\tsz = howmany(bp->b_bcount, DEV_BSIZE);\n\tbp->b_resid = bp->b_bcount;\n\tif (bn < 0) {\n\t\tbp->b_error = EINVAL;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\tif (DISKPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, vnd->sc_dk.dk_label,\n\t    vnd->sc_dk.dk_cpulabel, 1) == 0) {\n\t\tbiodone(bp);\n\t\treturn;\n\t}\n\n\t/* No bypassing of buffer cache?  */\n\tif (vndsimple(bp->b_dev)) {\n\t\t/*\n\t\t * In order to avoid \"locking against myself\" panics, we\n\t\t * must be prepared to queue operations during another I/O\n\t\t * operation.  This situation comes up where a dirty cache\n\t\t * buffer needs to be flushed in order to provide the current\n\t\t * operation with a fresh buffer.\n\t\t *\n\t\t * XXX do we really need to protect stuff relating to this with\n\t\t * splbio?\n\t\t */\n\t\tif (vnd->sc_flags & VNF_BUSY) {\n\t\t\ts = splbio();\n\t\t\tbp->b_actf = vnd->sc_tab.b_actf;\n\t\t\tvnd->sc_tab.b_actf = bp;\n\t\t\tvnd->sc_tab.b_active++;\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Loop until all queued requests are handled.  */\n\t\tfor (;;) {\n\t\t\tint part = DISKPART(bp->b_dev);\n\t\t\tint off = vnd->sc_dk.dk_label->d_partitions[part].p_offset;\n\n\t\t\taiov.iov_base = bp->b_data;\n\t\t\tauio.uio_resid = aiov.iov_len = bp->b_bcount;\n\t\t\tauio.uio_iov = &aiov;\n\t\t\tauio.uio_iovcnt = 1;\n\t\t\tauio.uio_offset = dbtob(bp->b_blkno + off);\n\t\t\tauio.uio_segflg = UIO_SYSSPACE;\n\t\t\tauio.uio_procp = NULL;\n\n\t\t\tvn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);\n\t\t\tvnd->sc_flags |= VNF_BUSY;\n\t\t\tif (bp->b_flags & B_READ) {\n\t\t\t\tauio.uio_rw = UIO_READ;\n\t\t\t\tbp->b_error = VOP_READ(vnd->sc_vp, &auio, 0,\n\t\t\t\t    vnd->sc_cred);\n\t\t\t} else {\n\t\t\t\tauio.uio_rw = UIO_WRITE;\n\t\t\t\tbp->b_error = VOP_WRITE(vnd->sc_vp, &auio, 0,\n\t\t\t\t    vnd->sc_cred);\n\t\t\t}\n\t\t\tvnd->sc_flags &= ~VNF_BUSY;\n\t\t\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\t\t\tif (bp->b_error)\n\t\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_resid = auio.uio_resid;\n\t\t\tbiodone(bp);\n\n\t\t\t/* If nothing more is queued, we are done.  */\n\t\t\tif (!vnd->sc_tab.b_active)\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Dequeue now since lower level strategy\n\t\t\t * routine might queue using same links.\n\t\t\t */\n\t\t\ts = splbio();\n\t\t\tbp = vnd->sc_tab.b_actf;\n\t\t\tvnd->sc_tab.b_actf = bp->b_actf;\n\t\t\tvnd->sc_tab.b_active--;\n\t\t\tsplx(s);\n\t\t}\n\t}\n\n\t/* The old-style buffercache bypassing method.  */\n\tbn += vnd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)].p_offset;\n\tbn = dbtob(bn);\n \tbsize = vnd->sc_vp->v_mount->mnt_stat.f_iosize;\n\taddr = bp->b_data;\n\tflags = bp->b_flags | B_CALL;\n\tfor (resid = bp->b_resid; resid; resid -= sz) {\n\t\tstruct vnode *vp;\n\t\tdaddr_t nbn;\n\t\tint off, s, nra;\n\n\t\tnra = 0;\n\t\tvn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);\n\t\terror = VOP_BMAP(vnd->sc_vp, bn / bsize, &vp, &nbn, &nra);\n\t\tVOP_UNLOCK(vnd->sc_vp, 0, p);\n\t\tif (error == 0 && (long)nbn == -1)\n\t\t\terror = EIO;\n#ifdef DEBUG\n\t\tif (!dovndcluster)\n\t\t\tnra = 0;\n#endif\n\n\t\tif ((off = bn % bsize) != 0)\n\t\t\tsz = bsize - off;\n\t\telse\n\t\t\tsz = (1 + nra) * bsize;\n\t\tif (resid < sz)\n\t\t\tsz = resid;\n#ifdef DEBUG\n\t\tif (vnddebug & VDB_IO)\n\t\t\tprintf(\"vndstrategy: vp %p/%p bn %x/%x sz %x\\n\",\n\t\t\t       vnd->sc_vp, vp, bn, nbn, sz);\n#endif\n\n\t\tnbp = getvndbuf();\n\t\tnbp->vb_buf.b_flags = flags;\n\t\tnbp->vb_buf.b_bcount = sz;\n\t\tnbp->vb_buf.b_bufsize = bp->b_bufsize;\n\t\tnbp->vb_buf.b_error = 0;\n\t\tif (vp->v_type == VBLK || vp->v_type == VCHR)\n\t\t\tnbp->vb_buf.b_dev = vp->v_rdev;\n\t\telse\n\t\t\tnbp->vb_buf.b_dev = NODEV;\n\t\tnbp->vb_buf.b_data = addr;\n\t\tnbp->vb_buf.b_blkno = nbn + btodb(off);\n\t\tnbp->vb_buf.b_proc = bp->b_proc;\n\t\tnbp->vb_buf.b_iodone = vndiodone;\n\t\tnbp->vb_buf.b_vp = vp;\n\t\tnbp->vb_buf.b_rcred = vnd->sc_cred;\t/* XXX crdup? */\n\t\tnbp->vb_buf.b_wcred = vnd->sc_cred;\t/* XXX crdup? */\n\t\tnbp->vb_buf.b_dirtyoff = bp->b_dirtyoff;\n\t\tnbp->vb_buf.b_dirtyend = bp->b_dirtyend;\n\t\tnbp->vb_buf.b_validoff = bp->b_validoff;\n\t\tnbp->vb_buf.b_validend = bp->b_validend;\n\t\tLIST_INIT(&nbp->vb_buf.b_dep);\n\n\t\t/* save a reference to the old buffer */\n\t\tnbp->vb_obp = bp;\n\n\t\t/*\n\t\t * If there was an error or a hole in the file...punt.\n\t\t * Note that we deal with this after the nbp allocation.\n\t\t * This ensures that we properly clean up any operations\n\t\t * that we have already fired off.\n\t\t *\n\t\t * XXX we could deal with holes here but it would be\n\t\t * a hassle (in the write case).\n\t\t */\n\t\tif (error) {\n\t\t\tnbp->vb_buf.b_error = error;\n\t\t\tnbp->vb_buf.b_flags |= B_ERROR;\n\t\t\tbp->b_resid -= (resid - sz);\n\t\t\tbiodone(&nbp->vb_buf);\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * Just sort by block number\n\t\t */\n\t\tnbp->vb_buf.b_cylin = nbp->vb_buf.b_blkno;\n\t\ts = splbio();\n\t\tdisksort(&vnd->sc_tab, &nbp->vb_buf);\n\t\tif (vnd->sc_tab.b_active < vnd->sc_maxactive) {\n\t\t\tvnd->sc_tab.b_active++;\n\t\t\tvndstart(vnd);\n\t\t}\n\t\tsplx(s);\n\t\tbn += sz;\n\t\taddr += sz;\n\t}\n}"
  },
  {
    "function_name": "vndclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "304-343",
    "snippet": "int\nvndclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclose(%x, %x, %x, %p)\\n\", dev, flags, mode, p);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((error = vndlock(sc)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (mode) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask =\n\t    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tvndunlock(sc);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;",
      "static\tint vndlock",
      "static\tvoid vndunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vndunlock",
          "args": [
            "sc"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "vndunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "1002-1012",
          "snippet": "static void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tvoid vndunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tvoid vndunlock;\n\nstatic void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndlock",
          "args": [
            "sc"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "vndlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "984-997",
          "snippet": "static int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tint vndlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tint vndlock;\n\nstatic int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndclose(%x, %x, %x, %p)\\n\"",
            "dev",
            "flags",
            "mode",
            "p"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\nstatic\tint vndlock;\nstatic\tvoid vndunlock;\n\nint\nvndclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndclose(%x, %x, %x, %p)\\n\", dev, flags, mode, p);\n#endif\n\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((error = vndlock(sc)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (mode) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask =\n\t    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tvndunlock(sc);\n\treturn (0);\n}"
  },
  {
    "function_name": "vndgetdisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "254-302",
    "snippet": "void\nvndgetdisklabel(dev, sc)\n\tdev_t dev;\n\tstruct vnd_softc *sc;\n{\n\tstruct disklabel *lp = sc->sc_dk.dk_label;\n\tchar *errstring;\n\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = 512;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = sc->sc_size / 100;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it (?) */\n\t}\n\n\tstrncpy(lp->d_typename, \"vnd device\", 16);\n\tlp->d_type = DTYPE_SCSI;\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->sc_size;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp,\n\t    sc->sc_dk.dk_cpulabel, 0);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "void\tvndgetdisklabel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "VNDLABELDEV(dev)",
            "vndstrategy",
            "lp",
            "sc->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VNDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "lp"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"fictitious\"",
            "16"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"vnd device\"",
            "16"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_dk.dk_cpulabel",
            "sizeof(struct cpu_disklabel)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(struct disklabel)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndgetdisklabel;\n\nvoid\nvndgetdisklabel(dev, sc)\n\tdev_t dev;\n\tstruct vnd_softc *sc;\n{\n\tstruct disklabel *lp = sc->sc_dk.dk_label;\n\tchar *errstring;\n\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = 512;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = sc->sc_size / 100;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it (?) */\n\t}\n\n\tstrncpy(lp->d_typename, \"vnd device\", 16);\n\tlp->d_type = DTYPE_SCSI;\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->sc_size;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp,\n\t    sc->sc_dk.dk_cpulabel, 0);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "vndopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "177-249",
    "snippet": "int\nvndopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndopen(%x, %x, %x, %p)\\n\", dev, flags, mode, p);\n#endif\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((error = vndlock(sc)) != 0)\n\t\treturn (error);\n\n\tif ((sc->sc_flags & VNF_INITED) &&\n\t    (sc->sc_flags & VNF_HAVELABEL) == 0) {\n\t\tsc->sc_flags |= VNF_HAVELABEL;\n\t\tvndgetdisklabel(dev, sc);\n\t}\n\n\tpart = DISKPART(dev);\n\tpmask = 1 << part;\n\n\t/*\n\t * If any partition is open, all succeeding openings must be of the\n\t * same type.\n\t */\n\tif (sc->sc_dk.dk_openmask) {\n\t\tif (((sc->sc_flags & VNF_SIMPLE) != 0) !=\n\t\t    (vndsimple(dev) != 0)) {\n\t\t\terror = EBUSY;\n\t\t\tgoto bad;\n\t\t}\n\t} else if (vndsimple(dev))\n\t\tsc->sc_flags |= VNF_SIMPLE;\n\telse\n\t\tsc->sc_flags &= ~VNF_SIMPLE;\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    ((sc->sc_flags & VNF_HAVELABEL) == 0 ||\n\t    part >= sc->sc_dk.dk_label->d_npartitions ||\n\t    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (mode) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask =\n\t    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tvndunlock(sc);\n\treturn (0);\nbad:\n\tvndunlock(sc);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VNF_SIMPLE\t0x1000",
      "#define\tVNF_HAVELABEL\t0x0400",
      "#define VNF_INITED\t0x0002",
      "#define VDB_FOLLOW\t0x01"
    ],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;",
      "void\tvndgetdisklabel",
      "static\tint vndlock",
      "static\tvoid vndunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vndunlock",
          "args": [
            "sc"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "vndunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "1002-1012",
          "snippet": "static void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tvoid vndunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tvoid vndunlock;\n\nstatic void\nvndunlock(sc)\n\tstruct vnd_softc *sc;\n{\n\n\tsc->sc_flags &= ~VNF_LOCKED;\n\tif ((sc->sc_flags & VNF_WANTED) != 0) {\n\t\tsc->sc_flags &= ~VNF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndsimple",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndsimple",
          "args": [
            "dev"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vndgetdisklabel",
          "args": [
            "dev",
            "sc"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vndgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "254-302",
          "snippet": "void\nvndgetdisklabel(dev, sc)\n\tdev_t dev;\n\tstruct vnd_softc *sc;\n{\n\tstruct disklabel *lp = sc->sc_dk.dk_label;\n\tchar *errstring;\n\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = 512;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = sc->sc_size / 100;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it (?) */\n\t}\n\n\tstrncpy(lp->d_typename, \"vnd device\", 16);\n\tlp->d_type = DTYPE_SCSI;\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->sc_size;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp,\n\t    sc->sc_dk.dk_cpulabel, 0);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "void\tvndgetdisklabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\nvoid\tvndgetdisklabel;\n\nvoid\nvndgetdisklabel(dev, sc)\n\tdev_t dev;\n\tstruct vnd_softc *sc;\n{\n\tstruct disklabel *lp = sc->sc_dk.dk_label;\n\tchar *errstring;\n\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = 512;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = sc->sc_size / 100;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it (?) */\n\t}\n\n\tstrncpy(lp->d_typename, \"vnd device\", 16);\n\tlp->d_type = DTYPE_SCSI;\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->sc_size;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp,\n\t    sc->sc_dk.dk_cpulabel, 0);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndlock",
          "args": [
            "sc"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "vndlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
          "lines": "984-997",
          "snippet": "static int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/vndioctl.h>",
            "#include <miscfs/specfs/specdev.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/vnode.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/namei.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VNF_LOCKED\t0x0080",
            "#define VNF_WANTED\t0x0040"
          ],
          "globals_used": [
            "struct vnd_softc *vnd_softc;",
            "static\tint vndlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_LOCKED\t0x0080\n#define VNF_WANTED\t0x0040\n\nstruct vnd_softc *vnd_softc;\nstatic\tint vndlock;\n\nstatic int\nvndlock(sc)\n\tstruct vnd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->sc_flags & VNF_LOCKED) != 0) {\n\t\tsc->sc_flags |= VNF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"vndlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tsc->sc_flags |= VNF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"vndopen(%x, %x, %x, %p)\\n\"",
            "dev",
            "flags",
            "mode",
            "p"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vndunit",
          "args": [
            "dev"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VNF_SIMPLE\t0x1000\n#define\tVNF_HAVELABEL\t0x0400\n#define VNF_INITED\t0x0002\n#define VDB_FOLLOW\t0x01\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\nvoid\tvndgetdisklabel;\nstatic\tint vndlock;\nstatic\tvoid vndunlock;\n\nint\nvndopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tint unit = vndunit(dev);\n\tstruct vnd_softc *sc;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (vnddebug & VDB_FOLLOW)\n\t\tprintf(\"vndopen(%x, %x, %x, %p)\\n\", dev, flags, mode, p);\n#endif\n\tif (unit >= numvnd)\n\t\treturn (ENXIO);\n\tsc = &vnd_softc[unit];\n\n\tif ((error = vndlock(sc)) != 0)\n\t\treturn (error);\n\n\tif ((sc->sc_flags & VNF_INITED) &&\n\t    (sc->sc_flags & VNF_HAVELABEL) == 0) {\n\t\tsc->sc_flags |= VNF_HAVELABEL;\n\t\tvndgetdisklabel(dev, sc);\n\t}\n\n\tpart = DISKPART(dev);\n\tpmask = 1 << part;\n\n\t/*\n\t * If any partition is open, all succeeding openings must be of the\n\t * same type.\n\t */\n\tif (sc->sc_dk.dk_openmask) {\n\t\tif (((sc->sc_flags & VNF_SIMPLE) != 0) !=\n\t\t    (vndsimple(dev) != 0)) {\n\t\t\terror = EBUSY;\n\t\t\tgoto bad;\n\t\t}\n\t} else if (vndsimple(dev))\n\t\tsc->sc_flags |= VNF_SIMPLE;\n\telse\n\t\tsc->sc_flags &= ~VNF_SIMPLE;\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    ((sc->sc_flags & VNF_HAVELABEL) == 0 ||\n\t    part >= sc->sc_dk.dk_label->d_npartitions ||\n\t    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (mode) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask =\n\t    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tvndunlock(sc);\n\treturn (0);\nbad:\n\tvndunlock(sc);\n\treturn (error);\n}"
  },
  {
    "function_name": "vndattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/vnd.c",
    "lines": "157-175",
    "snippet": "void\nvndattach(num)\n\tint num;\n{\n\tchar *mem;\n\tregister u_long size;\n\n\tif (num <= 0)\n\t\treturn;\n\tsize = num * sizeof(struct vnd_softc);\n\tmem = malloc(size, M_DEVBUF, M_NOWAIT);\n\tif (mem == NULL) {\n\t\tprintf(\"WARNING: no memory for vnode disks\\n\");\n\t\treturn;\n\t}\n\tbzero(mem, size);\n\tvnd_softc = (struct vnd_softc *)mem;\n\tnumvnd = num;\n}",
    "includes": [
      "#include <dev/vndioctl.h>",
      "#include <miscfs/specfs/specdev.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/file.h>",
      "#include <sys/vnode.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/namei.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vnd_softc *vnd_softc;",
      "int numvnd = 0;",
      "void\tvndattach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "mem",
            "size"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: no memory for vnode disks\\n\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/vndioctl.h>\n#include <miscfs/specfs/specdev.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/vnode.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/namei.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct vnd_softc *vnd_softc;\nint numvnd = 0;\nvoid\tvndattach;\n\nvoid\nvndattach(num)\n\tint num;\n{\n\tchar *mem;\n\tregister u_long size;\n\n\tif (num <= 0)\n\t\treturn;\n\tsize = num * sizeof(struct vnd_softc);\n\tmem = malloc(size, M_DEVBUF, M_NOWAIT);\n\tif (mem == NULL) {\n\t\tprintf(\"WARNING: no memory for vnode disks\\n\");\n\t\treturn;\n\t}\n\tbzero(mem, size);\n\tvnd_softc = (struct vnd_softc *)mem;\n\tnumvnd = num;\n}"
  }
]