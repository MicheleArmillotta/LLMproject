[
  {
    "function_name": "uaudio_set_speed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2329-2349",
    "snippet": "usbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "&data"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "3"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "endpt"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW2",
          "args": [
            "req.wValue",
            "SAMPLING_FREQ_CONTROL",
            "0"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed)"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}"
  },
  {
    "function_name": "uaudio_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2182-2327",
    "snippet": "int\nuaudio_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint flags = sc->sc_altflags;\n\tint pfactor, rfactor;\n\tint enc, i, j;\n\tvoid (*pswcode) __P((void *, u_char *buf, int cnt));\n\tvoid (*rswcode) __P((void *, u_char *buf, int cnt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_chan.pipe != NULL)\n\t\treturn (EBUSY);\n\n        pswcode = rswcode = 0;\n\tpfactor = rfactor = 1;\n\tenc = p->encoding;\n        switch (p->encoding) {\n        case AUDIO_ENCODING_SLINEAR_BE:\n        \tif (p->precision == 16) {\n                \trswcode = pswcode = swap_bytes;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_SLINEAR_LE:\n        \tif (p->precision == 8 && !(flags & HAS_8)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t}\n        \tbreak;\n        case AUDIO_ENCODING_ULINEAR_BE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = swap_bytes_change_sign16_le;\n\t\t\trswcode = change_sign16_swap_bytes_le;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8U)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_ULINEAR_LE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = rswcode = change_sign16_le;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8U)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t}\n        \tbreak;\n        case AUDIO_ENCODING_ULAW:\n\t\tif (!(flags & HAS_MULAW)) {\n\t\t\tif (flags & HAS_8U) {\n\t\t\t\tpswcode = mulaw_to_ulinear8;\n\t\t\t\trswcode = ulinear8_to_mulaw;\n\t\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t\t} else if (flags & HAS_8) {\n\t\t\t\tpswcode = mulaw_to_slinear8;\n\t\t\t\trswcode = slinear8_to_mulaw;\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#if 0\n\t\t\t} else if (flags & HAS_16) {\n\t\t\t\tpswcode = mulaw_to_slinear16_le;\n\t\t\t\tpfactor = 2;\n\t\t\t\t/* XXX recording not handled */\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#endif\n\t\t\t} else\n\t\t\t\treturn (EINVAL);\n\t\t}\n                break;\n        case AUDIO_ENCODING_ALAW:\n\t\tif (!(flags & HAS_ALAW)) {\n\t\t\tif (flags & HAS_8U) {\n\t\t\t\tpswcode = alaw_to_ulinear8;\n\t\t\t\trswcode = ulinear8_to_alaw;\n\t\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t\t} else if (flags & HAS_8) {\n\t\t\t\tpswcode = alaw_to_slinear8;\n\t\t\t\trswcode = slinear8_to_alaw;\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#if 0\n\t\t\t} else if (flags & HAS_16) {\n\t\t\t\tpswcode = alaw_to_slinear16_le;\n\t\t\t\tpfactor = 2;\n\t\t\t\t/* XXX recording not handled */\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#endif\n\t\t\t} else\n\t\t\t\treturn (EINVAL);\n\t\t}\n                break;\n        default:\n        \treturn (EINVAL);\n        }\n\t/* XXX do some other conversions... */\n\n\tDPRINTF((\"uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\\n\",\n\t\t p->channels, p->precision, enc, p->sample_rate));\n\n\tfor (i = 0; i < sc->sc_nalts; i++) {\n\t\tstruct usb_audio_streaming_type1_descriptor *a1d =\n\t\t\tsc->sc_alts[i].asf1desc;\n\t\tif (p->channels == a1d->bNrChannels &&\n\t\t    p->precision ==a1d->bBitResolution &&\n\t\t    enc == sc->sc_alts[i].encoding) {\n\t\t\tif (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {\n\t\t\t\tDPRINTFN(2,(\"uaudio_set_params: cont %d-%d\\n\",\n\t\t\t\t    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));\n\t\t\t\tif (UA_SAMP_LO(a1d) < p->sample_rate &&\n\t\t\t\t    p->sample_rate < UA_SAMP_HI(a1d))\n\t\t\t\t\tgoto found;\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < a1d->bSamFreqType; j++) {\n\t\t\t\t\tDPRINTFN(2,(\"uaudio_set_params: disc #\"\n\t\t\t\t\t    \"%d: %d\\n\", j, UA_GETSAMP(a1d, j)));\n\t\t\t\t\t/* XXX allow for some slack */\n\t\t\t\t\tif (UA_GETSAMP(a1d, j) ==\n\t\t\t\t\t    p->sample_rate)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (EINVAL);\n\n found:\n        p->sw_code = pswcode;\n        r->sw_code = rswcode;\n\tp->factor  = pfactor;\n\tr->factor  = rfactor;\n\tsc->sc_curaltidx = i;\n\n\tDPRINTF((\"uaudio_set_params: use altidx=%d, altno=%d\\n\", \n\t\t sc->sc_curaltidx, \n\t\t sc->sc_alts[sc->sc_curaltidx].idesc->bAlternateSetting));\n\t\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define HAS_MULAW 0x10",
      "#define HAS_ALAW  0x08",
      "#define HAS_8U    0x04",
      "#define HAS_16    0x02",
      "#define HAS_8     0x01"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_open __P((void *, int));",
      "uaudio_close __P((void *));",
      "uaudio_drain __P((void *));",
      "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
      "uaudio_round_blocksize __P((void *, int));",
      "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_halt_in_dma __P((void *));",
      "uaudio_halt_out_dma __P((void *));",
      "uaudio_get_props __P((void *));",
      "Static struct",
      "Static struct",
      "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_set_params: use altidx=%d, altno=%d\\n\", \n\t\t sc->sc_curaltidx, \n\t\t sc->sc_alts[sc->sc_curaltidx].idesc->bAlternateSetting)"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_GETSAMP",
          "args": [
            "a1d",
            "j"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_set_params: disc #\"\n\t\t\t\t\t    \"%d: %d\\n\", j, UA_GETSAMP(a1d, j))"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_GETSAMP",
          "args": [
            "a1d",
            "j"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_SAMP_HI",
          "args": [
            "a1d"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_SAMP_LO",
          "args": [
            "a1d"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_set_params: cont %d-%d\\n\",\n\t\t\t\t    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d))"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_SAMP_HI",
          "args": [
            "a1d"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_SAMP_LO",
          "args": [
            "a1d"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\\n\",\n\t\t p->channels, p->precision, enc, p->sample_rate)"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define HAS_MULAW 0x10\n#define HAS_ALAW  0x08\n#define HAS_8U    0x04\n#define HAS_16    0x02\n#define HAS_8     0x01\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_open __P((void *, int));\nuaudio_close __P((void *));\nuaudio_drain __P((void *));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_round_blocksize __P((void *, int));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_halt_in_dma __P((void *));\nuaudio_halt_out_dma __P((void *));\nuaudio_get_props __P((void *));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint flags = sc->sc_altflags;\n\tint pfactor, rfactor;\n\tint enc, i, j;\n\tvoid (*pswcode) __P((void *, u_char *buf, int cnt));\n\tvoid (*rswcode) __P((void *, u_char *buf, int cnt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_chan.pipe != NULL)\n\t\treturn (EBUSY);\n\n        pswcode = rswcode = 0;\n\tpfactor = rfactor = 1;\n\tenc = p->encoding;\n        switch (p->encoding) {\n        case AUDIO_ENCODING_SLINEAR_BE:\n        \tif (p->precision == 16) {\n                \trswcode = pswcode = swap_bytes;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_SLINEAR_LE:\n        \tif (p->precision == 8 && !(flags & HAS_8)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t}\n        \tbreak;\n        case AUDIO_ENCODING_ULINEAR_BE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = swap_bytes_change_sign16_le;\n\t\t\trswcode = change_sign16_swap_bytes_le;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8U)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_ULINEAR_LE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = rswcode = change_sign16_le;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t} else if (p->precision == 8 && !(flags & HAS_8U)) {\n\t\t\tpswcode = rswcode = change_sign8;\n\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\t}\n        \tbreak;\n        case AUDIO_ENCODING_ULAW:\n\t\tif (!(flags & HAS_MULAW)) {\n\t\t\tif (flags & HAS_8U) {\n\t\t\t\tpswcode = mulaw_to_ulinear8;\n\t\t\t\trswcode = ulinear8_to_mulaw;\n\t\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t\t} else if (flags & HAS_8) {\n\t\t\t\tpswcode = mulaw_to_slinear8;\n\t\t\t\trswcode = slinear8_to_mulaw;\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#if 0\n\t\t\t} else if (flags & HAS_16) {\n\t\t\t\tpswcode = mulaw_to_slinear16_le;\n\t\t\t\tpfactor = 2;\n\t\t\t\t/* XXX recording not handled */\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#endif\n\t\t\t} else\n\t\t\t\treturn (EINVAL);\n\t\t}\n                break;\n        case AUDIO_ENCODING_ALAW:\n\t\tif (!(flags & HAS_ALAW)) {\n\t\t\tif (flags & HAS_8U) {\n\t\t\t\tpswcode = alaw_to_ulinear8;\n\t\t\t\trswcode = ulinear8_to_alaw;\n\t\t\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\t\t} else if (flags & HAS_8) {\n\t\t\t\tpswcode = alaw_to_slinear8;\n\t\t\t\trswcode = slinear8_to_alaw;\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#if 0\n\t\t\t} else if (flags & HAS_16) {\n\t\t\t\tpswcode = alaw_to_slinear16_le;\n\t\t\t\tpfactor = 2;\n\t\t\t\t/* XXX recording not handled */\n\t\t\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n#endif\n\t\t\t} else\n\t\t\t\treturn (EINVAL);\n\t\t}\n                break;\n        default:\n        \treturn (EINVAL);\n        }\n\t/* XXX do some other conversions... */\n\n\tDPRINTF((\"uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\\n\",\n\t\t p->channels, p->precision, enc, p->sample_rate));\n\n\tfor (i = 0; i < sc->sc_nalts; i++) {\n\t\tstruct usb_audio_streaming_type1_descriptor *a1d =\n\t\t\tsc->sc_alts[i].asf1desc;\n\t\tif (p->channels == a1d->bNrChannels &&\n\t\t    p->precision ==a1d->bBitResolution &&\n\t\t    enc == sc->sc_alts[i].encoding) {\n\t\t\tif (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {\n\t\t\t\tDPRINTFN(2,(\"uaudio_set_params: cont %d-%d\\n\",\n\t\t\t\t    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));\n\t\t\t\tif (UA_SAMP_LO(a1d) < p->sample_rate &&\n\t\t\t\t    p->sample_rate < UA_SAMP_HI(a1d))\n\t\t\t\t\tgoto found;\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < a1d->bSamFreqType; j++) {\n\t\t\t\t\tDPRINTFN(2,(\"uaudio_set_params: disc #\"\n\t\t\t\t\t    \"%d: %d\\n\", j, UA_GETSAMP(a1d, j)));\n\t\t\t\t\t/* XXX allow for some slack */\n\t\t\t\t\tif (UA_GETSAMP(a1d, j) ==\n\t\t\t\t\t    p->sample_rate)\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (EINVAL);\n\n found:\n        p->sw_code = pswcode;\n        r->sw_code = rswcode;\n\tp->factor  = pfactor;\n\tr->factor  = rfactor;\n\tsc->sc_curaltidx = i;\n\n\tDPRINTF((\"uaudio_set_params: use altidx=%d, altno=%d\\n\", \n\t\t sc->sc_curaltidx, \n\t\t sc->sc_alts[sc->sc_curaltidx].idesc->bAlternateSetting));\n\t\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_chan_set_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2156-2180",
    "snippet": "void\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
      "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nStatic struct;\nStatic struct;\n\nvoid\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}"
  },
  {
    "function_name": "uaudio_chan_rintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2102-2154",
    "snippet": "void\nuaudio_chan_rintr(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n\tstruct chanbuf *cb = priv;\n\tstruct chan *ch = cb->chan;\n\tu_int32_t count;\n\tint s, n;\n\n\t/* Return if we are aborting. */\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tDPRINTFN(5,(\"uaudio_chan_rintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred));\n#ifdef DIAGNOSTIC\n\tif (count != cb->size) {\n\t\tprintf(\"uaudio_chan_pintr: count(%d) != size(%d)\\n\",\n\t\t       count, cb->size);\n\t}\n#endif\n\n\t/* \n\t * Transfer data from channel buffer to upper layer buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(count, ch->end - ch->cur);\n\tmemcpy(ch->cur, cb->buffer, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (count > n) {\n\t\tmemcpy(ch->cur, cb->buffer + n, count - n);\n\t\tch->cur += count - n;\n\t}\n\n\t/* Call back to upper layer */\n\tch->transferred += cb->size;\n\ts = splaudio();\n\twhile (ch->transferred >= ch->blksize) {\n\t\tch->transferred -= ch->blksize;\n\t\tDPRINTFN(5,(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg));\n\t\tch->intr(ch->arg);\n\t}\n\tsplx(s);\n\n\t/* start next transfer */\n\tuaudio_chan_rtransfer(ch);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_pintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "uaudio_chan_rintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));",
      "Static struct",
      "Static struct",
      "int size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_chan_rtransfer",
          "args": [
            "ch"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_rtransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2052-2100",
          "snippet": "void\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)",
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ch->intr",
          "args": [
            "ch->arg"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg)"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ch->cur",
            "cb->buffer + n",
            "count - n"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ch->cur",
            "cb->buffer",
            "n"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "ch->end - ch->cur"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_chan_pintr: count(%d) != size(%d)\\n\"",
            "count",
            "cb->size"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_rintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&count",
            "NULL"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_pintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_chan_rintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));\nStatic struct;\nStatic struct;\nint size;\n\nvoid\nuaudio_chan_rintr(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n\tstruct chanbuf *cb = priv;\n\tstruct chan *ch = cb->chan;\n\tu_int32_t count;\n\tint s, n;\n\n\t/* Return if we are aborting. */\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tDPRINTFN(5,(\"uaudio_chan_rintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred));\n#ifdef DIAGNOSTIC\n\tif (count != cb->size) {\n\t\tprintf(\"uaudio_chan_pintr: count(%d) != size(%d)\\n\",\n\t\t       count, cb->size);\n\t}\n#endif\n\n\t/* \n\t * Transfer data from channel buffer to upper layer buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(count, ch->end - ch->cur);\n\tmemcpy(ch->cur, cb->buffer, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (count > n) {\n\t\tmemcpy(ch->cur, cb->buffer + n, count - n);\n\t\tch->cur += count - n;\n\t}\n\n\t/* Call back to upper layer */\n\tch->transferred += cb->size;\n\ts = splaudio();\n\twhile (ch->transferred >= ch->blksize) {\n\t\tch->transferred -= ch->blksize;\n\t\tDPRINTFN(5,(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg));\n\t\tch->intr(ch->arg);\n\t}\n\tsplx(s);\n\n\t/* start next transfer */\n\tuaudio_chan_rtransfer(ch);\n}"
  },
  {
    "function_name": "uaudio_chan_rtransfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2052-2100",
    "snippet": "void\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "int size;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "cb->xfer"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_isoc_xfer",
          "args": [
            "cb->xfer",
            "ch->pipe",
            "cb",
            "cb->sizes",
            "UAUDIO_NFRAMES",
            "USBD_NO_COPY",
            "uaudio_chan_rintr"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_isoc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "475-497",
          "snippet": "void\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer)"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"   [%d] length %d\\n\", i, cb->sizes[i])"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue)"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
  },
  {
    "function_name": "uaudio_chan_pintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "2011-2049",
    "snippet": "void\nuaudio_chan_pintr(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n\tstruct chanbuf *cb = priv;\n\tstruct chan *ch = cb->chan;\n\tu_int32_t count;\n\tint s;\n\n\t/* Return if we are aborting. */\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tDPRINTFN(5,(\"uaudio_chan_pintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred));\n#ifdef DIAGNOSTIC\n\tif (count != cb->size) {\n\t\tprintf(\"uaudio_chan_pintr: count(%d) != size(%d)\\n\",\n\t\t       count, cb->size);\n\t}\n#endif\n\n\tch->transferred += cb->size;\n\ts = splaudio();\n\t/* Call back to upper layer */\n\twhile (ch->transferred >= ch->blksize) {\n\t\tch->transferred -= ch->blksize;\n\t\tDPRINTFN(5,(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg));\n\t\tch->intr(ch->arg);\n\t}\n\tsplx(s);\n\n\t/* start next transfer */\n\tuaudio_chan_ptransfer(ch);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_pintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "uaudio_chan_rintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));",
      "Static struct",
      "Static struct",
      "int size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_chan_ptransfer",
          "args": [
            "ch"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_ptransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1946-2009",
          "snippet": "void\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)",
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ch->intr",
          "args": [
            "ch->arg"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg)"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_chan_pintr: count(%d) != size(%d)\\n\"",
            "count",
            "cb->size"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_pintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred)"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&count",
            "NULL"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_pintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_chan_rintr __P((usbd_xfer_handle xfer, \n\t\t\t    usbd_private_handle priv, usbd_status status));\nStatic struct;\nStatic struct;\nint size;\n\nvoid\nuaudio_chan_pintr(xfer, priv, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle priv;\n\tusbd_status status;\n{\n\tstruct chanbuf *cb = priv;\n\tstruct chan *ch = cb->chan;\n\tu_int32_t count;\n\tint s;\n\n\t/* Return if we are aborting. */\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tDPRINTFN(5,(\"uaudio_chan_pintr: count=%d, transferred=%d\\n\",\n\t\t    count, ch->transferred));\n#ifdef DIAGNOSTIC\n\tif (count != cb->size) {\n\t\tprintf(\"uaudio_chan_pintr: count(%d) != size(%d)\\n\",\n\t\t       count, cb->size);\n\t}\n#endif\n\n\tch->transferred += cb->size;\n\ts = splaudio();\n\t/* Call back to upper layer */\n\twhile (ch->transferred >= ch->blksize) {\n\t\tch->transferred -= ch->blksize;\n\t\tDPRINTFN(5,(\"uaudio_chan_pintr: call %p(%p)\\n\", \n\t\t\t    ch->intr, ch->arg));\n\t\tch->intr(ch->arg);\n\t}\n\tsplx(s);\n\n\t/* start next transfer */\n\tuaudio_chan_ptransfer(ch);\n}"
  },
  {
    "function_name": "uaudio_chan_ptransfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1946-2009",
    "snippet": "void\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "int size;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "cb->xfer"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_isoc_xfer",
          "args": [
            "cb->xfer",
            "ch->pipe",
            "cb",
            "cb->sizes",
            "UAUDIO_NFRAMES",
            "USBD_NO_COPY",
            "uaudio_chan_pintr"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_isoc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "475-497",
          "snippet": "void\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_start_next __P((usbd_pipe_handle pipe));\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tu_int16_t *frlengths;\n\tu_int32_t nframes;\n\tu_int16_t flags;\n\tusbd_callback callback;\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = 0;\n\txfer->length = 0;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = USBD_NO_TIMEOUT;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->frlengths = frlengths;\n\txfer->nframes = nframes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer)"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"   [%d] length %d\\n\", i, cb->sizes[i])"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cb->buffer + n",
            "ch->cur",
            "total"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cb->buffer",
            "ch->cur",
            "n"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "total",
            "ch->end - ch->cur"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
  },
  {
    "function_name": "uaudio_chan_free_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1934-1943",
    "snippet": "void\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "ch->chanbufs[i].xfer"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}"
  },
  {
    "function_name": "uaudio_chan_alloc_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1901-1932",
    "snippet": "usbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
      "int size;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "ch->chanbufs[i].xfer"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "xfer",
            "size"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}"
  },
  {
    "function_name": "uaudio_chan_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1887-1899",
    "snippet": "void\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "ch->pipe"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "ch->pipe"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_interface",
          "args": [
            "sc->sc_as_ifaceh",
            "sc->sc_nullalt"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "689-715",
          "snippet": "usbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "u_int8_t index;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nu_int8_t index;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt)"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}"
  },
  {
    "function_name": "uaudio_chan_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1855-1885",
    "snippet": "usbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sc->sc_as_ifaceh",
            "endpt",
            "0",
            "&ch->pipe"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt)"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_set_speed",
          "args": [
            "sc",
            "endpt",
            "ch->sample_rate"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_set_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2329-2349",
          "snippet": "usbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err))"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_interface",
          "args": [
            "sc->sc_as_ifaceh",
            "as->alt"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "689-715",
          "snippet": "usbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "u_int8_t index;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nu_int8_t index;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt)"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}"
  },
  {
    "function_name": "uaudio_trigger_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1808-1852",
    "snippet": "int\nuaudio_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct chan *ch = &sc->sc_chan;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tDPRINTFN(3,(\"uaudio_trigger_output: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize));\n\n\tuaudio_chan_set_param(ch, param, start, end, blksize);\n\tDPRINTFN(3,(\"uaudio_trigger_output: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction));\n\n\terr = uaudio_chan_alloc_buffers(sc, ch);\n\tif (err)\n\t\treturn (EIO);\n\n\terr = uaudio_chan_open(sc, ch);\n\tif (err) {\n\t\tuaudio_chan_free_buffers(sc, ch);\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_chan.intr = intr;\n\tsc->sc_chan.arg = arg;\n\n\ts = splusb();\n\tfor (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */\n\t\tuaudio_chan_ptransfer(ch);\n\tsplx(s);\n\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "uaudio_open __P((void *, int));",
      "uaudio_close __P((void *));",
      "uaudio_drain __P((void *));",
      "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
      "uaudio_round_blocksize __P((void *, int));",
      "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_halt_in_dma __P((void *));",
      "uaudio_halt_out_dma __P((void *));",
      "uaudio_get_props __P((void *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_ptransfer",
          "args": [
            "ch"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_ptransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1946-2009",
          "snippet": "void\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)",
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_ptransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, n, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n\t/* \n\t * Transfer data from upper layer buffer to channel buffer, taking\n\t * care of wrapping the upper layer buffer.\n\t */\n\tn = min(total, ch->end - ch->cur);\n\tmemcpy(cb->buffer, ch->cur, n);\n\tch->cur += n;\n\tif (ch->cur >= ch->end)\n\t\tch->cur = ch->start;\n\tif (total > n) {\n\t\ttotal -= n;\n\t\tmemcpy(cb->buffer + n, ch->cur, total);\n\t\tch->cur += total;\n\t}\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_transfer: ptransfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_pintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_free_buffers",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1934-1943",
          "snippet": "void\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_open",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1855-1885",
          "snippet": "usbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "Static usbd_status",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_alloc_buffers",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_alloc_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1901-1932",
          "snippet": "usbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "Static usbd_status",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uaudio_trigger_output: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction)"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_set_param",
          "args": [
            "ch",
            "param",
            "start",
            "end",
            "blksize"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_set_param",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2156-2180",
          "snippet": "void\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
            "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
            "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nStatic struct;\nStatic struct;\n\nvoid\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uaudio_trigger_output: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize)"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_open __P((void *, int));\nuaudio_close __P((void *));\nuaudio_drain __P((void *));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_round_blocksize __P((void *, int));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_halt_in_dma __P((void *));\nuaudio_halt_out_dma __P((void *));\nuaudio_get_props __P((void *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct chan *ch = &sc->sc_chan;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tDPRINTFN(3,(\"uaudio_trigger_output: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize));\n\n\tuaudio_chan_set_param(ch, param, start, end, blksize);\n\tDPRINTFN(3,(\"uaudio_trigger_output: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction));\n\n\terr = uaudio_chan_alloc_buffers(sc, ch);\n\tif (err)\n\t\treturn (EIO);\n\n\terr = uaudio_chan_open(sc, ch);\n\tif (err) {\n\t\tuaudio_chan_free_buffers(sc, ch);\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_chan.intr = intr;\n\tsc->sc_chan.arg = arg;\n\n\ts = splusb();\n\tfor (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */\n\t\tuaudio_chan_ptransfer(ch);\n\tsplx(s);\n\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_trigger_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1762-1806",
    "snippet": "int\nuaudio_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct chan *ch = &sc->sc_chan;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tDPRINTFN(3,(\"uaudio_trigger_input: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize));\n\n\tuaudio_chan_set_param(ch, param, start, end, blksize);\n\tDPRINTFN(3,(\"uaudio_trigger_input: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction));\n\n\terr = uaudio_chan_alloc_buffers(sc, ch);\n\tif (err)\n\t\treturn (EIO);\n\n\terr = uaudio_chan_open(sc, ch);\n\tif (err) {\n\t\tuaudio_chan_free_buffers(sc, ch);\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_chan.intr = intr;\n\tsc->sc_chan.arg = arg;\n\n\ts = splusb();\n\tfor (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */\n\t\tuaudio_chan_rtransfer(ch);\n\tsplx(s);\n\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
      "uaudio_chan_ptransfer __P((struct chan *ch));",
      "uaudio_chan_rtransfer __P((struct chan *ch));",
      "uaudio_open __P((void *, int));",
      "uaudio_close __P((void *));",
      "uaudio_drain __P((void *));",
      "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
      "uaudio_round_blocksize __P((void *, int));",
      "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
      "uaudio_halt_in_dma __P((void *));",
      "uaudio_halt_out_dma __P((void *));",
      "uaudio_get_props __P((void *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_rtransfer",
          "args": [
            "ch"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_rtransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2052-2100",
          "snippet": "void\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)",
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_rtransfer(ch)\n\tstruct chan *ch;\n{\n\tstruct chanbuf *cb;\n\tint i, size, residue, total;\n\n\tif (ch->sc->sc_dying)\n\t\treturn;\n\n\t/* Pick the next channel buffer. */\n\tcb = &ch->chanbufs[ch->curchanbuf];\n\tif (++ch->curchanbuf >= UAUDIO_NCHANBUFS)\n\t\tch->curchanbuf = 0;\n\n\t/* Compute the size of each frame in the next transfer. */\n\tresidue = ch->residue;\n\ttotal = 0;\n\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\tsize = ch->bytes_per_frame;\n\t\tresidue += ch->fraction;\n\t\tif (residue >= USB_FRAMES_PER_SECOND) {\n\t\t\tsize += ch->sample_size;\n\t\t\tresidue -= USB_FRAMES_PER_SECOND;\n\t\t}\n\t\tcb->sizes[i] = size;\n\t\ttotal += size;\n\t}\n\tch->residue = residue;\n\tcb->size = total;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 8) {\n\t\tDPRINTF((\"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\\n\",\n\t\t\t cb->buffer, ch->residue));\n\t\tfor (i = 0; i < UAUDIO_NFRAMES; i++) {\n\t\t\tDPRINTF((\"   [%d] length %d\\n\", i, cb->sizes[i]));\n\t\t}\n\t}\n#endif\n\n\tDPRINTFN(5,(\"uaudio_chan_rtransfer: transfer xfer=%p\\n\", cb->xfer));\n\t/* Fill the request */\n\tusbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, \n\t\t\t     UAUDIO_NFRAMES, USBD_NO_COPY, \n\t\t\t     uaudio_chan_rintr);\n\n\t(void)usbd_transfer(cb->xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_free_buffers",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1934-1943",
          "snippet": "void\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_open",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1855-1885",
          "snippet": "usbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "Static usbd_status",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_open(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tstruct as_info *as = &sc->sc_alts[sc->sc_curaltidx];\n\tint endpt = as->edesc->bEndpointAddress;\n\tusbd_status err;\n\n\tDPRINTF((\"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\\n\", \n\t\t endpt, ch->sample_rate, as->alt));\n\n\t/* Set alternate interface corresponding to the mode. */\n\terr = usbd_set_interface(sc->sc_as_ifaceh, as->alt);\n\tif (err)\n\t\treturn (err);\n\n\t/* Some devices do not support this request, so ignore errors. */\n#ifdef UAUDIO_DEBUG\n\terr = uaudio_set_speed(sc, endpt, ch->sample_rate);\n\tif (err)\n\t\tDPRINTF((\"uaudio_chan_open: set_speed failed err=%s\\n\",\n\t\t\t usbd_errstr(err)));\n#else\n\t(void)uaudio_set_speed(sc, endpt, ch->sample_rate);\n#endif\n\n\tDPRINTF((\"uaudio_open_chan: create pipe to 0x%02x\\n\", endpt));\n\terr = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_alloc_buffers",
          "args": [
            "sc",
            "ch"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_alloc_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1901-1932",
          "snippet": "usbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "Static usbd_status",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_chan_alloc_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tusbd_xfer_handle xfer;\n\tvoid *buf;\n\tint i, size;\n\n\tsize = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++) {\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\tgoto bad;\n\t\tch->chanbufs[i].xfer = xfer;\n\t\tbuf = usbd_alloc_buffer(xfer, size);\n\t\tif (buf == 0) {\n\t\t\ti++;\n\t\t\tgoto bad;\n\t\t}\n\t\tch->chanbufs[i].buffer = buf;\n\t\tch->chanbufs[i].chan = ch;\n\t}\n\n\treturn (USBD_NORMAL_COMPLETION);\n\nbad:\n\twhile (--i >= 0)\n\t\t/* implicit buffer free */\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uaudio_trigger_input: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction)"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_chan_set_param",
          "args": [
            "ch",
            "param",
            "start",
            "end",
            "blksize"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_set_param",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2156-2180",
          "snippet": "void\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "uaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));",
            "uaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
            "uaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nStatic struct;\nStatic struct;\n\nvoid\nuaudio_chan_set_param(ch, param, start, end, blksize)\n\tstruct chan *ch;\n\tstruct audio_params *param;\n\tu_char *start, *end;\n\tint blksize;\n{\n\tint samples_per_frame, sample_size;\n\n\tsample_size = param->precision * param->channels / 8;\n\tsamples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;\n\tch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;\n\tch->sample_size = sample_size;\n\tch->sample_rate = param->sample_rate;\n\tch->bytes_per_frame = samples_per_frame * sample_size;\n\tch->residue = 0;\n\n\tch->start = start;\n\tch->end = end;\n\tch->cur = start;\n\tch->blksize = blksize;\n\tch->transferred = 0;\n\n\tch->curchanbuf = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "3",
            "(\"uaudio_trigger_input: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize)"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_set_param __P((struct chan *ch,\n\t\t\t    struct audio_params *param, u_char *start, \n\t\t\t    u_char *end, int blksize));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nuaudio_open __P((void *, int));\nuaudio_close __P((void *));\nuaudio_drain __P((void *));\nuaudio_set_params __P((void *, int, int, \n\t\t\t    struct audio_params *, struct audio_params *));\nuaudio_round_blocksize __P((void *, int));\nuaudio_trigger_output __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_trigger_input  __P((void *, void *, void *,\n\t\t\t    int, void (*)(void *), void *,\n\t\t\t    struct audio_params *));\nuaudio_halt_in_dma __P((void *));\nuaudio_halt_out_dma __P((void *));\nuaudio_get_props __P((void *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct chan *ch = &sc->sc_chan;\n\tusbd_status err;\n\tint i, s;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tDPRINTFN(3,(\"uaudio_trigger_input: sc=%p start=%p end=%p \"\n\t\t    \"blksize=%d\\n\", sc, start, end, blksize));\n\n\tuaudio_chan_set_param(ch, param, start, end, blksize);\n\tDPRINTFN(3,(\"uaudio_trigger_input: sample_size=%d bytes/frame=%d \"\n\t\t    \"fraction=0.%03d\\n\", ch->sample_size, ch->bytes_per_frame,\n\t\t    ch->fraction));\n\n\terr = uaudio_chan_alloc_buffers(sc, ch);\n\tif (err)\n\t\treturn (EIO);\n\n\terr = uaudio_chan_open(sc, ch);\n\tif (err) {\n\t\tuaudio_chan_free_buffers(sc, ch);\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_chan.intr = intr;\n\tsc->sc_chan.arg = arg;\n\n\ts = splusb();\n\tfor (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */\n\t\tuaudio_chan_rtransfer(ch);\n\tsplx(s);\n\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1723-1760",
    "snippet": "int\nuaudio_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint i, n, vals[MIX_MAX_CHAN];\n\n\tDPRINTFN(2,(\"uaudio_mixer_set_port: index = %d\\n\", cp->dev));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = cp->dev;\n\tif (n < 0 || n >= sc->sc_nctls)\n\t\treturn (ENXIO);\n\tmc = &sc->sc_ctls[n];\n\n\tif (mc->type == MIX_ON_OFF) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tuaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);\n\t} else {\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.value.num_channels == 1)\n\t\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\t\tvals[i] = cp->un.value.level[0];\n\t\telse if (cp->un.value.num_channels == mc->nchan)\n\t\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\t\tvals[i] = cp->un.value.level[i];\n\t\telse\n\t\t\treturn (EINVAL);\n\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\tuaudio_ctl_set(sc, SET_CUR, mc, i, vals[i]);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1",
      "#define MIX_MAX_CHAN 8"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_mixer_set_port __P((void *, mixer_ctrl_t *));",
      "uaudio_mixer_get_port __P((void *, mixer_ctrl_t *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_ctl_set",
          "args": [
            "sc",
            "SET_CUR",
            "mc",
            "i",
            "vals[i]"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_ctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1667-1678",
          "snippet": "void\nuaudio_ctl_set(sc, which, mc, chan, val)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n\tint val;\n{\n\tval = uaudio_bsd2value(mc, val);\n\tuaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],\n\t\t   mc->wIndex, MIX_SIZE(mc->type), val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_ctl_set(sc, which, mc, chan, val)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n\tint val;\n{\n\tval = uaudio_bsd2value(mc, val);\n\tuaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],\n\t\t   mc->wIndex, MIX_SIZE(mc->type), val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_mixer_set_port: index = %d\\n\", cp->dev)"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n#define MIX_MAX_CHAN 8\n\nStatic struct;\nuaudio_mixer_set_port __P((void *, mixer_ctrl_t *));\nuaudio_mixer_get_port __P((void *, mixer_ctrl_t *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint i, n, vals[MIX_MAX_CHAN];\n\n\tDPRINTFN(2,(\"uaudio_mixer_set_port: index = %d\\n\", cp->dev));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = cp->dev;\n\tif (n < 0 || n >= sc->sc_nctls)\n\t\treturn (ENXIO);\n\tmc = &sc->sc_ctls[n];\n\n\tif (mc->type == MIX_ON_OFF) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tuaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);\n\t} else {\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.value.num_channels == 1)\n\t\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\t\tvals[i] = cp->un.value.level[0];\n\t\telse if (cp->un.value.num_channels == mc->nchan)\n\t\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\t\tvals[i] = cp->un.value.level[i];\n\t\telse\n\t\t\treturn (EINVAL);\n\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\tuaudio_ctl_set(sc, SET_CUR, mc, i, vals[i]);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "uaudio_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1680-1721",
    "snippet": "int\nuaudio_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint i, n, vals[MIX_MAX_CHAN], val;\n\n\tDPRINTFN(2,(\"uaudio_mixer_get_port: index=%d\\n\", cp->dev));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = cp->dev;\n\tif (n < 0 || n >= sc->sc_nctls)\n\t\treturn (ENXIO);\n\tmc = &sc->sc_ctls[n];\n\n\tif (mc->type == MIX_ON_OFF) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tcp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);\n\t} else {\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.value.num_channels != 1 &&\n\t\t    cp->un.value.num_channels != mc->nchan)\n\t\t\treturn (EINVAL);\n\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\tvals[i] = uaudio_ctl_get(sc, GET_CUR, mc, i);\n\t\tif (cp->un.value.num_channels == 1 && mc->nchan != 1) {\n\t\t\tfor (val = 0, i = 0; i < mc->nchan; i++)\n\t\t\t\tval += vals[i];\n\t\t\tvals[0] = val / mc->nchan;\n\t\t}\n\t\tfor (i = 0; i < cp->un.value.num_channels; i++)\n\t\t\tcp->un.value.level[i] = vals[i];\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1",
      "#define MIX_MAX_CHAN 8"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "uaudio_mixer_set_port __P((void *, mixer_ctrl_t *));",
      "uaudio_mixer_get_port __P((void *, mixer_ctrl_t *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_ctl_get",
          "args": [
            "sc",
            "GET_CUR",
            "mc",
            "i"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_ctl_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1652-1665",
          "snippet": "int\nuaudio_ctl_get(sc, which, mc, chan)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n{\n\tint val;\n\n\tDPRINTFN(5,(\"uaudio_ctl_get: which=%d chan=%d\\n\", which, chan));\n\tval = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],\n\t\t\t mc->wIndex, MIX_SIZE(mc->type));\n\treturn (uaudio_value2bsd(mc, val));\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_ctl_get(sc, which, mc, chan)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n{\n\tint val;\n\n\tDPRINTFN(5,(\"uaudio_ctl_get: which=%d chan=%d\\n\", which, chan));\n\tval = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],\n\t\t\t mc->wIndex, MIX_SIZE(mc->type));\n\treturn (uaudio_value2bsd(mc, val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_mixer_get_port: index=%d\\n\", cp->dev)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n#define MIX_MAX_CHAN 8\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nuaudio_mixer_set_port __P((void *, mixer_ctrl_t *));\nuaudio_mixer_get_port __P((void *, mixer_ctrl_t *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint i, n, vals[MIX_MAX_CHAN], val;\n\n\tDPRINTFN(2,(\"uaudio_mixer_get_port: index=%d\\n\", cp->dev));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = cp->dev;\n\tif (n < 0 || n >= sc->sc_nctls)\n\t\treturn (ENXIO);\n\tmc = &sc->sc_ctls[n];\n\n\tif (mc->type == MIX_ON_OFF) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tcp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);\n\t} else {\n\t\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.value.num_channels != 1 &&\n\t\t    cp->un.value.num_channels != mc->nchan)\n\t\t\treturn (EINVAL);\n\t\tfor (i = 0; i < mc->nchan; i++)\n\t\t\tvals[i] = uaudio_ctl_get(sc, GET_CUR, mc, i);\n\t\tif (cp->un.value.num_channels == 1 && mc->nchan != 1) {\n\t\t\tfor (val = 0, i = 0; i < mc->nchan; i++)\n\t\t\t\tval += vals[i];\n\t\t\tvals[0] = val / mc->nchan;\n\t\t}\n\t\tfor (i = 0; i < cp->un.value.num_channels; i++)\n\t\t\tcp->un.value.level[i] = vals[i];\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "uaudio_ctl_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1667-1678",
    "snippet": "void\nuaudio_ctl_set(sc, which, mc, chan, val)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n\tint val;\n{\n\tval = uaudio_bsd2value(mc, val);\n\tuaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],\n\t\t   mc->wIndex, MIX_SIZE(mc->type), val);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_set",
          "args": [
            "sc",
            "which",
            "UT_WRITE_CLASS_INTERFACE",
            "mc->wValue[chan]",
            "mc->wIndex",
            "MIX_SIZE(mc->type)",
            "val"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_set_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "2329-2349",
          "snippet": "usbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_set_speed(sc, endpt, speed)\n\tstruct uaudio_softc *sc;\n\tint endpt;\n\tu_int speed;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[3];\n\n\tDPRINTFN(5,(\"uaudio_set_speed: endpt=%d speed=%u\\n\", endpt, speed));\n\treq.bmRequestType = UT_WRITE_CLASS_ENDPOINT;\n\treq.bRequest = SET_CUR;\n\tUSETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);\n\tUSETW(req.wIndex, endpt);\n\tUSETW(req.wLength, 3);\n\tdata[0] = speed;\n\tdata[1] = speed >> 8;\n\tdata[2] = speed >> 16;\n\n\treturn (usbd_do_request(sc->sc_udev, &req, &data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIX_SIZE",
          "args": [
            "mc->type"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_bsd2value",
          "args": [
            "mc",
            "val"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_bsd2value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1637-1650",
          "snippet": "int\nuaudio_bsd2value(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5,(\"uaudio_bsd2value: type=%03x val=%d min=%d max=%d \",\n\t\t    mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = val * (mc->maxval - mc->minval) / 256 + mc->minval;\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic struct;\nStatic struct;\n\nint\nuaudio_bsd2value(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5,(\"uaudio_bsd2value: type=%03x val=%d min=%d max=%d \",\n\t\t    mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = val * (mc->maxval - mc->minval) / 256 + mc->minval;\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_ctl_set(sc, which, mc, chan, val)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n\tint val;\n{\n\tval = uaudio_bsd2value(mc, val);\n\tuaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],\n\t\t   mc->wIndex, MIX_SIZE(mc->type), val);\n}"
  },
  {
    "function_name": "uaudio_ctl_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1652-1665",
    "snippet": "int\nuaudio_ctl_get(sc, which, mc, chan)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n{\n\tint val;\n\n\tDPRINTFN(5,(\"uaudio_ctl_get: which=%d chan=%d\\n\", which, chan));\n\tval = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],\n\t\t\t mc->wIndex, MIX_SIZE(mc->type));\n\treturn (uaudio_value2bsd(mc, val));\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_value2bsd",
          "args": [
            "mc",
            "val"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_value2bsd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1621-1635",
          "snippet": "int\nuaudio_value2bsd(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5, (\"uaudio_value2bsd: type=%03x val=%d min=%d max=%d \",\n\t\t     mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = (uaudio_signext(mc->type, val) - mc->minval) * 256\n\t\t\t/ (mc->maxval - mc->minval);\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "Static struct",
            "Static struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic struct;\nStatic struct;\n\nint\nuaudio_value2bsd(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5, (\"uaudio_value2bsd: type=%03x val=%d min=%d max=%d \",\n\t\t     mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = (uaudio_signext(mc->type, val) - mc->minval) * 256\n\t\t\t/ (mc->maxval - mc->minval);\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_get",
          "args": [
            "sc",
            "which",
            "UT_READ_CLASS_INTERFACE",
            "mc->wValue[chan]",
            "mc->wIndex",
            "MIX_SIZE(mc->type)"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1529-1568",
          "snippet": "int\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIX_SIZE",
          "args": [
            "mc->type"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_ctl_get: which=%d chan=%d\\n\", which, chan)"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_ctl_get(sc, which, mc, chan)\n\tstruct uaudio_softc *sc;\n\tint which;\n\tstruct mixerctl *mc;\n\tint chan;\n{\n\tint val;\n\n\tDPRINTFN(5,(\"uaudio_ctl_get: which=%d chan=%d\\n\", which, chan));\n\tval = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],\n\t\t\t mc->wIndex, MIX_SIZE(mc->type));\n\treturn (uaudio_value2bsd(mc, val));\n}"
  },
  {
    "function_name": "uaudio_bsd2value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1637-1650",
    "snippet": "int\nuaudio_bsd2value(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5,(\"uaudio_bsd2value: type=%03x val=%d min=%d max=%d \",\n\t\t    mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = val * (mc->maxval - mc->minval) / 256 + mc->minval;\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"val'=%d\\n\", val)"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_bsd2value: type=%03x val=%d min=%d max=%d \",\n\t\t    mc->type, val, mc->minval, mc->maxval)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic struct;\nStatic struct;\n\nint\nuaudio_bsd2value(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5,(\"uaudio_bsd2value: type=%03x val=%d min=%d max=%d \",\n\t\t    mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = val * (mc->maxval - mc->minval) / 256 + mc->minval;\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}"
  },
  {
    "function_name": "uaudio_value2bsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1621-1635",
    "snippet": "int\nuaudio_value2bsd(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5, (\"uaudio_value2bsd: type=%03x val=%d min=%d max=%d \",\n\t\t     mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = (uaudio_signext(mc->type, val) - mc->minval) * 256\n\t\t\t/ (mc->maxval - mc->minval);\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "Static struct",
      "Static struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"val'=%d\\n\", val)"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_signext",
          "args": [
            "mc->type",
            "val"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_signext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1608-1619",
          "snippet": "int\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\n\nint\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uaudio_value2bsd: type=%03x val=%d min=%d max=%d \",\n\t\t     mc->type, val, mc->minval, mc->maxval)"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic struct;\nStatic struct;\n\nint\nuaudio_value2bsd(mc, val)\n\tstruct mixerctl *mc;\n\tint val;\n{\n\tDPRINTFN(5, (\"uaudio_value2bsd: type=%03x val=%d min=%d max=%d \",\n\t\t     mc->type, val, mc->minval, mc->maxval));\n\tif (mc->type == MIX_ON_OFF)\n\t\tval = val != 0;\n\telse\n\t\tval = (uaudio_signext(mc->type, val) - mc->minval) * 256\n\t\t\t/ (mc->maxval - mc->minval);\n\tDPRINTFN(5, (\"val'=%d\\n\", val));\n\treturn (val);\n}"
  },
  {
    "function_name": "uaudio_signext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1608-1619",
    "snippet": "int\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIX_SIZE",
          "args": [
            "type"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIX_UNSIGNED",
          "args": [
            "type"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\n\nint\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}"
  },
  {
    "function_name": "uaudio_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1570-1606",
    "snippet": "void\nuaudio_set(sc, which, type, wValue, wIndex, len, val)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len, val;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\n\tif (wValue == -1)\n\t\treturn;\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tswitch (len) {\n\tcase 1:\n\t\tdata[0] = val;\n\t\tbreak;\n\tcase 2:\n\t\tdata[0] = val;\n\t\tdata[1] = val >> 8;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d, val=%d\\n\", \n\t\t    type, which, wValue, wIndex, len, val & 0xffff));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n#ifdef UAUDIO_DEBUG\n\tif (err)\n\t\tDPRINTF((\"uaudio_set: err=%d\\n\", err));\n#endif\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_set: err=%d\\n\", err)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "&data"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d, val=%d\\n\", \n\t\t    type, which, wValue, wIndex, len, val & 0xffff)"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "len"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "wIndex"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "wValue"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_set(sc, which, type, wValue, wIndex, len, val)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len, val;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\n\tif (wValue == -1)\n\t\treturn;\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tswitch (len) {\n\tcase 1:\n\t\tdata[0] = val;\n\t\tbreak;\n\tcase 2:\n\t\tdata[0] = val;\n\t\tdata[1] = val >> 8;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d, val=%d\\n\", \n\t\t    type, which, wValue, wIndex, len, val & 0xffff));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n#ifdef UAUDIO_DEBUG\n\tif (err)\n\t\tDPRINTF((\"uaudio_set: err=%d\\n\", err));\n#endif\n}"
  },
  {
    "function_name": "uaudio_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1529-1568",
    "snippet": "int\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_signext __P((int type, int val));",
      "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
      "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
      "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
      "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_get: val=%d\\n\", val)"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_get: bad length=%d\\n\", len)"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_get: err=%s\\n\", usbd_errstr(err))"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "&data"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len)"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "len"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "wIndex"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "wValue"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}"
  },
  {
    "function_name": "uaudio_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1520-1527",
    "snippet": "int\nuaudio_get_props(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\treturn (sc->sc_props);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_get_props(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\treturn (sc->sc_props);\n}"
  },
  {
    "function_name": "uaudio_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1492-1518",
    "snippet": "int\nuaudio_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint bpf;\n\n\tbpf = sc->sc_chan.bytes_per_frame + sc->sc_chan.sample_size;\n\t/* XXX */\n\tbpf *= UAUDIO_NFRAMES * UAUDIO_NCHANBUFS;\n\n\tbpf = (bpf + 15) &~ 15;\n\n\tif (blk < bpf)\n\t\tblk = bpf;\n\n#ifdef DIAGNOSTIC\n\tif (blk <= 0) {\n\t\tprintf(\"uaudio_round_blocksize: blk=%d\\n\", blk);\n\t\tblk = 512;\n\t}\n#endif\n\n\tDPRINTFN(1,(\"uaudio_round_blocksize: blk=%d\\n\", blk));\n\treturn (blk);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uaudio_round_blocksize: blk=%d\\n\", blk)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_round_blocksize: blk=%d\\n\"",
            "blk"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint bpf;\n\n\tbpf = sc->sc_chan.bytes_per_frame + sc->sc_chan.sample_size;\n\t/* XXX */\n\tbpf *= UAUDIO_NFRAMES * UAUDIO_NCHANBUFS;\n\n\tbpf = (bpf + 15) &~ 15;\n\n\tif (blk < bpf)\n\t\tblk = bpf;\n\n#ifdef DIAGNOSTIC\n\tif (blk <= 0) {\n\t\tprintf(\"uaudio_round_blocksize: blk=%d\\n\", blk);\n\t\tblk = 512;\n\t}\n#endif\n\n\tDPRINTFN(1,(\"uaudio_round_blocksize: blk=%d\\n\", blk));\n\treturn (blk);\n}"
  },
  {
    "function_name": "uaudio_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1474-1487",
    "snippet": "int\nuaudio_getdev(addr, retp)\n\tvoid *addr;\n        struct audio_device *retp;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_mixer_getdev:\\n\"));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\t*retp = uaudio_device;\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "uaudio_getdev __P((void *, struct audio_device *));",
      "Static struct",
      "Static struct",
      "audio_device uaudio_device = {\n\t\"USB audio\",\n\t\"\",\n\t\"uaudio\"\n};",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_mixer_getdev:\\n\")"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_getdev __P((void *, struct audio_device *));\nStatic struct;\nStatic struct;\naudio_device uaudio_device = {\n\t\"USB audio\",\n\t\"\",\n\t\"uaudio\"\n};\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_getdev(addr, retp)\n\tvoid *addr;\n        struct audio_device *retp;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_mixer_getdev:\\n\"));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\t*retp = uaudio_device;\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_halt_in_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1459-1472",
    "snippet": "int\nuaudio_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_in_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_chan_free_buffers",
          "args": [
            "sc",
            "&sc->sc_chan"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1934-1943",
          "snippet": "void\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_close",
          "args": [
            "sc",
            "&sc->sc_chan"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1887-1899",
          "snippet": "void\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_halt_in_dma: enter\\n\")"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_in_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_halt_out_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1444-1457",
    "snippet": "int\nuaudio_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_out_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_chan_free_buffers",
          "args": [
            "sc",
            "&sc->sc_chan"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1934-1943",
          "snippet": "void\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
          ],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_free_buffers(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tint i;\n\n\tfor (i = 0; i < UAUDIO_NCHANBUFS; i++)\n\t\tusbd_free_xfer(ch->chanbufs[i].xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_chan_close",
          "args": [
            "sc",
            "&sc->sc_chan"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_chan_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1887-1899",
          "snippet": "void\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_ptransfer __P((struct chan *ch));",
            "uaudio_chan_rtransfer __P((struct chan *ch));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_chan_open __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_close __P((struct uaudio_softc *sc,\n\t\t\t    struct chan *ch));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_ptransfer __P((struct chan *ch));\nuaudio_chan_rtransfer __P((struct chan *ch));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_chan_close(sc, ch)\n\tstruct uaudio_softc *sc;\n\tstruct chan *ch;\n{\n\tif (sc->sc_nullalt >= 0) {\n\t\tDPRINTF((\"uaudio_close_chan: set null alt=%d\\n\",\n\t\t\t sc->sc_nullalt));\n\t\tusbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);\n\t}\n\tusbd_abort_pipe(ch->pipe);\n\tusbd_close_pipe(ch->pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_halt_out_dma: enter\\n\")"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_out_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1433-1442",
    "snippet": "int\nuaudio_drain(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tusbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "sc->sc_udev",
            "UAUDIO_NCHANBUFS * UAUDIO_NFRAMES"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_drain(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tusbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "uaudio_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1420-1431",
    "snippet": "void\nuaudio_close(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_close: sc=%p\\n\", sc));\n\tuaudio_halt_in_dma(sc);\n\tuaudio_halt_out_dma(sc);\n\n\tsc->sc_chan.intr = 0;\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_halt_out_dma",
          "args": [
            "sc"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_halt_out_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1444-1457",
          "snippet": "int\nuaudio_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_out_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_out_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_halt_in_dma",
          "args": [
            "sc"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_halt_in_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1459-1472",
          "snippet": "int\nuaudio_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_in_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_halt_in_dma: enter\\n\"));\n\tif (sc->sc_chan.pipe != NULL) {\n\t\tuaudio_chan_close(sc, &sc->sc_chan);\n\t\tsc->sc_chan.pipe = 0;\n\t\tuaudio_chan_free_buffers(sc, &sc->sc_chan);\n\t}\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_close: sc=%p\\n\", sc)"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_close(addr)\n\tvoid *addr;\n{\n\tstruct uaudio_softc *sc = addr;\n\n\tDPRINTF((\"uaudio_close: sc=%p\\n\", sc));\n\tuaudio_halt_in_dma(sc);\n\tuaudio_halt_out_dma(sc);\n\n\tsc->sc_chan.intr = 0;\n}"
  },
  {
    "function_name": "uaudio_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1393-1415",
    "snippet": "int\nuaudio_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct uaudio_softc *sc = addr;\n\n        DPRINTF((\"uaudio_open: sc=%p\\n\", sc));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_chan.terminal < 0)\n\t\treturn (ENXIO);\n\n\tif ((flags & FREAD) && sc->sc_chan.dir != UE_DIR_IN)\n\t\treturn (EACCES);\n\tif ((flags & FWRITE) && sc->sc_chan.dir != UE_DIR_OUT)\n\t\treturn (EACCES);\n\n        sc->sc_chan.intr = 0;\n\n        return (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_open: sc=%p\\n\", sc)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct uaudio_softc *sc = addr;\n\n        DPRINTF((\"uaudio_open: sc=%p\\n\", sc));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_chan.terminal < 0)\n\t\treturn (ENXIO);\n\n\tif ((flags & FREAD) && sc->sc_chan.dir != UE_DIR_IN)\n\t\treturn (EACCES);\n\tif ((flags & FWRITE) && sc->sc_chan.dir != UE_DIR_OUT)\n\t\treturn (EACCES);\n\n        sc->sc_chan.intr = 0;\n\n        return (0);\n}"
  },
  {
    "function_name": "uaudio_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1331-1391",
    "snippet": "int\nuaudio_query_devinfo(addr, mi)\n\tvoid *addr;\n\tmixer_devinfo_t *mi;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint n, nctls;\n\n\tDPRINTFN(2,(\"uaudio_query_devinfo: index=%d\\n\", mi->index));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = mi->index;\n\tnctls = sc->sc_nctls;\n\n\tif (n < 0 || n >= nctls) {\n\t\tswitch (n - nctls) {\n\t\tcase UAC_OUTPUT:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_OUTPUT;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCoutputs);\n\t\t\treturn (0);\n\t\tcase UAC_INPUT:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_INPUT;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCinputs);\n\t\t\treturn (0);\n\t\tcase UAC_EQUAL:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_EQUAL;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCequalization);\n\t\t\treturn (0);\n\t\tdefault:\n\t\t\treturn (ENXIO);\n\t\t}\n\t}\n\tmc = &sc->sc_ctls[n];\n\tstrncpy(mi->label.name, mc->ctlname, MAX_AUDIO_DEV_LEN);\n\tmi->mixer_class = mc->class;\n\tmi->next = mi->prev = AUDIO_MIXER_LAST;\t/* XXX */\n\tswitch (mc->type) {\n\tcase MIX_ON_OFF:\n\t\tmi->type = AUDIO_MIXER_ENUM;\n\t\tmi->un.e.num_mem = 2;\n\t\tstrcpy(mi->un.e.member[0].label.name, AudioNoff);\n\t\tmi->un.e.member[0].ord = 0;\n\t\tstrcpy(mi->un.e.member[1].label.name, AudioNon);\n\t\tmi->un.e.member[1].ord = 1;\n\t\tbreak;\n\tdefault:\n\t\tmi->type = AUDIO_MIXER_VALUE;\n\t\tstrncpy(mi->un.v.units.name, mc->ctlunit, MAX_AUDIO_DEV_LEN);\n\t\tmi->un.v.num_channels = mc->nchan;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAC_EQUAL  2",
      "#define UAC_INPUT  1",
      "#define UAC_OUTPUT 0",
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "uaudio_query_devinfo __P((void *, mixer_devinfo_t *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "mi->un.v.units.name",
            "mc->ctlunit",
            "MAX_AUDIO_DEV_LEN"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mi->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mi->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "mi->label.name",
            "mc->ctlname",
            "MAX_AUDIO_DEV_LEN"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mi->label.name",
            "AudioCequalization"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mi->label.name",
            "AudioCinputs"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mi->label.name",
            "AudioCoutputs"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_query_devinfo: index=%d\\n\", mi->index)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAC_EQUAL  2\n#define UAC_INPUT  1\n#define UAC_OUTPUT 0\n#define MIX_ON_OFF\t1\n\nStatic struct;\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nuaudio_query_devinfo __P((void *, mixer_devinfo_t *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_query_devinfo(addr, mi)\n\tvoid *addr;\n\tmixer_devinfo_t *mi;\n{\n\tstruct uaudio_softc *sc = addr;\n\tstruct mixerctl *mc;\n\tint n, nctls;\n\n\tDPRINTFN(2,(\"uaudio_query_devinfo: index=%d\\n\", mi->index));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tn = mi->index;\n\tnctls = sc->sc_nctls;\n\n\tif (n < 0 || n >= nctls) {\n\t\tswitch (n - nctls) {\n\t\tcase UAC_OUTPUT:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_OUTPUT;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCoutputs);\n\t\t\treturn (0);\n\t\tcase UAC_INPUT:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_INPUT;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCinputs);\n\t\t\treturn (0);\n\t\tcase UAC_EQUAL:\n\t\t\tmi->type = AUDIO_MIXER_CLASS;\n\t\t\tmi->mixer_class = nctls + UAC_EQUAL;\n\t\t\tmi->next = mi->prev = AUDIO_MIXER_LAST;\n\t\t\tstrcpy(mi->label.name, AudioCequalization);\n\t\t\treturn (0);\n\t\tdefault:\n\t\t\treturn (ENXIO);\n\t\t}\n\t}\n\tmc = &sc->sc_ctls[n];\n\tstrncpy(mi->label.name, mc->ctlname, MAX_AUDIO_DEV_LEN);\n\tmi->mixer_class = mc->class;\n\tmi->next = mi->prev = AUDIO_MIXER_LAST;\t/* XXX */\n\tswitch (mc->type) {\n\tcase MIX_ON_OFF:\n\t\tmi->type = AUDIO_MIXER_ENUM;\n\t\tmi->un.e.num_mem = 2;\n\t\tstrcpy(mi->un.e.member[0].label.name, AudioNoff);\n\t\tmi->un.e.member[0].ord = 0;\n\t\tstrcpy(mi->un.e.member[1].label.name, AudioNon);\n\t\tmi->un.e.member[1].ord = 1;\n\t\tbreak;\n\tdefault:\n\t\tmi->type = AUDIO_MIXER_VALUE;\n\t\tstrncpy(mi->un.v.units.name, mc->ctlunit, MAX_AUDIO_DEV_LEN);\n\t\tmi->un.v.num_channels = mc->nchan;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "uaudio_identify_ac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1223-1329",
    "snippet": "usbd_status\nuaudio_identify_ac(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tstruct usb_audio_control_descriptor *acdp;\n\tusb_descriptor_t *dp, *dps[256];\n\tchar *buf, *ibuf, *ibufend;\n\tint size, offs, aclen, ndps, i;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioControl interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tif (offs + sizeof *acdp > size)\n\t\treturn (USBD_INVAL);\n\tsc->sc_ac_iface = id->bInterfaceNumber;\n\tDPRINTFN(2,(\"uaudio_identify: AC interface is %d\\n\", sc->sc_ac_iface));\n\n\t/* A class-specific AC interface header should follow. */\n\tibuf = buf + offs;\n\tacdp = (struct usb_audio_control_descriptor *)ibuf;\n\tif (acdp->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)\n\t\treturn (USBD_INVAL);\n\taclen = UGETW(acdp->wTotalLength);\n\tif (offs + aclen > size)\n\t\treturn (USBD_INVAL);\n\n\tif (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&\n\t     UGETW(acdp->bcdADC) != UAUDIO_VERSION)\n\t\treturn (USBD_INVAL);\n\n\tsc->sc_audio_rev = UGETW(acdp->bcdADC);\n\tDPRINTFN(2,(\"uaudio_identify: found AC header, vers=%03x, len=%d\\n\",\n\t\t sc->sc_audio_rev, aclen));\n\n\tsc->sc_nullalt = -1;\n\n\t/* Scan through all the AC specific descriptors */\n\tibufend = ibuf + aclen;\n\tdp = (usb_descriptor_t *)ibuf;\n\tndps = 0;\n\tmemset(dps, 0, sizeof dps);\n\tfor (;;) {\n\t\tibuf += dp->bLength;\n\t\tif (ibuf >= ibufend)\n\t\t\tbreak;\n\t\tdp = (usb_descriptor_t *)ibuf;\n\t\tif (ibuf + dp->bLength > ibufend)\n\t\t\treturn (USBD_INVAL);\n\t\tif (dp->bDescriptorType != UDESC_CS_INTERFACE) {\n\t\t\tprintf(\"uaudio_identify: skip desc type=0x%02x\\n\",\n\t\t\t       dp->bDescriptorType);\n\t\t\tcontinue;\n\t\t}\n\t\ti = ((struct usb_audio_input_terminal *)dp)->bTerminalId;\n\t\tdps[i] = dp;\n\t\tif (i > ndps)\n\t\t\tndps = i;\n\t}\n\tndps++;\n\n\tfor (i = 0; i < ndps; i++) {\n\t\tdp = dps[i];\n\t\tif (dp == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"uaudio_identify: subtype=%d\\n\", \n\t\t\t dp->bDescriptorSubtype));\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_HEADER:\n\t\t\tprintf(\"uaudio_identify: unexpected AC header\\n\");\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_INPUT:\n\t\t\tuaudio_add_input(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_OUTPUT:\n\t\t\tuaudio_add_output(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n\t\t\tuaudio_add_mixer(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\tuaudio_add_selector(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n\t\t\tuaudio_add_feature(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n\t\t\tuaudio_add_processing(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_EXTENSION:\n\t\t\tuaudio_add_extension(sc, dp, dps);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"uaudio_identify: bad AC desc subtype=0x%02x\\n\",\n\t\t\t       dp->bDescriptorSubtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "uaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "uaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
      "Static usb_interface_descriptor_t",
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "Static usbd_status",
      "uaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));",
      "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
      "int size;",
      "int subtype;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;",
      "int id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_identify: bad AC desc subtype=0x%02x\\n\"",
            "dp->bDescriptorSubtype"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_extension",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "988-1013",
          "snippet": "void\nuaudio_add_extension(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_extension_unit *d = \n\t    (struct usb_audio_extension_unit *)v;\n\tstruct usb_audio_extension_unit_1 *d1 =\n\t    (struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_extension: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"ext%d-enable\", d->bUnitId);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_extension(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_extension_unit *d = \n\t    (struct usb_audio_extension_unit *)v;\n\tstruct usb_audio_extension_unit_1 *d1 =\n\t    (struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_extension: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"ext%d-enable\", d->bUnitId);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_processing",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_processing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "943-986",
          "snippet": "void\nuaudio_add_processing(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tint ptype = UGETW(d->wProcessType);\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_processing: wProcessType=%d bUnitId=%d \"\n\t\t    \"bNrInPins=%d\\n\", ptype, d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"pro%d.%d-enable\", d->bUnitId, ptype);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n\n\tswitch(ptype) {\n\tcase UPDOWNMIX_PROCESS:\n\t\tuaudio_add_processing_updown(sc, v, dps);\n\t\tbreak;\n\tcase DOLBY_PROLOGIC_PROCESS:\n\tcase P3D_STEREO_EXTENDER_PROCESS:\n\tcase REVERBATION_PROCESS:\n\tcase CHORUS_PROCESS:\n\tcase DYN_RANGE_COMP_PROCESS:\n\tdefault:\n#ifdef UAUDIO_DEBUG\n\t\tprintf(\"uaudio_add_processing: unit %d, type=%d not impl.\\n\",\n\t\t       d->bUnitId, ptype);\n#endif\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_processing(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tint ptype = UGETW(d->wProcessType);\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_processing: wProcessType=%d bUnitId=%d \"\n\t\t    \"bNrInPins=%d\\n\", ptype, d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"pro%d.%d-enable\", d->bUnitId, ptype);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n\n\tswitch(ptype) {\n\tcase UPDOWNMIX_PROCESS:\n\t\tuaudio_add_processing_updown(sc, v, dps);\n\t\tbreak;\n\tcase DOLBY_PROLOGIC_PROCESS:\n\tcase P3D_STEREO_EXTENDER_PROCESS:\n\tcase REVERBATION_PROCESS:\n\tcase CHORUS_PROCESS:\n\tcase DYN_RANGE_COMP_PROCESS:\n\tdefault:\n#ifdef UAUDIO_DEBUG\n\t\tprintf(\"uaudio_add_processing: unit %d, type=%d not impl.\\n\",\n\t\t       d->bUnitId, ptype);\n#endif\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_feature",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "777-901",
          "snippet": "void\nuaudio_add_feature(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_feature_unit *d = (struct usb_audio_feature_unit *)v;\n\tuByte *ctls = d->bmaControls;\n\tint ctlsize = d->bControlSize;\n\tint nchan = (d->bLength - 7) / ctlsize;\n\tint srcId = d->bSourceId;\n\tu_int fumask, mmask, cmask;\n\tstruct mixerctl mix;\n\tint chan, ctl, i, unit;\n\n#define GET(i) (ctls[(i)*ctlsize] | \\\n\t\t(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))\n\n\tmmask = GET(0);\n\t/* Figure out what we can control */\n\tfor (cmask = 0, chan = 1; chan < nchan; chan++) {\n\t\tDPRINTFN(9,(\"uaudio_add_feature: chan=%d mask=%x\\n\",\n\t\t\t    chan, GET(chan)));\n\t\tcmask |= GET(chan);\n\t}\n\n\tDPRINTFN(1,(\"uaudio_add_feature: bUnitId=%d bSourceId=%d, \"\n\t\t    \"%d channels, mmask=0x%04x, cmask=0x%04x\\n\", \n\t\t    d->bUnitId, srcId, nchan, mmask, cmask));\n\n\tif (nchan > MIX_MAX_CHAN)\n\t\tnchan = MIX_MAX_CHAN;\n\tunit = d->bUnitId;\n\tmix.wIndex = MAKE(unit, sc->sc_ac_iface);\n\tfor (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {\n\t\tfumask = FU_MASK(ctl);\n\t\tDPRINTFN(4,(\"uaudio_add_feature: ctl=%d fumask=0x%04x\\n\",\n\t\t\t    ctl, fumask));\n\t\tif (mmask & fumask) {\n\t\t\tmix.nchan = 1;\n\t\t\tmix.wValue[0] = MAKE(ctl, 0);\n\t\t} else if (cmask & fumask) {\n\t\t\tmix.nchan = nchan - 1;\n\t\t\tfor (i = 1; i < nchan; i++) {\n\t\t\t\tif (GET(i) & fumask)\n\t\t\t\t\tmix.wValue[i-1] = MAKE(ctl, i);\n\t\t\t\telse\n\t\t\t\t\tmix.wValue[i-1] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n#undef GET\n\t\tmix.class = -1;\t/* XXX */\n\t\tswitch (ctl) {\n\t\tcase MUTE_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmute);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase VOLUME_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmaster);\n\t\t\tmix.ctlunit = AudioNvolume;\n\t\t\tbreak;\n\t\tcase BASS_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbass);\n\t\t\tmix.ctlunit = AudioNbass;\n\t\t\tbreak;\n\t\tcase MID_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmid);\n\t\t\tmix.ctlunit = AudioNmid;\n\t\t\tbreak;\n\t\tcase TREBLE_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNtreble);\n\t\t\tmix.ctlunit = AudioNtreble;\n\t\t\tbreak;\n\t\tcase GRAPHIC_EQUALIZER_CONTROL:\n\t\t\tcontinue; /* XXX don't add anything */\n\t\t\tbreak;\n\t\tcase AGC_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNagc);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase DELAY_CONTROL:\n\t\t\tmix.type = MIX_UNSIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNdelay);\n\t\t\tmix.ctlunit = \"4 ms\";\n\t\t\tbreak;\n\t\tcase BASS_BOOST_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbassboost);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase LOUDNESS_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNloudness);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_SIGNED_8\t4",
            "#define MIX_UNSIGNED_16\t3",
            "#define MIX_SIGNED_16\t2",
            "#define MIX_ON_OFF\t1",
            "#define MIX_MAX_CHAN 8"
          ],
          "globals_used": [
            "Static char \t\t*uaudio_id_name",
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "uaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_SIGNED_8\t4\n#define MIX_UNSIGNED_16\t3\n#define MIX_SIGNED_16\t2\n#define MIX_ON_OFF\t1\n#define MIX_MAX_CHAN 8\n\nStatic char \t\t*uaudio_id_name;\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nuaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_feature(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_feature_unit *d = (struct usb_audio_feature_unit *)v;\n\tuByte *ctls = d->bmaControls;\n\tint ctlsize = d->bControlSize;\n\tint nchan = (d->bLength - 7) / ctlsize;\n\tint srcId = d->bSourceId;\n\tu_int fumask, mmask, cmask;\n\tstruct mixerctl mix;\n\tint chan, ctl, i, unit;\n\n#define GET(i) (ctls[(i)*ctlsize] | \\\n\t\t(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))\n\n\tmmask = GET(0);\n\t/* Figure out what we can control */\n\tfor (cmask = 0, chan = 1; chan < nchan; chan++) {\n\t\tDPRINTFN(9,(\"uaudio_add_feature: chan=%d mask=%x\\n\",\n\t\t\t    chan, GET(chan)));\n\t\tcmask |= GET(chan);\n\t}\n\n\tDPRINTFN(1,(\"uaudio_add_feature: bUnitId=%d bSourceId=%d, \"\n\t\t    \"%d channels, mmask=0x%04x, cmask=0x%04x\\n\", \n\t\t    d->bUnitId, srcId, nchan, mmask, cmask));\n\n\tif (nchan > MIX_MAX_CHAN)\n\t\tnchan = MIX_MAX_CHAN;\n\tunit = d->bUnitId;\n\tmix.wIndex = MAKE(unit, sc->sc_ac_iface);\n\tfor (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {\n\t\tfumask = FU_MASK(ctl);\n\t\tDPRINTFN(4,(\"uaudio_add_feature: ctl=%d fumask=0x%04x\\n\",\n\t\t\t    ctl, fumask));\n\t\tif (mmask & fumask) {\n\t\t\tmix.nchan = 1;\n\t\t\tmix.wValue[0] = MAKE(ctl, 0);\n\t\t} else if (cmask & fumask) {\n\t\t\tmix.nchan = nchan - 1;\n\t\t\tfor (i = 1; i < nchan; i++) {\n\t\t\t\tif (GET(i) & fumask)\n\t\t\t\t\tmix.wValue[i-1] = MAKE(ctl, i);\n\t\t\t\telse\n\t\t\t\t\tmix.wValue[i-1] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n#undef GET\n\t\tmix.class = -1;\t/* XXX */\n\t\tswitch (ctl) {\n\t\tcase MUTE_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmute);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase VOLUME_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmaster);\n\t\t\tmix.ctlunit = AudioNvolume;\n\t\t\tbreak;\n\t\tcase BASS_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbass);\n\t\t\tmix.ctlunit = AudioNbass;\n\t\t\tbreak;\n\t\tcase MID_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmid);\n\t\t\tmix.ctlunit = AudioNmid;\n\t\t\tbreak;\n\t\tcase TREBLE_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNtreble);\n\t\t\tmix.ctlunit = AudioNtreble;\n\t\t\tbreak;\n\t\tcase GRAPHIC_EQUALIZER_CONTROL:\n\t\t\tcontinue; /* XXX don't add anything */\n\t\t\tbreak;\n\t\tcase AGC_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNagc);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase DELAY_CONTROL:\n\t\t\tmix.type = MIX_UNSIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNdelay);\n\t\t\tmix.ctlunit = \"4 ms\";\n\t\t\tbreak;\n\t\tcase BASS_BOOST_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbassboost);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase LOUDNESS_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNloudness);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_selector",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_selector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "761-775",
          "snippet": "void\nuaudio_add_selector(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_selector_unit *d =\n\t\t(struct usb_audio_selector_unit *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_selector: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n#endif\n\tprintf(\"uaudio_add_selector: NOT IMPLEMENTED\\n\");\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_selector(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_selector_unit *d =\n\t\t(struct usb_audio_selector_unit *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_selector: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n#endif\n\tprintf(\"uaudio_add_selector: NOT IMPLEMENTED\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_mixer",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_mixer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "695-759",
          "snippet": "void\nuaudio_add_mixer(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_mixer_unit *d = (struct usb_audio_mixer_unit *)v;\n\tstruct usb_audio_mixer_unit_1 *d1;\n\tint c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;\n\tuByte *bm;\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\t\n\t/* Compute the number of input channels */\n\tichs = 0;\n\tfor (i = 0; i < d->bNrInPins; i++)\n\t\tichs += uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\n\t/* and the number of output channels */\n\td1 = (struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tochs = d1->bNrChannels;\n\tDPRINTFN(2,(\"uaudio_add_mixer: ichs=%d ochs=%d\\n\", ichs, ochs));\n\n\tbm = d1->bmControls;\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.class = -1;\n\tmix.type = MIX_SIGNED_16;\n\tmix.ctlunit = AudioNvolume;\n#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)\n\tfor (p = i = 0; i < d->bNrInPins; i++) {\n\t\tchs = uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\t\tmc = 0;\n\t\tfor (c = 0; c < chs; c++) {\n\t\t\tmo = 0;\n\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\tif (BIT(bno))\n\t\t\t\t\tmo++;\n\t\t\t}\n\t\t\tif (mo == 1)\n\t\t\t\tmc++;\n\t\t}\n\t\tif (mc == chs && chs <= MIX_MAX_CHAN) {\n\t\t\tk = 0;\n\t\t\tfor (c = 0; c < chs; c++)\n\t\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\t\tif (BIT(bno))\n\t\t\t\t\t\tmix.wValue[k++] = \n\t\t\t\t\t\t\tMAKE(p+c+1, o+1);\n\t\t\t\t}\n\t\t\tsprintf(mix.ctlname, \"mix%d-%s\", d->bUnitId,\n\t\t\t\tuaudio_id_name(sc, dps, d->baSourceId[i]));\n\t\t\tmix.nchan = chs;\n\t\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t\t} else {\n\t\t\t/* XXX */\n\t\t}\n#undef BIT\n\t\tp += chs;\n\t}\n\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)",
            "#define MIX_SIGNED_16\t2",
            "#define MIX_MAX_CHAN 8"
          ],
          "globals_used": [
            "Static char \t\t*uaudio_id_name",
            "Static struct",
            "usb_audio_cluster uaudio_get_cluster",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define MIX_SIGNED_16\t2\n#define MIX_MAX_CHAN 8\n\nStatic char \t\t*uaudio_id_name;\nStatic struct;\nusb_audio_cluster uaudio_get_cluster;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_mixer(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_mixer_unit *d = (struct usb_audio_mixer_unit *)v;\n\tstruct usb_audio_mixer_unit_1 *d1;\n\tint c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;\n\tuByte *bm;\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\t\n\t/* Compute the number of input channels */\n\tichs = 0;\n\tfor (i = 0; i < d->bNrInPins; i++)\n\t\tichs += uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\n\t/* and the number of output channels */\n\td1 = (struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tochs = d1->bNrChannels;\n\tDPRINTFN(2,(\"uaudio_add_mixer: ichs=%d ochs=%d\\n\", ichs, ochs));\n\n\tbm = d1->bmControls;\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.class = -1;\n\tmix.type = MIX_SIGNED_16;\n\tmix.ctlunit = AudioNvolume;\n#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)\n\tfor (p = i = 0; i < d->bNrInPins; i++) {\n\t\tchs = uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\t\tmc = 0;\n\t\tfor (c = 0; c < chs; c++) {\n\t\t\tmo = 0;\n\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\tif (BIT(bno))\n\t\t\t\t\tmo++;\n\t\t\t}\n\t\t\tif (mo == 1)\n\t\t\t\tmc++;\n\t\t}\n\t\tif (mc == chs && chs <= MIX_MAX_CHAN) {\n\t\t\tk = 0;\n\t\t\tfor (c = 0; c < chs; c++)\n\t\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\t\tif (BIT(bno))\n\t\t\t\t\t\tmix.wValue[k++] = \n\t\t\t\t\t\t\tMAKE(p+c+1, o+1);\n\t\t\t\t}\n\t\t\tsprintf(mix.ctlname, \"mix%d-%s\", d->bUnitId,\n\t\t\t\tuaudio_id_name(sc, dps, d->baSourceId[i]));\n\t\t\tmix.nchan = chs;\n\t\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t\t} else {\n\t\t\t/* XXX */\n\t\t}\n#undef BIT\n\t\tp += chs;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_output",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "678-693",
          "snippet": "void\nuaudio_add_output(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_output_terminal *d = \n\t\t(struct usb_audio_output_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bSourceId=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bSourceId, d->iTerminal));\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_output(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_output_terminal *d = \n\t\t(struct usb_audio_output_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bSourceId=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bSourceId, d->iTerminal));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_input",
          "args": [
            "sc",
            "dp",
            "dps"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "659-676",
          "snippet": "void\nuaudio_add_input(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_input_terminal *d = \n\t\t(struct usb_audio_input_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d \"\n\t\t    \"iChannelNames=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bNrChannels, UGETW(d->wChannelConfig),\n\t\t    d->iChannelNames, d->iTerminal));\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_input(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_input_terminal *d = \n\t\t(struct usb_audio_input_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d \"\n\t\t    \"iChannelNames=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bNrChannels, UGETW(d->wChannelConfig),\n\t\t    d->iChannelNames, d->iTerminal));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_identify: subtype=%d\\n\", \n\t\t\t dp->bDescriptorSubtype)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dps",
            "0",
            "sizeof dps"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_identify: found AC header, vers=%03x, len=%d\\n\",\n\t\t sc->sc_audio_rev, aclen)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "acdp->bcdADC"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "acdp->bcdADC"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_quirks",
          "args": [
            "sc->sc_udev"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "acdp->wTotalLength"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_identify: AC interface is %d\\n\", sc->sc_ac_iface)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_find_iface",
          "args": [
            "buf",
            "size",
            "&offs",
            "UISUBCLASS_AUDIOCONTROL"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "cdesc->wTotalLength"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic usb_interface_descriptor_t;\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nStatic usbd_status;\nuaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nint subtype;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\nint id;\n\nusbd_status\nuaudio_identify_ac(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tstruct usb_audio_control_descriptor *acdp;\n\tusb_descriptor_t *dp, *dps[256];\n\tchar *buf, *ibuf, *ibufend;\n\tint size, offs, aclen, ndps, i;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioControl interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tif (offs + sizeof *acdp > size)\n\t\treturn (USBD_INVAL);\n\tsc->sc_ac_iface = id->bInterfaceNumber;\n\tDPRINTFN(2,(\"uaudio_identify: AC interface is %d\\n\", sc->sc_ac_iface));\n\n\t/* A class-specific AC interface header should follow. */\n\tibuf = buf + offs;\n\tacdp = (struct usb_audio_control_descriptor *)ibuf;\n\tif (acdp->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)\n\t\treturn (USBD_INVAL);\n\taclen = UGETW(acdp->wTotalLength);\n\tif (offs + aclen > size)\n\t\treturn (USBD_INVAL);\n\n\tif (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&\n\t     UGETW(acdp->bcdADC) != UAUDIO_VERSION)\n\t\treturn (USBD_INVAL);\n\n\tsc->sc_audio_rev = UGETW(acdp->bcdADC);\n\tDPRINTFN(2,(\"uaudio_identify: found AC header, vers=%03x, len=%d\\n\",\n\t\t sc->sc_audio_rev, aclen));\n\n\tsc->sc_nullalt = -1;\n\n\t/* Scan through all the AC specific descriptors */\n\tibufend = ibuf + aclen;\n\tdp = (usb_descriptor_t *)ibuf;\n\tndps = 0;\n\tmemset(dps, 0, sizeof dps);\n\tfor (;;) {\n\t\tibuf += dp->bLength;\n\t\tif (ibuf >= ibufend)\n\t\t\tbreak;\n\t\tdp = (usb_descriptor_t *)ibuf;\n\t\tif (ibuf + dp->bLength > ibufend)\n\t\t\treturn (USBD_INVAL);\n\t\tif (dp->bDescriptorType != UDESC_CS_INTERFACE) {\n\t\t\tprintf(\"uaudio_identify: skip desc type=0x%02x\\n\",\n\t\t\t       dp->bDescriptorType);\n\t\t\tcontinue;\n\t\t}\n\t\ti = ((struct usb_audio_input_terminal *)dp)->bTerminalId;\n\t\tdps[i] = dp;\n\t\tif (i > ndps)\n\t\t\tndps = i;\n\t}\n\tndps++;\n\n\tfor (i = 0; i < ndps; i++) {\n\t\tdp = dps[i];\n\t\tif (dp == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"uaudio_identify: subtype=%d\\n\", \n\t\t\t dp->bDescriptorSubtype));\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_HEADER:\n\t\t\tprintf(\"uaudio_identify: unexpected AC header\\n\");\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_INPUT:\n\t\t\tuaudio_add_input(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_OUTPUT:\n\t\t\tuaudio_add_output(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n\t\t\tuaudio_add_mixer(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\tuaudio_add_selector(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n\t\t\tuaudio_add_feature(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n\t\t\tuaudio_add_processing(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_EXTENSION:\n\t\t\tuaudio_add_extension(sc, dp, dps);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"uaudio_identify: bad AC desc subtype=0x%02x\\n\",\n\t\t\t       dp->bDescriptorSubtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uaudio_identify_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1166-1221",
    "snippet": "usbd_status\nuaudio_identify_as(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tusbd_status err;\n\tchar *buf;\n\tint size, offs;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioStreaming interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tsc->sc_as_iface = id->bInterfaceNumber;\n\tDPRINTF((\"uaudio_identify_as: AS interface is %d\\n\", sc->sc_as_iface));\n\n\tsc->sc_chan.terminal = -1;\n\n\t/* Loop through all the alternate settings. */\n\twhile (offs <= size) {\n\t\tswitch (id->bNumEndpoints) {\n\t\tcase 0:\n\t\t\tDPRINTFN(2, (\"uaudio_identify: AS null alt=%d\\n\",\n\t\t\t\t     id->bAlternateSetting));\n\t\t\tsc->sc_nullalt = id->bAlternateSetting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\terr = uaudio_process_as(sc, buf, &offs, size, id);\n\t\t\tbreak;\n\t\tdefault:\n#ifdef AUDIO_DEBUG\n\t\t\tprintf(\"%s: ignored audio interface with %d \"\n\t\t\t       \"endpoints\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tid = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);\n\t\tif (id == NULL)\n\t\t\tbreak;\n\t}\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_identify_as: %d alts available\\n\", sc->sc_nalts));\n\tif (sc->sc_chan.terminal < 0) {\n\t\tprintf(\"%s: no useable endpoint found\\n\", \n\t\t       USBDEVNAME(sc->sc_dev));\n\t\treturn (USBD_INVAL);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "uaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "uaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
      "Static usb_interface_descriptor_t",
      "Static struct",
      "Static usbd_status",
      "uaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
      "int size;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "int id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no useable endpoint found\\n\"",
            "USBDEVNAME(sc->sc_dev)"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_identify_as: %d alts available\\n\", sc->sc_nalts)"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_find_iface",
          "args": [
            "buf",
            "size",
            "&offs",
            "UISUBCLASS_AUDIOSTREAM"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_process_as",
          "args": [
            "sc",
            "buf",
            "&offs",
            "size",
            "id"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_process_as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1048-1163",
          "snippet": "usbd_status\nuaudio_process_as(sc, buf, offsp, size, id)\n\tstruct uaudio_softc *sc;\n\tchar *buf;\n\tint *offsp;\n#define offs (*offsp)\n\tint size;\n\tusb_interface_descriptor_t *id;\n{\n\tstruct usb_audio_streaming_interface_descriptor *asid;\n\tstruct usb_audio_streaming_type1_descriptor *asf1d;\n\tusb_endpoint_descriptor_audio_t *ed;\n\tstruct usb_audio_streaming_endpoint_descriptor *sed;\n\tint format, chan, prec, enc;\n\tint dir, type;\n\tstruct as_info ai;\n\n\tasid = (void *)(buf + offs);\n\tif (asid->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asid->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += asid->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tasf1d = (void *)(buf + offs);\n\tif (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asf1d->bDescriptorSubtype != FORMAT_TYPE)\n\t\treturn (USBD_INVAL);\n\toffs += asf1d->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\n\tif (asf1d->bFormatType != FORMAT_TYPE_I) {\n\t\tprintf(\"%s: ignored setting with type %d format\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\ted = (void *)(buf + offs);\n\tif (ed->bDescriptorType != UDESC_ENDPOINT)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d \"\n\t\t \"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d \"\n\t\t \"bInterval=%d bRefresh=%d bSynchAddress=%d\\n\",\n\t\t ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,\n\t\t ed->bmAttributes, UGETW(ed->wMaxPacketSize),\n\t\t ed->bInterval, ed->bRefresh, ed->bSynchAddress));\n\toffs += ed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tif (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)\n\t\treturn (USBD_INVAL);\n\n\tdir = UE_GET_DIR(ed->bEndpointAddress);\n\ttype = UE_GET_ISO_TYPE(ed->bmAttributes);\n\t/* We can't handle endpoints that need a sync pipe. */\n\tif (dir == UE_DIR_IN ? type == UE_ISO_ADAPT : type == UE_ISO_ASYNC) {\n\t\tprintf(\"%s: ignored %sput endpoint of type 0x%x\\n\",\n\t\t       USBDEVNAME(sc->sc_dev),\n\t\t       dir == UE_DIR_IN ? \"in\" : \"out\",\n\t\t       ed->bmAttributes & UE_ISO_TYPE);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\t\n\tsed = (void *)(buf + offs);\n\tif (sed->bDescriptorType != UDESC_CS_ENDPOINT ||\n\t    sed->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += sed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\t\n\tformat = UGETW(asid->wFormatTag);\n\tchan = asf1d->bNrChannels;\n\tprec = asf1d->bBitResolution;\n\tif (prec != 8 && prec != 16) {\n#ifdef AUDIO_DEBUG\n\t\tprintf(\"%s: ignored setting with precision %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), prec);\n#endif\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tswitch (format) {\n\tcase UA_FMT_PCM:\n\t\tsc->sc_altflags |= prec == 8 ? HAS_8 : HAS_16;\n\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\tbreak;\n\tcase UA_FMT_PCM8:\n\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\tsc->sc_altflags |= HAS_8U;\n\t\tbreak;\n\tcase UA_FMT_ALAW:\n\t\tenc = AUDIO_ENCODING_ALAW;\n\t\tsc->sc_altflags |= HAS_ALAW;\n\t\tbreak;\n\tcase UA_FMT_MULAW:\n\t\tenc = AUDIO_ENCODING_ULAW;\n\t\tsc->sc_altflags |= HAS_MULAW;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: ignored setting with format %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), format);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tDPRINTFN(1,(\"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\\n\",\n\t\t    id->bAlternateSetting, enc, chan, prec));\n\tai.alt = id->bAlternateSetting;\n\tai.encoding = enc;\n\tai.idesc = id;\n\tai.edesc = ed;\n\tai.asf1desc = asf1d;\n\tuaudio_add_alt(sc, &ai);\n\tsc->sc_chan.terminal = asid->bTerminalLink; /* XXX */\n\tsc->sc_chan.dir = dir;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define HAS_MULAW 0x10",
            "#define HAS_ALAW  0x08",
            "#define HAS_8U    0x04",
            "#define HAS_16    0x02",
            "#define HAS_8     0x01"
          ],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
            "uaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));",
            "Static usb_interface_descriptor_t",
            "Static struct",
            "Static usbd_status",
            "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
            "Static struct",
            "Static struct",
            "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
            "int size;",
            "int *offsp;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "int id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define HAS_MULAW 0x10\n#define HAS_ALAW  0x08\n#define HAS_8U    0x04\n#define HAS_16    0x02\n#define HAS_8     0x01\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nuaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));\nStatic usb_interface_descriptor_t;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nint *offsp;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nint id;\n\nusbd_status\nuaudio_process_as(sc, buf, offsp, size, id)\n\tstruct uaudio_softc *sc;\n\tchar *buf;\n\tint *offsp;\n#define offs (*offsp)\n\tint size;\n\tusb_interface_descriptor_t *id;\n{\n\tstruct usb_audio_streaming_interface_descriptor *asid;\n\tstruct usb_audio_streaming_type1_descriptor *asf1d;\n\tusb_endpoint_descriptor_audio_t *ed;\n\tstruct usb_audio_streaming_endpoint_descriptor *sed;\n\tint format, chan, prec, enc;\n\tint dir, type;\n\tstruct as_info ai;\n\n\tasid = (void *)(buf + offs);\n\tif (asid->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asid->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += asid->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tasf1d = (void *)(buf + offs);\n\tif (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asf1d->bDescriptorSubtype != FORMAT_TYPE)\n\t\treturn (USBD_INVAL);\n\toffs += asf1d->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\n\tif (asf1d->bFormatType != FORMAT_TYPE_I) {\n\t\tprintf(\"%s: ignored setting with type %d format\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\ted = (void *)(buf + offs);\n\tif (ed->bDescriptorType != UDESC_ENDPOINT)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d \"\n\t\t \"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d \"\n\t\t \"bInterval=%d bRefresh=%d bSynchAddress=%d\\n\",\n\t\t ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,\n\t\t ed->bmAttributes, UGETW(ed->wMaxPacketSize),\n\t\t ed->bInterval, ed->bRefresh, ed->bSynchAddress));\n\toffs += ed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tif (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)\n\t\treturn (USBD_INVAL);\n\n\tdir = UE_GET_DIR(ed->bEndpointAddress);\n\ttype = UE_GET_ISO_TYPE(ed->bmAttributes);\n\t/* We can't handle endpoints that need a sync pipe. */\n\tif (dir == UE_DIR_IN ? type == UE_ISO_ADAPT : type == UE_ISO_ASYNC) {\n\t\tprintf(\"%s: ignored %sput endpoint of type 0x%x\\n\",\n\t\t       USBDEVNAME(sc->sc_dev),\n\t\t       dir == UE_DIR_IN ? \"in\" : \"out\",\n\t\t       ed->bmAttributes & UE_ISO_TYPE);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\t\n\tsed = (void *)(buf + offs);\n\tif (sed->bDescriptorType != UDESC_CS_ENDPOINT ||\n\t    sed->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += sed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\t\n\tformat = UGETW(asid->wFormatTag);\n\tchan = asf1d->bNrChannels;\n\tprec = asf1d->bBitResolution;\n\tif (prec != 8 && prec != 16) {\n#ifdef AUDIO_DEBUG\n\t\tprintf(\"%s: ignored setting with precision %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), prec);\n#endif\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tswitch (format) {\n\tcase UA_FMT_PCM:\n\t\tsc->sc_altflags |= prec == 8 ? HAS_8 : HAS_16;\n\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\tbreak;\n\tcase UA_FMT_PCM8:\n\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\tsc->sc_altflags |= HAS_8U;\n\t\tbreak;\n\tcase UA_FMT_ALAW:\n\t\tenc = AUDIO_ENCODING_ALAW;\n\t\tsc->sc_altflags |= HAS_ALAW;\n\t\tbreak;\n\tcase UA_FMT_MULAW:\n\t\tenc = AUDIO_ENCODING_ULAW;\n\t\tsc->sc_altflags |= HAS_MULAW;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: ignored setting with format %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), format);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tDPRINTFN(1,(\"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\\n\",\n\t\t    id->bAlternateSetting, enc, chan, prec));\n\tai.alt = id->bAlternateSetting;\n\tai.encoding = enc;\n\tai.idesc = id;\n\tai.edesc = ed;\n\tai.asf1desc = asf1d;\n\tuaudio_add_alt(sc, &ai);\n\tsc->sc_chan.terminal = asid->bTerminalLink; /* XXX */\n\tsc->sc_chan.dir = dir;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_identify: AS null alt=%d\\n\",\n\t\t\t\t     id->bAlternateSetting)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_identify_as: AS interface is %d\\n\", sc->sc_as_iface)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_find_iface",
          "args": [
            "buf",
            "size",
            "&offs",
            "UISUBCLASS_AUDIOSTREAM"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "cdesc->wTotalLength"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic usb_interface_descriptor_t;\nStatic struct;\nStatic usbd_status;\nuaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nint id;\n\nusbd_status\nuaudio_identify_as(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tusbd_status err;\n\tchar *buf;\n\tint size, offs;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioStreaming interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tsc->sc_as_iface = id->bInterfaceNumber;\n\tDPRINTF((\"uaudio_identify_as: AS interface is %d\\n\", sc->sc_as_iface));\n\n\tsc->sc_chan.terminal = -1;\n\n\t/* Loop through all the alternate settings. */\n\twhile (offs <= size) {\n\t\tswitch (id->bNumEndpoints) {\n\t\tcase 0:\n\t\t\tDPRINTFN(2, (\"uaudio_identify: AS null alt=%d\\n\",\n\t\t\t\t     id->bAlternateSetting));\n\t\t\tsc->sc_nullalt = id->bAlternateSetting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\terr = uaudio_process_as(sc, buf, &offs, size, id);\n\t\t\tbreak;\n\t\tdefault:\n#ifdef AUDIO_DEBUG\n\t\t\tprintf(\"%s: ignored audio interface with %d \"\n\t\t\t       \"endpoints\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tid = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);\n\t\tif (id == NULL)\n\t\t\tbreak;\n\t}\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_identify_as: %d alts available\\n\", sc->sc_nalts));\n\tif (sc->sc_chan.terminal < 0) {\n\t\tprintf(\"%s: no useable endpoint found\\n\", \n\t\t       USBDEVNAME(sc->sc_dev));\n\t\treturn (USBD_INVAL);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uaudio_process_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1048-1163",
    "snippet": "usbd_status\nuaudio_process_as(sc, buf, offsp, size, id)\n\tstruct uaudio_softc *sc;\n\tchar *buf;\n\tint *offsp;\n#define offs (*offsp)\n\tint size;\n\tusb_interface_descriptor_t *id;\n{\n\tstruct usb_audio_streaming_interface_descriptor *asid;\n\tstruct usb_audio_streaming_type1_descriptor *asf1d;\n\tusb_endpoint_descriptor_audio_t *ed;\n\tstruct usb_audio_streaming_endpoint_descriptor *sed;\n\tint format, chan, prec, enc;\n\tint dir, type;\n\tstruct as_info ai;\n\n\tasid = (void *)(buf + offs);\n\tif (asid->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asid->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += asid->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tasf1d = (void *)(buf + offs);\n\tif (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asf1d->bDescriptorSubtype != FORMAT_TYPE)\n\t\treturn (USBD_INVAL);\n\toffs += asf1d->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\n\tif (asf1d->bFormatType != FORMAT_TYPE_I) {\n\t\tprintf(\"%s: ignored setting with type %d format\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\ted = (void *)(buf + offs);\n\tif (ed->bDescriptorType != UDESC_ENDPOINT)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d \"\n\t\t \"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d \"\n\t\t \"bInterval=%d bRefresh=%d bSynchAddress=%d\\n\",\n\t\t ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,\n\t\t ed->bmAttributes, UGETW(ed->wMaxPacketSize),\n\t\t ed->bInterval, ed->bRefresh, ed->bSynchAddress));\n\toffs += ed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tif (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)\n\t\treturn (USBD_INVAL);\n\n\tdir = UE_GET_DIR(ed->bEndpointAddress);\n\ttype = UE_GET_ISO_TYPE(ed->bmAttributes);\n\t/* We can't handle endpoints that need a sync pipe. */\n\tif (dir == UE_DIR_IN ? type == UE_ISO_ADAPT : type == UE_ISO_ASYNC) {\n\t\tprintf(\"%s: ignored %sput endpoint of type 0x%x\\n\",\n\t\t       USBDEVNAME(sc->sc_dev),\n\t\t       dir == UE_DIR_IN ? \"in\" : \"out\",\n\t\t       ed->bmAttributes & UE_ISO_TYPE);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\t\n\tsed = (void *)(buf + offs);\n\tif (sed->bDescriptorType != UDESC_CS_ENDPOINT ||\n\t    sed->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += sed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\t\n\tformat = UGETW(asid->wFormatTag);\n\tchan = asf1d->bNrChannels;\n\tprec = asf1d->bBitResolution;\n\tif (prec != 8 && prec != 16) {\n#ifdef AUDIO_DEBUG\n\t\tprintf(\"%s: ignored setting with precision %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), prec);\n#endif\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tswitch (format) {\n\tcase UA_FMT_PCM:\n\t\tsc->sc_altflags |= prec == 8 ? HAS_8 : HAS_16;\n\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\tbreak;\n\tcase UA_FMT_PCM8:\n\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\tsc->sc_altflags |= HAS_8U;\n\t\tbreak;\n\tcase UA_FMT_ALAW:\n\t\tenc = AUDIO_ENCODING_ALAW;\n\t\tsc->sc_altflags |= HAS_ALAW;\n\t\tbreak;\n\tcase UA_FMT_MULAW:\n\t\tenc = AUDIO_ENCODING_ULAW;\n\t\tsc->sc_altflags |= HAS_MULAW;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: ignored setting with format %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), format);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tDPRINTFN(1,(\"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\\n\",\n\t\t    id->bAlternateSetting, enc, chan, prec));\n\tai.alt = id->bAlternateSetting;\n\tai.encoding = enc;\n\tai.idesc = id;\n\tai.edesc = ed;\n\tai.asf1desc = asf1d;\n\tuaudio_add_alt(sc, &ai);\n\tsc->sc_chan.terminal = asid->bTerminalLink; /* XXX */\n\tsc->sc_chan.dir = dir;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define HAS_MULAW 0x10",
      "#define HAS_ALAW  0x08",
      "#define HAS_8U    0x04",
      "#define HAS_16    0x02",
      "#define HAS_8     0x01"
    ],
    "globals_used": [
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
      "uaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));",
      "Static usb_interface_descriptor_t",
      "Static struct",
      "Static usbd_status",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "Static struct",
      "Static struct",
      "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
      "int size;",
      "int *offsp;",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "int id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_add_alt",
          "args": [
            "sc",
            "&ai"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_alt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1028-1046",
          "snippet": "void\nuaudio_add_alt(sc, ai)\n\tstruct uaudio_softc *sc;\n\tstruct as_info *ai;\n{\n\tif (sc->sc_nalts == NULL)\n\t\tsc->sc_alts = malloc(sizeof *ai, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_alts = realloc(sc->sc_alts,\n\t\t\t\t      (sc->sc_nalts+1) * sizeof *ai,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_alts == NULL) {\n\t\tprintf(\"uaudio_add_alt: no memory\\n\");\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_add_alt: adding alt=%d, enc=%d\\n\",\n\t\t    ai->alt, ai->encoding));\n\tsc->sc_alts[sc->sc_nalts++] = *ai;\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));",
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_add_alt(sc, ai)\n\tstruct uaudio_softc *sc;\n\tstruct as_info *ai;\n{\n\tif (sc->sc_nalts == NULL)\n\t\tsc->sc_alts = malloc(sizeof *ai, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_alts = realloc(sc->sc_alts,\n\t\t\t\t      (sc->sc_nalts+1) * sizeof *ai,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_alts == NULL) {\n\t\tprintf(\"uaudio_add_alt: no memory\\n\");\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_add_alt: adding alt=%d, enc=%d\\n\",\n\t\t    ai->alt, ai->encoding));\n\tsc->sc_alts[sc->sc_nalts++] = *ai;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\\n\",\n\t\t    id->bAlternateSetting, enc, chan, prec)"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ignored setting with format %d\\n\"",
            "USBDEVNAME(sc->sc_dev)",
            "format"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "asid->wFormatTag"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_ISO_TYPE",
          "args": [
            "ed->bmAttributes"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "ed->bEndpointAddress"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_XFERTYPE",
          "args": [
            "ed->bmAttributes"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d \"\n\t\t \"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d \"\n\t\t \"bInterval=%d bRefresh=%d bSynchAddress=%d\\n\",\n\t\t ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,\n\t\t ed->bmAttributes, UGETW(ed->wMaxPacketSize),\n\t\t ed->bInterval, ed->bRefresh, ed->bSynchAddress)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ed->wMaxPacketSize"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "asid->wFormatTag"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define HAS_MULAW 0x10\n#define HAS_ALAW  0x08\n#define HAS_8U    0x04\n#define HAS_16    0x02\n#define HAS_8     0x01\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nuaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));\nStatic usb_interface_descriptor_t;\nStatic struct;\nStatic usbd_status;\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nint *offsp;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nint id;\n\nusbd_status\nuaudio_process_as(sc, buf, offsp, size, id)\n\tstruct uaudio_softc *sc;\n\tchar *buf;\n\tint *offsp;\n#define offs (*offsp)\n\tint size;\n\tusb_interface_descriptor_t *id;\n{\n\tstruct usb_audio_streaming_interface_descriptor *asid;\n\tstruct usb_audio_streaming_type1_descriptor *asf1d;\n\tusb_endpoint_descriptor_audio_t *ed;\n\tstruct usb_audio_streaming_endpoint_descriptor *sed;\n\tint format, chan, prec, enc;\n\tint dir, type;\n\tstruct as_info ai;\n\n\tasid = (void *)(buf + offs);\n\tif (asid->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asid->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += asid->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tasf1d = (void *)(buf + offs);\n\tif (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    asf1d->bDescriptorSubtype != FORMAT_TYPE)\n\t\treturn (USBD_INVAL);\n\toffs += asf1d->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\n\tif (asf1d->bFormatType != FORMAT_TYPE_I) {\n\t\tprintf(\"%s: ignored setting with type %d format\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\n\ted = (void *)(buf + offs);\n\tif (ed->bDescriptorType != UDESC_ENDPOINT)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d \"\n\t\t \"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d \"\n\t\t \"bInterval=%d bRefresh=%d bSynchAddress=%d\\n\",\n\t\t ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,\n\t\t ed->bmAttributes, UGETW(ed->wMaxPacketSize),\n\t\t ed->bInterval, ed->bRefresh, ed->bSynchAddress));\n\toffs += ed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tif (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)\n\t\treturn (USBD_INVAL);\n\n\tdir = UE_GET_DIR(ed->bEndpointAddress);\n\ttype = UE_GET_ISO_TYPE(ed->bmAttributes);\n\t/* We can't handle endpoints that need a sync pipe. */\n\tif (dir == UE_DIR_IN ? type == UE_ISO_ADAPT : type == UE_ISO_ASYNC) {\n\t\tprintf(\"%s: ignored %sput endpoint of type 0x%x\\n\",\n\t\t       USBDEVNAME(sc->sc_dev),\n\t\t       dir == UE_DIR_IN ? \"in\" : \"out\",\n\t\t       ed->bmAttributes & UE_ISO_TYPE);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\t\n\tsed = (void *)(buf + offs);\n\tif (sed->bDescriptorType != UDESC_CS_ENDPOINT ||\n\t    sed->bDescriptorSubtype != AS_GENERAL)\n\t\treturn (USBD_INVAL);\n\toffs += sed->bLength;\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\t\n\tformat = UGETW(asid->wFormatTag);\n\tchan = asf1d->bNrChannels;\n\tprec = asf1d->bBitResolution;\n\tif (prec != 8 && prec != 16) {\n#ifdef AUDIO_DEBUG\n\t\tprintf(\"%s: ignored setting with precision %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), prec);\n#endif\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tswitch (format) {\n\tcase UA_FMT_PCM:\n\t\tsc->sc_altflags |= prec == 8 ? HAS_8 : HAS_16;\n\t\tenc = AUDIO_ENCODING_SLINEAR_LE;\n\t\tbreak;\n\tcase UA_FMT_PCM8:\n\t\tenc = AUDIO_ENCODING_ULINEAR_LE;\n\t\tsc->sc_altflags |= HAS_8U;\n\t\tbreak;\n\tcase UA_FMT_ALAW:\n\t\tenc = AUDIO_ENCODING_ALAW;\n\t\tsc->sc_altflags |= HAS_ALAW;\n\t\tbreak;\n\tcase UA_FMT_MULAW:\n\t\tenc = AUDIO_ENCODING_ULAW;\n\t\tsc->sc_altflags |= HAS_MULAW;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: ignored setting with format %d\\n\",\n\t\t       USBDEVNAME(sc->sc_dev), format);\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n\tDPRINTFN(1,(\"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\\n\",\n\t\t    id->bAlternateSetting, enc, chan, prec));\n\tai.alt = id->bAlternateSetting;\n\tai.encoding = enc;\n\tai.idesc = id;\n\tai.edesc = ed;\n\tai.asf1desc = asf1d;\n\tuaudio_add_alt(sc, &ai);\n\tsc->sc_chan.terminal = asid->bTerminalLink; /* XXX */\n\tsc->sc_chan.dir = dir;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "uaudio_add_alt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1028-1046",
    "snippet": "void\nuaudio_add_alt(sc, ai)\n\tstruct uaudio_softc *sc;\n\tstruct as_info *ai;\n{\n\tif (sc->sc_nalts == NULL)\n\t\tsc->sc_alts = malloc(sizeof *ai, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_alts = realloc(sc->sc_alts,\n\t\t\t\t      (sc->sc_nalts+1) * sizeof *ai,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_alts == NULL) {\n\t\tprintf(\"uaudio_add_alt: no memory\\n\");\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_add_alt: adding alt=%d, enc=%d\\n\",\n\t\t    ai->alt, ai->encoding));\n\tsc->sc_alts[sc->sc_nalts++] = *ai;\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "uaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));",
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_alt: adding alt=%d, enc=%d\\n\",\n\t\t    ai->alt, ai->encoding)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_add_alt: no memory\\n\""
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "sc->sc_alts",
            "(sc->sc_nalts+1) * sizeof *ai",
            "M_USBDEV",
            "M_NOWAIT"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *ai",
            "M_USBDEV",
            "M_NOWAIT"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuaudio_add_alt __P((struct uaudio_softc *sc, \n\t\t\t    struct as_info *ai));\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_add_alt(sc, ai)\n\tstruct uaudio_softc *sc;\n\tstruct as_info *ai;\n{\n\tif (sc->sc_nalts == NULL)\n\t\tsc->sc_alts = malloc(sizeof *ai, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_alts = realloc(sc->sc_alts,\n\t\t\t\t      (sc->sc_nalts+1) * sizeof *ai,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_alts == NULL) {\n\t\tprintf(\"uaudio_add_alt: no memory\\n\");\n\t\treturn;\n\t}\n\tDPRINTFN(2,(\"uaudio_add_alt: adding alt=%d, enc=%d\\n\",\n\t\t    ai->alt, ai->encoding));\n\tsc->sc_alts[sc->sc_nalts++] = *ai;\n}"
  },
  {
    "function_name": "uaudio_identify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "1015-1026",
    "snippet": "usbd_status\nuaudio_identify(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusbd_status err;\n\n\terr = uaudio_identify_ac(sc, cdesc);\n\tif (err)\n\t\treturn (err);\n\treturn (uaudio_identify_as(sc, cdesc));\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "uaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "uaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "Static struct",
      "Static usbd_status",
      "uaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));",
      "Static usbd_status",
      "Static usbd_status",
      "Static usbd_status",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_identify_as",
          "args": [
            "sc",
            "cdesc"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_identify_as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1166-1221",
          "snippet": "usbd_status\nuaudio_identify_as(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tusbd_status err;\n\tchar *buf;\n\tint size, offs;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioStreaming interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tsc->sc_as_iface = id->bInterfaceNumber;\n\tDPRINTF((\"uaudio_identify_as: AS interface is %d\\n\", sc->sc_as_iface));\n\n\tsc->sc_chan.terminal = -1;\n\n\t/* Loop through all the alternate settings. */\n\twhile (offs <= size) {\n\t\tswitch (id->bNumEndpoints) {\n\t\tcase 0:\n\t\t\tDPRINTFN(2, (\"uaudio_identify: AS null alt=%d\\n\",\n\t\t\t\t     id->bAlternateSetting));\n\t\t\tsc->sc_nullalt = id->bAlternateSetting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\terr = uaudio_process_as(sc, buf, &offs, size, id);\n\t\t\tbreak;\n\t\tdefault:\n#ifdef AUDIO_DEBUG\n\t\t\tprintf(\"%s: ignored audio interface with %d \"\n\t\t\t       \"endpoints\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tid = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);\n\t\tif (id == NULL)\n\t\t\tbreak;\n\t}\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_identify_as: %d alts available\\n\", sc->sc_nalts));\n\tif (sc->sc_chan.terminal < 0) {\n\t\tprintf(\"%s: no useable endpoint found\\n\", \n\t\t       USBDEVNAME(sc->sc_dev));\n\t\treturn (USBD_INVAL);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "uaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
            "Static usbd_status",
            "uaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
            "Static usbd_status",
            "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
            "Static usb_interface_descriptor_t",
            "Static struct",
            "Static usbd_status",
            "uaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
            "int size;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "int id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic usb_interface_descriptor_t;\nStatic struct;\nStatic usbd_status;\nuaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nint id;\n\nusbd_status\nuaudio_identify_as(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tusbd_status err;\n\tchar *buf;\n\tint size, offs;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioStreaming interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tsc->sc_as_iface = id->bInterfaceNumber;\n\tDPRINTF((\"uaudio_identify_as: AS interface is %d\\n\", sc->sc_as_iface));\n\n\tsc->sc_chan.terminal = -1;\n\n\t/* Loop through all the alternate settings. */\n\twhile (offs <= size) {\n\t\tswitch (id->bNumEndpoints) {\n\t\tcase 0:\n\t\t\tDPRINTFN(2, (\"uaudio_identify: AS null alt=%d\\n\",\n\t\t\t\t     id->bAlternateSetting));\n\t\t\tsc->sc_nullalt = id->bAlternateSetting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\terr = uaudio_process_as(sc, buf, &offs, size, id);\n\t\t\tbreak;\n\t\tdefault:\n#ifdef AUDIO_DEBUG\n\t\t\tprintf(\"%s: ignored audio interface with %d \"\n\t\t\t       \"endpoints\\n\",\n\t\t\t       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tid = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);\n\t\tif (id == NULL)\n\t\t\tbreak;\n\t}\n\tif (offs > size)\n\t\treturn (USBD_INVAL);\n\tDPRINTF((\"uaudio_identify_as: %d alts available\\n\", sc->sc_nalts));\n\tif (sc->sc_chan.terminal < 0) {\n\t\tprintf(\"%s: no useable endpoint found\\n\", \n\t\t       USBDEVNAME(sc->sc_dev));\n\t\treturn (USBD_INVAL);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_identify_ac",
          "args": [
            "sc",
            "cdesc"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_identify_ac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1223-1329",
          "snippet": "usbd_status\nuaudio_identify_ac(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tstruct usb_audio_control_descriptor *acdp;\n\tusb_descriptor_t *dp, *dps[256];\n\tchar *buf, *ibuf, *ibufend;\n\tint size, offs, aclen, ndps, i;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioControl interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tif (offs + sizeof *acdp > size)\n\t\treturn (USBD_INVAL);\n\tsc->sc_ac_iface = id->bInterfaceNumber;\n\tDPRINTFN(2,(\"uaudio_identify: AC interface is %d\\n\", sc->sc_ac_iface));\n\n\t/* A class-specific AC interface header should follow. */\n\tibuf = buf + offs;\n\tacdp = (struct usb_audio_control_descriptor *)ibuf;\n\tif (acdp->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)\n\t\treturn (USBD_INVAL);\n\taclen = UGETW(acdp->wTotalLength);\n\tif (offs + aclen > size)\n\t\treturn (USBD_INVAL);\n\n\tif (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&\n\t     UGETW(acdp->bcdADC) != UAUDIO_VERSION)\n\t\treturn (USBD_INVAL);\n\n\tsc->sc_audio_rev = UGETW(acdp->bcdADC);\n\tDPRINTFN(2,(\"uaudio_identify: found AC header, vers=%03x, len=%d\\n\",\n\t\t sc->sc_audio_rev, aclen));\n\n\tsc->sc_nullalt = -1;\n\n\t/* Scan through all the AC specific descriptors */\n\tibufend = ibuf + aclen;\n\tdp = (usb_descriptor_t *)ibuf;\n\tndps = 0;\n\tmemset(dps, 0, sizeof dps);\n\tfor (;;) {\n\t\tibuf += dp->bLength;\n\t\tif (ibuf >= ibufend)\n\t\t\tbreak;\n\t\tdp = (usb_descriptor_t *)ibuf;\n\t\tif (ibuf + dp->bLength > ibufend)\n\t\t\treturn (USBD_INVAL);\n\t\tif (dp->bDescriptorType != UDESC_CS_INTERFACE) {\n\t\t\tprintf(\"uaudio_identify: skip desc type=0x%02x\\n\",\n\t\t\t       dp->bDescriptorType);\n\t\t\tcontinue;\n\t\t}\n\t\ti = ((struct usb_audio_input_terminal *)dp)->bTerminalId;\n\t\tdps[i] = dp;\n\t\tif (i > ndps)\n\t\t\tndps = i;\n\t}\n\tndps++;\n\n\tfor (i = 0; i < ndps; i++) {\n\t\tdp = dps[i];\n\t\tif (dp == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"uaudio_identify: subtype=%d\\n\", \n\t\t\t dp->bDescriptorSubtype));\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_HEADER:\n\t\t\tprintf(\"uaudio_identify: unexpected AC header\\n\");\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_INPUT:\n\t\t\tuaudio_add_input(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_OUTPUT:\n\t\t\tuaudio_add_output(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n\t\t\tuaudio_add_mixer(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\tuaudio_add_selector(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n\t\t\tuaudio_add_feature(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n\t\t\tuaudio_add_processing(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_EXTENSION:\n\t\t\tuaudio_add_extension(sc, dp, dps);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"uaudio_identify: bad AC desc subtype=0x%02x\\n\",\n\t\t\t       dp->bDescriptorSubtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "uaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
            "Static usbd_status",
            "uaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));",
            "Static usbd_status",
            "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
            "Static usb_interface_descriptor_t",
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "Static usbd_status",
            "uaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));",
            "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "usb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;",
            "int size;",
            "int subtype;",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;",
            "int id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic usb_interface_descriptor_t;\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nStatic usbd_status;\nuaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nusb_interface_descriptor_t *\nuaudio_find_iface(buf, size, offsp, subtype)\n\tchar *buf;\nint size;\nint subtype;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\nint id;\n\nusbd_status\nuaudio_identify_ac(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusb_interface_descriptor_t *id;\n\tstruct usb_audio_control_descriptor *acdp;\n\tusb_descriptor_t *dp, *dps[256];\n\tchar *buf, *ibuf, *ibufend;\n\tint size, offs, aclen, ndps, i;\n\n\tsize = UGETW(cdesc->wTotalLength);\n\tbuf = (char *)cdesc;\n\n\t/* Locate the AudioControl interface descriptor. */\n\toffs = 0;\n\tid = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);\n\tif (id == NULL)\n\t\treturn (USBD_INVAL);\n\tif (offs + sizeof *acdp > size)\n\t\treturn (USBD_INVAL);\n\tsc->sc_ac_iface = id->bInterfaceNumber;\n\tDPRINTFN(2,(\"uaudio_identify: AC interface is %d\\n\", sc->sc_ac_iface));\n\n\t/* A class-specific AC interface header should follow. */\n\tibuf = buf + offs;\n\tacdp = (struct usb_audio_control_descriptor *)ibuf;\n\tif (acdp->bDescriptorType != UDESC_CS_INTERFACE ||\n\t    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)\n\t\treturn (USBD_INVAL);\n\taclen = UGETW(acdp->wTotalLength);\n\tif (offs + aclen > size)\n\t\treturn (USBD_INVAL);\n\n\tif (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&\n\t     UGETW(acdp->bcdADC) != UAUDIO_VERSION)\n\t\treturn (USBD_INVAL);\n\n\tsc->sc_audio_rev = UGETW(acdp->bcdADC);\n\tDPRINTFN(2,(\"uaudio_identify: found AC header, vers=%03x, len=%d\\n\",\n\t\t sc->sc_audio_rev, aclen));\n\n\tsc->sc_nullalt = -1;\n\n\t/* Scan through all the AC specific descriptors */\n\tibufend = ibuf + aclen;\n\tdp = (usb_descriptor_t *)ibuf;\n\tndps = 0;\n\tmemset(dps, 0, sizeof dps);\n\tfor (;;) {\n\t\tibuf += dp->bLength;\n\t\tif (ibuf >= ibufend)\n\t\t\tbreak;\n\t\tdp = (usb_descriptor_t *)ibuf;\n\t\tif (ibuf + dp->bLength > ibufend)\n\t\t\treturn (USBD_INVAL);\n\t\tif (dp->bDescriptorType != UDESC_CS_INTERFACE) {\n\t\t\tprintf(\"uaudio_identify: skip desc type=0x%02x\\n\",\n\t\t\t       dp->bDescriptorType);\n\t\t\tcontinue;\n\t\t}\n\t\ti = ((struct usb_audio_input_terminal *)dp)->bTerminalId;\n\t\tdps[i] = dp;\n\t\tif (i > ndps)\n\t\t\tndps = i;\n\t}\n\tndps++;\n\n\tfor (i = 0; i < ndps; i++) {\n\t\tdp = dps[i];\n\t\tif (dp == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"uaudio_identify: subtype=%d\\n\", \n\t\t\t dp->bDescriptorSubtype));\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_HEADER:\n\t\t\tprintf(\"uaudio_identify: unexpected AC header\\n\");\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_INPUT:\n\t\t\tuaudio_add_input(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_OUTPUT:\n\t\t\tuaudio_add_output(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n\t\t\tuaudio_add_mixer(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\tuaudio_add_selector(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n\t\t\tuaudio_add_feature(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n\t\t\tuaudio_add_processing(sc, dp, dps);\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_EXTENSION:\n\t\t\tuaudio_add_extension(sc, dp, dps);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"uaudio_identify: bad AC desc subtype=0x%02x\\n\",\n\t\t\t       dp->bDescriptorSubtype);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nuaudio_identify_ac __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nuaudio_identify_as __P((struct uaudio_softc *sc,\n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_identify __P((struct uaudio_softc *sc, \n\t\t\t    usb_config_descriptor_t *cdesc));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nusbd_status\nuaudio_identify(sc, cdesc)\n\tstruct uaudio_softc *sc;\n\tusb_config_descriptor_t *cdesc;\n{\n\tusbd_status err;\n\n\terr = uaudio_identify_ac(sc, cdesc);\n\tif (err)\n\t\treturn (err);\n\treturn (uaudio_identify_as(sc, cdesc));\n}"
  },
  {
    "function_name": "uaudio_add_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "988-1013",
    "snippet": "void\nuaudio_add_extension(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_extension_unit *d = \n\t    (struct usb_audio_extension_unit *)v;\n\tstruct usb_audio_extension_unit_1 *d1 =\n\t    (struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_extension: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"ext%d-enable\", d->bUnitId);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_mixer_add_ctl",
          "args": [
            "sc",
            "&mix"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_mixer_add_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "535-580",
          "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"ext%d-enable\"",
            "d->bUnitId"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "UA_EXT_ENABLE",
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "d->bUnitId",
            "sc->sc_ac_iface"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_extension: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_extension(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_extension_unit *d = \n\t    (struct usb_audio_extension_unit *)v;\n\tstruct usb_audio_extension_unit_1 *d1 =\n\t    (struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_extension: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"ext%d-enable\", d->bUnitId);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}"
  },
  {
    "function_name": "uaudio_add_processing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "943-986",
    "snippet": "void\nuaudio_add_processing(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tint ptype = UGETW(d->wProcessType);\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_processing: wProcessType=%d bUnitId=%d \"\n\t\t    \"bNrInPins=%d\\n\", ptype, d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"pro%d.%d-enable\", d->bUnitId, ptype);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n\n\tswitch(ptype) {\n\tcase UPDOWNMIX_PROCESS:\n\t\tuaudio_add_processing_updown(sc, v, dps);\n\t\tbreak;\n\tcase DOLBY_PROLOGIC_PROCESS:\n\tcase P3D_STEREO_EXTENDER_PROCESS:\n\tcase REVERBATION_PROCESS:\n\tcase CHORUS_PROCESS:\n\tcase DYN_RANGE_COMP_PROCESS:\n\tdefault:\n#ifdef UAUDIO_DEBUG\n\t\tprintf(\"uaudio_add_processing: unit %d, type=%d not impl.\\n\",\n\t\t       d->bUnitId, ptype);\n#endif\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_add_processing: unit %d, type=%d not impl.\\n\"",
            "d->bUnitId",
            "ptype"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_add_processing_updown",
          "args": [
            "sc",
            "v",
            "dps"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_add_processing_updown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "903-941",
          "snippet": "void\nuaudio_add_processing_updown(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct usb_audio_processing_unit_updown *ud =\n\t    (struct usb_audio_processing_unit_updown *)\n\t\t&d1->bmControls[d1->bControlSize];\n\tstruct mixerctl mix;\n\tint i;\n\n\tDPRINTFN(2,(\"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\\n\",\n\t\t    d->bUnitId, ud->bNrModes));\n\n\tif (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {\n\t\tDPRINTF((\"uaudio_add_processing_updown: no mode select\\n\"));\n\t\treturn;\n\t}\n\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.nchan = 1;\n\tmix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);\n\tmix.class = -1;\n\tmix.type = MIX_ON_OFF;\t/* XXX */\n\tmix.ctlunit = \"\";\n\tsprintf(mix.ctlname, \"pro%d-mode\", d->bUnitId);\n\n\tfor (i = 0; i < ud->bNrModes; i++) {\n\t\tDPRINTFN(2,(\"uaudio_add_processing_updown: i=%d bm=0x%x\\n\",\n\t\t\t    i, UGETW(ud->waModes[i])));\n\t\t/* XXX */\n\t}\n\tuaudio_mixer_add_ctl(sc, &mix);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
            "usb_descriptor_t **dps;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_processing_updown(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct usb_audio_processing_unit_updown *ud =\n\t    (struct usb_audio_processing_unit_updown *)\n\t\t&d1->bmControls[d1->bControlSize];\n\tstruct mixerctl mix;\n\tint i;\n\n\tDPRINTFN(2,(\"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\\n\",\n\t\t    d->bUnitId, ud->bNrModes));\n\n\tif (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {\n\t\tDPRINTF((\"uaudio_add_processing_updown: no mode select\\n\"));\n\t\treturn;\n\t}\n\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.nchan = 1;\n\tmix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);\n\tmix.class = -1;\n\tmix.type = MIX_ON_OFF;\t/* XXX */\n\tmix.ctlunit = \"\";\n\tsprintf(mix.ctlname, \"pro%d-mode\", d->bUnitId);\n\n\tfor (i = 0; i < ud->bNrModes; i++) {\n\t\tDPRINTFN(2,(\"uaudio_add_processing_updown: i=%d bm=0x%x\\n\",\n\t\t\t    i, UGETW(ud->waModes[i])));\n\t\t/* XXX */\n\t}\n\tuaudio_mixer_add_ctl(sc, &mix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_mixer_add_ctl",
          "args": [
            "sc",
            "&mix"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_mixer_add_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "535-580",
          "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"pro%d.%d-enable\"",
            "d->bUnitId",
            "ptype"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "XX_ENABLE_CONTROL",
            "0"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "d->bUnitId",
            "sc->sc_ac_iface"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_processing: wProcessType=%d bUnitId=%d \"\n\t\t    \"bNrInPins=%d\\n\", ptype, d->bUnitId, d->bNrInPins)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "d->wProcessType"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_processing(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tint ptype = UGETW(d->wProcessType);\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_processing: wProcessType=%d bUnitId=%d \"\n\t\t    \"bNrInPins=%d\\n\", ptype, d->bUnitId, d->bNrInPins));\n\n\tif (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {\n\t\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\t\tmix.nchan = 1;\n\t\tmix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);\n\t\tmix.class = -1;\n\t\tmix.type = MIX_ON_OFF;\n\t\tmix.ctlunit = \"\";\n\t\tsprintf(mix.ctlname, \"pro%d.%d-enable\", d->bUnitId, ptype);\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n\n\tswitch(ptype) {\n\tcase UPDOWNMIX_PROCESS:\n\t\tuaudio_add_processing_updown(sc, v, dps);\n\t\tbreak;\n\tcase DOLBY_PROLOGIC_PROCESS:\n\tcase P3D_STEREO_EXTENDER_PROCESS:\n\tcase REVERBATION_PROCESS:\n\tcase CHORUS_PROCESS:\n\tcase DYN_RANGE_COMP_PROCESS:\n\tdefault:\n#ifdef UAUDIO_DEBUG\n\t\tprintf(\"uaudio_add_processing: unit %d, type=%d not impl.\\n\",\n\t\t       d->bUnitId, ptype);\n#endif\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "uaudio_add_processing_updown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "903-941",
    "snippet": "void\nuaudio_add_processing_updown(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct usb_audio_processing_unit_updown *ud =\n\t    (struct usb_audio_processing_unit_updown *)\n\t\t&d1->bmControls[d1->bControlSize];\n\tstruct mixerctl mix;\n\tint i;\n\n\tDPRINTFN(2,(\"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\\n\",\n\t\t    d->bUnitId, ud->bNrModes));\n\n\tif (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {\n\t\tDPRINTF((\"uaudio_add_processing_updown: no mode select\\n\"));\n\t\treturn;\n\t}\n\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.nchan = 1;\n\tmix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);\n\tmix.class = -1;\n\tmix.type = MIX_ON_OFF;\t/* XXX */\n\tmix.ctlunit = \"\";\n\tsprintf(mix.ctlname, \"pro%d-mode\", d->bUnitId);\n\n\tfor (i = 0; i < ud->bNrModes; i++) {\n\t\tDPRINTFN(2,(\"uaudio_add_processing_updown: i=%d bm=0x%x\\n\",\n\t\t\t    i, UGETW(ud->waModes[i])));\n\t\t/* XXX */\n\t}\n\tuaudio_mixer_add_ctl(sc, &mix);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_mixer_add_ctl",
          "args": [
            "sc",
            "&mix"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_mixer_add_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "535-580",
          "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_processing_updown: i=%d bm=0x%x\\n\",\n\t\t\t    i, UGETW(ud->waModes[i]))"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ud->waModes[i]"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"pro%d-mode\"",
            "d->bUnitId"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "UD_MODE_SELECT_CONTROL",
            "0"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "d->bUnitId",
            "sc->sc_ac_iface"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_add_processing_updown: no mode select\\n\")"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UA_PROC_MASK",
          "args": [
            "UD_MODE_SELECT_CONTROL"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\\n\",\n\t\t    d->bUnitId, ud->bNrModes)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_processing_updown(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_processing_unit *d = \n\t    (struct usb_audio_processing_unit *)v;\n\tstruct usb_audio_processing_unit_1 *d1 =\n\t    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tstruct usb_audio_processing_unit_updown *ud =\n\t    (struct usb_audio_processing_unit_updown *)\n\t\t&d1->bmControls[d1->bControlSize];\n\tstruct mixerctl mix;\n\tint i;\n\n\tDPRINTFN(2,(\"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\\n\",\n\t\t    d->bUnitId, ud->bNrModes));\n\n\tif (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {\n\t\tDPRINTF((\"uaudio_add_processing_updown: no mode select\\n\"));\n\t\treturn;\n\t}\n\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.nchan = 1;\n\tmix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);\n\tmix.class = -1;\n\tmix.type = MIX_ON_OFF;\t/* XXX */\n\tmix.ctlunit = \"\";\n\tsprintf(mix.ctlname, \"pro%d-mode\", d->bUnitId);\n\n\tfor (i = 0; i < ud->bNrModes; i++) {\n\t\tDPRINTFN(2,(\"uaudio_add_processing_updown: i=%d bm=0x%x\\n\",\n\t\t\t    i, UGETW(ud->waModes[i])));\n\t\t/* XXX */\n\t}\n\tuaudio_mixer_add_ctl(sc, &mix);\n}"
  },
  {
    "function_name": "uaudio_add_feature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "777-901",
    "snippet": "void\nuaudio_add_feature(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_feature_unit *d = (struct usb_audio_feature_unit *)v;\n\tuByte *ctls = d->bmaControls;\n\tint ctlsize = d->bControlSize;\n\tint nchan = (d->bLength - 7) / ctlsize;\n\tint srcId = d->bSourceId;\n\tu_int fumask, mmask, cmask;\n\tstruct mixerctl mix;\n\tint chan, ctl, i, unit;\n\n#define GET(i) (ctls[(i)*ctlsize] | \\\n\t\t(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))\n\n\tmmask = GET(0);\n\t/* Figure out what we can control */\n\tfor (cmask = 0, chan = 1; chan < nchan; chan++) {\n\t\tDPRINTFN(9,(\"uaudio_add_feature: chan=%d mask=%x\\n\",\n\t\t\t    chan, GET(chan)));\n\t\tcmask |= GET(chan);\n\t}\n\n\tDPRINTFN(1,(\"uaudio_add_feature: bUnitId=%d bSourceId=%d, \"\n\t\t    \"%d channels, mmask=0x%04x, cmask=0x%04x\\n\", \n\t\t    d->bUnitId, srcId, nchan, mmask, cmask));\n\n\tif (nchan > MIX_MAX_CHAN)\n\t\tnchan = MIX_MAX_CHAN;\n\tunit = d->bUnitId;\n\tmix.wIndex = MAKE(unit, sc->sc_ac_iface);\n\tfor (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {\n\t\tfumask = FU_MASK(ctl);\n\t\tDPRINTFN(4,(\"uaudio_add_feature: ctl=%d fumask=0x%04x\\n\",\n\t\t\t    ctl, fumask));\n\t\tif (mmask & fumask) {\n\t\t\tmix.nchan = 1;\n\t\t\tmix.wValue[0] = MAKE(ctl, 0);\n\t\t} else if (cmask & fumask) {\n\t\t\tmix.nchan = nchan - 1;\n\t\t\tfor (i = 1; i < nchan; i++) {\n\t\t\t\tif (GET(i) & fumask)\n\t\t\t\t\tmix.wValue[i-1] = MAKE(ctl, i);\n\t\t\t\telse\n\t\t\t\t\tmix.wValue[i-1] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n#undef GET\n\t\tmix.class = -1;\t/* XXX */\n\t\tswitch (ctl) {\n\t\tcase MUTE_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmute);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase VOLUME_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmaster);\n\t\t\tmix.ctlunit = AudioNvolume;\n\t\t\tbreak;\n\t\tcase BASS_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbass);\n\t\t\tmix.ctlunit = AudioNbass;\n\t\t\tbreak;\n\t\tcase MID_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmid);\n\t\t\tmix.ctlunit = AudioNmid;\n\t\t\tbreak;\n\t\tcase TREBLE_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNtreble);\n\t\t\tmix.ctlunit = AudioNtreble;\n\t\t\tbreak;\n\t\tcase GRAPHIC_EQUALIZER_CONTROL:\n\t\t\tcontinue; /* XXX don't add anything */\n\t\t\tbreak;\n\t\tcase AGC_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNagc);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase DELAY_CONTROL:\n\t\t\tmix.type = MIX_UNSIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNdelay);\n\t\t\tmix.ctlunit = \"4 ms\";\n\t\t\tbreak;\n\t\tcase BASS_BOOST_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbassboost);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase LOUDNESS_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNloudness);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_SIGNED_8\t4",
      "#define MIX_UNSIGNED_16\t3",
      "#define MIX_SIGNED_16\t2",
      "#define MIX_ON_OFF\t1",
      "#define MIX_MAX_CHAN 8"
    ],
    "globals_used": [
      "Static char \t\t*uaudio_id_name",
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "uaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));",
      "uaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "uaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_mixer_add_ctl",
          "args": [
            "sc",
            "&mix"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_mixer_add_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "535-580",
          "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNloudness"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNbassboost"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNdelay"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNagc"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNtreble"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNmid"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNbass"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNmaster"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"fea%d-%s-%s\"",
            "unit",
            "uaudio_id_name(sc, dps, srcId)",
            "AudioNmute"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "srcId"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "ctl",
            "i"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET",
          "args": [
            "i"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "ctl",
            "0"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "4",
            "(\"uaudio_add_feature: ctl=%d fumask=0x%04x\\n\",\n\t\t\t    ctl, fumask)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FU_MASK",
          "args": [
            "ctl"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "unit",
            "sc->sc_ac_iface"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uaudio_add_feature: bUnitId=%d bSourceId=%d, \"\n\t\t    \"%d channels, mmask=0x%04x, cmask=0x%04x\\n\", \n\t\t    d->bUnitId, srcId, nchan, mmask, cmask)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET",
          "args": [
            "chan"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "9",
            "(\"uaudio_add_feature: chan=%d mask=%x\\n\",\n\t\t\t    chan, GET(chan))"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET",
          "args": [
            "chan"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET",
          "args": [
            "0"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_SIGNED_8\t4\n#define MIX_UNSIGNED_16\t3\n#define MIX_SIGNED_16\t2\n#define MIX_ON_OFF\t1\n#define MIX_MAX_CHAN 8\n\nStatic char \t\t*uaudio_id_name;\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_ctl_get __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nuaudio_set_speed __P((struct uaudio_softc *, int,\n\t\t\t    u_int));\nuaudio_chan_alloc_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nuaudio_chan_free_buffers __P((struct uaudio_softc *,\n\t\t\t    struct chan *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_feature(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_feature_unit *d = (struct usb_audio_feature_unit *)v;\n\tuByte *ctls = d->bmaControls;\n\tint ctlsize = d->bControlSize;\n\tint nchan = (d->bLength - 7) / ctlsize;\n\tint srcId = d->bSourceId;\n\tu_int fumask, mmask, cmask;\n\tstruct mixerctl mix;\n\tint chan, ctl, i, unit;\n\n#define GET(i) (ctls[(i)*ctlsize] | \\\n\t\t(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))\n\n\tmmask = GET(0);\n\t/* Figure out what we can control */\n\tfor (cmask = 0, chan = 1; chan < nchan; chan++) {\n\t\tDPRINTFN(9,(\"uaudio_add_feature: chan=%d mask=%x\\n\",\n\t\t\t    chan, GET(chan)));\n\t\tcmask |= GET(chan);\n\t}\n\n\tDPRINTFN(1,(\"uaudio_add_feature: bUnitId=%d bSourceId=%d, \"\n\t\t    \"%d channels, mmask=0x%04x, cmask=0x%04x\\n\", \n\t\t    d->bUnitId, srcId, nchan, mmask, cmask));\n\n\tif (nchan > MIX_MAX_CHAN)\n\t\tnchan = MIX_MAX_CHAN;\n\tunit = d->bUnitId;\n\tmix.wIndex = MAKE(unit, sc->sc_ac_iface);\n\tfor (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {\n\t\tfumask = FU_MASK(ctl);\n\t\tDPRINTFN(4,(\"uaudio_add_feature: ctl=%d fumask=0x%04x\\n\",\n\t\t\t    ctl, fumask));\n\t\tif (mmask & fumask) {\n\t\t\tmix.nchan = 1;\n\t\t\tmix.wValue[0] = MAKE(ctl, 0);\n\t\t} else if (cmask & fumask) {\n\t\t\tmix.nchan = nchan - 1;\n\t\t\tfor (i = 1; i < nchan; i++) {\n\t\t\t\tif (GET(i) & fumask)\n\t\t\t\t\tmix.wValue[i-1] = MAKE(ctl, i);\n\t\t\t\telse\n\t\t\t\t\tmix.wValue[i-1] = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n#undef GET\n\t\tmix.class = -1;\t/* XXX */\n\t\tswitch (ctl) {\n\t\tcase MUTE_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmute);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase VOLUME_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmaster);\n\t\t\tmix.ctlunit = AudioNvolume;\n\t\t\tbreak;\n\t\tcase BASS_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbass);\n\t\t\tmix.ctlunit = AudioNbass;\n\t\t\tbreak;\n\t\tcase MID_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNmid);\n\t\t\tmix.ctlunit = AudioNmid;\n\t\t\tbreak;\n\t\tcase TREBLE_CONTROL:\n\t\t\tmix.type = MIX_SIGNED_8;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNtreble);\n\t\t\tmix.ctlunit = AudioNtreble;\n\t\t\tbreak;\n\t\tcase GRAPHIC_EQUALIZER_CONTROL:\n\t\t\tcontinue; /* XXX don't add anything */\n\t\t\tbreak;\n\t\tcase AGC_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNagc);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase DELAY_CONTROL:\n\t\t\tmix.type = MIX_UNSIGNED_16;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNdelay);\n\t\t\tmix.ctlunit = \"4 ms\";\n\t\t\tbreak;\n\t\tcase BASS_BOOST_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNbassboost);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\tcase LOUDNESS_CONTROL:\n\t\t\tmix.type = MIX_ON_OFF;\n\t\t\tsprintf(mix.ctlname, \"fea%d-%s-%s\", unit,\n\t\t\t\tuaudio_id_name(sc, dps, srcId), \n\t\t\t\tAudioNloudness);\n\t\t\tmix.ctlunit = \"\";\n\t\t\tbreak;\n\t\t}\n\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t}\n}"
  },
  {
    "function_name": "uaudio_add_selector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "761-775",
    "snippet": "void\nuaudio_add_selector(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_selector_unit *d =\n\t\t(struct usb_audio_selector_unit *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_selector: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n#endif\n\tprintf(\"uaudio_add_selector: NOT IMPLEMENTED\\n\");\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_add_selector: NOT IMPLEMENTED\\n\""
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_selector: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_selector(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_selector_unit *d =\n\t\t(struct usb_audio_selector_unit *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_selector: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n#endif\n\tprintf(\"uaudio_add_selector: NOT IMPLEMENTED\\n\");\n}"
  },
  {
    "function_name": "uaudio_add_mixer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "695-759",
    "snippet": "void\nuaudio_add_mixer(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_mixer_unit *d = (struct usb_audio_mixer_unit *)v;\n\tstruct usb_audio_mixer_unit_1 *d1;\n\tint c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;\n\tuByte *bm;\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\t\n\t/* Compute the number of input channels */\n\tichs = 0;\n\tfor (i = 0; i < d->bNrInPins; i++)\n\t\tichs += uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\n\t/* and the number of output channels */\n\td1 = (struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tochs = d1->bNrChannels;\n\tDPRINTFN(2,(\"uaudio_add_mixer: ichs=%d ochs=%d\\n\", ichs, ochs));\n\n\tbm = d1->bmControls;\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.class = -1;\n\tmix.type = MIX_SIGNED_16;\n\tmix.ctlunit = AudioNvolume;\n#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)\n\tfor (p = i = 0; i < d->bNrInPins; i++) {\n\t\tchs = uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\t\tmc = 0;\n\t\tfor (c = 0; c < chs; c++) {\n\t\t\tmo = 0;\n\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\tif (BIT(bno))\n\t\t\t\t\tmo++;\n\t\t\t}\n\t\t\tif (mo == 1)\n\t\t\t\tmc++;\n\t\t}\n\t\tif (mc == chs && chs <= MIX_MAX_CHAN) {\n\t\t\tk = 0;\n\t\t\tfor (c = 0; c < chs; c++)\n\t\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\t\tif (BIT(bno))\n\t\t\t\t\t\tmix.wValue[k++] = \n\t\t\t\t\t\t\tMAKE(p+c+1, o+1);\n\t\t\t\t}\n\t\t\tsprintf(mix.ctlname, \"mix%d-%s\", d->bUnitId,\n\t\t\t\tuaudio_id_name(sc, dps, d->baSourceId[i]));\n\t\t\tmix.nchan = chs;\n\t\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t\t} else {\n\t\t\t/* XXX */\n\t\t}\n#undef BIT\n\t\tp += chs;\n\t}\n\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)",
      "#define MIX_SIGNED_16\t2",
      "#define MIX_MAX_CHAN 8"
    ],
    "globals_used": [
      "Static char \t\t*uaudio_id_name",
      "Static struct",
      "usb_audio_cluster uaudio_get_cluster",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaudio_mixer_add_ctl",
          "args": [
            "sc",
            "&mix"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_mixer_add_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "535-580",
          "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MIX_ON_OFF\t1"
          ],
          "globals_used": [
            "Static struct",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "mix.ctlname",
            "\"mix%d-%s\"",
            "d->bUnitId",
            "uaudio_id_name(sc, dps, d->baSourceId[i])"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_id_name",
          "args": [
            "sc",
            "dps",
            "d->baSourceId[i]"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "p+c+1",
            "o+1"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bno"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bno"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_get_cluster",
          "args": [
            "d->baSourceId[i]",
            "dps"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_get_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "593-657",
          "snippet": "struct usb_audio_cluster\nuaudio_get_cluster(id, dps)\n\tint id;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_cluster r;\n\tusb_descriptor_t *dp;\n\tint i;\n\n\tfor (i = 0; i < 25; i++) { /* avoid infinite loops */\n\t\tdp = dps[id];\n\t\tif (dp == 0)\n\t\t\tgoto bad;\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_INPUT:\n#define p ((struct usb_audio_input_terminal *)dp)\n\t\t\tr.bNrChannels = p->bNrChannels;\n\t\t\tUSETW(r.wChannelConfig, UGETW(p->wChannelConfig));\n\t\t\tr.iChannelNames = p->iChannelNames;\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_OUTPUT:\n#define p ((struct usb_audio_output_terminal *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n#define p ((struct usb_audio_mixer_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\t/* XXX This is not really right */\n#define p ((struct usb_audio_selector_unit *)dp)\n\t\t\tid = p->baSourceId[0];\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n#define p ((struct usb_audio_feature_unit *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n#define p ((struct usb_audio_processing_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_EXTENSION:\n#define p ((struct usb_audio_extension_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tdefault:\n\t\t\tgoto bad;\n\t\t}\n\t}\n bad:\n\tprintf(\"uaudio_get_cluster: bad data\\n\");\n\tmemset(&r, 0, sizeof r);\n\treturn (r);\n\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define p ((struct usb_audio_extension_unit *)dp)",
            "#define p ((struct usb_audio_processing_unit *)dp)",
            "#define p ((struct usb_audio_feature_unit *)dp)",
            "#define p ((struct usb_audio_selector_unit *)dp)",
            "#define p ((struct usb_audio_mixer_unit *)dp)",
            "#define p ((struct usb_audio_output_terminal *)dp)",
            "#define p ((struct usb_audio_input_terminal *)dp)"
          ],
          "globals_used": [
            "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
            "Static struct",
            "usb_audio_cluster uaudio_get_cluster",
            "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
            "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
            "Static struct",
            "Static struct",
            "usb_descriptor_t **dps;",
            "int id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic struct;\nusb_audio_cluster uaudio_get_cluster;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nStatic struct;\nStatic struct;\nusb_descriptor_t **dps;\nint id;\n\nstruct usb_audio_cluster\nuaudio_get_cluster(id, dps)\n\tint id;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_cluster r;\n\tusb_descriptor_t *dp;\n\tint i;\n\n\tfor (i = 0; i < 25; i++) { /* avoid infinite loops */\n\t\tdp = dps[id];\n\t\tif (dp == 0)\n\t\t\tgoto bad;\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_INPUT:\n#define p ((struct usb_audio_input_terminal *)dp)\n\t\t\tr.bNrChannels = p->bNrChannels;\n\t\t\tUSETW(r.wChannelConfig, UGETW(p->wChannelConfig));\n\t\t\tr.iChannelNames = p->iChannelNames;\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_OUTPUT:\n#define p ((struct usb_audio_output_terminal *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n#define p ((struct usb_audio_mixer_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\t/* XXX This is not really right */\n#define p ((struct usb_audio_selector_unit *)dp)\n\t\t\tid = p->baSourceId[0];\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n#define p ((struct usb_audio_feature_unit *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n#define p ((struct usb_audio_processing_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_EXTENSION:\n#define p ((struct usb_audio_extension_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tdefault:\n\t\t\tgoto bad;\n\t\t}\n\t}\n bad:\n\tprintf(\"uaudio_get_cluster: bad data\\n\");\n\tmemset(&r, 0, sizeof r);\n\treturn (r);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAKE",
          "args": [
            "d->bUnitId",
            "sc->sc_ac_iface"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_mixer: ichs=%d ochs=%d\\n\", ichs, ochs)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n#define MIX_SIGNED_16\t2\n#define MIX_MAX_CHAN 8\n\nStatic char \t\t*uaudio_id_name;\nStatic struct;\nusb_audio_cluster uaudio_get_cluster;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_mixer(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_mixer_unit *d = (struct usb_audio_mixer_unit *)v;\n\tstruct usb_audio_mixer_unit_1 *d1;\n\tint c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;\n\tuByte *bm;\n\tstruct mixerctl mix;\n\n\tDPRINTFN(2,(\"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\\n\",\n\t\t    d->bUnitId, d->bNrInPins));\n\t\n\t/* Compute the number of input channels */\n\tichs = 0;\n\tfor (i = 0; i < d->bNrInPins; i++)\n\t\tichs += uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\n\t/* and the number of output channels */\n\td1 = (struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];\n\tochs = d1->bNrChannels;\n\tDPRINTFN(2,(\"uaudio_add_mixer: ichs=%d ochs=%d\\n\", ichs, ochs));\n\n\tbm = d1->bmControls;\n\tmix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);\n\tmix.class = -1;\n\tmix.type = MIX_SIGNED_16;\n\tmix.ctlunit = AudioNvolume;\n#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)\n\tfor (p = i = 0; i < d->bNrInPins; i++) {\n\t\tchs = uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;\n\t\tmc = 0;\n\t\tfor (c = 0; c < chs; c++) {\n\t\t\tmo = 0;\n\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\tif (BIT(bno))\n\t\t\t\t\tmo++;\n\t\t\t}\n\t\t\tif (mo == 1)\n\t\t\t\tmc++;\n\t\t}\n\t\tif (mc == chs && chs <= MIX_MAX_CHAN) {\n\t\t\tk = 0;\n\t\t\tfor (c = 0; c < chs; c++)\n\t\t\t\tfor (o = 0; o < ochs; o++) {\n\t\t\t\t\tbno = (p + c) * ochs + o;\n\t\t\t\t\tif (BIT(bno))\n\t\t\t\t\t\tmix.wValue[k++] = \n\t\t\t\t\t\t\tMAKE(p+c+1, o+1);\n\t\t\t\t}\n\t\t\tsprintf(mix.ctlname, \"mix%d-%s\", d->bUnitId,\n\t\t\t\tuaudio_id_name(sc, dps, d->baSourceId[i]));\n\t\t\tmix.nchan = chs;\n\t\t\tuaudio_mixer_add_ctl(sc, &mix);\n\t\t} else {\n\t\t\t/* XXX */\n\t\t}\n#undef BIT\n\t\tp += chs;\n\t}\n\n}"
  },
  {
    "function_name": "uaudio_add_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "678-693",
    "snippet": "void\nuaudio_add_output(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_output_terminal *d = \n\t\t(struct usb_audio_output_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bSourceId=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bSourceId, d->iTerminal));\n#endif\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bSourceId=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bSourceId, d->iTerminal)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "d->wTerminalType"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_output(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_output_terminal *d = \n\t\t(struct usb_audio_output_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bSourceId=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bSourceId, d->iTerminal));\n#endif\n}"
  },
  {
    "function_name": "uaudio_add_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "659-676",
    "snippet": "void\nuaudio_add_input(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_input_terminal *d = \n\t\t(struct usb_audio_input_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d \"\n\t\t    \"iChannelNames=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bNrChannels, UGETW(d->wChannelConfig),\n\t\t    d->iChannelNames, d->iTerminal));\n#endif\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;",
      "usb_descriptor_t **dps;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d \"\n\t\t    \"iChannelNames=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bNrChannels, UGETW(d->wChannelConfig),\n\t\t    d->iChannelNames, d->iTerminal)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "d->wChannelConfig"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "d->wTerminalType"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_set __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int l, int v));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\nusb_descriptor_t **dps;\n\nvoid\nuaudio_add_input(sc, v, dps)\n\tstruct uaudio_softc *sc;\n\tusb_descriptor_t *v;\n\tusb_descriptor_t **dps;\n{\n#ifdef UAUDIO_DEBUG\n\tstruct usb_audio_input_terminal *d = \n\t\t(struct usb_audio_input_terminal *)v;\n\n\tDPRINTFN(2,(\"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x \"\n\t\t    \"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d \"\n\t\t    \"iChannelNames=%d iTerminal=%d\\n\",\n\t\t    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,\n\t\t    d->bNrChannels, UGETW(d->wChannelConfig),\n\t\t    d->iChannelNames, d->iTerminal));\n#endif\n}"
  },
  {
    "function_name": "uaudio_get_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "593-657",
    "snippet": "struct usb_audio_cluster\nuaudio_get_cluster(id, dps)\n\tint id;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_cluster r;\n\tusb_descriptor_t *dp;\n\tint i;\n\n\tfor (i = 0; i < 25; i++) { /* avoid infinite loops */\n\t\tdp = dps[id];\n\t\tif (dp == 0)\n\t\t\tgoto bad;\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_INPUT:\n#define p ((struct usb_audio_input_terminal *)dp)\n\t\t\tr.bNrChannels = p->bNrChannels;\n\t\t\tUSETW(r.wChannelConfig, UGETW(p->wChannelConfig));\n\t\t\tr.iChannelNames = p->iChannelNames;\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_OUTPUT:\n#define p ((struct usb_audio_output_terminal *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n#define p ((struct usb_audio_mixer_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\t/* XXX This is not really right */\n#define p ((struct usb_audio_selector_unit *)dp)\n\t\t\tid = p->baSourceId[0];\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n#define p ((struct usb_audio_feature_unit *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n#define p ((struct usb_audio_processing_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_EXTENSION:\n#define p ((struct usb_audio_extension_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tdefault:\n\t\t\tgoto bad;\n\t\t}\n\t}\n bad:\n\tprintf(\"uaudio_get_cluster: bad data\\n\");\n\tmemset(&r, 0, sizeof r);\n\treturn (r);\n\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define p ((struct usb_audio_extension_unit *)dp)",
      "#define p ((struct usb_audio_processing_unit *)dp)",
      "#define p ((struct usb_audio_feature_unit *)dp)",
      "#define p ((struct usb_audio_selector_unit *)dp)",
      "#define p ((struct usb_audio_mixer_unit *)dp)",
      "#define p ((struct usb_audio_output_terminal *)dp)",
      "#define p ((struct usb_audio_input_terminal *)dp)"
    ],
    "globals_used": [
      "uaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));",
      "Static struct",
      "usb_audio_cluster uaudio_get_cluster",
      "__P((int id, \n\t\t\t    usb_descriptor_t **dps));",
      "uaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "uaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));",
      "Static struct",
      "Static struct",
      "usb_descriptor_t **dps;",
      "int id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&r",
            "0",
            "sizeof r"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_get_cluster: bad data\\n\""
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "r.wChannelConfig",
            "UGETW(p->wChannelConfig)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "p->wChannelConfig"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define p ((struct usb_audio_extension_unit *)dp)\n#define p ((struct usb_audio_processing_unit *)dp)\n#define p ((struct usb_audio_feature_unit *)dp)\n#define p ((struct usb_audio_selector_unit *)dp)\n#define p ((struct usb_audio_mixer_unit *)dp)\n#define p ((struct usb_audio_output_terminal *)dp)\n#define p ((struct usb_audio_input_terminal *)dp)\n\nuaudio_process_as __P((struct uaudio_softc *sc,\n\t\t\t    char *buf, int *offsp, int size,\n\t\t\t    usb_interface_descriptor_t *id));\nStatic struct;\nusb_audio_cluster uaudio_get_cluster;\n__P((int id, \n\t\t\t    usb_descriptor_t **dps));\nuaudio_add_input __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_output __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_mixer __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_selector __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_feature __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing_updown\n\t\t\t    __P((struct uaudio_softc *sc,\n\t\t\t         usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_processing __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nuaudio_add_extension __P((struct uaudio_softc *sc,\n\t\t\t    usb_descriptor_t *v, usb_descriptor_t **dps));\nStatic struct;\nStatic struct;\nusb_descriptor_t **dps;\nint id;\n\nstruct usb_audio_cluster\nuaudio_get_cluster(id, dps)\n\tint id;\n\tusb_descriptor_t **dps;\n{\n\tstruct usb_audio_cluster r;\n\tusb_descriptor_t *dp;\n\tint i;\n\n\tfor (i = 0; i < 25; i++) { /* avoid infinite loops */\n\t\tdp = dps[id];\n\t\tif (dp == 0)\n\t\t\tgoto bad;\n\t\tswitch (dp->bDescriptorSubtype) {\n\t\tcase UDESCSUB_AC_INPUT:\n#define p ((struct usb_audio_input_terminal *)dp)\n\t\t\tr.bNrChannels = p->bNrChannels;\n\t\t\tUSETW(r.wChannelConfig, UGETW(p->wChannelConfig));\n\t\t\tr.iChannelNames = p->iChannelNames;\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_OUTPUT:\n#define p ((struct usb_audio_output_terminal *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_MIXER:\n#define p ((struct usb_audio_mixer_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_SELECTOR:\n\t\t\t/* XXX This is not really right */\n#define p ((struct usb_audio_selector_unit *)dp)\n\t\t\tid = p->baSourceId[0];\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_FEATURE:\n#define p ((struct usb_audio_feature_unit *)dp)\n\t\t\tid = p->bSourceId;\n#undef p\n\t\t\tbreak;\n\t\tcase UDESCSUB_AC_PROCESSING:\n#define p ((struct usb_audio_processing_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tcase UDESCSUB_AC_EXTENSION:\n#define p ((struct usb_audio_extension_unit *)dp)\n\t\t\tr = *(struct usb_audio_cluster *)\n\t\t\t\t&p->baSourceId[p->bNrInPins];\n#undef p\n\t\t\treturn (r);\n\t\tdefault:\n\t\t\tgoto bad;\n\t\t}\n\t}\n bad:\n\tprintf(\"uaudio_get_cluster: bad data\\n\");\n\tmemset(&r, 0, sizeof r);\n\treturn (r);\n\n}"
  },
  {
    "function_name": "uaudio_mixer_add_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "535-580",
    "snippet": "void\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MIX_ON_OFF\t1"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\",%04x\", mc->wValue[i])"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0])"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uaudio_signext",
          "args": [
            "mc->type",
            "uaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type))"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_signext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1608-1619",
          "snippet": "int\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\n\nint\nuaudio_signext(type, val)\n\tint type, val;\n{\n\tif (!MIX_UNSIGNED(type)) {\n\t\tif (MIX_SIZE(type) == 2)\n\t\t\tval = (int16_t)val;\n\t\telse\n\t\t\tval = (int8_t)val;\n\t}\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uaudio_get",
          "args": [
            "sc",
            "GET_MAX",
            "UT_READ_CLASS_INTERFACE",
            "mc->wValue[0]",
            "mc->wIndex",
            "MIX_SIZE(mc->type)"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "uaudio_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
          "lines": "1529-1568",
          "snippet": "int\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/uaudioreg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/poll.h>",
            "#include <sys/device.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static usbd_status",
            "uaudio_signext __P((int type, int val));",
            "uaudio_value2bsd __P((struct mixerctl *mc, int val));",
            "uaudio_bsd2value __P((struct mixerctl *mc, int val));",
            "uaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));",
            "uaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static struct",
            "Static struct",
            "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic usbd_status;\nuaudio_signext __P((int type, int val));\nuaudio_value2bsd __P((struct mixerctl *mc, int val));\nuaudio_bsd2value __P((struct mixerctl *mc, int val));\nuaudio_get __P((struct uaudio_softc *sc, int type,\n\t\t\t    int which, int wValue, int wIndex, int len));\nuaudio_ctl_set __P((struct uaudio_softc *sc, int which,\n\t\t\t    struct mixerctl *mc, int chan, int val));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_get(sc, which, type, wValue, wIndex, len)\n\tstruct uaudio_softc *sc;\n\tint type, which, wValue, wIndex, len;\n{\n\tusb_device_request_t req;\n\tu_int8_t data[4];\n\tusbd_status err;\n\tint val;\n\n\tif (wValue == -1)\n\t\treturn (0);\n\n\treq.bmRequestType = type;\n\treq.bRequest = which;\n\tUSETW(req.wValue, wValue);\n\tUSETW(req.wIndex, wIndex);\n\tUSETW(req.wLength, len);\n\tDPRINTFN(2,(\"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x \"\n\t\t    \"wIndex=0x%04x len=%d\\n\", \n\t\t    type, which, wValue, wIndex, len));\n\terr = usbd_do_request(sc->sc_udev, &req, &data);\n\tif (err) {\n\t\tDPRINTF((\"uaudio_get: err=%s\\n\", usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\tswitch (len) {\n\tcase 1:\n\t\tval = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tval = data[0] | (data[1] << 8);\n\t\tbreak;\n\tdefault:\n\t\tDPRINTF((\"uaudio_get: bad length=%d\\n\", len));\n\t\treturn (-1);\n\t}\n\tDPRINTFN(2,(\"uaudio_get: val=%d\\n\", val));\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIX_SIZE",
          "args": [
            "mc->type"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIX_SIZE",
          "args": [
            "mc->type"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uaudio_mixer_add_ctl: no memory\\n\""
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "sc->sc_ctls",
            "(sc->sc_nctls+1) * sizeof *mc",
            "M_USBDEV",
            "M_NOWAIT"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *mc",
            "M_USBDEV",
            "M_NOWAIT"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MIX_ON_OFF\t1\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nvoid\nuaudio_mixer_add_ctl(sc, mc)\n\tstruct uaudio_softc *sc;\n\tstruct mixerctl *mc;\n{\n\tif (sc->sc_nctls == NULL)\n\t\tsc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);\n\telse\n\t\tsc->sc_ctls = realloc(sc->sc_ctls, \n\t\t\t\t      (sc->sc_nctls+1) * sizeof *mc,\n\t\t\t\t      M_USBDEV, M_NOWAIT);\n\tif (sc->sc_ctls == NULL) {\n\t\tprintf(\"uaudio_mixer_add_ctl: no memory\\n\");\n\t\treturn;\n\t}\n\n\tif (mc->type != MIX_ON_OFF) {\n\t\t/* Determine min and max values. */\n\t\tmc->minval = uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, \n\t\t\t\t   mc->wValue[0], mc->wIndex, \n\t\t\t\t   MIX_SIZE(mc->type)));\n\t\tmc->maxval = 1 + uaudio_signext(mc->type, \n\t\t\tuaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,\n\t\t\t\t   mc->wValue[0], mc->wIndex,\n\t\t\t\t   MIX_SIZE(mc->type)));\n\t} else {\n\t\tmc->minval = 0;\n\t\tmc->maxval = 1;\n\t}\n\n\tsc->sc_ctls[sc->sc_nctls++] = *mc;\n\n#ifdef UAUDIO_DEBUG\n\tif (uaudiodebug > 2) {\n\t\tint i;\n\t\tDPRINTF((\"uaudio_mixer_add_ctl: wValue=%04x\",mc->wValue[0]));\n\t\tfor (i = 1; i < mc->nchan; i++)\n\t\t\tDPRINTF((\",%04x\", mc->wValue[i]));\n\t\tDPRINTF((\" wIndex=%04x type=%d name='%s' unit='%s' \"\n\t\t\t \"min=%d max=%d\\n\",\n\t\t\t mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,\n\t\t\t mc->minval, mc->maxval));\n\t}\n#endif\n}"
  },
  {
    "function_name": "uaudio_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "445-513",
    "snippet": "int\nuaudio_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint flags = sc->sc_altflags;\n\tint idx;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tif (sc->sc_nalts == 0 || flags == 0)\n\t\treturn (ENXIO);\n\n\tidx = fp->index;\n\tswitch (idx) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_8U ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_MULAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_ALAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_8 ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n        case 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define HAS_MULAW 0x10",
      "#define HAS_ALAW  0x08",
      "#define HAS_8U    0x04",
      "#define HAS_8     0x01"
    ],
    "globals_used": [
      "Static struct",
      "uaudio_query_encoding __P((void *,\n\t\t\t    struct audio_encoding *));",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define HAS_MULAW 0x10\n#define HAS_ALAW  0x08\n#define HAS_8U    0x04\n#define HAS_8     0x01\n\nStatic struct;\nuaudio_query_encoding __P((void *,\n\t\t\t    struct audio_encoding *));\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tstruct uaudio_softc *sc = addr;\n\tint flags = sc->sc_altflags;\n\tint idx;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n    \n\tif (sc->sc_nalts == 0 || flags == 0)\n\t\treturn (ENXIO);\n\n\tidx = fp->index;\n\tswitch (idx) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_8U ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_MULAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_ALAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = flags&HAS_8 ? 0 : AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n        case 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}"
  },
  {
    "function_name": "uaudio_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "425-443",
    "snippet": "int\nuaudio_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct uaudio_softc *sc = (struct uaudio_softc *)self;\n\tint rv = 0;\n\n\t/* Wait for outstanding requests to complete. */\n\tusbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);\n\n\tif (sc->sc_audiodev != NULL)\n\t\trv = config_detach(sc->sc_audiodev, flags);\n\n\tusbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,\n\t\t\t   USBDEV(sc->sc_dev));\n\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */",
      "#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */"
    ],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_add_drv_event",
          "args": [
            "USB_EVENT_DRIVER_DETACH",
            "sc->sc_udev",
            "USBDEV(sc->sc_dev)"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_add_drv_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb.c",
          "lines": "658-670",
          "snippet": "void\nusbd_add_drv_event(type, udev, dev)\n\tint type;\n\tusbd_device_handle udev;\n\tdevice_ptr_t dev;\n{\n\tstruct usb_event ue;\n\n\tue.u.ue_driver.ue_cookie = udev->cookie;\n\tstrncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), \n\t    sizeof ue.u.ue_driver.ue_devname);\n\tusb_add_event(type, &ue);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <machine/bus.h>",
            "#include \"usb_if.h\"",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/vnode.h>",
            "#include <sys/select.h>",
            "#include <sys/poll.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/filio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/proc.h>",
            "#include <sys/kthread.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static struct",
            "usb_add_event __P((int, struct usb_event *));",
            "usb_get_next_event __P((struct usb_event *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdivar.h>\n#include <machine/bus.h>\n#include \"usb_if.h\"\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/signalvar.h>\n#include <sys/vnode.h>\n#include <sys/select.h>\n#include <sys/poll.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/filio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/proc.h>\n#include <sys/kthread.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nusb_add_event __P((int, struct usb_event *));\nusb_get_next_event __P((struct usb_event *));\n\nvoid\nusbd_add_drv_event(type, udev, dev)\n\tint type;\n\tusbd_device_handle udev;\n\tdevice_ptr_t dev;\n{\n\tstruct usb_event ue;\n\n\tue.u.ue_driver.ue_cookie = udev->cookie;\n\tstrncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), \n\t    sizeof ue.u.ue_driver.ue_devname);\n\tusb_add_event(type, &ue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_detach",
          "args": [
            "sc->sc_audiodev",
            "flags"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "sc->sc_udev",
            "UAUDIO_NCHANBUFS * UAUDIO_NFRAMES"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UAUDIO_NFRAMES   20\t/* ms of sound in each request */\n#define UAUDIO_NCHANBUFS 6\t/* number of outstanding request */\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct uaudio_softc *sc = (struct uaudio_softc *)self;\n\tint rv = 0;\n\n\t/* Wait for outstanding requests to complete. */\n\tusbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);\n\n\tif (sc->sc_audiodev != NULL)\n\t\trv = config_detach(sc->sc_audiodev, flags);\n\n\tusbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,\n\t\t\t   USBDEV(sc->sc_dev));\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "uaudio_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uaudio.c",
    "lines": "403-423",
    "snippet": "int\nuaudio_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uaudio_softc *sc = (struct uaudio_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_audiodev)\n\t\t\trv = config_deactivate(sc->sc_audiodev);\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/usb/uaudioreg.h>",
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <sys/poll.h>",
      "#include <sys/device.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static struct",
      "Static struct",
      "char *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_deactivate",
          "args": [
            "sc->sc_audiodev"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uaudioreg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/poll.h>\n#include <sys/device.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic struct;\nStatic struct;\nStatic struct;\nchar *\nuaudio_id_name(sc, dps, id)\n\tstruct uaudio_softc *sc;\n\nint\nuaudio_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct uaudio_softc *sc = (struct uaudio_softc *)self;\n\tint rv = 0;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif (sc->sc_audiodev)\n\t\t\trv = config_deactivate(sc->sc_audiodev);\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (rv);\n}"
  }
]