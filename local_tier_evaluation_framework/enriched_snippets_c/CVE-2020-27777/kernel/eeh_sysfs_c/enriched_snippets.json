[
  {
    "function_name": "eeh_sysfs_remove_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "158-181",
    "snippet": "void eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_notify_resume_remove",
          "args": [
            "pdev"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_notify_resume_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "133-133",
          "snippet": "static inline void eeh_notify_resume_remove(struct pci_dev *pdev) { }",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic inline void eeh_notify_resume_remove(struct pci_dev *pdev) { }"
        }
      },
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_pe_state"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_pe_config_addr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_mode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "eeh_enabled()"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}"
  },
  {
    "function_name": "eeh_sysfs_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "136-156",
    "snippet": "void eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\trc += eeh_notify_resume_add(pdev);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Unable to create sysfs entries\\n\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_notify_resume_add",
          "args": [
            "pdev"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_notify_resume_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "132-132",
          "snippet": "static inline int eeh_notify_resume_add(struct pci_dev *pdev) { return 0; }",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic inline int eeh_notify_resume_add(struct pci_dev *pdev) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_pe_state"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_pe_config_addr"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_mode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\trc += eeh_notify_resume_add(pdev);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}"
  },
  {
    "function_name": "eeh_notify_resume_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "133-133",
    "snippet": "static inline void eeh_notify_resume_remove(struct pci_dev *pdev) { }",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic inline void eeh_notify_resume_remove(struct pci_dev *pdev) { }"
  },
  {
    "function_name": "eeh_notify_resume_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "132-132",
    "snippet": "static inline int eeh_notify_resume_add(struct pci_dev *pdev) { return 0; }",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic inline int eeh_notify_resume_add(struct pci_dev *pdev) { return 0; }"
  },
  {
    "function_name": "eeh_notify_resume_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "122-130",
    "snippet": "static void eeh_notify_resume_remove(struct pci_dev *pdev)\n{\n\tstruct device_node *np;\n\n\tnp = pci_device_to_OF_node(pdev->is_physfn ? pdev : pdev->physfn);\n\n\tif (of_property_read_bool(np, \"ibm,is-open-sriov-pf\"))\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_notify_resume);\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_notify_resume"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_bool",
          "args": [
            "np",
            "\"ibm,is-open-sriov-pf\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev->is_physfn ? pdev : pdev->physfn"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic void eeh_notify_resume_remove(struct pci_dev *pdev)\n{\n\tstruct device_node *np;\n\n\tnp = pci_device_to_OF_node(pdev->is_physfn ? pdev : pdev->physfn);\n\n\tif (of_property_read_bool(np, \"ibm,is-open-sriov-pf\"))\n\t\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_notify_resume);\n}"
  },
  {
    "function_name": "eeh_notify_resume_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "109-120",
    "snippet": "static int eeh_notify_resume_add(struct pci_dev *pdev)\n{\n\tstruct device_node *np;\n\tint rc = 0;\n\n\tnp = pci_device_to_OF_node(pdev->is_physfn ? pdev : pdev->physfn);\n\n\tif (of_property_read_bool(np, \"ibm,is-open-sriov-pf\"))\n\t\trc = device_create_file(&pdev->dev, &dev_attr_eeh_notify_resume);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&pdev->dev",
            "&dev_attr_eeh_notify_resume"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_bool",
          "args": [
            "np",
            "\"ibm,is-open-sriov-pf\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev->is_physfn ? pdev : pdev->physfn"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic int eeh_notify_resume_add(struct pci_dev *pdev)\n{\n\tstruct device_node *np;\n\tint rc = 0;\n\n\tnp = pci_device_to_OF_node(pdev->is_physfn ? pdev : pdev->physfn);\n\n\tif (of_property_read_bool(np, \"ibm,is-open-sriov-pf\"))\n\t\trc = device_create_file(&pdev->dev, &dev_attr_eeh_notify_resume);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_notify_resume_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "92-106",
    "snippet": "static ssize_t eeh_notify_resume_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev || !edev->pe || !eeh_ops->notify_resume)\n\t\treturn -ENODEV;\n\n\tif (eeh_ops->notify_resume(edev))\n\t\treturn -EIO;\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->notify_resume",
          "args": [
            "edev"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic ssize_t eeh_notify_resume_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev || !edev->pe || !eeh_ops->notify_resume)\n\t\treturn -ENODEV;\n\n\tif (eeh_ops->notify_resume(edev))\n\t\treturn -EIO;\n\n\treturn count;\n}"
  },
  {
    "function_name": "eeh_notify_resume_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "79-90",
    "snippet": "static ssize_t eeh_notify_resume_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tstruct pci_dn *pdn = pci_get_pdn(pdev);\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", pdn->last_allow_rc);\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pdn->last_allow_rc"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "95-125",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic ssize_t eeh_notify_resume_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tstruct pci_dn *pdn = pci_get_pdn(pdev);\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", pdn->last_allow_rc);\n}"
  },
  {
    "function_name": "eeh_pe_state_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "55-74",
    "snippet": "static ssize_t eeh_pe_state_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\t/* Nothing to do if it's not frozen */\n\tif (!(edev->pe->state & EEH_PE_ISOLATED))\n\t\treturn count;\n\n\tif (eeh_unfreeze_pe(edev->pe))\n\t\treturn -EIO;\n\teeh_pe_state_clear(edev->pe, EEH_PE_ISOLATED, true);\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "edev->pe",
            "EEH_PE_ISOLATED",
            "true"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "edev->pe"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1131-1150",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic ssize_t eeh_pe_state_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\t/* Nothing to do if it's not frozen */\n\tif (!(edev->pe->state & EEH_PE_ISOLATED))\n\t\treturn count;\n\n\tif (eeh_unfreeze_pe(edev->pe))\n\t\treturn -EIO;\n\teeh_pe_state_clear(edev->pe, EEH_PE_ISOLATED, true);\n\n\treturn count;\n}"
  },
  {
    "function_name": "eeh_pe_state_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
    "lines": "40-53",
    "snippet": "static ssize_t eeh_pe_state_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint state;\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\tstate = eeh_ops->get_state(edev->pe, NULL);\n\treturn sprintf(buf, \"0x%08x 0x%08x\\n\",\n\t\t       state, edev->pe->state);\n}",
    "includes": [
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <linux/stat.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"0x%08x 0x%08x\\n\"",
            "state",
            "edev->pe->state"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "edev->pe",
            "NULL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nstatic ssize_t eeh_pe_state_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint state;\n\n\tif (!edev || !edev->pe)\n\t\treturn -ENODEV;\n\n\tstate = eeh_ops->get_state(edev->pe, NULL);\n\treturn sprintf(buf, \"0x%08x 0x%08x\\n\",\n\t\t       state, edev->pe->state);\n}"
  }
]