[
  {
    "function_name": "eeh_pe_bus_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "848-867",
    "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&pe->edevs",
            "structeeh_dev",
            "entry"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_loc_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "810-836",
    "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,slot-location-code\"",
            "NULL"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,io-base-loc-code\"",
            "NULL"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_is_root_bus",
          "args": [
            "bus"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "pe"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "848-867",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}"
  },
  {
    "function_name": "eeh_pe_restore_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "792-799",
    "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_restore_one_device_bars",
            "NULL"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
  },
  {
    "function_name": "eeh_restore_one_device_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "773-783",
    "snippet": "static void eeh_restore_one_device_bars(struct eeh_dev *edev, void *flag)\n{\n\t/* Do special restore for bridges */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\teeh_restore_bridge_bars(edev);\n\telse\n\t\teeh_restore_device_bars(edev);\n\n\tif (eeh_ops->restore_config)\n\t\teeh_ops->restore_config(edev);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->restore_config",
          "args": [
            "edev"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_restore_device_bars",
          "args": [
            "edev"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_restore_device_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "730-762",
          "snippet": "static void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(edev, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, cmd);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(edev, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_restore_bridge_bars",
          "args": [
            "edev"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_restore_bridge_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "701-728",
          "snippet": "static void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(edev, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, edev->config_space[1] |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(edev, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, edev->config_space[1] |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_one_device_bars(struct eeh_dev *edev, void *flag)\n{\n\t/* Do special restore for bridges */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\teeh_restore_bridge_bars(edev);\n\telse\n\t\teeh_restore_device_bars(edev);\n\n\tif (eeh_ops->restore_config)\n\t\teeh_ops->restore_config(edev);\n}"
  },
  {
    "function_name": "eeh_restore_device_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "730-762",
    "snippet": "static void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(edev, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, cmd);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_COMMAND",
            "4",
            "cmd"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "PCI_COMMAND",
            "4",
            "&cmd"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "15*4",
            "4",
            "edev->config_space[15]"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_LATENCY_TIMER",
            "1",
            "SAVED_BYTE(PCI_LATENCY_TIMER)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_LATENCY_TIMER"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_CACHE_LINE_SIZE",
            "1",
            "SAVED_BYTE(PCI_CACHE_LINE_SIZE)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_CACHE_LINE_SIZE"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "12*4",
            "4",
            "edev->config_space[12]"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "i*4",
            "4",
            "edev->config_space[i]"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(edev, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, cmd);\n}"
  },
  {
    "function_name": "eeh_restore_bridge_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "701-728",
    "snippet": "static void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(edev, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, edev->config_space[1] |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_bridge_check_link",
          "args": [
            "edev"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_bridge_check_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "631-696",
          "snippet": "static void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\teeh_edev_dbg(edev, \"Checking PCIe link...\\n\");\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\teeh_edev_dbg(edev, \"No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\teeh_edev_dbg(edev, \"In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(edev, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(edev, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\teeh_edev_dbg(edev, \"No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\teeh_edev_dbg(edev, \"Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\teeh_edev_dbg(edev, \"Link not ready (0x%04x)\\n\", val);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\teeh_edev_dbg(edev, \"Checking PCIe link...\\n\");\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\teeh_edev_dbg(edev, \"No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\teeh_edev_dbg(edev, \"In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(edev, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(edev, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\teeh_edev_dbg(edev, \"No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\teeh_edev_dbg(edev, \"Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\teeh_edev_dbg(edev, \"Link not ready (0x%04x)\\n\", val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_COMMAND",
            "4",
            "edev->config_space[1] |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "15*4",
            "4",
            "edev->config_space[15]"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_LATENCY_TIMER",
            "1",
            "SAVED_BYTE(PCI_LATENCY_TIMER)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_LATENCY_TIMER"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "PCI_CACHE_LINE_SIZE",
            "1",
            "SAVED_BYTE(PCI_CACHE_LINE_SIZE)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_CACHE_LINE_SIZE"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "14*4",
            "4",
            "edev->config_space[14]"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "i*4",
            "4",
            "edev->config_space[i]"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(edev, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(edev, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(edev, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(edev, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(edev, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(edev, PCI_COMMAND, 4, edev->config_space[1] |\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}"
  },
  {
    "function_name": "eeh_bridge_check_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "631-696",
    "snippet": "static void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\teeh_edev_dbg(edev, \"Checking PCIe link...\\n\");\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\teeh_edev_dbg(edev, \"No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\teeh_edev_dbg(edev, \"In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(edev, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(edev, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\teeh_edev_dbg(edev, \"No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\teeh_edev_dbg(edev, \"Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\teeh_edev_dbg(edev, \"Link not ready (0x%04x)\\n\", val);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Link not ready (0x%04x)\\n\"",
            "val"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Link up (%s)\\n\"",
            "(val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_LNKSTA",
            "2",
            "&val"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "20"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"No link reporting capability (0x%08x) \\n\"",
            "val"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_LNKCAP",
            "4",
            "&val"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "cap + PCI_EXP_LNKCTL",
            "2",
            "val"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_LNKCTL",
            "2",
            "&val"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "2 * 1000"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "edev",
            "cap + PCI_EXP_SLTCTL",
            "2",
            "val"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"In power-off state, power it on ...\\n\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_SLTCTL",
            "2",
            "&val"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_SLTCAP",
            "2",
            "&val"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"No card in the slot (0x%04x) !\\n\"",
            "val"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap + PCI_EXP_SLTSTA",
            "2",
            "&val"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Checking PCIe link...\\n\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\teeh_edev_dbg(edev, \"Checking PCIe link...\\n\");\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\teeh_edev_dbg(edev, \"No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\teeh_edev_dbg(edev, \"In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(edev, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(edev, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(edev, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\teeh_edev_dbg(edev, \"No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(edev, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\teeh_edev_dbg(edev, \"Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\teeh_edev_dbg(edev, \"Link not ready (0x%04x)\\n\", val);\n}"
  },
  {
    "function_name": "eeh_pe_state_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "581-618",
    "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
  },
  {
    "function_name": "eeh_pe_dev_mode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "566-569",
    "snippet": "void eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "__eeh_pe_dev_mode_mark",
            "&mode"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}"
  },
  {
    "function_name": "__eeh_pe_dev_mode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "553-558",
    "snippet": "static void __eeh_pe_dev_mode_mark(struct eeh_dev *edev, void *flag)\n{\n\tint mode = *((int *)flag);\n\n\tedev->mode |= mode;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void __eeh_pe_dev_mode_mark(struct eeh_dev *edev, void *flag)\n{\n\tint mode = *((int *)flag);\n\n\tedev->mode |= mode;\n}"
  },
  {
    "function_name": "eeh_pe_mark_isolated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "533-550",
    "snippet": "void eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "edev",
            "&pe->edevs",
            "entry"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "root",
            "EEH_PE_ISOLATED"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}"
  },
  {
    "function_name": "eeh_pe_state_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "515-522",
    "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
  },
  {
    "function_name": "eeh_pe_update_time_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "489-505",
    "snippet": "void eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\ttime64_t tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tpe->tstamp = ktime_get_seconds();\n\t} else {\n\t\ttstamp = ktime_get_seconds();\n\t\tif (tstamp - pe->tstamp > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_seconds",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_seconds",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\ttime64_t tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tpe->tstamp = ktime_get_seconds();\n\t} else {\n\t\ttstamp = ktime_get_seconds();\n\t\tif (tstamp - pe->tstamp > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_pe_tree_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "402-478",
    "snippet": "int eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&pe->child_list",
            "child"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->edevs"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pe->child"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->child_list"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->edevs"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "keep && !recover"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&edev->entry"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"No PE found for device.\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "306-391",
    "snippet": "int eeh_pe_tree_insert(struct eeh_dev *edev, struct eeh_pe *new_pe_parent)\n{\n\tstruct pci_controller *hose = edev->controller;\n\tstruct eeh_pe *pe, *parent;\n\n\t/*\n\t * Search the PE has been existing or not according\n\t * to the PE address. If that has been existing, the\n\t * PE should be composed of PCI bus and its subordinate\n\t * components.\n\t */\n\tpe = eeh_pe_get(hose, edev->pe_config_addr);\n\tif (pe) {\n\t\tif (pe->type & EEH_PE_INVALID) {\n\t\t\tlist_add_tail(&edev->entry, &pe->edevs);\n\t\t\tedev->pe = pe;\n\t\t\t/*\n\t\t\t * We're running to here because of PCI hotplug caused by\n\t\t\t * EEH recovery. We need clear EEH_PE_INVALID until the top.\n\t\t\t */\n\t\t\tparent = pe;\n\t\t\twhile (parent) {\n\t\t\t\tif (!(parent->type & EEH_PE_INVALID))\n\t\t\t\t\tbreak;\n\t\t\t\tparent->type &= ~EEH_PE_INVALID;\n\t\t\t\tparent = parent->parent;\n\t\t\t}\n\n\t\t\teeh_edev_dbg(edev, \"Added to existing PE (parent: PE#%x)\\n\",\n\t\t\t\t     pe->parent->addr);\n\t\t} else {\n\t\t\t/* Mark the PE as type of PCI bus */\n\t\t\tpe->type = EEH_PE_BUS;\n\t\t\tedev->pe = pe;\n\n\t\t\t/* Put the edev to PE */\n\t\t\tlist_add_tail(&edev->entry, &pe->edevs);\n\t\t\teeh_edev_dbg(edev, \"Added to bus PE\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Create a new EEH PE */\n\tif (edev->physfn)\n\t\tpe = eeh_pe_alloc(hose, EEH_PE_VF);\n\telse\n\t\tpe = eeh_pe_alloc(hose, EEH_PE_DEVICE);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tpe->addr\t= edev->pe_config_addr;\n\tpe->config_addr\t= edev->bdfn;\n\n\t/*\n\t * Put the new EEH PE into hierarchy tree. If the parent\n\t * can't be found, the newly created PE will be attached\n\t * to PHB directly. Otherwise, we have to associate the\n\t * PE with its parent.\n\t */\n\tif (!new_pe_parent) {\n\t\tnew_pe_parent = eeh_phb_pe_get(hose);\n\t\tif (!new_pe_parent) {\n\t\t\tpr_err(\"%s: No PHB PE is found (PHB Domain=%d)\\n\",\n\t\t\t\t__func__, hose->global_number);\n\t\t\tedev->pe = NULL;\n\t\t\tkfree(pe);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\t/* link new PE into the tree */\n\tpe->parent = new_pe_parent;\n\tlist_add_tail(&pe->child, &new_pe_parent->child_list);\n\n\t/*\n\t * Put the newly created PE into the child list and\n\t * link the EEH device accordingly.\n\t */\n\tlist_add_tail(&edev->entry, &pe->edevs);\n\tedev->pe = pe;\n\teeh_edev_dbg(edev, \"Added to new (parent: PE#%x)\\n\",\n\t\t     new_pe_parent->addr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Added to new (parent: PE#%x)\\n\"",
            "new_pe_parent->addr"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->entry",
            "&pe->edevs"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pe->child",
            "&new_pe_parent->child_list"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: No PHB PE is found (PHB Domain=%d)\\n\"",
            "__func__",
            "hose->global_number"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "hose"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "157-172",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: out of memory!\\n\"",
            "__func__"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_alloc",
          "args": [
            "hose",
            "EEH_PE_DEVICE"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "46-70",
          "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int eeh_pe_aux_size = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Added to bus PE\\n\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->entry",
            "&pe->edevs"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Added to existing PE (parent: PE#%x)\\n\"",
            "pe->parent->addr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->entry",
            "&pe->edevs"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_get",
          "args": [
            "hose",
            "edev->pe_config_addr"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "286-291",
          "snippet": "struct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_insert(struct eeh_dev *edev, struct eeh_pe *new_pe_parent)\n{\n\tstruct pci_controller *hose = edev->controller;\n\tstruct eeh_pe *pe, *parent;\n\n\t/*\n\t * Search the PE has been existing or not according\n\t * to the PE address. If that has been existing, the\n\t * PE should be composed of PCI bus and its subordinate\n\t * components.\n\t */\n\tpe = eeh_pe_get(hose, edev->pe_config_addr);\n\tif (pe) {\n\t\tif (pe->type & EEH_PE_INVALID) {\n\t\t\tlist_add_tail(&edev->entry, &pe->edevs);\n\t\t\tedev->pe = pe;\n\t\t\t/*\n\t\t\t * We're running to here because of PCI hotplug caused by\n\t\t\t * EEH recovery. We need clear EEH_PE_INVALID until the top.\n\t\t\t */\n\t\t\tparent = pe;\n\t\t\twhile (parent) {\n\t\t\t\tif (!(parent->type & EEH_PE_INVALID))\n\t\t\t\t\tbreak;\n\t\t\t\tparent->type &= ~EEH_PE_INVALID;\n\t\t\t\tparent = parent->parent;\n\t\t\t}\n\n\t\t\teeh_edev_dbg(edev, \"Added to existing PE (parent: PE#%x)\\n\",\n\t\t\t\t     pe->parent->addr);\n\t\t} else {\n\t\t\t/* Mark the PE as type of PCI bus */\n\t\t\tpe->type = EEH_PE_BUS;\n\t\t\tedev->pe = pe;\n\n\t\t\t/* Put the edev to PE */\n\t\t\tlist_add_tail(&edev->entry, &pe->edevs);\n\t\t\teeh_edev_dbg(edev, \"Added to bus PE\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Create a new EEH PE */\n\tif (edev->physfn)\n\t\tpe = eeh_pe_alloc(hose, EEH_PE_VF);\n\telse\n\t\tpe = eeh_pe_alloc(hose, EEH_PE_DEVICE);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tpe->addr\t= edev->pe_config_addr;\n\tpe->config_addr\t= edev->bdfn;\n\n\t/*\n\t * Put the new EEH PE into hierarchy tree. If the parent\n\t * can't be found, the newly created PE will be attached\n\t * to PHB directly. Otherwise, we have to associate the\n\t * PE with its parent.\n\t */\n\tif (!new_pe_parent) {\n\t\tnew_pe_parent = eeh_phb_pe_get(hose);\n\t\tif (!new_pe_parent) {\n\t\t\tpr_err(\"%s: No PHB PE is found (PHB Domain=%d)\\n\",\n\t\t\t\t__func__, hose->global_number);\n\t\t\tedev->pe = NULL;\n\t\t\tkfree(pe);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\t/* link new PE into the tree */\n\tpe->parent = new_pe_parent;\n\tlist_add_tail(&pe->child, &new_pe_parent->child_list);\n\n\t/*\n\t * Put the newly created PE into the child list and\n\t * link the EEH device accordingly.\n\t */\n\tlist_add_tail(&edev->entry, &pe->edevs);\n\tedev->pe = pe;\n\teeh_edev_dbg(edev, \"Added to new (parent: PE#%x)\\n\",\n\t\t     new_pe_parent->addr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "286-291",
    "snippet": "struct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "root",
            "__eeh_pe_get",
            "&pe_no"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "211-223",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "phb"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "157-172",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}"
  },
  {
    "function_name": "__eeh_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "260-272",
    "snippet": "static void *__eeh_pe_get(struct eeh_pe *pe, void *flag)\n{\n\tint *target_pe = flag;\n\n\t/* PHB PEs are special and should be ignored */\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn NULL;\n\n\tif (*target_pe == pe->addr)\n\t\treturn pe;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_pe_get(struct eeh_pe *pe, void *flag)\n{\n\tint *target_pe = flag;\n\n\t/* PHB PEs are special and should be ignored */\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn NULL;\n\n\tif (*target_pe == pe->addr)\n\t\treturn pe;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_dev_traverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "234-250",
    "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "edev",
            "flag"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "29-63",
          "snippet": "unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nunsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid PE %p\\n\"",
            "__func__",
            "root"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
  },
  {
    "function_name": "eeh_pe_traverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "211-223",
    "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pe",
            "flag"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "29-63",
          "snippet": "unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nunsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "182-198",
    "snippet": "struct eeh_pe *eeh_pe_next(struct eeh_pe *pe, struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structeeh_pe",
            "child"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_pe_next(struct eeh_pe *pe, struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}"
  },
  {
    "function_name": "eeh_phb_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "157-172",
    "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(eeh_phb_pe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pe",
            "&eeh_phb_pe",
            "child"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_wait_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "106-147",
    "snippet": "int eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)",
      "#define EEH_STATE_MIN_WAIT_TIME\t(1000)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "min(mwait, max_wait)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "mwait",
            "max_wait"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Firmware returned too long wait value %d\\n\"",
            "__func__",
            "mwait"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Firmware returned bad wait value %d\\n\"",
            "__func__",
            "mwait"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Timeout when getting PE's state (%d)\\n\"",
            "__func__",
            "max_wait"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "&mwait"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n\nint eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}"
  },
  {
    "function_name": "eeh_phb_pe_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "79-96",
    "snippet": "int eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(eeh_phb_pe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Add PE for PHB#%x\\n\"",
            "phb->global_number"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pe->child",
            "&eeh_phb_pe"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: out of memory!\\n\"",
            "__func__"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_alloc",
          "args": [
            "phb",
            "EEH_PE_PHB"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "46-70",
          "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int eeh_pe_aux_size = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nint eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "46-70",
    "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eeh_pe_aux_size = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct eeh_pe)",
            "cache_line_size()"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pe->edevs"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pe->child_list"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc_size",
            "GFP_KERNEL"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "alloc_size",
            "cache_line_size()"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
  },
  {
    "function_name": "eeh_set_pe_aux_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "31-37",
    "snippet": "void eeh_set_pe_aux_size(int size)\n{\n\tif (size < 0)\n\t\treturn;\n\n\teeh_pe_aux_size = size;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eeh_pe_aux_size = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nvoid eeh_set_pe_aux_size(int size)\n{\n\tif (size < 0)\n\t\treturn;\n\n\teeh_pe_aux_size = size;\n}"
  }
]