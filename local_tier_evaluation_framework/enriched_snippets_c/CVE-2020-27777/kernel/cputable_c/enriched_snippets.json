[
  {
    "function_name": "mmu_feature_keys_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2230-2240",
    "snippet": "void __init mmu_feature_keys_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_MMU_FTR_KEYS; i++) {\n\t\tunsigned long f = 1ul << i;\n\n\t\tif (!(cur_cpu_spec->mmu_features & f))\n\t\t\tstatic_branch_disable(&mmu_feature_keys[i]);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpu_spec* cur_cpu_spec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&mmu_feature_keys[i]"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec* cur_cpu_spec;\n\nvoid __init mmu_feature_keys_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_MMU_FTR_KEYS; i++) {\n\t\tunsigned long f = 1ul << i;\n\n\t\tif (!(cur_cpu_spec->mmu_features & f))\n\t\t\tstatic_branch_disable(&mmu_feature_keys[i]);\n\t}\n}"
  },
  {
    "function_name": "cpu_feature_keys_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2213-2223",
    "snippet": "void __init cpu_feature_keys_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_CPU_FTR_KEYS; i++) {\n\t\tunsigned long f = 1ul << i;\n\n\t\tif (!(cur_cpu_spec->cpu_features & f))\n\t\t\tstatic_branch_disable(&cpu_feature_keys[i]);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpu_spec* cur_cpu_spec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&cpu_feature_keys[i]"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec* cur_cpu_spec;\n\nvoid __init cpu_feature_keys_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_CPU_FTR_KEYS; i++) {\n\t\tunsigned long f = 1ul << i;\n\n\t\tif (!(cur_cpu_spec->cpu_features & f))\n\t\t\tstatic_branch_disable(&cpu_feature_keys[i]);\n\t}\n}"
  },
  {
    "function_name": "identify_cpu_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2189-2204",
    "snippet": "void __init identify_cpu_name(unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tint i;\n\n\ts = PTRRELOC(s);\n\tt = PTRRELOC(t);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value) {\n\t\t\tt->cpu_name = s->cpu_name;\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpu_spec the_cpu_spec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cpu_specs"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "t"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "s"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstatic struct cpu_spec the_cpu_spec;\n\nvoid __init identify_cpu_name(unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tint i;\n\n\ts = PTRRELOC(s);\n\tt = PTRRELOC(t);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value) {\n\t\t\tt->cpu_name = s->cpu_name;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "identify_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2167-2182",
    "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_cpu_spec",
          "args": [
            "offset",
            "s"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cpu_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2095-2165",
          "snippet": "static struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/*\n\t * Copy everything, then do fixups. Use memcpy() instead of *t = *s\n\t * so that GCC replaces it by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type. Futhermore, let's ensure that the\n\t\t * fix for the PMAO bug is enabled on compatibility mode.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->cpu_features |= old.cpu_features & CPU_FTR_PMAO_BUG;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/mce.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpu_spec the_cpu_spec",
            "struct cpu_spec* cur_cpu_spec",
            "const char *powerpc_base_platform;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstatic struct cpu_spec the_cpu_spec;\nstruct cpu_spec* cur_cpu_spec;\nconst char *powerpc_base_platform;\n\nstatic struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/*\n\t * Copy everything, then do fixups. Use memcpy() instead of *t = *s\n\t * so that GCC replaces it by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type. Futhermore, let's ensure that the\n\t\t * fix for the PMAO bug is enabled on compatibility mode.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->cpu_features |= old.cpu_features & CPU_FTR_PMAO_BUG;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cpu_specs"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "s"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "setup_cpu_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2095-2165",
    "snippet": "static struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/*\n\t * Copy everything, then do fixups. Use memcpy() instead of *t = *s\n\t * so that GCC replaces it by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type. Futhermore, let's ensure that the\n\t\t * fix for the PMAO bug is enabled on compatibility mode.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->cpu_features |= old.cpu_features & CPU_FTR_PMAO_BUG;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpu_spec the_cpu_spec",
      "struct cpu_spec* cur_cpu_spec",
      "const char *powerpc_base_platform;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->cpu_setup",
          "args": [
            "offset",
            "t"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&powerpc_base_platform"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&powerpc_base_platform"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&cur_cpu_spec"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "t",
            "s",
            "sizeof(*t)"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "t"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstatic struct cpu_spec the_cpu_spec;\nstruct cpu_spec* cur_cpu_spec;\nconst char *powerpc_base_platform;\n\nstatic struct cpu_spec * __init setup_cpu_spec(unsigned long offset,\n\t\t\t\t\t       struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\tstruct cpu_spec old;\n\n\tt = PTRRELOC(t);\n\told = *t;\n\n\t/*\n\t * Copy everything, then do fixups. Use memcpy() instead of *t = *s\n\t * so that GCC replaces it by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t/*\n\t * If we are overriding a previous value derived from the real\n\t * PVR with a new value obtained using a logical PVR value,\n\t * don't modify the performance monitor fields.\n\t */\n\tif (old.num_pmcs && !s->num_pmcs) {\n\t\tt->num_pmcs = old.num_pmcs;\n\t\tt->pmc_type = old.pmc_type;\n\t\tt->oprofile_type = old.oprofile_type;\n\t\tt->oprofile_mmcra_sihv = old.oprofile_mmcra_sihv;\n\t\tt->oprofile_mmcra_sipr = old.oprofile_mmcra_sipr;\n\t\tt->oprofile_mmcra_clear = old.oprofile_mmcra_clear;\n\n\t\t/*\n\t\t * If we have passed through this logic once before and\n\t\t * have pulled the default case because the real PVR was\n\t\t * not found inside cpu_specs[], then we are possibly\n\t\t * running in compatibility mode. In that case, let the\n\t\t * oprofiler know which set of compatibility counters to\n\t\t * pull from by making sure the oprofile_cpu_type string\n\t\t * is set to that of compatibility mode. If the\n\t\t * oprofile_cpu_type already has a value, then we are\n\t\t * possibly overriding a real PVR with a logical one,\n\t\t * and, in that case, keep the current value for\n\t\t * oprofile_cpu_type. Futhermore, let's ensure that the\n\t\t * fix for the PMAO bug is enabled on compatibility mode.\n\t\t */\n\t\tif (old.oprofile_cpu_type != NULL) {\n\t\t\tt->oprofile_cpu_type = old.oprofile_cpu_type;\n\t\t\tt->cpu_features |= old.cpu_features & CPU_FTR_PMAO_BUG;\n\t\t}\n\t}\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n\n\t/*\n\t * Set the base platform string once; assumes\n\t * we're called with real pvr first.\n\t */\n\tif (*PTRRELOC(&powerpc_base_platform) == NULL)\n\t\t*PTRRELOC(&powerpc_base_platform) = t->platform;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_BOOKE)\n\t/* ppc64 and booke expect identify_cpu to also call setup_cpu for\n\t * that processor. I will consolidate that at a later time, for now,\n\t * just use #ifdef. We also don't need to PTRRELOC the function\n\t * pointer on ppc64 and booke as we are running at 0 in real mode\n\t * on ppc64 and reloc_offset is always 0 on booke.\n\t */\n\tif (t->cpu_setup) {\n\t\tt->cpu_setup(offset, t);\n\t}\n#endif /* CONFIG_PPC64 || CONFIG_BOOKE */\n\n\treturn t;\n}"
  },
  {
    "function_name": "set_cur_cpu_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
    "lines": "2081-2093",
    "snippet": "void __init set_cur_cpu_spec(struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\n\tt = PTRRELOC(t);\n\t/*\n\t * use memcpy() instead of *t = *s so that GCC replaces it\n\t * by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/mmu.h>",
      "#include <asm/mce.h>",
      "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
      "#include <asm/cputable.h>",
      "#include <asm/oprofile_impl.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/threads.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpu_spec the_cpu_spec",
      "struct cpu_spec* cur_cpu_spec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "&cur_cpu_spec"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "t",
            "s",
            "sizeof(*t)"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTRRELOC",
          "args": [
            "t"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstatic struct cpu_spec the_cpu_spec;\nstruct cpu_spec* cur_cpu_spec;\n\nvoid __init set_cur_cpu_spec(struct cpu_spec *s)\n{\n\tstruct cpu_spec *t = &the_cpu_spec;\n\n\tt = PTRRELOC(t);\n\t/*\n\t * use memcpy() instead of *t = *s so that GCC replaces it\n\t * by __memcpy() when KASAN is active\n\t */\n\tmemcpy(t, s, sizeof(*t));\n\n\t*PTRRELOC(&cur_cpu_spec) = &the_cpu_spec;\n}"
  }
]